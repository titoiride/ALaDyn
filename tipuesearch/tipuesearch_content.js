var tipuesearch = {"pages":[{"title":" ALaDyn ","text":"ALaDyn ALaDyn ( A cceleration by La ser and Dyn amics of charged particles) is a PIC code firstly described in ALaDyn: A High-Accuracy PIC code for the Maxwell-Vlasov Equations by C. Benedetti et al., published on IEEE Transactions on Plasma Science, 36 4, 1790-1798 (2008) and then again in the update Charge preserving high order PIC schemes by P. Londrillo et al., published on Nucl. Instrum. Meth. A, 620 1, 28-35 (2010). PWFA modules have been presented in Numerical investigation of beam-driven PWFA in quasi-nonlinear regime by P. Londrillo et al., published on Nucl. Instrum. Meth. A, 740 (2014). To date, main usage of the code has been carried on in simulating: L aser W ake F ield A cceleration ( LWFA Laser driven), P lasma W ake F ield A cceleration ( PWFA Beam driven), T arget N ormal S heath A cceleration ( TNSA Interaction with solid targets). This newer version, in part rewritten from scratch, is released as is, without any warranty, and will be maintained here on GitHub. A new publication is currently underway to describe progresses on this new code. If you use ALaDyn , you're kindly required to cite the Zenodo DOI of the latest release: . General code guide Papers published by the ALaDyn Collaboration Code description Input guide Warning ALaDyn code is fully maintained and tested.\nAnyway, if while using it you find any bug affecting the code or if you simply\nhave questions, please feel free to open an issue in the GitHub page . Copyright on the code is by the ALaDyn Collaboration. Developer Info The ALaDyn Collaboration","tags":"home","loc":"index.html"},{"title":"ALaDyn.F90 – ALaDyn","text":"Program: ALaDyn. Main file that executes the dynamics. This file depends on sourcefile~~aladyn.f90~~EfferentGraph sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~diag_part_and_fields.f90->sourcefile~control_bunch_input.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~diag_part_and_fields.f90->sourcefile~fstruct_data.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~diag_part_and_fields.f90->sourcefile~grid_param.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~diag_part_and_fields.f90->sourcefile~pstruct_data.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~diag_part_and_fields.f90->sourcefile~parallel.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~diag_part_and_fields.f90->sourcefile~code_util.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~diag_part_and_fields.f90->sourcefile~phys_param.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~boris_push.f90 boris_push.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~run_data_info.f90->sourcefile~control_bunch_input.f90 sourcefile~run_data_info.f90->sourcefile~fstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~run_data_info.f90->sourcefile~ionz_data.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~run_data_info.f90->sourcefile~code_util.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~run_data_info.f90->sourcefile~common_param.f90 sourcefile~run_data_info.f90->sourcefile~phys_param.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~util.f90 util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~pic_out_util.f90->sourcefile~phys_param.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~control_bunch_input.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~code_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~util.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~pic_out.f90->sourcefile~fstruct_data.f90 sourcefile~pic_out.f90->sourcefile~grid_param.f90 sourcefile~pic_out.f90->sourcefile~pstruct_data.f90 sourcefile~pic_out.f90->sourcefile~parallel.f90 sourcefile~pic_out.f90->sourcefile~code_util.f90 sourcefile~pic_out.f90->sourcefile~common_param.f90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~start_all.f90->sourcefile~set_grid_param.f90 sourcefile~system_utilities.f90 system_utilities.f90 sourcefile~start_all.f90->sourcefile~system_utilities.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~read_input.f90 read_input.f90 sourcefile~start_all.f90->sourcefile~read_input.f90 sourcefile~start_all.f90->sourcefile~array_alloc.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~set_grid_param.f90->sourcefile~grid_param.f90 sourcefile~set_grid_param.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~set_grid_param.f90->sourcefile~mpi_var.f90 sourcefile~system_utilities.f90->sourcefile~mpi_var.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~psolve.f90->sourcefile~fstruct_data.f90 sourcefile~psolve.f90->sourcefile~grid_param.f90 sourcefile~psolve.f90->sourcefile~pstruct_data.f90 sourcefile~psolve.f90->sourcefile~common_param.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~boris_push.f90->sourcefile~fstruct_data.f90 sourcefile~boris_push.f90->sourcefile~pstruct_data.f90 sourcefile~boris_push.f90->sourcefile~common_param.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~curr_and_fields_util.f90->sourcefile~fstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_param.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~pstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~fstruct_data.f90 sourcefile~window.f90->sourcefile~grid_param.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~window.f90->sourcefile~pstruct_data.f90 sourcefile~window.f90->sourcefile~common_param.f90 sourcefile~window.f90->sourcefile~util.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~set_init_param.f90->sourcefile~control_bunch_input.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~set_init_param.f90->sourcefile~grid_param.f90 sourcefile~set_init_param.f90->sourcefile~ionz_data.f90 sourcefile~set_init_param.f90->sourcefile~code_util.f90 sourcefile~set_init_param.f90->sourcefile~common_param.f90 sourcefile~set_init_param.f90->sourcefile~phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~pic_dump.f90->sourcefile~grid_param.f90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~pic_dump.f90->sourcefile~code_util.f90 sourcefile~pic_dump.f90->sourcefile~common_param.f90 sourcefile~pic_dump.f90->sourcefile~array_alloc.f90 sourcefile~read_input.f90->sourcefile~control_bunch_input.f90 sourcefile~read_input.f90->sourcefile~code_util.f90 sourcefile~read_input.f90->sourcefile~common_param.f90 sourcefile~read_input.f90->sourcefile~mpi_var.f90 sourcefile~grid_part_util.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_util.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_part_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90->sourcefile~code_util.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~ionize.f90->sourcefile~ionz_data.f90 sourcefile~ionize.f90->sourcefile~common_param.f90 sourcefile~ionize.f90->sourcefile~util.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 sourcefile~ionize.f90->sourcefile~mpi_var.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~init_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~init_part_distrib.f90->sourcefile~code_util.f90 sourcefile~init_part_distrib.f90->sourcefile~common_param.f90 sourcefile~init_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~init_part_distrib.f90->sourcefile~util.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~init_part_distrib.f90->sourcefile~mpi_var.f90 sourcefile~init_laser_field.f90->sourcefile~fstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~pstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~modern_fft_lib.f90 modern_fft_lib.F90 sourcefile~prl_fft.f90->sourcefile~modern_fft_lib.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~grid_part_connect.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~modern_fft_lib.f90->sourcefile~precision_def.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs aladyn Source Code ALaDyn.F90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! !! author: The ALaDyn Collaboration !! version: v{!./docs/VERSION.md!} !! !! Program: ALaDyn. Main file that executes the dynamics. program aladyn use start_all use diag_part_and_fields , only : En_data , Envar use run_data_info use pic_out_util use pic_out use init_beam_part_distrib , only : beam_inject use pic_evolve , only : Lp_run use env_evolve , only : Env_run implicit none call Start !============= info related to initial data if ( pe0 ) then write ( 6 , * ) 'START OF RUN' write ( 6 , * ) 'Running on ' , npe , ' cpu' write ( 6 , '(a32,3i4)' ) ' MPI decomposition along x-y-z: ' , npe_xloc , & npe_yloc , npe_zloc end if !====To activate/disactivate diagnostics in envar() en_data routines========= diag = . true . initial_time = . false . if ( iene == 0 ) then diag = . false . iene = 1 end if if ( prl ) then call Part_numbers call Max_pmemory_check () end if if ( pe0 ) then call initial_run_info ( new_sim ) endif !============================= call CPU_TIME ( unix_time_now ) unix_time_begin = unix_time_now unix_time_last_dump = unix_time_begin tnow = tstart if ( tnow < dt_loc ) initial_time = . true . ! iter=last_iter iter = 0 select case ( mod_ord ) case ( 1 ) call Lp_cycle case ( 2 ) call Env_cycle end select !call timing call MPI_BARRIER ( comm , error ) call Final_run_info call End_parallel !-------------------------- contains !-------------------------- subroutine Lp_cycle !! LP_CYCLE: collects the Laser-plasma dynamics evolved as a standard PIC. call Data_out do while ( tnow < tmax ) !======================= call lp_run ( tnow , iter ) call timing call Data_out if ( ier /= 0 ) then call error_message exit end if if ( tnow + dt_loc >= tmax ) dt_loc = tmax - tnow if ( initial_time ) initial_time = . false . end do if ( dump > 0 ) call dump_data ( iter , tnow ) end subroutine !-------------------------- subroutine Env_cycle if ( inject_beam ) then if ( tnow <= t_inject . and . tnow + dt_loc > t_inject ) then call beam_inject call Part_numbers if ( pe0 ) write ( 6 , '(a24,e11.4)' ) ' Injected beam at time =' , tnow end if !call den_energy_out( 0, nden, 1 ) !data on jc(1) for beam potential at injection endif call Data_out !================ tk_ind = 0 do while ( tnow < tmax ) !================================= call env_run ( tnow , iter ) call timing !iter=iter+1  tnow=tnow+dt_loc call Data_out if ( ier /= 0 ) then call error_message exit end if if ( tnow + dt_loc >= tmax ) dt_loc = tmax - tnow if ( initial_time ) initial_time = . false . end do if ( dump > 0 ) call dump_data ( iter , tnow ) end subroutine !====================== subroutine data_out integer :: i , iic , idata idata = iout if ( diag ) then if ( tnow >= tdia ) then ienout = ienout + 1 call Envar ( ienout ) tdia = tdia + dtdia if ( pe0 ) then write ( 6 , '(a10,i3,a10,e11.4)' ) ' rms data ' , ienout , & ' at time =' , tnow write ( 6 , * ) '==========================' endif end if end if if ( tnow >= tout ) then call create_timestep_folder ( iout ) tout = tout + dtout if ( diag ) then if ( pe0 ) call en_data ( ienout , iter , idata ) end if !================== if ( nvout > 0 ) then if ( mod_ord == 2 ) then if ( L_env_modulus ) then i = 0 call env_fields_out ( env , i ) if ( Two_color ) call env_fields_out ( env1 , - 1 ) !EXIT |A| else if ( Two_color ) then do i = 1 , 2 call env_two_fields_out ( env , env1 , i ) end do else do i = 1 , 2 call env_fields_out ( env , i ) !EXIT [Ar,Ai] end do end if end if end if do i = 1 , nvout if ( l_force_singlefile_output ) then call fields_out ( ebf , i , i ) !i to label field name else call fields_out_new ( ebf , i , i ) end if end do end if if ( nden > 0 ) then do i = 1 , nsp call prl_den_energy_interp ( i , nden ) do iic = 1 , min ( 2 , nden ) call den_energy_out ( i , iic , iic ) end do end do end if if ( hybrid ) then do i = 1 , nfcomp call fluid_den_mom_out ( up , i , nfcomp ) end do end if if ( ionization ) call part_ionz_out ( tnow ) if ( gam_min > 1. ) call part_high_gamma_out ( gam_min , tnow ) if ( npout > 0 ) then iic = npout if ( iic <= nsp ) then call part_pdata_out ( tnow , xp0_out , xp1_out , yp_out , iic , pjump ) else do i = 1 , nsp call part_pdata_out ( tnow , xp0_out , xp1_out , yp_out , i , pjump ) end do end if end if call CPU_TIME ( unix_time_now ) if ( pe0 ) then write ( 6 , '(a10,i6,a10,e11.4,a10,e11.4)' ) 'iter = ' , iter , ' t = ' , & tnow , ' dt = ' , dt_loc write ( 6 , * ) ' END DATA WRITE' write ( 6 , '(a16,f12.3)' ) ' Time elapsed = ' , & unix_time_now - unix_time_begin end if if ( dump > 0 . and . time_interval_dumps < 0.0 ) then if ( iter > 0 ) call dump_data ( iter , tnow ) endif iout = iout + 1 end if call CPU_TIME ( unix_time_now ) !if((unix_time_now - unix_time_last_dump) > time_interval_dumps .and. time_interval_dumps > 0.0) then ! call dump_data(iter,tnow) !endif end subroutine data_out !-------------------------- end program","tags":"","loc":"sourcefile/aladyn.f90.html"},{"title":"ionize.f90 – ALaDyn","text":"This file depends on sourcefile~~ionize.f90~~EfferentGraph sourcefile~ionize.f90 ionize.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~ionize.f90->sourcefile~ionz_data.f90 sourcefile~util.f90 util.f90 sourcefile~ionize.f90->sourcefile~util.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~ionize.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~ionize.f90->sourcefile~mpi_var.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ionize.f90~~AfferentGraph sourcefile~ionize.f90 ionize.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ionize Source Code ionize.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module ionize use ionz_data use common_param use array_alloc use mpi_var use util implicit none private public :: ionization_cycle , set_field_ioniz_wfunction , de_inv , & deb_inv integer , allocatable :: el_ionz_count (:) real ( dp ), allocatable :: efp_aux (:, :) contains !================================ subroutine set_field_ioniz_wfunction ( z0 , zm , loc_ion , nz_lev , & nz_model , e_max , dt_in ) integer , intent ( in ) :: z0 , zm , loc_ion , nz_lev , nz_model real ( dp ), intent ( in ) :: e_max integer :: i , k , j , ic , z , zk , zm_loc , ll real ( dp ) :: ei , w_bsi , w_adk , ns , fact1 , fact2 , dt_temp real ( dp ), allocatable :: aw (:, :) real ( dp ) :: p2 , efact , avg_fact real ( dp ), optional :: dt_in !============================= ! uses stored coefficients nstar(z,ic), vfact(z,ic),C_nstar(z,ic) ! ionz_model, ionz_lev,nsp_ionz z0=z_ion(), zmax=atn() in common !=============================== wi = 0.0 dge = e_max / real ( n_ge , dp ) d2ge = dge * dge de_inv = 1. / dge deb_inv = de_inv / 51 4. !For fields in GV/m unit ic = loc_ion - 1 dt_temp = dt_loc if ( present ( dt_in )) then dt_temp = dt_in end if select case ( nz_model ) case ( 1 ) !Only ADK: W_DC in chen et al (2013) do k = z0 + 1 , zm !V(k,ic) to ionize ion(ic) A(k-1)=> A(k), j = k - z0 ns = 2. * nstar ( k , ic ) - 1. do i = 1 , n_ge ei = dge * real ( i , dp ) !The gridded field intensity fact2 = ( 2. * vfact ( k , ic ) / ei ) !Vfact= (V/V_H)&#94;{3/2} fact1 = ( fact2 ) ** ns w_adk = c_nstar ( k , ic ) * fact1 * exp ( - fact2 / 3. ) !============= if ( w_adk < tiny ) w_adk = 0.0 wi ( i , j , ic ) = w_adk !Wi(Ei,j,ic)  for j=1,zm-z0 end do end do case ( 2 ) ! W_AC = <W_DC> in chen et al. (2013) do k = z0 + 1 , zm j = k - z0 ns = 2. * nstar ( k , ic ) - 1. do i = 1 , n_ge ei = dge * real ( i , dp ) !The field intensity on grid fact2 = ( 2. * vfact ( k , ic ) / ei ) fact1 = ( fact2 ) ** ns fact1 = fact1 * sqrt ( 3. * ei / ( pig * vfact ( k , ic ))) w_adk = c_nstar ( k , ic ) * fact1 * exp ( - fact2 / 3. ) !============= if ( w_adk < tiny ) w_adk = 0.0 wi ( i , j , ic ) = w_adk end do end do case ( 3 ) !BSI +adk(AC) (Posthumus) do k = z0 + 1 , zm j = k - z0 ns = 2. * nstar ( k , ic ) - 1. do i = 1 , n_ge ei = dge * real ( i , dp ) fact2 = ( 2. * vfact ( k , ic ) / ei ) fact1 = ( fact2 ) ** ns fact1 = fact1 * sqrt ( 3. * ei / ( pig * vfact ( k , ic ))) w_adk = c_nstar ( k , ic ) * fact1 * exp ( - fact2 / 3. ) if ( w_adk < tiny ) w_adk = 0.0 wi ( i , j , ic ) = w_adk !============= if ( ei > e_c ( k , ic )) then !w_adk(Ei=Ec) fact2 = ( 2. * vfact ( k , ic ) / e_c ( k , ic )) fact1 = ( fact2 ) ** ns fact1 = fact1 * sqrt ( 3. * e_c ( k , ic ) / ( pig * vfact ( k , ic ))) w_adk = c_nstar ( k , ic ) * fact1 * exp ( - fact2 / 3. ) w_bsi = vfact ( k , ic ) * ( 1. - e_c ( k , ic ) / ei ) / ( 4. * pig * real ( k , dp )) wi ( i , j , ic ) = w_bsi + w_adk end if end do end do case ( 4 ) ! Epoch version Min(adk-BSI) with adk = adk<m> do k = z0 + 1 , zm ll = ( l_fact ( k ) - 1 ) / 2 j = k - z0 ns = 2. * nstar ( k , ic ) - 1. do i = 1 , n_ge ei = dge * real ( i , dp ) !The field intensity on grid fact2 = ( 2. * vfact ( k , ic ) / ei ) fact1 = ( fact2 ) ** ns avg_fact = 1.0 if ( l_fact ( k ) > 1 ) then do ll = 1 , ( l_fact ( k ) - 1 ) / 2 avg_fact = avg_fact + 2. / ( fact2 ) ** ll end do avg_fact = avg_fact / l_fact ( k ) fact1 = fact1 * avg_fact end if fact1 = fact1 * sqrt ( 3. * ei / ( pig * vfact ( k , ic ))) w_adk = c_nstar ( k , ic ) * fact1 * exp ( - fact2 / 3. ) if ( w_adk < tiny ) w_adk = 0.0 !============= wi ( i , j , ic ) = w_adk efact = 1. - e_c ( k , ic ) / ei w_bsi = vfact ( k , ic ) * efact / ( 4. * pig * real ( k , dp )) if ( w_bsi < tiny ) w_bsi = 0. if ( ei > e_c ( k , ic )) wi ( i , j , ic ) = min ( w_bsi , w_adk ) if ( ei > e_b ( k , ic )) wi ( i , j , ic ) = w_bsi end do end do case ( 5 ) !cycle averaged BSI +adk (Posthumus) do k = z0 + 1 , zm j = k - z0 ns = 2. * nstar ( k , ic ) - 1. do i = 1 , n_ge ei = dge * real ( i , dp ) !The gridded field intensity fact2 = ( 2. * vfact ( k , ic ) / ei ) fact1 = sqrt ( 3. * ei / ( pig * vfact ( k , ic ))) * ( fact2 ) ** ns w_adk = c_nstar ( k , ic ) * fact1 * exp ( - fact2 / 3. ) if ( w_adk < tiny ) w_adk = 0.0 wi ( i , j , ic ) = w_adk !============= if ( ei > e_c ( k , ic )) then fact2 = ( 2. * vfact ( k , ic ) / e_c ( k , ic )) fact1 = sqrt ( 3. * e_c ( k , ic ) / ( pig * vfact ( k , ic ))) * ( fact2 ) ** ns w_adk = c_nstar ( k , ic ) * fact1 * exp ( - fact2 / 3. ) w_bsi = vfact ( k , ic ) * ( 1. - e_c ( k , ic ) / ei ) / ( 4. * pig * real ( k , dp )) wi ( i , j , ic ) = w_bsi + w_adk end if end do end do end select !=================== ordering================ ! k=0 !V(z0+1) for n[z0]=> n[z0+1] transition with probability W[1] ! k=1,2,... !V(z0+k+1) for n[z0+k]=> n[z0+k+1] transition with probability W(k+1) ! k=zmax-z0-1 !V(zmax) for n[zmax-1]=> n[zmax] transition with probability W[zmax-z0] !=============================================== ! dt in unit l0/c= 10/3. fs  dt_fs in fs unit dt_fs = 1 0. * dt_temp / 3. wi = omega_a * wi zm_loc = zm - z0 if ( nz_lev == 1 ) then ! one level ionization !W_one_level(Ef,k=z0:zm,ic) P(k.k+1) ionization !Wi(Ef,zk=1,zm-z0,ic) Rate of ionization zk+z0-1=> zk+z0 w_one_lev ( 0 : n_ge , zm , ic ) = zero_dp do z = 0 , zm_loc - 1 zk = z + 1 k = z + z0 !z0 is the initial ion charge status !k=z0,z0+1,..,zm-1  zk=k-z0+1 do i = 1 , n_ge w_one_lev ( i , k , ic ) = 1. - exp ( - dt_fs * wi ( i , zk , ic )) end do end do return end if !=================== allocate ( aw ( 0 : zm_loc , 0 : zm_loc )) do i = 1 , n_ge do z = 0 , zm_loc - 1 zk = z + 1 !z is the initial ion charge status !z=z0,z0+1,..,zmax-1 !for fixed z0=0,   zmax-1 !with inization potential v(1),...,V(zmax) aw ( 0 , 0 ) = one_dp k = 0 wsp ( i , k , z + z0 , ic ) = aw ( 0 , 0 ) * exp ( - dt_fs * wi ( i , zk , ic )) if ( wi ( i , zk , ic ) > 0.0 ) then if ( zk < zm_loc ) then do k = 1 , zm_loc - zk aw ( k , k ) = 0.0 if ( wi ( i , k + zk , ic ) > 0.0 ) then p2 = 0.0 do j = 0 , k - 1 fact1 = wi ( i , k - 1 + zk , ic ) / wi ( i , k + zk , ic ) fact2 = wi ( i , j + zk , ic ) / wi ( i , k + zk , ic ) aw ( j , k ) = aw ( j , k - 1 ) * fact1 / ( 1. - fact2 ) aw ( k , k ) = aw ( k , k ) - aw ( j , k ) p2 = p2 + aw ( j , k ) * exp ( - dt_fs * wi ( i , zk + j , ic )) end do wsp ( i , k , z + z0 , ic ) = p2 + aw ( k , k ) * exp ( - dt_fs * wi ( i , k + zk , ic )) else p2 = 0.0 if ( k == 1 ) then j = 0 aw ( j , k ) = - aw ( j , k - 1 ) aw ( k , k ) = - aw ( j , k ) p2 = p2 + aw ( j , k ) * exp ( - dt_fs * wi ( i , zk + j , ic )) end if if ( k == 2 ) then j = 0 aw ( j , k ) = - aw ( j , k - 1 ) * wi ( i , zk + k - 1 , ic ) / wi ( i , zk + j , ic ) aw ( k , k ) = - aw ( j , k ) p2 = p2 + aw ( j , k ) * exp ( - dt_fs * wi ( i , zk + j , ic )) j = 1 aw ( j , k ) = - aw ( j , k - 1 ) aw ( k , k ) = aw ( k , k ) - aw ( j , k ) p2 = p2 + aw ( j , k ) * exp ( - dt_fs * wi ( i , zk + j , ic )) end if wsp ( i , k , z + z0 , ic ) = p2 + aw ( k , k ) end if end do do k = 1 , zm_loc - zk wsp ( i , k , z + z0 , ic ) = wsp ( i , k , z + z0 , ic ) + & wsp ( i , k - 1 , z + z0 , ic ) end do end if else do k = 1 , zm_loc - zk wsp ( i , k , z + z0 , ic ) = wsp ( i , 0 , z + z0 , ic ) end do end if wsp ( i , zm_loc + 1 - zk , z + z0 , ic ) = 1. end do end do !============================ ! EXIT the cumulative DF F_j= u_0, u_0+u_1,.., u_0+u_1+ u_zmax-1 ! ndexed with j=1,2,1 end subroutine !======================================== subroutine ionization_electrons_inject ( ion_ch_inc , ic , np , np_el , & new_np_el ) integer , intent ( in ) :: ion_ch_inc (:) integer , intent ( in ) :: ic , np , new_np_el integer , intent ( inout ) :: np_el integer ( sp ) :: inc , id_ch real ( dp ) :: u , temp ( 3 ) integer :: n , i , ii !========== Enter sp_field(n,1)= the rms momenta Delta*a (n) for env model !                 inc=ion_ch_inc(n) the number of ionization electrons id_ch = nd2 + 1 ii = np_el temp ( 1 ) = t0_pl ( 1 ) temp ( 2 : 3 ) = temp ( 1 ) if ( ii == 0 ) write ( 6 , '(a33,2I6)' ) 'warning, no electrons before ionz' & , imody , imodz select case ( curr_ndim ) case ( 2 ) do n = 1 , np inc = ion_ch_inc ( n ) if ( inc > 0 ) then wgh_cmp = spec ( ic )% part ( n , id_ch ) charge = - one_int_hp part_ind = - one_int_hp wgh = wgh * n_mol_atoms ( ic - 1 ) do i = 1 , inc ii = ii + 1 spec ( 1 )% part ( ii , 1 : 2 ) = spec ( ic )% part ( n , 1 : 2 ) call gasdev ( u ) spec ( 1 )% part ( ii , 3 ) = temp ( 1 ) * u call gasdev ( u ) spec ( 1 )% part ( ii , 4 ) = temp ( 2 ) * u spec ( 1 )% part ( ii , id_ch ) = wgh_cmp end do np_el = np_el + inc end if end do case ( 3 ) do n = 1 , np inc = ion_ch_inc ( n ) if ( inc > 0 ) then wgh_cmp = spec ( ic )% part ( n , id_ch ) charge = - one_int_hp part_ind = - one_int_hp wgh = wgh * n_mol_atoms ( ic - 1 ) do i = 1 , inc ii = ii + 1 spec ( 1 )% part ( ii , 1 : 3 ) = spec ( ic )% part ( n , 1 : 3 ) call gasdev ( u ) spec ( 1 )% part ( ii , 4 ) = temp ( 1 ) * u call gasdev ( u ) spec ( 1 )% part ( ii , 5 ) = temp ( 2 ) * u call gasdev ( u ) spec ( 1 )% part ( ii , 6 ) = temp ( 3 ) * u spec ( 1 )% part ( ii , id_ch ) = wgh_cmp end do np_el = np_el + inc end if end do end select loc_npart ( imody , imodz , imodx , 1 ) = np_el !============ Now create new_np_el electrons end subroutine !======================================= subroutine env_ionization_electrons_inject ( sp_field , ion_ch_inc , ic , & np , np_el , new_np_el ) real ( dp ), intent ( in ) :: sp_field (:, :) integer , intent ( in ) :: ion_ch_inc (:) integer , intent ( in ) :: ic , np , new_np_el integer , intent ( inout ) :: np_el integer ( sp ) :: inc , id_ch real ( dp ) :: u , temp ( 3 ), a_symm integer :: n , i , ii !========== Enter sp_field(n,1)= the rms momenta Delta*a (n) for env model !                 inc=ion_ch_inc(n) the number of ionization electrons id_ch = nd2 + 1 temp ( 1 ) = t0_pl ( 1 ) temp ( 2 : 3 ) = temp ( 1 ) ii = np_el !if(ii==0)write(6,'(a33,2I6)')'warning, no electrons before ionz',imody,imodz select case ( curr_ndim ) case ( 2 ) do n = 1 , np inc = ion_ch_inc ( n ) if ( inc > 0 ) then wgh_cmp = spec ( ic )% part ( n , id_ch ) charge = - one_int_hp part_ind = - one_int_hp wgh = wgh * n_mol_atoms ( ic - 1 ) do i = 1 , inc ii = ii + 1 spec ( 1 )% part ( ii , 1 : 2 ) = spec ( ic )% part ( n , 1 : 2 ) call gasdev ( u ) spec ( 1 )% part ( ii , 3 ) = temp ( 1 ) * u call gasdev ( u ) spec ( 1 )% part ( ii , 4 ) = sp_field ( n , 1 ) * u spec ( 1 )% part ( ii , id_ch ) = wgh_cmp end do np_el = np_el + inc end if end do case ( 3 ) do n = 1 , np inc = ion_ch_inc ( n ) if ( inc > 0 ) then wgh_cmp = spec ( ic )% part ( n , id_ch ) charge = - one_int_hp part_ind = - one_int_hp wgh = wgh * n_mol_atoms ( ic - 1 ) do i = 1 , inc ii = ii + 1 spec ( 1 )% part ( ii , 1 : 3 ) = spec ( ic )% part ( n , 1 : 3 ) call gasdev ( u ) spec ( 1 )% part ( ii , 4 ) = temp ( 1 ) * u call gasdev ( u ) spec ( 1 )% part ( ii , 5 ) = sp_field ( n , 1 ) * u a_symm = sp_field ( n , 1 ) * sqrt ( 2.0 ) spec ( 1 )% part ( ii , 6 ) = sin ( 2.0 * pig * u ) * a_symm spec ( 1 )% part ( ii , id_ch ) = wgh_cmp end do np_el = np_el + inc end if end do end select loc_npart ( imody , imodz , imodx , 1 ) = np_el !============ Now create new_np_el electrons end subroutine !=============================== subroutine part_ionize ( sp_loc , amp_aux , np , ic , new_np_el , ion_ch_inc ) type ( species ), intent ( inout ) :: sp_loc real ( dp ), intent ( inout ) :: amp_aux (:, :) integer , intent ( in ) :: np , ic integer , intent ( inout ) :: new_np_el integer , intent ( inout ) :: ion_ch_inc (:) real ( dp ) :: p integer :: n , nk , kk , z0 integer :: kf , id_ch , sp_ion real ( dp ) :: ef_ion !===================== ! Units Ef_ion is in unit mc&#94;2/e=2 MV/m ! Hence E0*Ef_ion, E0=0.51 is the electric field in MV/m ! The reference value in ADK formula is Ea= 1a.u. 0.514 MV/m, ! then Ef_ion/Ea= Ef_approximates the field in code units. ! Vfact(z,ic)=(V/V_H)&#94;(3/2) where V_H is the Hydrogen ionization energy !              V(z,ic) is the potential  to ionize ion(ic) z-1 => z !=============================== ! enters nk=ion_ch_inc(n) the index of field modulus on ion n=1,np ! exit  ion_ch_inc(n)= the number(0,1, ionz_lev) of ionization electrons of ion n=1,np ! exit sp_aux(n,id_ch)=Delta*a= sqrt(1.5*Ef/Vfact(Z,ic))*a_n for envelope model !======================= !energy_norm=1./energy_unit id_ch = nd2 + 1 kf = curr_ndim sp_ion = ic - 1 kk = 0 !=========================== select case ( ionz_lev ) case ( 1 ) !========= Only one level ionization usining  adk model do n = 1 , np nk = ion_ch_inc ( n ) !the ioniz field grid value on the n-th ion E_f=nk*dge wgh_cmp = sp_loc % part ( n , id_ch ) z0 = charge !the current ion Z charge, charge is short_int ion_ch_inc ( n ) = 0 call random_number ( p ) if ( p < w_one_lev ( nk , z0 , sp_ion )) then charge = charge + one_int_hp ion_ch_inc ( n ) = 1 !the ionization electron count z0 = z0 + 1 sp_loc % part ( n , id_ch ) = wgh_cmp !the new ion (id,z-chargei,wgh) ef_ion = 1.5 * amp_aux ( n , 1 ) / vfact ( z0 , sp_ion ) if ( ef_ion > 0.0 ) amp_aux ( n , 1 ) = sqrt ( ef_ion ) * amp_aux ( n , 2 ) !Delta*|A| on ion(n,ic) kk = kk + 1 end if !ion_ch_inc(n)=0 or 1 end do new_np_el = kk !============= old ion charge stored in ebfp(id_ch) case ( 2 ) new_np_el = 0 write ( 6 , * ) 'WARNING :    two-step ionization no yet activated' return end select !============= old ion charge stored in ebfp(id_ch) !================= Exit end subroutine !==================== subroutine ionization_cycle ( sp_loc , sp_aux , np , ic , itloc , mom_id , & def_inv ) type ( species ), intent ( inout ) :: sp_loc real ( dp ), intent ( inout ) :: sp_aux (:, :) integer , intent ( in ) :: np , ic , itloc , mom_id real ( dp ), intent ( in ) :: def_inv integer :: id_ch , old_np_el , new_np_el , new_np_alloc , n , nk real ( dp ) :: ef2_ion , ef_ion new_np_el = 0 id_ch = nd2 + 1 !================== ! In sp_aux(id_ch) enters the |E|&#94;2 env field assigned  to each ion ! np is the number of ions !================== ! sp_loc(np,1:id_ch) is the array structure of ions coordinates, charge and weight !========================== !mom_id=1  select ionization procedure for envelope !mom_id=0 for other models !============================== !======== First check memory for auxiliary arrays============= if ( allocated ( el_ionz_count )) then if ( size ( el_ionz_count , 1 ) < np ) then deallocate ( el_ionz_count ) allocate ( el_ionz_count ( np + 100 )) end if else allocate ( el_ionz_count ( np + 100 )) end if el_ionz_count (:) = 0 if ( allocated ( efp_aux )) then if ( size ( efp_aux , 1 ) < np ) then deallocate ( efp_aux ) allocate ( efp_aux ( np + 100 , 2 )) end if else allocate ( efp_aux ( np + 100 , 2 )) end if efp_aux (:, :) = 0.0 efp_aux ( 1 : np , 1 ) = sp_aux ( 1 : np , id_ch ) efp_aux ( 1 : np , 2 ) = sp_aux ( 1 : np , id_ch - 1 ) !========================= ! In efp_aux(n,1) is the ionizing field squared |E|&#94;2 on ions n=1,np ! For envelope model : in efp_aux(n,2) is the env |A| value on ions n=1,np !========================= do n = 1 , np ef2_ion = efp_aux ( n , 1 ) !the interpolated E&#94;2 field if ( ef2_ion > 0. ) then ef_ion = sqrt ( ef2_ion ) nk = nint ( def_inv * ef_ion ) efp_aux ( n , 1 ) = ef_ion el_ionz_count ( n ) = nk !for each ion index n nk(n) is the ionizing fiels grid index end if end do !===================== ! The ionizing field ef_ion=|E| discretized to a grid. !            Ef(n)=nk*DE=nk*dge=nk/def_inv ! Grid index nk stored in el_ionz_count(n) !==================== call part_ionize ( sp_loc , efp_aux , np , ic , new_np_el , el_ionz_count ) !======= In part_ionize: ! The transition probality from ion charge z_0 => z_0 +1 is evaluated using ! the probability table W_one_lev(nk,z0,sp_ion) !===================== !EXIT in el_ionz_count(n) the numeber of ionization electrons (=0 or =1) on each ion(n) ! For envelope model in efp_aux(n,1)=sqrt(1.5*E_f/Vfact(z1))*|A| ! To modelize the rms P_y moment of ionization electron !========================== !=========== CHECK FOR MEMORYof electron struct array ================ if ( new_np_el > 0 ) then old_np_el = loc_npart ( imody , imodz , imodx , 1 ) new_np_alloc = old_np_el + new_np_el loc_ne_ionz ( imody , imodz , imodx ) = loc_ne_ionz ( imody , imodz , imodx ) & + new_np_el !========== if ( allocated ( spec ( 1 )% part )) then if ( size ( spec ( 1 )% part , 1 ) < new_np_alloc ) then do n = 1 , old_np_el ebfp ( n , 1 : id_ch ) = spec ( 1 )% part ( n , 1 : id_ch ) end do deallocate ( spec ( 1 )% part ) allocate ( spec ( 1 )% part ( new_np_alloc , id_ch )) do n = 1 , old_np_el spec ( 1 )% part ( n , 1 : id_ch ) = ebfp ( n , 1 : id_ch ) end do end if else allocate ( spec ( 1 )% part ( new_np_alloc , id_ch )) write ( 6 , '(a37,2I6)' ) & 'warning, electron array not previously allocated' , imody , imodz end if call v_realloc ( ebfp , new_np_alloc , id_ch ) !=========== and then Inject new electrons================ select case ( mom_id ) case ( 0 ) call ionization_electrons_inject ( el_ionz_count , ic , np , old_np_el , & new_np_el ) case ( 1 ) call env_ionization_electrons_inject ( efp_aux , el_ionz_count , ic , & np , old_np_el , new_np_el ) end select end if !Ionization energy to be added to the plasma particles current end subroutine !======================================= end module","tags":"","loc":"sourcefile/ionize.f90.html"},{"title":"ionz_data.f90 – ALaDyn","text":"This file depends on sourcefile~~ionz_data.f90~~EfferentGraph sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ionz_data.f90~~AfferentGraph sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~ionz_data.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~ionize.f90->sourcefile~ionz_data.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~ionz_data.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ionz_data Source Code ionz_data.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module ionz_data use precision_def implicit none character ( 10 ), dimension ( 0 : 28 ), parameter :: species_name = [ & ' Electron ' , ' Hydrogen ' , '  Helium  ' , ' Lithium  ' , & 'Berillium ' , ' Boron    ' , '  Carbon  ' , ' Nitrogen ' , & ' Oxygen   ' , ' Florine  ' , '   Neon   ' , ' Sodium   ' , & 'Magnesium ' , ' Aluminium' , ' Silicon  ' , 'Phosphorus' , & ' Solfur   ' , ' Chlorine ' , ' Argon    ' , 'Potassium ' , & ' Calcium  ' , ' Scandium ' , ' Titanium ' , '          ' , & ' Chromium ' , 'Manganese ' , '  Iron    ' , '          ' , & '  Nickel  ' ] integer , parameter :: an_max = 40 real ( dp ) :: v ( an_max ), vfact ( an_max , 3 ), nstar ( an_max , 3 ), & c_nstar ( an_max , 3 ) real ( dp ) :: e_c ( an_max , 3 ), e_b ( an_max , 3 ), e_m ( an_max , 3 ), & v_norm ( an_max , 3 ) integer :: nl_fact ( 0 : an_max ), nl_indx ( 0 : an_max ), & ne_shell ( 1 : 6 , 0 : an_max ) integer :: l_fact ( an_max ), z1_coll real ( dp ) :: be ( 10 , 0 : an_max ), p_nl ( 10 , 0 : an_max ) !(nl shell,ion charge) real ( dp ), allocatable :: wi (:, :, :), wsp (:, :, :, :), & w_one_lev (:, :, :) real ( dp ), allocatable :: sigma_coll (:, :, :), e_coll (:, :) real ( dp ), parameter :: v_h = 1 3.5984 !The H ionizazion potential(eV) real ( dp ), parameter :: e_unit = 0.511 * 1.e+06 !mc&#94;2(eV) real ( dp ), parameter :: omega_a = 4 1.3 ! 1/fs=E15/s real ( dp ), parameter :: c_au = 13 7.0 ! speed of light in au real ( dp ), parameter :: euler = 2.71828 , omega_l = 0.057 !(laser frequency in a.u.) real ( dp ), parameter :: pig = 3.141592653589793 , tiny = 1.e-10 integer , parameter :: n_ge = 10000 , nec = 1000 real ( dp ) :: lstar , dge , d2ge , de_inv , deb_inv , dt_fs real ( dp ) :: dgi , d2gi , dei_inv contains subroutine set_atomic_weight ( at_number , w_number ) integer , intent ( in ) :: at_number real ( dp ), intent ( out ) :: w_number select case ( at_number ) case ( 1 ) !H w_number = 1. case ( 2 ) !He w_number = 4. case ( 3 ) !Li w_number = 6. case ( 6 ) !C w_number = 1 2. case ( 7 ) !N w_number = 1 4. case ( 8 ) !O w_number = 1 6. case ( 10 ) !Ne w_number = 2 0. case ( 13 ) !Al w_number = 2 6.98 case ( 14 ) !Si w_number = 2 8.09 case ( 18 ) !Ar w_number = 3 9.948 case ( 22 ) !Ti w_number = 4 7.8 case ( 28 ) !Ni w_number = 5 8.7 case ( 29 ) !Cu w_number = 6 3.54 end select end subroutine !================================ subroutine set_atoms_per_molecule ( at_number , n_mol_atoms ) integer , intent ( in ) :: at_number integer , intent ( inout ) :: n_mol_atoms !======================================== ! This subroutine sets if the neutral gas ! Is mono- or diatomic !======================================== select case ( at_number ) case ( 1 ) n_mol_atoms = 2 !H case ( 2 ) n_mol_atoms = 1 !He case ( 7 ) n_mol_atoms = 2 !N case ( 8 ) n_mol_atoms = 2 !O case ( 9 ) n_mol_atoms = 2 !F case ( 10 ) n_mol_atoms = 1 !Ne case ( 17 ) n_mol_atoms = 2 !Cl case ( 18 ) n_mol_atoms = 1 !Ar case ( 35 ) n_mol_atoms = 2 !Br case ( 36 ) n_mol_atoms = 1 !Kr case ( 53 ) n_mol_atoms = 2 !I case ( 54 ) n_mol_atoms = 1 !Xe case default n_mol_atoms = 1 end select end subroutine !================================ subroutine set_ionization_coeff ( an , sp_ionz ) integer , intent ( in ) :: an (:), sp_ionz integer :: i , j , loc_zm ! The atomin number An identifies the element ! Z_max <= An indicates the local max ionization level allowed !============================================== loc_zm = maxval ( an ( 1 : sp_ionz - 1 )) !=========================== allocate ( wi ( n_ge + 1 , loc_zm + 1 , sp_ionz )) allocate ( wsp ( 0 : n_ge + 1 , 0 : loc_zm , 0 : loc_zm , 1 : sp_ionz )) allocate ( w_one_lev ( 0 : n_ge + 1 , 0 : loc_zm , 1 : sp_ionz )) ne_shell = 0 l_fact = 1 z1_coll = 1 nl_indx ( 0 : an_max ) = 1 nl_fact ( 0 : an_max ) = 1 be ( 1 : 10 , 0 : an_max ) = 0.0 p_nl ( 1 : 10 , 1 : an_max ) = 0.0 !Ne_shell(nl,z)= electrons in suborbitals s,p,d of shell n=1,2,3 !================================= ! Potentials V(i) to ionize from state Z=i-1 to Z= i !            V(i) from i=1, atomic number = Z_max !========================================================== do j = 1 , sp_ionz - 1 !=========== cycles over all ion species to be ionized sp_ionz=1,2,3 select case ( an ( j )) !The atomic number case ( 1 ) !H: 1s v ( 1 ) = 1 3.5984 case ( 2 ) !He 1s&#94;2 z1_coll = 0 v ( 1 ) = 2 4.5874 v ( 2 ) = 5 4.41776 be ( 1 , 0 ) = 2 3. !He&#94;0+ be ( 1 , 1 ) = 5 4. !He&#94;1+ p_nl ( 1 , 0 ) = be ( 1 , 0 ) + v ( 2 ) - be ( 1 , 1 ) nl_indx ( 0 ) = 1 ne_shell ( 1 , 0 ) = 2 p_nl ( 1 , 1 ) = v ( 2 ) ne_shell ( 1 , 1 ) = 1 nl_indx ( 1 ) = 1 case ( 3 ) !Li [He]2s v ( 1 ) = 5.3917 v ( 2 ) = 7 5.6400 v ( 3 ) = 12 2.4543 case ( 6 ) !C [He] 2s&#94;2 2p&#94;2 v ( 1 ) = 1 1.2603 v ( 2 ) = 2 4.3833 l_fact ( 1 : 2 ) = 3 ! the 2p shell v ( 3 ) = 4 7.8878 v ( 4 ) = 6 4.4939 !=========== L shell v ( 5 ) = 39 2.087 v ( 6 ) = 48 9.993 !=========== K shell case ( 7 ) !N [He] 2s&#94;2 2p&#94;3 v ( 1 ) = 1 4.53 v ( 2 ) = 2 9.601 v ( 3 ) = 4 7.449 l_fact ( 1 : 3 ) = 3 ! the 2p shell v ( 4 ) = 7 7.473 v ( 5 ) = 9 7.89 nl_fact ( 1 : 5 ) = 2 !========= L-shell v ( 6 ) = 55 2.07 v ( 7 ) = 66 7.046 nl_fact ( 6 : 7 ) = 1 ! the 1s shell !========= K-shell !========= Binding energies z1_coll = 0 be ( 1 , 0 ) = 411 !N&#94;0+ be ( 2 , 0 ) = 22 be ( 3 , 0 ) = 13 p_nl ( 1 : 3 , 0 ) = be ( 1 : 3 , 0 ) + v ( 1 ) - be ( 3 , 0 ) ne_shell ( 1 , 0 ) = 2 ne_shell ( 2 , 0 ) = 2 ne_shell ( 3 , 0 ) = 3 !N&#94;1+ be ( 1 , 1 ) = 433 be ( 2 , 1 ) = 39 be ( 3 , 1 ) = 27 p_nl ( 1 : 3 , 1 ) = be ( 1 : 3 , 1 ) + v ( 2 ) - be ( 3 , 1 ) ne_shell ( 1 , 1 ) = 2 ne_shell ( 2 , 1 ) = 2 ne_shell ( 3 , 1 ) = 2 be ( 1 , 2 ) = 457 be ( 2 , 2 ) = 53 be ( 3 , 2 ) = 47 p_nl ( 1 : 3 , 2 ) = be ( 1 : 3 , 2 ) + v ( 3 ) - be ( 3 , 2 ) nl_indx ( 0 : 2 ) = 3 ne_shell ( 1 , 2 ) = 2 ne_shell ( 2 , 2 ) = 2 ne_shell ( 3 , 2 ) = 1 be ( 1 , 3 ) = 488 be ( 2 , 3 ) = 75 p_nl ( 1 : 2 , 3 ) = be ( 1 : 2 , 3 ) + v ( 4 ) - be ( 2 , 3 ) ne_shell ( 1 , 3 ) = 2 ne_shell ( 2 , 3 ) = 2 ne_shell ( 3 , 3 : 6 ) = 0 be ( 1 , 4 ) = 516 be ( 2 , 4 ) = 98 p_nl ( 1 : 2 , 4 ) = be ( 1 : 2 , 4 ) + v ( 5 ) - be ( 2 , 4 ) nl_indx ( 3 : 4 ) = 2 ne_shell ( 1 , 4 ) = 2 ne_shell ( 2 , 4 ) = 1 p_nl ( 1 , 5 ) = v ( 6 ) ne_shell ( 1 , 5 ) = 2 p_nl ( 1 , 6 ) = v ( 7 ) ne_shell ( 1 , 6 ) = 1 ne_shell ( 2 , 5 : 6 ) = 0 nl_indx ( 5 : 6 ) = 1 !==================== case ( 10 ) !Ne: [He]2s&#94;2 2p&#94;6 v ( 1 ) = 2 1.5646 v ( 2 ) = 4 0.9633 v ( 3 ) = 6 3.45 v ( 4 ) = 9 7.12 v ( 5 ) = 12 6.21 v ( 6 ) = 15 7.93 l_fact ( 1 : 6 ) = 3 ! the 2p shell v ( 7 ) = 20 7.276 v ( 8 ) = 23 9.099 ! the 2s shell nl_fact ( 1 : 8 ) = 2 !========= L-shell v ( 9 ) = 119 5.8286 v ( 10 ) = 136 2.199 nl_fact ( 9 : 10 ) = 1 !========= K-shell !========= Binding energies z1_coll = 0 be ( 1 , 0 ) = 869 !Ne&#94;0+ be ( 2 , 0 ) = 49 be ( 3 , 0 ) = 20 p_nl ( 1 : 3 , 0 ) = be ( 1 : 3 , 0 ) + v ( 1 ) - be ( 3 , 0 ) nl_indx ( 0 ) = 3 ne_shell ( 1 , 0 ) = 2 ne_shell ( 2 , 0 ) = 2 ne_shell ( 3 , 0 ) = 6 !Ne&#94;1+ be ( 1 , 1 ) = 895 be ( 2 , 1 ) = 66 be ( 3 , 1 ) = 40 p_nl ( 1 : 3 , 1 ) = be ( 1 : 3 , 1 ) + v ( 2 ) - be ( 3 , 1 ) nl_indx ( 1 ) = 3 ne_shell ( 1 , 1 ) = 2 ne_shell ( 2 , 1 ) = 2 ne_shell ( 3 , 1 ) = 5 !Ne&#94;2+ be ( 1 , 1 ) = 925 be ( 2 , 2 ) = 87 be ( 3 , 2 ) = 67 p_nl ( 1 : 3 , 2 ) = be ( 1 : 3 , 2 ) + v ( 3 ) - be ( 3 , 2 ) nl_indx ( 2 ) = 3 ne_shell ( 1 , 2 ) = 2 ne_shell ( 2 , 2 ) = 2 ne_shell ( 3 , 2 ) = 4 !Ne&#94;3+ be ( 1 , 3 ) = 962 be ( 2 , 3 ) = 113 be ( 3 , 3 ) = 94 p_nl ( 1 : 3 , 3 ) = be ( 1 : 3 , 3 ) + v ( 4 ) - be ( 3 , 3 ) nl_indx ( 3 ) = 3 ne_shell ( 1 , 3 ) = 2 ne_shell ( 2 , 3 ) = 2 ne_shell ( 3 , 3 ) = 3 !Ne&#94;4+ be ( 1 , 4 ) = 1004 be ( 2 , 4 ) = 143 be ( 3 , 4 ) = 123 p_nl ( 1 : 3 , 4 ) = be ( 1 : 3 , 4 ) + v ( 5 ) - be ( 3 , 4 ) nl_indx ( 4 ) = 3 ne_shell ( 1 , 4 ) = 2 ne_shell ( 2 , 4 ) = 2 ne_shell ( 3 , 4 ) = 2 !Ne&#94;5+ be ( 1 , 5 ) = 1048 be ( 2 , 5 ) = 169 be ( 3 , 5 ) = 158 p_nl ( 1 : 3 , 5 ) = be ( 1 : 3 , 5 ) + v ( 6 ) - be ( 3 , 5 ) nl_indx ( 5 ) = 3 ne_shell ( 1 , 5 ) = 2 ne_shell ( 2 , 5 ) = 2 ne_shell ( 3 , 5 ) = 1 !Ne&#94;6+ be ( 1 , 6 ) = 1099 be ( 2 , 6 ) = 204 p_nl ( 1 : 2 , 6 ) = be ( 1 : 2 , 6 ) + v ( 7 ) - be ( 2 , 6 ) ne_shell ( 1 , 6 ) = 2 ne_shell ( 2 , 6 ) = 2 ne_shell ( 3 , 6 : 9 ) = 0 !Ne&#94;7+ be ( 1 , 7 ) = 1143 be ( 2 , 7 ) = 239 p_nl ( 1 : 2 , 7 ) = be ( 1 : 2 , 7 ) + v ( 8 ) - be ( 2 , 7 ) nl_indx ( 6 : 7 ) = 2 ne_shell ( 1 , 7 ) = 2 ne_shell ( 2 , 7 ) = 1 !Ne&#94;8+ be ( 1 , 8 ) = 1195 p_nl ( 1 , 8 ) = v ( 9 ) ne_shell ( 1 , 8 ) = 2 ne_shell ( 2 , 8 : 9 ) = 0 !Ne&#94;9+ be ( 1 , 9 ) = 1362 p_nl ( 1 , 9 ) = v ( 10 ) ne_shell ( 1 , 9 ) = 1 nl_indx ( 8 : 9 ) = 1 !============================ case ( 13 ) !Al [Ne] 3s&#94;2 3p&#94;1 v ( 1 ) = 5.98577 l_fact ( 1 ) = 3 ! 3p shell v ( 2 ) = 1 8.8285 v ( 3 ) = 2 8.4476 ! 3s shell nl_fact ( 1 : 3 ) = 3 !============ M shell v ( 4 ) = 11 9.992 v ( 5 ) = 15 3.825 v ( 6 ) = 19 0.40 v ( 7 ) = 24 1.76 v ( 8 ) = 28 4.66 v ( 9 ) = 33 0.13 l_fact ( 4 : 9 ) = 3 ! 2p shell v ( 10 ) = 39 8.75 v ( 11 ) = 44 2.0 nl_fact ( 4 : 11 ) = 2 !======= L-shell v ( 12 ) = 208 5.98 v ( 13 ) = 230 4.14 nl_fact ( 12 : 13 ) = 1 !=================== K-shell !========= Binding energies z1_coll = 2 ne_shell ( 1 , 2 : 9 ) = 2 !1s&#94;2 ne_shell ( 2 , 2 : 9 ) = 2 !2s&#94;2 be ( 1 , 2 ) = 1592 !A&#94;2+ be ( 2 , 2 ) = 150 be ( 3 , 2 ) = 104 be ( 4 , 2 ) = 28 p_nl ( 1 : 4 , 2 ) = be ( 1 : 4 , 2 ) + v ( 3 ) - be ( 4 , 2 ) nl_indx ( 2 ) = 4 ne_shell ( 3 , 2 ) = 6 !2p&#94;6 ne_shell ( 4 , 2 ) = 1 !3s&#94;1 be ( 1 , 3 ) = 1608 !A&#94;3+ be ( 2 , 3 ) = 165 be ( 3 , 3 ) = 119 be ( 4 , 3 ) = 118 p_nl ( 1 : 4 , 3 ) = be ( 1 : 4 , 3 ) + v ( 4 ) - be ( 4 , 3 ) nl_indx ( 3 ) = 4 ne_shell ( 3 , 3 ) = 6 !2p&#94;6 ne_shell ( 4 , 3 : 11 ) = 0 !3s&#94;1 !A&#94;4+ be ( 1 , 4 ) = 1653 be ( 2 , 4 ) = 193 be ( 3 , 4 ) = 153 p_nl ( 1 : 3 , 4 ) = be ( 1 : 3 , 4 ) + v ( 5 ) - be ( 3 , 4 ) nl_indx ( 4 ) = 3 ne_shell ( 3 , 4 ) = 5 !2p&#94;5 !A&#94;5+ be ( 1 , 5 ) = 1703 be ( 2 , 5 ) = 227 be ( 3 , 5 ) = 196 p_nl ( 1 : 3 , 5 ) = be ( 1 : 3 , 5 ) + v ( 6 ) - be ( 3 , 5 ) nl_indx ( 5 ) = 3 ne_shell ( 3 , 5 ) = 4 !2p&#94;4 !A&#94;6+ be ( 1 , 6 ) = 1760 be ( 2 , 6 ) = 265 be ( 3 , 6 ) = 237 p_nl ( 1 : 3 , 6 ) = be ( 1 : 3 , 6 ) + v ( 7 ) - be ( 3 , 6 ) nl_indx ( 6 ) = 3 ne_shell ( 3 , 6 ) = 3 !2p&#94;3 !A&#94;7+ be ( 1 , 7 ) = 1822 be ( 2 , 7 ) = 309 be ( 3 , 7 ) = 280 p_nl ( 1 : 3 , 7 ) = be ( 1 : 3 , 7 ) + v ( 8 ) - be ( 3 , 7 ) nl_indx ( 7 ) = 3 ne_shell ( 3 , 7 ) = 2 !2p&#94;2 !A&#94;8+ be ( 1 , 8 ) = 1885 be ( 2 , 8 ) = 346 be ( 3 , 8 ) = 331 p_nl ( 1 : 3 , 8 ) = be ( 1 : 3 , 8 ) + v ( 9 ) - be ( 3 , 8 ) nl_indx ( 8 ) = 3 ne_shell ( 3 , 8 ) = 1 !2p&#94;1 !A&#94;9 be ( 1 , 9 ) = 1957 be ( 2 , 9 ) = 394 p_nl ( 1 : 2 , 9 ) = be ( 1 : 2 , 9 ) + v ( 10 ) - be ( 2 , 9 ) nl_indx ( 9 ) = 2 ne_shell ( 3 , 9 : 11 ) = 0 !2p&#94;1 !A&#94;10+ be ( 1 , 10 ) = 2016 be ( 2 , 10 ) = 442 p_nl ( 1 : 2 , 10 ) = be ( 1 : 2 , 10 ) + v ( 11 ) - be ( 2 , 10 ) nl_indx ( 10 ) = 2 ne_shell ( 1 , 10 ) = 2 ne_shell ( 2 , 10 ) = 1 !A&#94;11+ be ( 1 , 11 ) = 2085 p_nl ( 1 , 11 ) = v ( 12 ) nl_indx ( 11 ) = 1 ne_shell ( 1 , 11 ) = 2 ne_shell ( 2 , 11 : 12 ) = 0 !A&#94;12+ be ( 1 , 12 ) = 2304 p_nl ( 1 , 12 ) = v ( 13 ) nl_indx ( 12 ) = 1 ne_shell ( 1 , 12 ) = 1 !============================ case ( 14 ) !Si [Ne] 3s&#94;2 3p&#94;2 v ( 1 ) = 8.1516 v ( 2 ) = 1 6.3458 v ( 3 ) = 3 3.4930 v ( 4 ) = 4 5.1418 nl_fact ( 1 : 4 ) = 3 !========== M-shell 3s,3p v ( 5 ) = 16 6.767 v ( 6 ) = 20 5.27 v ( 7 ) = 24 6.5 v ( 8 ) = 30 3.54 v ( 9 ) = 35 1.12 v ( 10 ) = 40 1.37 v ( 11 ) = 47 6.36 v ( 12 ) = 52 3.42 !================= L-shell nl_fact ( 5 : 12 ) = 2 v ( 13 ) = 243 7.63 v ( 14 ) = 267 3.18 nl_fact ( 13 : 14 ) = 1 !================= K-shell case ( 18 ) !Ar =  [Ne] 3s&#94;2 3p&#94;6 v ( 1 ) = 1 5.75962 v ( 2 ) = 2 7.62967 v ( 3 ) = 4 0.74 v ( 4 ) = 5 9.81 v ( 5 ) = 7 5.02 v ( 6 ) = 9 1.009 l_fact ( 1 : 6 ) = 3 v ( 7 ) = 12 4.323 v ( 8 ) = 14 3.460 nl_fact ( 1 : 8 ) = 3 !==================== M shell nl=3  3s&#94;2  3p&#94;6 v ( 9 ) = 42 2.45 v ( 10 ) = 47 8.69 v ( 11 ) = 53 8.96 v ( 12 ) = 61 8.26 v ( 13 ) = 68 6.10 v ( 14 ) = 75 5.74 l_fact ( 9 : 14 ) = 3 ! 2p shell v ( 15 ) = 85 4.77 v ( 16 ) = 91 8.03 nl_fact ( 9 : 16 ) = 2 !===========================L shell nl=2 2s&#94;2 2p&#94;6 v ( 17 ) = 412 0.8857 v ( 18 ) = 442 6.2296 !K-shell nl=1 1s&#94;2 shell nl_fact ( 17 : 18 ) = 1 !============================ !======================== case ( 22 ) !Ti [Ar] 3d&#94;2 4s&#94;2 v ( 1 ) = 6.82 v ( 2 ) = 1 3.57 ! the 4s shell v ( 3 ) = 2 7.49 v ( 4 ) = 4 3.26 l_fact ( 3 : 4 ) = 5 ! 3d shell v ( 5 ) = 9 9.30 v ( 6 ) = 11 9.53 v ( 7 ) = 14 0.8 v ( 8 ) = 17 0.4 v ( 9 ) = 19 2.1 v ( 10 ) = 21 5.92 l_fact ( 5 : 10 ) = 3 ! 3p shell v ( 11 ) = 26 5.07 v ( 12 ) = 29 1.5 nl_fact ( 3 : 12 ) = 3 !the 3 (s,p,d)shell !========== M-shell 3s,3p, 3d v ( 13 ) = 78 7.84 v ( 14 ) = 86 3.1 v ( 15 ) = 94 1.9 v ( 16 ) = 104 4. v ( 17 ) = 113 1. v ( 18 ) = 122 1. l_fact ( 13 : 18 ) = 3 ! 2p shell v ( 19 ) = 134 6. v ( 20 ) = 142 5.4 nl_fact ( 13 : 20 ) = 2 !========== L-shell 2s,2p v ( 21 ) = 624 9. v ( 22 ) = 662 5. nl_fact ( 21 : 22 ) = 1 !========== K-shell !========= Binding energies z1_coll = 2 !================== !===================== !A2+ be ( 1 , 2 ) = 4994 ! 1s be ( 2 , 2 ) = 591 ! 2s be ( 3 , 2 ) = 490 ! 2p be ( 4 , 2 ) = 91 ! 3s be ( 5 , 2 ) = 60 ! 3p be ( 6 , 2 ) = 26 ! 3d- p_nl ( 1 : 6 , 2 ) = be ( 1 : 6 , 2 ) + v ( 3 ) - be ( 6 , 2 ) nl_indx ( 2 ) = 6 ne_shell ( 1 , 2 : 20 ) = 2 !1s&#94;2 ne_shell ( 1 , 21 ) = 1 !1s&#94;1 ne_shell ( 2 , 2 : 18 ) = 2 !2s&#94;2 ne_shell ( 2 , 19 ) = 1 !2s&#94;1 ne_shell ( 2 , 20 : 21 ) = 0 ne_shell ( 3 , 2 : 12 ) = 6 !2p&#94;6 ne_shell ( 3 , 13 ) = 5 !2p&#94;5 ne_shell ( 3 , 14 ) = 4 !2p&#94;4 ne_shell ( 3 , 15 ) = 3 !2p&#94;3 ne_shell ( 3 , 16 ) = 2 !2p&#94;2 ne_shell ( 3 , 17 ) = 1 !2p&#94;1 ne_shell ( 3 , 18 : 21 ) = 0 ne_shell ( 4 , 2 : 10 ) = 2 !3s&#94;2 ne_shell ( 4 , 11 ) = 1 !3s&#94;1 ne_shell ( 4 , 12 : 21 ) = 0 ne_shell ( 5 , 2 : 4 ) = 6 !3p&#94;6 ne_shell ( 5 , 5 ) = 5 !3p&#94;5 ne_shell ( 5 , 6 ) = 4 !3p&#94;4 ne_shell ( 5 , 7 ) = 3 !3p&#94;3 ne_shell ( 5 , 8 ) = 2 !3p&#94;2 ne_shell ( 5 , 9 ) = 1 !3p&#94;1 ne_shell ( 5 , 10 : 21 ) = 0 ne_shell ( 6 , 2 ) = 2 !3d&#94;2 ne_shell ( 6 , 3 ) = 1 !3d&#94;2 ne_shell ( 6 , 4 : 21 ) = 0 !=============== be ( 1 , 3 ) = 5014 !A&#94;3+ be ( 2 , 3 ) = 612 be ( 3 , 3 ) = 503 be ( 4 , 3 ) = 109 be ( 5 , 3 ) = 76 be ( 6 , 3 ) = 42 p_nl ( 1 : 6 , 3 ) = be ( 1 : 6 , 3 ) + v ( 4 ) - be ( 6 , 3 ) nl_indx ( 3 ) = 6 be ( 1 , 4 ) = 5037 !A&#94;4+ be ( 2 , 4 ) = 636 be ( 3 , 4 ) = 528 be ( 4 , 4 ) = 130 be ( 5 , 4 ) = 98 p_nl ( 1 : 5 , 4 ) = be ( 1 : 5 , 4 ) + v ( 5 ) - be ( 5 , 4 ) nl_indx ( 4 ) = 5 be ( 1 , 5 ) = 5065 !A&#94;5+ be ( 2 , 5 ) = 662 be ( 3 , 5 ) = 553 be ( 4 , 5 ) = 147 be ( 5 , 5 ) = 119 p_nl ( 1 : 5 , 5 ) = be ( 1 : 5 , 5 ) + v ( 6 ) - be ( 5 , 5 ) nl_indx ( 5 ) = 5 be ( 1 , 6 ) = 5096 !A&#94;6+ be ( 2 , 6 ) = 691 be ( 3 , 6 ) = 582 be ( 4 , 6 ) = 187 be ( 5 , 6 ) = 143 p_nl ( 1 : 5 , 6 ) = be ( 1 : 5 , 6 ) + v ( 7 ) - be ( 5 , 6 ) nl_indx ( 6 ) = 5 be ( 1 , 7 ) = 5129 !A&#94;7+ be ( 2 , 7 ) = 721 be ( 3 , 7 ) = 612 be ( 4 , 7 ) = 189 be ( 5 , 7 ) = 166 p_nl ( 1 : 5 , 7 ) = be ( 1 : 5 , 7 ) + v ( 8 ) - be ( 5 , 7 ) nl_indx ( 7 ) = 5 be ( 1 , 8 ) = 5164 !A&#94;8+ be ( 2 , 8 ) = 753 be ( 3 , 8 ) = 645 be ( 4 , 8 ) = 215 p_nl ( 1 : 4 , 8 ) = be ( 1 : 4 , 8 ) + v ( 9 ) - be ( 4 , 8 ) nl_indx ( 8 ) = 4 be ( 1 , 9 ) = 5200 !A&#94;9+ be ( 2 , 9 ) = 785 be ( 3 , 9 ) = 678 be ( 4 , 9 ) = 235 p_nl ( 1 : 4 , 9 ) = be ( 1 : 4 , 9 ) + v ( 10 ) - be ( 4 , 9 ) nl_indx ( 9 ) = 4 be ( 1 , 10 ) = 5240 !A&#94;10+ be ( 2 , 10 ) = 820 be ( 3 , 10 ) = 714 be ( 4 , 10 ) = 263 p_nl ( 1 : 4 , 10 ) = be ( 1 : 4 , 10 ) + v ( 11 ) - be ( 4 , 10 ) nl_indx ( 10 ) = 4 be ( 1 , 11 ) = 5278 !A&#94;11+ be ( 2 , 11 ) = 853 be ( 3 , 11 ) = 749 be ( 4 , 11 ) = 291 p_nl ( 1 : 4 , 11 ) = be ( 1 : 4 , 11 ) + v ( 12 ) - be ( 4 , 11 ) nl_indx ( 11 ) = 4 be ( 1 , 12 ) = 5319 !A&#94;12+ be ( 2 , 12 ) = 890 be ( 3 , 12 ) = 786 p_nl ( 1 : 3 , 12 ) = be ( 1 : 3 , 12 ) + v ( 13 ) - be ( 3 , 12 ) nl_indx ( 12 ) = 3 !A&#94;13+ be ( 1 , 13 ) = 5421 be ( 2 , 13 ) = 951 be ( 3 , 13 ) = 864 p_nl ( 1 : 3 , 13 ) = be ( 1 : 3 , 13 ) + v ( 14 ) - be ( 3 , 13 ) nl_indx ( 13 ) = 3 !A&#94;14+ be ( 1 , 14 ) = 5529 be ( 2 , 14 ) = 1020 be ( 3 , 14 ) = 953 p_nl ( 1 : 3 , 14 ) = be ( 1 : 3 , 14 ) + v ( 15 ) - be ( 3 , 14 ) nl_indx ( 14 ) = 3 !A&#94;15+ be ( 1 , 15 ) = 5645 be ( 2 , 15 ) = 1097 be ( 3 , 15 ) = 1036 p_nl ( 1 : 3 , 15 ) = be ( 1 : 3 , 15 ) + v ( 16 ) - be ( 3 , 15 ) nl_indx ( 15 ) = 3 !A&#94;16+ be ( 1 , 16 ) = 5768 be ( 2 , 16 ) = 1181 be ( 3 , 16 ) = 1126 p_nl ( 1 : 3 , 16 ) = be ( 1 : 3 , 16 ) + v ( 17 ) - be ( 3 , 16 ) nl_indx ( 16 ) = 3 !A&#94;17+ be ( 1 , 17 ) = 5888 be ( 2 , 17 ) = 1251 be ( 3 , 17 ) = 1222 p_nl ( 1 : 3 , 17 ) = be ( 1 : 3 , 17 ) + v ( 18 ) - be ( 3 , 17 ) nl_indx ( 17 ) = 3 !A18&#94; be ( 1 , 18 ) = 6020 be ( 2 , 18 ) = 1340 p_nl ( 1 : 2 , 18 ) = be ( 1 : 2 , 18 ) + v ( 19 ) - be ( 2 , 18 ) nl_indx ( 18 ) = 2 !A&#94;19+ be ( 1 , 19 ) = 6126 be ( 2 , 19 ) = 1425 p_nl ( 1 : 2 , 19 ) = be ( 1 : 2 , 19 ) + v ( 20 ) - be ( 2 , 19 ) nl_indx ( 19 ) = 2 !A&#94;20+ be ( 1 , 20 ) = 6248 p_nl ( 1 , 20 ) = v ( 21 ) nl_indx ( 20 ) = 1 !A&#94;21+ be ( 1 , 21 ) = 6626 p_nl ( 1 , 21 ) = v ( 22 ) nl_indx ( 21 ) = 1 !============================== case ( 28 ) !Ni   [Ar] 3d&#94;8 4s&#94;2 z1_coll = 3 v ( 1 ) = 7.6398 v ( 2 ) = 1 8.1688 !============a       the 4s shell v ( 3 ) = 3 5.19 v ( 4 ) = 5 4.9 v ( 5 ) = 7 6.06 v ( 6 ) = 10 8.0 v ( 7 ) = 13 3.0 v ( 8 ) = 16 2.0 v ( 9 ) = 19 3.0 v ( 10 ) = 22 4.6 l_fact ( 3 : 10 ) = 5 !3d shell v ( 11 ) = 32 1.0 v ( 12 ) = 35 2.0 v ( 13 ) = 38 4.0 v ( 14 ) = 43 0.0 v ( 15 ) = 46 4.0 v ( 16 ) = 49 9.0 l_fact ( 11 : 16 ) = 3 !3p shell v ( 17 ) = 57 1.08 v ( 18 ) = 60 7.06 nl_fact ( 3 : 18 ) = 3 !==================    the M shell nl=3 3s&#94;2  3p&#94;6  3d&#94;8 v ( 19 ) = 154 1.0 v ( 20 ) = 164 8.0 v ( 21 ) = 175 6.0 v ( 22 ) = 189 4.0 v ( 23 ) = 201 1.0 v ( 24 ) = 213 1.0 l_fact ( 19 : 24 ) = 3 !2p&#94;6 shell v ( 25 ) = 229 5.0 v ( 26 ) = 239 9.2 !2s&#94;2 shell nl_fact ( 19 : 26 ) = 2 !===============      !L shell nl=2 2s&#94;2 2p&#94;6 v ( 27 ) = 1028 8.8 v ( 28 ) = 1077 5.4 !1s shell nl_fact ( 27 : 28 ) = 1 !========== K-shell !===================== case ( 29 ) !Cu =[Ar] 3d&#94;10 4s&#94;1 z1_coll = 2 v ( 1 ) = 7.726 !============       the 4s shell, nl=4 v ( 2 ) = 2 0.29 v ( 3 ) = 3 6.84 v ( 4 ) = 5 7.38 v ( 5 ) = 7 9.8 v ( 6 ) = 10 3.0 v ( 7 ) = 13 9.0 v ( 8 ) = 16 6.0 v ( 9 ) = 19 9.0 v ( 10 ) = 23 2.0 v ( 11 ) = 26 5.0 l_fact ( 2 : 11 ) = 5 !3d shell v ( 12 ) = 36 9.0 v ( 13 ) = 38 4.0 v ( 14 ) = 40 1.0 v ( 15 ) = 43 5.0 v ( 16 ) = 48 4.0 v ( 17 ) = 52 0.0 l_fact ( 12 : 17 ) = 3 !3p shell v ( 18 ) = 55 7.0 v ( 19 ) = 67 0.6 !3s shell nl_fact ( 2 : 19 ) = 3 !===============      !M shell nl=3  3s&#94;2 3p&#94;6 3d&#94;10 v ( 20 ) = 169 7.0 v ( 21 ) = 180 4.0 v ( 22 ) = 191 6.0 v ( 23 ) = 206 0.0 v ( 24 ) = 218 2.0 v ( 25 ) = 230 8.0 l_fact ( 20 : 25 ) = 3 !2p shell v ( 26 ) = 247 8.0 !2s shell v ( 27 ) = 258 7.8 nl_fact ( 20 : 27 ) = 2 !===============      !L shell nl=2  2s&#94;2 2p&#94;6 v ( 28 ) = 1106 2.0 v ( 29 ) = 1156 7.0 !K-shell nl=1 1s nl_fact ( 28 : 29 ) = 1 !========== K-shell case default write ( 6 , * ) 'set_ionization_coeff -> atomic number unknown' stop end select !=============== Coefficients for field ionization ! in common coefficients functions of(z,sp_ioniz) do i = 1 , an ( j ) !V(i) is the potential for z=i-1 => z=i  ionization transition v_norm ( i , j ) = v ( i ) / v_h e_c ( i , j ) = v_norm ( i , j ) * v_norm ( i , j ) / ( 1 6. * real ( i , dp )) e_m ( i , j ) = omega_l * sqrt ( v_norm ( i , j )) nstar ( i , j ) = real ( i , dp ) / sqrt ( v_norm ( i , j )) vfact ( i , j ) = ( v_norm ( i , j )) * sqrt ( v_norm ( i , j )) e_b ( i , j ) = 2. * vfact ( i , j ) / ( 3. * ( 2. * nstar ( i , j ) - 1. )) end do lstar = sqrt ( v ( 1 ) / v_h ) lstar = 1. / lstar - 1. do i = 1 , an ( j ) c_nstar ( i , j ) = ( 2. * euler / nstar ( i , j )) ** ( 2 * nstar ( i , j )) c_nstar ( i , j ) = c_nstar ( i , j ) * l_fact ( i ) / ( 2. * pig * nstar ( i , j )) c_nstar ( i , j ) = 0.5 * v_norm ( i , j ) * c_nstar ( i , j ) end do !============= m=0 assumed !================================ end do !=================================== end subroutine !================================ subroutine set_impact_ioniz_wfunction ( zm , imod ) integer , intent ( in ) :: zm , imod integer :: i , k , j , m , bc real ( dp ) :: ei , uu , sigma_m , sigma_a real ( dp ) :: g0 , g1 , g2 , g3 , fs , rf , gr real ( dp ) :: eta ( 6 ), etap ( 6 ), qnl ( 6 ), sbell ( 7 ), efact , efact1 real ( dp ) :: a_bell ( 0 : 7 , 6 ), mby ( 6 ), f_ion real ( dp ), parameter :: lam = 0.067 !=================== zm is the atomic number select case ( imod ) case ( 1 ) !             Implements GKLV scheme eta ( 1 ) = 0.499 eta ( 2 ) = 0.4 eta ( 3 ) = 0.57 eta ( 4 ) = 0.65 eta ( 5 ) = 0.70 eta ( 6 ) = 1.15 etap ( 1 ) = 2.0 etap ( 2 ) = 1.0 etap ( 3 ) = 1.0 etap ( 4 ) = 2.0 etap ( 5 ) = 0.30 etap ( 6 ) = 0.1 dgi = 0.1 do k = z1_coll , zm - 1 !the ionization state qnl ( 1 ) = zm - ne_shell ( 1 , k ) do j = 2 , 6 qnl ( j ) = zm - sum ( ne_shell ( 1 : j , k )) end do do j = 1 , nl_indx ( k ) p_nl ( j , k ) = be ( j , k ) end do m = nl_indx ( k ) do i = 1 , nec ei = p_nl ( m , k ) * ( 1. + dgi * real ( i , dp )) e_coll ( i , k ) = ei / e_unit end do do j = 1 , nl_indx ( k ) p_nl ( j , k ) = p_nl ( j , k ) / e_unit end do do j = 1 , nl_indx ( k ) !the subshells  index max nlindx=6 efact = eta ( j ) / p_nl ( j , k ) efact1 = 0.141 / p_nl ( j , k ) do i = 1 , nec sigma_coll ( i , j , k ) = 0.0 ei = e_coll ( i , k ) uu = ei / p_nl ( j , k ) if ( uu > 1. ) then fs = 1. if ( uu <= 1.70 ) fs = 2.5 * ( 1. - 1. / uu ) rf = 1. + 0.054 * ( uu ** lam ) g0 = ( ei + 1. ) g1 = g0 * g0 / ( ei * ( g0 + 1. )) g2 = ei / g0 g2 = 0.5 * g2 * g2 g3 = ( 2. * ei + 1. ) / ( g0 * g0 ) sigma_m = efact * g1 * ( 1. - ( 1. - g2 + g3 * log ( uu )) / uu ) !================ g3 = 1.243 * ( ei + 2. ) / p_nl ( j , k ) sigma_a = efact1 * g1 * ( log ( g3 ) - ei * ( ei + 2. ) / ( g0 * g0 )) !Ei=Ei+etap(j)*P_nl(j,k)/sqrt(1.+qnl(j)) sigma_a = fs * sigma_a sigma_coll ( i , j , k ) = ne_shell ( j , k ) * rf * ( sigma_a + sigma_m ) end if end do end do end do !Implements (R)MBELL scheme case ( 2 ) !============ the empirical MBEL coefficients in 10&#94;{-13}(eV)&#94;2 cm&#94;2 a_bell ( 6 : 7 , 1 : 4 ) = 0.0 ! 1s  subshell a_bell ( 0 , 1 ) = 0.5250 a_bell ( 1 , 1 ) = - 0.510 a_bell ( 2 , 1 ) = 0.200 a_bell ( 3 , 1 ) = 0.050 a_bell ( 4 , 1 ) = - 0.0250 a_bell ( 5 , 1 ) = - 0.100 ! 2s  subshell a_bell ( 0 , 2 ) = 0.530 a_bell ( 1 , 2 ) = - 0.410 a_bell ( 2 , 2 ) = 0.150 a_bell ( 3 , 2 ) = 0.150 a_bell ( 4 , 2 ) = - 0.020 a_bell ( 5 , 2 ) = - 0.150 ! 2p  subshell a_bell ( 0 , 3 ) = 0.600 a_bell ( 1 , 3 ) = - 0.400 a_bell ( 2 , 3 ) = 0.710 a_bell ( 3 , 3 ) = 0.655 a_bell ( 4 , 3 ) = 0.425 a_bell ( 5 , 3 ) = - 0.750 ! 3s  subshell a_bell ( 0 , 4 ) = 0.130 a_bell ( 1 , 4 ) = 0.250 a_bell ( 2 , 4 ) = - 1.500 a_bell ( 3 , 4 ) = 2.400 a_bell ( 4 , 4 ) = 3.220 a_bell ( 5 , 4 ) = - 3.667 ! 3p  subshell a_bell ( 0 , 5 ) = 0.388 a_bell ( 1 , 5 ) = - 0.200 a_bell ( 2 , 5 ) = - 0.2356 a_bell ( 3 , 5 ) = 0.5355 a_bell ( 4 , 5 ) = 3.150 a_bell ( 5 , 5 ) = - 8.500 a_bell ( 6 , 5 ) = 5.050 a_bell ( 7 , 5 ) = 0.370 ! 3d  subshell a_bell ( 0 , 6 ) = 0.350 a_bell ( 1 , 6 ) = 1.600 a_bell ( 2 , 6 ) = - 3.000 a_bell ( 3 , 6 ) = 4.000 a_bell ( 4 , 6 ) = 2.000 a_bell ( 5 , 6 ) = - 5.000 a_bell ( 6 , 6 ) = - 1.500 a_bell ( 7 , 6 ) = 3.500 mby ( 1 : 2 ) = 1.27 mby ( 3 ) = 0.542 mby ( 6 ) = 0.95 mby ( 4 ) = mby ( 1 ) mby ( 5 ) = mby ( 3 ) !======================== dgi = 0.1 do k = z1_coll , zm - 1 !the ionization state qnl ( 1 ) = zm - ne_shell ( 1 , k ) do j = 2 , 6 qnl ( j ) = zm - sum ( ne_shell ( 1 : j , k )) end do m = nl_indx ( k ) do i = 1 , nec ei = p_nl ( m , k ) * ( 1. + dgi * real ( i , dp )) e_coll ( i , k ) = ei !(E,P) in eV end do do j = 1 , nl_indx ( k ) !the subshells  index max nlindx=6 bc = 5 if ( j > 4 ) bc = 7 g0 = e_unit / p_nl ( j , k ) do i = 1 , nec sigma_coll ( i , j , k ) = 0.0 ei = p_nl ( j , k ) * ( 1. + dgi * real ( i , dp )) uu = ei / p_nl ( j , k ) if ( uu > 1. ) then sbell ( 1 ) = ( 1. - 1. / uu ) do m = 2 , bc sbell ( m ) = ( 1. - 1. / uu ) * sbell ( m - 1 ) end do g1 = ( 1. + 2. * g0 ) / ( uu + 2. * g0 ) g2 = ( uu + g0 ) / ( 1. + g0 ) g1 = g1 * g2 * g2 g2 = ( 1. + uu ) * ( uu + 2. * g0 ) * ( 1. + g0 ) * ( 1. + g0 ) g3 = g0 * g0 * ( 1. + 2. * g0 ) + uu * ( uu + 2. * g0 ) * ( 1. + g0 ) * ( 1. + g0 ) gr = g1 * ( g2 / g3 ) ** 1.5 !============== f_ion = 1. + 3. * ( qnl ( j ) / ( uu * zm )) ** mby ( j ) !===================== efact = dot_product ( a_bell ( 1 : bc , j ), sbell ( 1 : bc )) sigma_coll ( i , j , k ) = ( a_bell ( 0 , j ) * log ( uu ) + efact ) / ( p_nl ( j , k ) * ei ) sigma_coll ( i , j , k ) = gr * f_ion * ne_shell ( j , k ) * & sigma_coll ( i , j , k ) end if end do end do end do end select end subroutine !==================== end module","tags":"","loc":"sourcefile/ionz_data.f90.html"},{"title":"window.f90 – ALaDyn","text":"This file depends on sourcefile~~window.f90~~EfferentGraph sourcefile~window.f90 window.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~util.f90 util.f90 sourcefile~window.f90->sourcefile~util.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~window.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~window.f90->sourcefile~common_param.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~window.f90->sourcefile~grid_param.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~window.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~common_param.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~run_data_info.f90->sourcefile~fstruct_data.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~run_data_info.f90->sourcefile~ionz_data.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~run_data_info.f90->sourcefile~phys_param.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~run_data_info.f90->sourcefile~control_bunch_input.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~run_data_info.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_part_interface.f90->sourcefile~grid_param.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90->sourcefile~code_util.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~window.f90~~AfferentGraph sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules window Source Code window.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module window use util , only : init_random_seed , gasdev use pstruct_data use fstruct_data use common_param use grid_param use mpi_field_interface use mpi_part_interface use run_data_info , only : part_numbers implicit none !=============================== ! MOVING WINDOW SECTION !============================= contains subroutine add_particles ( np , i1 , i2 , ic ) integer , intent ( in ) :: np , i1 , i2 , ic integer :: n , ix , j , k , j2 , k2 real ( dp ) :: u , tmp0 , whz tmp0 = t0_pl ( ic ) n = np charge = int ( unit_charge ( ic ), hp_int ) part_ind = 0 k2 = loc_nptz ( ic ) j2 = loc_npty ( ic ) if ( curr_ndim > 2 ) then do k = 1 , k2 do j = 1 , j2 do ix = i1 , i2 whz = wghpt ( ix , ic ) * loc_wghyz ( j , k , ic ) wgh = real ( whz , sp ) n = n + 1 spec ( ic )% part ( n , 1 ) = xpt ( ix , ic ) spec ( ic )% part ( n , 2 ) = loc_ypt ( j , ic ) spec ( ic )% part ( n , 3 ) = loc_zpt ( k , ic ) spec ( ic )% part ( n , 4 : 6 ) = zero_dp spec ( ic )% part ( n , 7 ) = wgh_cmp end do end do end do else do j = 1 , j2 do ix = i1 , i2 wgh = real ( loc_wghyz ( j , 1 , ic ) * wghpt ( ix , ic ), sp ) n = n + 1 spec ( ic )% part ( n , 1 ) = xpt ( ix , ic ) spec ( ic )% part ( n , 2 ) = loc_ypt ( j , ic ) spec ( ic )% part ( n , 3 : 4 ) = zero_dp spec ( ic )% part ( n , 5 ) = wgh_cmp end do end do end if if ( tmp0 > 0.0 ) then n = np call init_random_seed ( mype ) if ( curr_ndim > 2 ) then do k = 1 , k2 do j = 1 , j2 do ix = i1 , i2 n = n + 1 call gasdev ( u ) spec ( ic )% part ( n , 4 ) = tmp0 * u spec ( ic )% part ( n , 5 ) = tmp0 * u spec ( ic )% part ( n , 6 ) = tmp0 * u end do end do end do else do j = 1 , j2 do ix = i1 , i2 n = n + 1 call gasdev ( u ) spec ( ic )% part ( n , 3 ) = tmp0 * u call gasdev ( u ) spec ( ic )% part ( n , 4 ) = tmp0 * u end do end do end if end if end subroutine !--------------------------- subroutine particles_inject ( xmx ) real ( dp ), intent ( in ) :: xmx integer :: ic , ix , npt_inj ( 4 ), np_old , np_new integer :: i1 , i2 , n , q integer :: j2 , k2 , ndv integer :: j , k !========== inject particles from the right !   xmx is the box xmax grid value at current time after window move !   in Comoving frame xmax is fixed and particles are left advected !================================= !  nptx(ic) is the max particle index inside the computational box !  nptx(ic) is updated in the same way both for moving window xmax !  or for left-advect particles with fixed xmax !=============================================== ndv = nd2 + 1 do ic = 1 , nsp i1 = 1 + nptx ( ic ) if ( i1 <= sptx_max ( ic )) then !while particle index is less then the max index do ix = i1 , sptx_max ( ic ) if ( xpt ( ix , ic ) > xmx ) exit end do i2 = ix - 1 if ( ix == sptx_max ( ic )) i2 = ix else i2 = i1 - 1 end if nptx ( ic ) = i2 ! endif !========================== ! Partcles to be injected have index ix [i1,i2] !============================ if ( i2 > i1 ) then !========================== npt_inj ( ic ) = 0 !=========== injects particles with coordinates index i1<= ix <=i2 select case ( ndim ) case ( 1 ) do ix = i1 , i2 npt_inj ( ic ) = npt_inj ( ic ) + 1 end do case ( 2 ) j2 = loc_npty ( ic ) do ix = i1 , i2 do j = 1 , j2 npt_inj ( ic ) = npt_inj ( ic ) + 1 end do end do case ( 3 ) k2 = loc_nptz ( ic ) j2 = loc_npty ( ic ) do ix = i1 , i2 do k = 1 , k2 do j = 1 , j2 npt_inj ( ic ) = npt_inj ( ic ) + 1 end do end do end do end select np_new = 0 np_old = loc_npart ( imody , imodz , imodx , ic ) np_new = max ( np_old + npt_inj ( ic ), np_new ) call v_realloc ( ebfp , np_new , ndv ) !========================= if ( size ( spec ( ic )% part , ic ) < np_new ) then ebfp ( 1 : np_old , 1 : ndv ) = spec ( ic )% part ( 1 : np_old , 1 : ndv ) deallocate ( spec ( ic )% part ) allocate ( spec ( ic )% part ( np_new , ndv )) spec ( ic )% part ( 1 : np_old , 1 : ndv ) = ebfp ( 1 : np_old , 1 : ndv ) end if q = np_old call add_particles ( q , i1 , i2 , ic ) loc_npart ( imody , imodz , imodx , ic ) = np_new end if end do !======================= end subroutine !======================= subroutine reset_loc_xgrid integer :: p , ip , i , ii , n_loc p = 0 n_loc = loc_xgrid ( p )% ng loc_xg ( 0 , 1 , p ) = x ( 1 ) - dx loc_xg ( 0 , 2 , p ) = xh ( 1 ) - dx do i = 1 , n_loc + 1 loc_xg ( i , 1 , p ) = x ( i ) loc_xg ( i , 2 , p ) = xh ( i ) end do ip = loc_xgrid ( 0 )% ng if ( npe_xloc > 2 ) then do p = 1 , npe_xloc - 2 n_loc = loc_xgrid ( p - 1 )% ng loc_xg ( 0 , 1 : 2 , p ) = loc_xg ( n_loc , 1 : 2 , p - 1 ) n_loc = loc_xgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_xg ( i , 1 , p ) = x ( ii ) loc_xg ( i , 2 , p ) = xh ( ii ) end do loc_xgrid ( p )% gmin = loc_xgrid ( p - 1 )% gmax ip = ip + n_loc loc_xgrid ( p )% gmax = x ( ip + 1 ) end do end if p = npe_xloc - 1 n_loc = loc_xgrid ( p - 1 )% ng loc_xg ( 0 , 1 : 2 , p ) = loc_xg ( n_loc , 1 : 2 , p - 1 ) n_loc = loc_xgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_xg ( i , 1 , p ) = x ( ii ) loc_xg ( i , 2 , p ) = xh ( ii ) end do loc_xgrid ( p )% gmin = loc_xgrid ( p - 1 )% gmax ip = ip + n_loc loc_xgrid ( p )% gmax = x ( ip + 1 ) end subroutine !======================================== subroutine comoving_coordinate ( vb , w_nst , loc_it ) real ( dp ), intent ( in ) :: vb integer , intent ( in ) :: w_nst , loc_it integer :: i , ic , nshx real ( dp ) :: dt_tot , dt_step logical , parameter :: mw = . true . !====================== ! In comoving x-coordinate the ! [xmin <= x <= xmax] computational box is stationaty ! xi= (x-vb*t) => xw is left-advected ! fields are left-advected in the x-grid directely in the maxw. equations ! particles are left-advected: ! xp=xp-vb*dt inside the computational box is added in the eq. of motion and ! for moving coordinates at each w_nst steps ! xpt(ix,ic)=xpt(ix,ic)-vb*w_nst*dt outside the computational box ! then targ_in=targ_in -vb*w_nst*dt   targ_out=targ_out-vb*w_nst*dt ! !================== if ( loc_it == 0 ) return dt_step = dt_loc dt_tot = 0.0 do i = 1 , w_nst dt_tot = dt_tot + dt_step end do nshx = nint ( dx_inv * dt_tot * vb ) !the number of grid points x-shift for each w_nst step do i = 1 , nx + 1 xw ( i ) = xw ( i ) - dx * nshx !moves backwards the grid xw end do xw_max = xw_max - dx * nshx xw_min = xw_min - dx * nshx !======================== xw(i) grid used only for diagnostics purposes targ_in = targ_in - vb * dt_tot targ_end = targ_end - vb * dt_tot if (. not . part ) return !=========================== do ic = 1 , nsp !left-advects all particles of the target outside the computational box do i = nptx ( ic ) + 1 , sptx_max ( ic ) xpt ( i , ic ) = xpt ( i , ic ) - vb * dt_tot end do end do !====================== call cell_part_dist ( mw ) !particles are redistributes along the if ( pex1 ) then if ( targ_in <= xmax . and . targ_end > xmax ) then call particles_inject ( xmax ) end if end if end subroutine !==================================== subroutine lp_window_xshift ( witr , init_iter ) integer , intent ( in ) :: witr , init_iter integer :: i1 , n1p , nc_env integer :: ix , nshx , wi2 real ( dp ), save :: xlapse , dt_step integer , save :: wi1 logical , parameter :: mw = . true . if ( init_iter == 0 ) then xlapse = 0.0 wi1 = 0 return end if dt_step = dt_loc !================== i1 = loc_xgrid ( imodx )% p_ind ( 1 ) n1p = loc_xgrid ( imodx )% p_ind ( 2 ) !====================== xlapse = xlapse + w_speed * dt_step * witr wi2 = nint ( dx_inv * xlapse ) nshx = wi2 - wi1 wi1 = wi2 do ix = 1 , nx + 1 x ( ix ) = x ( ix ) + dx * nshx xh ( ix ) = xh ( ix ) + dx * nshx end do xmin = xmin + dx * nshx xmax = xmax + dx * nshx xp0_out = xp0_out + dx * nshx xp1_out = xp1_out + dx * nshx loc_xgrid ( imodx )% gmin = loc_xgrid ( imodx )% gmin + dx * nshx loc_xgrid ( imodx )% gmax = loc_xgrid ( imodx )% gmax + dx * nshx xmn = xmn + dx * nshx wi2 = n1p - nshx if ( wi2 <= 0 ) then write ( 6 , '(a37,3i6)' ) 'Error in window shifting for MPI proc' , & imody , imodz , imodx ier = 2 return end if !=========================== call fields_left_xshift ( ebf , i1 , wi2 , 1 , nfield , nshx ) if ( hybrid ) then do ix = 1 , nxf - nshx fluid_x_profile ( ix ) = fluid_x_profile ( ix + nshx ) end do nxf = nxf - nshx call fluid_left_xshift ( up , fluid_x_profile , fluid_yz_profile , i1 , & wi2 , 1 , nfcomp , nshx ) call fields_left_xshift ( up0 , i1 , wi2 , 1 , nfcomp , nshx ) end if if ( envelope ) then nc_env = size ( env , 4 ) call fields_left_xshift ( env , i1 , wi2 , 1 , nc_env , nshx ) if ( Two_color ) call fields_left_xshift ( env1 , i1 , wi2 , 1 , nc_env , & nshx ) end if !shifts fields data and inject right ebf(wi2+1:n1p) x-grid nshx new data !=========================== if ( part ) then call cell_part_dist ( mw ) !particles are redistributes along the ! right-shifted x-coordinate in MPI domains if ( pex1 ) then if ( targ_in <= xmax ) then if ( targ_end > xmax ) then call particles_inject ( xmax ) end if end if end if call part_numbers end if end subroutine !============================== end module","tags":"","loc":"sourcefile/window.f90.html"},{"title":"fluid_density_momenta.f90 – ALaDyn","text":"This file depends on sourcefile~~fluid_density_momenta.f90~~EfferentGraph sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~fluid_density_momenta.f90~~AfferentGraph sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules fluid_density_momenta Source Code fluid_density_momenta.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module fluid_density_momenta use mpi_field_interface use grid_fields implicit none contains subroutine fluid_curr_accumulate ( flx , curr ) real ( dp ), intent ( inout ) :: flx (:, :, :, :), curr (:, :, :, :) integer :: i , j , k , ic , str , stl , fdim real ( dp ) :: pp ( 1 : 3 ), den , gam2 , ch , gam_inv real ( dp ) :: qx , qy , qz , av2 real ( dp ), parameter :: WK1 = 0.5 stl = 1 str = 1 ! Enter fluid variables at t&#94;{n+1/2} and flx(fdim+1)= |a|&#94;2/2 at t&#94;{n+1/2} ch = dt_loc * WK1 * unit_charge ( 1 ) fdim = curr_ndim + 1 if ( envelope ) then do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 av2 = flx ( i , j , k , fdim + 1 ) !time centered |A|&#94;{n+1/2}/2 den = flx ( i , j , k , fdim ) !den&#94;{n+1/2} pp ( 1 : curr_ndim ) = flx ( i , j , k , 1 : curr_ndim ) !p momenta at t&#94;{n+1/2} gam2 = 1. + dot_product ( pp ( 1 : curr_ndim ), pp ( 1 : curr_ndim )) gam2 = gam2 + av2 gam_inv = 1. / sqrt ( gam2 ) do ic = 1 , curr_ndim flx ( i , j , k , ic ) = den * gam_inv * pp ( ic ) !n*v= density flux at t&#94;{n+1/2} end do end do end do end do else do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 den = flx ( i , j , k , fdim ) !den&#94;{n+1/2} pp ( 1 : curr_ndim ) = flx ( i , j , k , 1 : curr_ndim ) !p momenta at t&#94;{n+1/2} gam2 = 1. + dot_product ( pp ( 1 : curr_ndim ), pp ( 1 : curr_ndim )) gam_inv = 1. / sqrt ( gam2 ) do ic = 1 , curr_ndim flx ( i , j , k , ic ) = den * gam_inv * pp ( ic ) !n*v= density flux at t&#94;{n+1/2} end do end do end do end do end if call fill_ebfield_yzxbdsdata ( flx , 1 , curr_ndim , str , stl ) call field_xyzbd ( flx , curr_ndim ) if ( pe1x ) then do k = kz1 , kz2 do j = jy1 , jy2 i = ix2 flx ( i + 1 , j , k , 1 ) = flx ( i , j , k , 1 ) end do end do endif do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 qx = ch * ( flx ( i , j , k , 1 ) + flx ( i + 1 , j , k , 1 )) !Dt*Jx(i+1/2,j,k) qy = ch * ( flx ( i , j , k , 2 ) + flx ( i , j + 1 , k , 2 )) !Dt*Jy(i,j+1/2,k) curr ( i , j , k , 1 ) = curr ( i , j , k , 1 ) + qx curr ( i , j , k , 2 ) = curr ( i , j , k , 2 ) + qy end do end do end do if ( curr_ndim == 3 ) then do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 qz = ch * ( flx ( i , j , k + 1 , 3 ) + flx ( i , j , k , 3 )) !Dt*Jz(i,j,k+1/2) curr ( i , j , k , 3 ) = curr ( i , j , k , 3 ) + qz end do end do end do end if !In curr(1:curr_ndim) exit  Dt*J&#94;{n+1/2} end subroutine !============================ subroutine set_env_momentum_density_flux ( uv , ef , curr , eb_tot , flx ) real ( dp ), intent ( in ) :: uv (:, :, :, :), ef (:, :, :, :) real ( dp ), intent ( inout ) :: curr (:, :, :, :) real ( dp ), intent ( out ) :: flx (:, :, :, :), eb_tot (:, :, :, :) integer :: fdim , ic , i , j , k real ( dp ) :: den , pp ( 3 ), gam2 , gam_inv !================ set density and momenta flux !fdim = curr_ndim + 1 fdim = size ( uv , 4 ) flx (:, :, :, 1 : fdim ) = uv (:, :, :, 1 : fdim ) ! Enter curr(1)= |A|&#94;2/2 and curr(2:4) grad|A|&#94;2/2 at t&#94;n time level !===================== eb_tot ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 : nfield ) = ef ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 : nfield ) do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 den = uv ( i , j , k , fdim ) pp ( 1 : curr_ndim ) = uv ( i , j , k , 1 : curr_ndim ) !p momenta gam2 = 1. + dot_product ( pp ( 1 : curr_ndim ), pp ( 1 : curr_ndim )) gam2 = gam2 + curr ( i , j , k , 1 ) gam_inv = 1. / sqrt ( gam2 ) pp ( 1 : curr_ndim ) = gam_inv * pp ( 1 : curr_ndim ) !(vx,vy,vz)=pp/gam at time t&#94;n curr ( i , j , k , 1 ) = gam_inv * den !n/gam fluid contribution of the sorce of envelope equation do ic = 1 , curr_ndim eb_tot ( i , j , k , ic ) = eb_tot ( i , j , k , ic ) + & 0.5 * gam_inv * curr ( i , j , k , ic + 1 ) !Envelope grad|A|&#94;2/(4*gam_p):wq flx ( i , j , k , fdim + ic ) = pp ( ic ) !(vx,vy,vz) end do end do end do end do !Exit flx(1:4)=uv(1:4)=[Px,Py,Pz,den] flx(5:8)=[vx,vy,vz] !====================================== end subroutine !==================== subroutine set_momentum_density_flux ( uv , flx ) real ( dp ), intent ( in ) :: uv (:, :, :, :) real ( dp ), intent ( inout ) :: flx (:, :, :, :) integer :: fdim , ic , i , j , k real ( dp ) :: den , pp ( 3 ), gam2 , gam_inv !================ set density and momenta flux fdim = curr_ndim + 1 flx (:, :, :, 1 : fdim ) = uv (:, :, :, 1 : fdim ) !stores the modentum-density at current time level t&#94;n !===================== do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 den = uv ( i , j , k , fdim ) pp ( 1 : curr_ndim ) = uv ( i , j , k , 1 : curr_ndim ) !p momenta gam2 = 1. + dot_product ( pp ( 1 : curr_ndim ), pp ( 1 : curr_ndim )) gam_inv = 1. / sqrt ( gam2 ) pp ( 1 : curr_ndim ) = gam_inv * pp ( 1 : curr_ndim ) !(vx,vy,vz)=pp/gam at time t&#94;n do ic = 1 , curr_ndim flx ( i , j , k , fdim + ic ) = gam_inv * uv ( i , j , k , ic ) !(vx,vy,vz) end do end do end do end do !Exit non-conservative variables flx(1:4)=uv(1:4)=[Px,Py,Pz,den] flx(5:8)=[vx,vy,vz] end subroutine !======================================= subroutine update_adam_bash_fluid_variables ( u , u0 , flx , ef ) real ( dp ), intent ( inout ) :: u (:, :, :, :), u0 (:, :, :, :) real ( dp ), intent ( inout ) :: ef (:, :, :, :), flx (:, :, :, :) integer :: i , j , k , ic , str , stl , fdim , fldim real ( dp ) :: den , lzf real ( dp ) :: ex , ey , ez , bx , by , bz , vx , vy , vz , b1p , b1m real ( dp ), parameter :: WK1 = 0.5 , EPS = 1.e-06 real ( dp ) :: abf_0 , abf_1 !=================================== ! INTEGRATES by a one-step adam-bashfort (dissipative leap-frog) !=============================== !   NON-CONSERVATIVE FORM of RELATIVISTC COLD FLUID !========================================== !   D_t(p)+v*grad(p)=charge*[E +vxB] !   D_t(n) +div(nv) =0 !   arrays :  q(1:3)=v,  u(1:3)=p   gamm&#94;2=1+p*p !=============================== ! enter ef=total (E,B) fields on staggered grid at t&#94;n time level !================================ lzf = lorentz_fact ( 1 ) * unit_charge ( 1 ) * dt_loc fdim = size ( u , 4 ) !fdim=curr_ndim+1 fldim = size ( flx , 4 ) !fldim = 2*curr_ndim + 1 !(five or seven components) abf_0 = - 0.5 abf_1 = 1.5 !================== Enter ! flx[Px,Py,Pz,den,vx,vy,vz]&#94;n fldim components ! ef[1:nfield] = total (E,B) fields and ponderomotive force !=============================================== str = 1 stl = 1 if ( prl ) then !extends flux data to j1-2,j2+2 and k1-2,k2+2 call fill_ebfield_yzxbdsdata ( flx , 1 , fldim , 2 , 2 ) call fill_ebfield_yzxbdsdata ( ef , 1 , nfield , str , stl ) call field_xyzbd ( ef , nfield ) end if if ( initial_time ) then !a one_step update u0 (:, :, :, :) = zero_dp call nc_fluid_density_momenta ( flx , u0 , dt_loc , fdim ) ! - F_adv(u) = - grad(Flux) call add_lorentz_force !in u_0 is stored Dt*(-F_adv(u)+ F_{Lorentz}) at t&#94;n do ic = 1 , fdim do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 u ( i , j , k , ic ) = u ( i , j , k , ic ) + u0 ( i , j , k , ic ) !updates u&#94;{n+1}=u&#94;{n-1}+2*Dt*F&#94;n flx ( i , j , k , ic ) = 0.5 * ( flx ( i , j , k , ic ) + u ( i , j , k , ic )) ! (P,den) at t(n+1/2) end do end do end do end do else !in u_0 enter F&#94;{n-1} do ic = 1 , fdim do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 u ( i , j , k , ic ) = u ( i , j , k , ic ) + abf_0 * u0 ( i , j , k , ic ) end do end do end do end do u0 (:, :, :, :) = 0.0 call nc_fluid_density_momenta ( flx , u0 , dt_loc , fdim ) call add_lorentz_force !in u_0 is ftored Dt*(F_adv(u)+ F_{Lorentz}) for next timestep do ic = 1 , fdim do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 u ( i , j , k , ic ) = u ( i , j , k , ic ) + abf_1 * u0 ( i , j , k , ic ) !updates u&#94;{n+1}=u&#94;{n}+Dt*(3/2*F&#94;n-1/2F&#94;{n-1}) end do do i = ix1 , ix2 flx ( i , j , k , ic ) = 0.5 * ( flx ( i , j , k , ic ) + u ( i , j , k , ic )) ! (P,den) at t(n+1/2) end do end do end do end do end if !========================== contains subroutine add_lorentz_force !in u0() -flux derivatives do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 den = 1. if ( flx ( i , j , k , fdim ) <= EPS ) den = 0.0 ex = WK1 * ( ef ( i , j , k , 1 ) + ef ( i - 1 , j , k , 1 )) !Ex(i,j,k) ey = WK1 * ( ef ( i , j , k , 2 ) + ef ( i , j - 1 , k , 2 )) !Ey(i,j,k) b1p = WK1 * ( ef ( i , j , k , nfield ) + ef ( i - 1 , j , k , nfield )) !bz(i,j+1/2,k) b1m = WK1 * ( ef ( i , j - 1 , k , nfield ) + ef ( i - 1 , j - 1 , k , nfield )) !bz(i,j-1/2,k) bz = WK1 * ( b1p + b1m ) !Bz(i,j,k) vx = flx ( i , j , k , fdim + 1 ) !vx&#94;n vy = flx ( i , j , k , fdim + 2 ) !vy&#94;n u0 ( i , j , k , 1 ) = u0 ( i , j , k , 1 ) + den * lzf * ( ex + vy * bz ) !=> u&#94;{n+1} u0 ( i , j , k , 2 ) = u0 ( i , j , k , 2 ) + den * lzf * ( ey - vx * bz ) end do end do end do if ( curr_ndim == 3 ) then do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 den = 1. if ( flx ( i , j , k , fdim ) <= EPS ) den = 0.0 ez = WK1 * ( ef ( i , j , k , 3 ) + ef ( i , j , k - 1 , 3 )) !Ez(i,j,k) b1p = WK1 * ( ef ( i , j , k , 5 ) + ef ( i - 1 , j , k , 5 )) !by(i+1/2,j,k+1/2) b1m = WK1 * ( ef ( i , j , k - 1 , 5 ) + ef ( i - 1 , j , k - 1 , 5 )) by = WK1 * ( b1p + b1m ) !By(i,j,k) b1p = WK1 * ( ef ( i , j , k , 4 ) + ef ( i , j - 1 , k , 4 )) !bx(i,j+1/2,k+1/2) b1m = WK1 * ( ef ( i , j , k - 1 , 4 ) + ef ( i , j - 1 , k - 1 , 4 )) bx = WK1 * ( b1p + b1m ) !Bx(i,j,k) vx = flx ( i , j , k , fdim + 1 ) !vx&#94;n vy = flx ( i , j , k , fdim + 2 ) !vy&#94;n vz = flx ( i , j , k , fdim + 3 ) !vz&#94;n u0 ( i , j , k , 1 ) = u0 ( i , j , k , 1 ) - den * lzf * vz * by u0 ( i , j , k , 2 ) = u0 ( i , j , k , 2 ) + den * lzf * vz * bx u0 ( i , j , k , 3 ) = u0 ( i , j , k , 3 ) + den * lzf * ( ez + vx * by - vy * bx ) !=> u&#94;{n+1} end do end do end do end if end subroutine end subroutine end module","tags":"","loc":"sourcefile/fluid_density_momenta.f90.html"},{"title":"curr_and_fields_util.f90 – ALaDyn","text":"This file depends on sourcefile~~curr_and_fields_util.f90~~EfferentGraph sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_param.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~grid_part_connect.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~curr_and_fields_util.f90~~AfferentGraph sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules curr_and_fields_util Source Code curr_and_fields_util.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module curr_and_fields_util use pstruct_data use fstruct_data use grid_param use mpi_curr_interface use mpi_field_interface use grid_part_connect use grid_fields use init_grid_field implicit none !=============================== ! MOVING WINDOW SECTION !============================= contains !============================ subroutine set_lpf_acc ( ef , sp_loc , apt , np , nf ) real ( dp ), intent ( in ) :: ef (:, :, :, :) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: apt (:, :) integer , intent ( in ) :: np , nf ! Uses alternating order quadratic or linear shapes select case ( ndim ) case ( 1 ) call set_part1d_acc ( ef , sp_loc , apt , np , nf ) case ( 2 ) call set_part2d_hcell_acc ( ef , sp_loc , apt , np , nf ) case ( 3 ) call set_part3d_hcell_acc ( ef , sp_loc , apt , np ) end select end subroutine subroutine field_charge_multiply ( sp_loc , apt , np , ncmp ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: apt (:, :) integer , intent ( in ) :: np , ncmp integer :: p , ch ch = size ( apt , 2 ) !========================== do p = 1 , np wgh_cmp = sp_loc % part ( p , ch ) apt ( p , 1 : ncmp ) = charge * apt ( p , 1 : ncmp ) end do ! EXIT p-assigned (E,B) fields multiplied by charge end subroutine subroutine curr_accumulate ( sp_loc , pdata , curr , npt ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pdata (:, :), curr (:, :, :, :) integer , intent ( in ) :: npt ! real(dp),intent(in) :: dtloc !========================= ! charge preserving for iform=0, 1 !iform=0 => (D_xJx,D_yJy,D_zJz) inverted on each particle=> (Jx,Jy,Jz) !iform=1    as iform=0 !iform=2    no charge preserving !========================= if ( npt == 0 ) return if ( ndim < 3 ) then if ( iform < 2 ) then call esirkepov_2d_curr ( sp_loc , pdata , curr , npt ) else call ncdef_2d_curr ( sp_loc , pdata , curr , npt ) end if return end if if ( iform < 2 ) then call esirkepov_3d_curr ( sp_loc , pdata , curr , npt ) else call ncdef_3d_curr ( sp_loc , pdata , curr , npt ) end if !======================== ! accumulates for each species currents on curr(i1:n1p,j1:n2p,k1:n3p,1:compnent) !============================ end subroutine !============================== subroutine curr_mpi_collect ( curr ) real ( dp ), intent ( inout ) :: curr (:, :, :, :) integer :: i , j , k , jj , kk real ( dp ) :: dery , derhy , derz , derhz !============sums data on ghost points if ( prl ) then call fill_curr_yzxbdsdata ( curr , curr_ndim ) end if call jc_xyzbd ( curr , curr_ndim ) !================= if ( iform < 2 ) then do i = 1 , ndim curr (:, :, :, i ) = djc ( i ) * curr (:, :, :, i ) end do end if if ( stretch ) then select case ( curr_ndim ) case ( 2 ) do k = kz1 , kz2 do j = jy1 , jy2 jj = j - 2 dery = loc_yg ( jj , 3 , imody ) derhy = loc_yg ( jj , 4 , imody ) do i = ix1 , ix2 curr ( i , j , k , 1 ) = dery * curr ( i , j , k , 1 ) curr ( i , j , k , 2 ) = derhy * curr ( i , j , k , 2 ) end do end do end do case ( 3 ) do k = kz1 , kz2 kk = k - 2 derz = loc_zg ( kk , 3 , imodz ) derhz = loc_zg ( kk , 4 , imodz ) do j = jy1 , jy2 jj = j - 2 dery = loc_yg ( jj , 3 , imody ) derhy = loc_yg ( jj , 4 , imody ) do i = ix1 , ix2 curr ( i , j , k , 1 ) = dery * derz * curr ( i , j , k , 1 ) curr ( i , j , k , 2 ) = derhy * derz * curr ( i , j , k , 2 ) curr ( i , j , k , 3 ) = dery * derhz * curr ( i , j , k , 3 ) end do end do end do end select end if end subroutine !================================= ! END SECTION ON GRID DEFINED PARTICLE VARIABLES !================================================ subroutine pfields_prepare ( ef , nc , spr , spl ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) integer , intent ( in ) :: nc , spr , spl !=================== ! Enter fields ef[i1:i2,j1,j2,k1,k2,1:nc) ! Exit fields ef[i1:i2,j1,j2,k1,k2,1:nc) !=========================== if ( prl ) then call fill_ebfield_yzxbdsdata ( ef , 1 , nc , spr , spl ) !====================== ! Adds point data => spl to the left spr to the right ! Sets periodic BCs for ! iby,ibz,ibx =2 !================== end if call field_xyzbd ( ef , nc ) ! extends for one point at the box boundaries !================================================== end subroutine !================================ subroutine advance_lpf_fields ( ef , curr , ibd ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: curr (:, :, :, :) integer , intent ( in ) :: ibd integer :: str , stl , ik real ( dp ) :: dth , dt_lp dt_lp = dt_loc dth = 0.5 * dt_lp !======================= ! A LPF order Lpf with time-centered source term !============================= if ( prl ) then str = 1 stl = 2 call fill_ebfield_yzxbdsdata ( ef , 1 , curr_ndim , str , stl ) ! To fill electric field data ! sends stl to the left, ! recvs stl points from right at (nyp+stl), (nzp+stl) end if !============== first substep dt/2 advance of B-field call ef_bds ( ef , zero_dp , ibd ) ! Uses upper BCs of E fields: ibd=0 for inflow-outflow !                             ibd=1 for symmetric if ( comoving ) then call field_xadvect ( ef , dth , - vbeam , curr_ndim + 1 , nfield , 0 ) ! Solves for one-half step backward advection B field explicit ! B&#94;{n} => B&#94;{n}+v_b*Dth[Dx]B&#94;n  v_b >0 end if !================================== ! solves B&#94;{n+1/2}= B&#94;n -Dth[rot E]&#94;n !============================ call rote ( ef , dth ) !============================= !============== central step for advance of E-field if ( prl ) then str = 2 stl = 1 call fill_ebfield_yzxbdsdata ( ef , curr_ndim + 1 , nfield , str , stl ) ! sends nyp+1-str to the right ! recvs str points from left at (1-str) end if !====================== call bf_bds ( ef , dt_lp , ibd ) ! Uses lower BCs for B fields: ibd=0 for inflow-outflow !                             ibd=1 for symmetric if ( comoving ) then call field_xadvect ( ef , dth , - vbeam , 1 , curr_ndim , 0 ) ! Solves for half-step backward advection E field explicit ! E&#94;{n} => E&#94;{n}+v_b*Dth[Dx]E&#94;n end if !======================= ! solves E&#94;{n+1}= E&#94;n +DT[rot B]&#94;{n+1/2}- ompe*DT*J&#94;{n+1/2} !================== call rotb ( ef , dt_lp ) !=================== ! adds currents do ik = 1 , curr_ndim ef ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , ik ) = ef ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , & ik ) - ompe * curr ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , ik ) end do if ( comoving ) then call field_xadvect ( ef , dth , - vbeam , 1 , curr_ndim , 2 ) ! Solves for backward advection E field implicit ! E&#94;{n+1} => E&#94;{n}+v_b*Dth[Dx]E&#94;{n+1} end if !============== second substep dt/2 advance of B-field if ( prl ) then str = 1 stl = 2 call fill_ebfield_yzxbdsdata ( ef , 1 , curr_ndim , str , stl ) end if ! E field gets stl points from right (nyp+stl), (nzp+stl) call ef_bds ( ef , dt_lp , ibd ) ! solves B&#94;{n+1}= B&#94;{n+1/2} -Dth[rot E]&#94;{n+1} !=================== call rote ( ef , dth ) !============== if ( comoving ) then call field_xadvect ( ef , dth , - vbeam , curr_ndim + 1 , nfield , 2 ) ! Solves for one-half step backward advection B field implicit ! B&#94;{n+1} => B&#94;{n+1/2}+v_b*Dth[Dx]B&#94;{n+1} end if !=============== end subroutine !====================== subroutine advance_lpf_envelope ( curr , evf , omg ) real ( dp ), intent ( inout ) :: curr (:, :, :, :), evf (:, :, :, :) real ( dp ), intent ( in ) :: omg integer :: i , j , k integer :: str , stl , cind , ib !====== enter env(3:4)=A&#94;{n-1} and env(1:2)= A&#94;{n} ! enters jc(3)=<wgh*n/gamp> >0 str = 2 stl = 2 !ord=2 cind = 1 !cind=0 FFT cind=1 grid deriv ib = 2 !ib=1 implicit ib=2 optimazid explicit !optimized advection scheme if ( comoving ) ib = 0 if ( prl ) then call fill_ebfield_yzxbdsdata ( evf , 1 , 2 , str , stl ) end if call env_bds ( evf , str , stl ) do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 curr ( i , j , k , 1 ) = - ompe * curr ( i , j , k , 3 ) * evf ( i , j , k , 1 ) curr ( i , j , k , 2 ) = - ompe * curr ( i , j , k , 3 ) * evf ( i , j , k , 2 ) end do end do end do !  curr(1:2)=-ompe*chi*env(1:2)  the J_{env} source term !================================== if ( ib == 0 ) then call env_lpf_solve ( jc , evf , ib , omg , dt_loc ) else !=================== second order in time full wave equation call env_maxw_solve ( jc , evf , omg , dt_loc ) end if ! ================================= end subroutine !======================================================== subroutine wave_field_left_inject ( ef , x_left ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: x_left real ( dp ) :: tnew , xm integer :: wmodel_id , ic wmodel_id = model_id xm = xmn if ( plane_wave ) wmodel_id = 0 tnew = tnow !Set inflow values [B_z{n}(i1-1/2) E_y{n}(i-1} lp_inject = . false . do ic = 1 , nb_laser if ( lp_in ( ic ) < x_left ) then if ( lp_end ( ic ) >= xm ) then lp_inject = . true . if ( model_id < 3 ) call inflow_lp_fields ( ebf , lp_amp , tnew , t0_lp , & w0_x , w0_y , xf_loc ( ic ), oml , wmodel_id , ix1 , jy1 , jy2 , kz1 , kz2 ) if ( model_id == 3 ) call inflow_cp_fields ( ebf , lp_amp , tnew , t0_lp , & w0_x , w0_y , xf_loc ( ic ), wmodel_id , ix1 , jy1 , jy2 , kz1 , kz2 ) end if end if lp_in ( ic ) = lp_in ( ic ) + dt_loc lp_end ( ic ) = lp_end ( ic ) + dt_loc end do if ( Two_color ) then if ( lp_ionz_in < x_left ) then if ( lp_ionz_end >= xm ) then lp_inject = . true . call inflow_lp_fields ( ebf , lp1_amp , tnew , t1_lp , w1_x , w1_y , xf1 , & om1 , model_id , ix1 , jy1 , jy2 , kz1 , kz2 ) end if end if lp_ionz_in = lp_ionz_in + dt_loc lp_ionz_end = lp_ionz_end + dt_loc end if end subroutine !=================================================== subroutine advect_bunch_fields ( fb , curr , v_b ) real ( dp ), intent ( inout ) :: fb (:, :, :, :), curr (:, :, :, :) real ( dp ), intent ( in ) :: v_b real ( dp ) :: dth integer :: ix , iy , iz dth = 0.5 * dt_loc !In 2D nfield=3 nbfield=4=nfield+1   in fb(4)=Jx[i+1/2,j,k] at t=0 !fb=[Ex,Ey,Ez,Jx,By,Bz] !================================================ call fill_ebfield_xbdsdata ( fb , 1 , nbfield , 1 , 1 ) if ( initial_time ) then call field_xadvect ( fb , dth , - v_b , 4 , 4 , 1 ) fb (:, :, :, 4 ) = dt_loc * fb (:, :, :, 4 ) end if call field_xadvect ( fb , dt_loc , v_b , 1 , nbfield , 1 ) do iz = kz1 , kz2 do iy = jy1 , jy2 do ix = ix1 , ix2 curr ( ix , iy , iz , 1 ) = curr ( ix , iy , iz , 1 ) - fb ( ix , iy , iz , 4 ) end do end do end do ! Subtracts from the longitudinal bunch current the advected initial bunch ! current end subroutine !============================ end module","tags":"","loc":"sourcefile/curr_and_fields_util.f90.html"},{"title":"boris_push.f90 – ALaDyn","text":"This file depends on sourcefile~~boris_push.f90~~EfferentGraph sourcefile~boris_push.f90 boris_push.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~boris_push.f90->sourcefile~fstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~boris_push.f90->sourcefile~common_param.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~boris_push.f90->sourcefile~pstruct_data.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~boris_push.f90~~AfferentGraph sourcefile~boris_push.f90 boris_push.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules boris_push Source Code boris_push.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module boris_push use pstruct_data use fstruct_data use common_param implicit none contains ! SECTION for Leap-frog integrators in LP regime !========================== subroutine init_lpf_momenta ( sp_loc , pt , np , ic ) type ( species ), intent ( inout ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np , ic integer :: p real ( dp ) :: alp , dth_lp , pp ( 3 ), vp ( 3 ), efp ( 6 ), gam2 , gam_inv dth_lp = 0.5 * dt_loc alp = dth_lp * lorentz_fact ( ic ) ! Lfact =1./m ! Fields are already multiplied by particle(ic) charge !========================= ! from p&#94;n to p&#94;{n-1/2} !========================== select case ( curr_ndim ) case ( 2 ) do p = 1 , np efp ( 1 : 3 ) = - alp * pt ( p , 1 : 3 ) !-DT/2*charge*(Ex,Ey,Bz)&#94;n pp ( 1 : 2 ) = sp_loc % part ( p , 3 : 4 ) !p_{n} gam2 = 1. + dot_product ( pp ( 1 : 2 ), pp ( 1 : 2 )) gam_inv = 1. / sqrt ( gam2 ) vp ( 1 : 2 ) = pp ( 1 : 2 ) * gam_inv sp_loc % part ( p , 3 ) = sp_loc % part ( p , 3 ) + efp ( 1 ) + vp ( 2 ) * efp ( 3 ) sp_loc % part ( p , 4 ) = sp_loc % part ( p , 4 ) + efp ( 2 ) - vp ( 1 ) * efp ( 3 ) end do case ( 3 ) do p = 1 , np pp ( 1 : 3 ) = sp_loc % part ( p , 4 : 6 ) efp ( 1 : 6 ) = - alp * pt ( p , 1 : 6 ) gam2 = 1. + dot_product ( pp ( 1 : 3 ), pp ( 1 : 3 )) gam_inv = 1. / sqrt ( gam2 ) !1/gamma vp ( 1 : 3 ) = gam_inv * pp ( 1 : 3 ) sp_loc % part ( p , 4 ) = sp_loc % part ( p , 4 ) + efp ( 1 ) + vp ( 2 ) * efp ( 6 ) - & vp ( 3 ) * efp ( 5 ) sp_loc % part ( p , 5 ) = sp_loc % part ( p , 5 ) + efp ( 2 ) + vp ( 3 ) * efp ( 4 ) - & vp ( 1 ) * efp ( 6 ) sp_loc % part ( p , 6 ) = sp_loc % part ( p , 6 ) + efp ( 3 ) + vp ( 1 ) * efp ( 5 ) - & vp ( 2 ) * efp ( 4 ) end do end select end subroutine !====================================== subroutine lpf_momenta_and_positions ( sp_loc , pt , np , ic ) type ( species ), intent ( inout ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np , ic integer :: p , ch real ( dp ) :: alp , dt_lp , dth_lp , bb ( 3 ), pp ( 3 ), vp ( 3 ), vph ( 3 ), efp ( 6 ), & b2 , bv , gam02 , gam2 , gam !======================================== ! uses exact explicit solution for ! p&#94;{n}=(p&#94;{n+1/2}+p&#94;{n-1/2})/2 and gamma&#94;n=sqrt( 1+p&#94;n*p&#94;n) ! v&#94;n=p&#94;n/gamma&#94;n !======================================== !Enter Fields multiplied by particle charge dt_lp = dt_loc dth_lp = 0.5 * dt_lp alp = dth_lp * lorentz_fact ( ic ) select case ( curr_ndim ) case ( 2 ) ch = 5 do p = 1 , np pp ( 1 : 2 ) = sp_loc % part ( p , 3 : 4 ) !p_{n-1/2} efp ( 1 : 3 ) = alp * pt ( p , 1 : 3 ) !q*Lfact*(Ex,Ey,Bz)*Dt/2 vp ( 1 : 2 ) = pp ( 1 : 2 ) + efp ( 1 : 2 ) !u&#94;{-} in Boris push vp ( 3 ) = efp ( 3 ) !b_z gam02 = 1. + dot_product ( vp ( 1 : 2 ), vp ( 1 : 2 )) !gam0 in Boris push b2 = vp ( 3 ) * vp ( 3 ) !b_z*b_z gam02 = gam02 - b2 gam2 = 0.5 * ( gam02 + sqrt ( gam02 * gam02 + 4. * b2 )) !exact gam&#94;2 solution gam = sqrt ( gam2 ) !============================== !p_n=(gam2*vp+gam*(vp crossb)+b*bv/(gam2+b2) vph ( 1 ) = gam2 * vp ( 1 ) + gam * vp ( 2 ) * vp ( 3 ) vph ( 2 ) = gam2 * vp ( 2 ) - gam * vp ( 1 ) * vp ( 3 ) vph ( 1 : 2 ) = vph ( 1 : 2 ) / ( gam2 + b2 ) sp_loc % part ( p , 3 : 4 ) = 2. * vph ( 1 : 2 ) - pp ( 1 : 2 ) !=========== the new momenta !        update positions pt ( p , 3 : 4 ) = sp_loc % part ( p , 1 : 2 ) !old positions stored pp ( 1 : 2 ) = sp_loc % part ( p , 3 : 4 ) gam2 = 1. + dot_product ( pp ( 1 : 2 ), pp ( 1 : 2 )) pt ( p , 5 ) = dt_lp / sqrt ( gam2 ) vp ( 1 : 2 ) = pt ( p , 5 ) * pp ( 1 : 2 ) !velocities pt ( p , 1 : 2 ) = vp ( 1 : 2 ) !stores DT*V&#94;{n+1/2} sp_loc % part ( p , 1 : 2 ) = sp_loc % part ( p , 1 : 2 ) + vp ( 1 : 2 ) !new positions end do case ( 3 ) ch = 7 do p = 1 , np pp ( 1 : 3 ) = sp_loc % part ( p , 4 : 6 ) efp ( 1 : 6 ) = alp * pt ( p , 1 : 6 ) !q*Lfact*(E,B) on p-th-particle vp ( 1 : 3 ) = pp ( 1 : 3 ) + efp ( 1 : 3 ) !p&#94;{-} in Boris push bb ( 1 : 3 ) = efp ( 4 : 6 ) gam02 = 1. + dot_product ( vp ( 1 : 3 ), vp ( 1 : 3 )) !the lower order gamma in Boris scheme !============================= b2 = dot_product ( bb ( 1 : 3 ), bb ( 1 : 3 )) bv = dot_product ( bb ( 1 : 3 ), vp ( 1 : 3 )) gam02 = gam02 - b2 gam2 = 0.5 * ( gam02 + sqrt ( gam02 * gam02 + 4. * ( b2 + bv * bv ))) ! exact solution for gam2=1+p_n*p_n gam = sqrt ( gam2 ) !============================ vph ( 1 : 3 ) = gam2 * vp ( 1 : 3 ) + bb ( 1 : 3 ) * bv vph ( 1 ) = vph ( 1 ) + gam * ( vp ( 2 ) * bb ( 3 ) - vp ( 3 ) * bb ( 2 )) vph ( 2 ) = vph ( 2 ) + gam * ( vp ( 3 ) * bb ( 1 ) - vp ( 1 ) * bb ( 3 )) vph ( 3 ) = vph ( 3 ) + gam * ( vp ( 1 ) * bb ( 2 ) - vp ( 2 ) * bb ( 1 )) vph ( 1 : 3 ) = vph ( 1 : 3 ) / ( b2 + gam2 ) !p_n=(p_{n+1/2)+p_{n-1/2})/2 !======== advance momenta sp_loc % part ( p , 4 : 6 ) = 2. * vph ( 1 : 3 ) - pp ( 1 : 3 ) !========== pt ( p , 4 : 6 ) = sp_loc % part ( p , 1 : 3 ) !stores old positions pp ( 1 : 3 ) = sp_loc % part ( p , 4 : 6 ) gam2 = 1. + dot_product ( pp ( 1 : 3 ), pp ( 1 : 3 )) pt ( p , 7 ) = dt_lp / sqrt ( gam2 ) vp ( 1 : 3 ) = pt ( p , 7 ) * pp ( 1 : 3 ) pt ( p , 1 : 3 ) = vp ( 1 : 3 ) !stores dt*V sp_loc % part ( p , 1 : 3 ) = sp_loc % part ( p , 1 : 3 ) + vp ( 1 : 3 ) !new positions end do end select !==================== if ( iform < 2 ) then !old charge stored for charge preserving schemes do p = 1 , np pt ( p , ch ) = sp_loc % part ( p , ch ) end do end if !In comoving frame vbeam >0 if ( vbeam > 0. ) then do p = 1 , np sp_loc % part ( p , 1 ) = sp_loc % part ( p , 1 ) - dt_lp * vbeam pt ( p , 1 ) = pt ( p , 1 ) - dt_lp * vbeam ! end do end if end subroutine !============================= subroutine lpf_env_momenta ( sp_loc , f_pt , np , ic ) type ( species ), intent ( inout ) :: sp_loc real ( dp ), intent ( inout ) :: f_pt (:, :) integer , intent ( in ) :: np , ic integer :: p real ( dp ) :: bb ( 3 ), pp ( 3 ), vp ( 3 ), vph ( 3 ) real ( dp ) :: b2 , bv , alp , dt_lp , efp ( 6 ) dt_lp = dt_loc alp = 0.5 * dt_lp * lorentz_fact ( ic ) !========================== !Enter F_pt(1:2)= q*(E+0.5q*grad[F]/gamp) and F_pt(3)=q*B/gamp     where F=|A|&#94;2/2 select case ( curr_ndim ) case ( 2 ) !F_pt(5)=wgh/gamp do p = 1 , np pp ( 1 : 2 ) = sp_loc % part ( p , 3 : 4 ) !p_{n-1/2} efp ( 1 : 3 ) = alp * f_pt ( p , 1 : 3 ) !Lz_fact*Dt/2 vp ( 1 : 2 ) = pp ( 1 : 2 ) + efp ( 1 : 2 ) !u&#94;{-} bb ( 1 ) = efp ( 3 ) !============================== b2 = 1. + bb ( 1 ) * bb ( 1 ) vph ( 1 ) = vp ( 1 ) + vp ( 2 ) * bb ( 1 ) vph ( 2 ) = vp ( 2 ) - vp ( 1 ) * bb ( 1 ) vph ( 1 : 2 ) = vph ( 1 : 2 ) / b2 !p_n=(p_{n+1/2)+p_{n-1/2})/2 sp_loc % part ( p , 3 : 4 ) = 2. * vph ( 1 : 2 ) - pp ( 1 : 2 ) f_pt ( p , 1 : 2 ) = sp_loc % part ( p , 1 : 2 ) end do !F_pt(5)=wgh/gamp unchanged case ( 3 ) !F_pt(7)=wgh/gamp do p = 1 , np pp ( 1 : 3 ) = sp_loc % part ( p , 4 : 6 ) efp ( 1 : 6 ) = alp * f_pt ( p , 1 : 6 ) !multiply by Lz_fact*Dt/2 vp ( 1 : 3 ) = efp ( 1 : 3 ) + pp ( 1 : 3 ) !p_{n-1/2}+alp*(E+0.5*F/gamp) bb ( 1 : 3 ) = efp ( 4 : 6 ) !alp*B/gamp !============================= ! The Boris pusher !========================= b2 = 1. + dot_product ( bb ( 1 : 3 ), bb ( 1 : 3 )) bv = dot_product ( bb ( 1 : 3 ), vp ( 1 : 3 )) vph ( 1 ) = vp ( 1 ) + vp ( 2 ) * bb ( 3 ) - vp ( 3 ) * bb ( 2 ) + bb ( 1 ) * bv vph ( 2 ) = vp ( 2 ) + vp ( 3 ) * bb ( 1 ) - vp ( 1 ) * bb ( 3 ) + bb ( 2 ) * bv vph ( 3 ) = vp ( 3 ) + vp ( 1 ) * bb ( 2 ) - vp ( 2 ) * bb ( 1 ) + bb ( 3 ) * bv vph ( 1 : 3 ) = vph ( 1 : 3 ) / b2 !p_n=(p_{n+1/2)+p_{n-1/2})/2 !======== advance momenta sp_loc % part ( p , 4 : 6 ) = 2. * vph ( 1 : 3 ) - pp ( 1 : 3 ) f_pt ( p , 1 : 3 ) = sp_loc % part ( p , 1 : 3 ) !stores old positions end do !F_pt(7)=wgh/gamp unchanged end select end subroutine !====================== subroutine lpf_env_positions ( sp_loc , f_pt , np ) type ( species ), intent ( inout ) :: sp_loc real ( dp ), intent ( inout ) :: f_pt (:, :) integer , intent ( in ) :: np integer :: p , ch real ( dp ) :: pp ( 3 ), vp ( 3 ) real ( dp ) :: b2 , gam2 , gam_inv , dt_lp , dth_lp , gam , gam3 dt_lp = dt_loc dth_lp = 0.5 * dt_lp ch = 5 !========================== select case ( curr_ndim ) !============  enter F_pt(3)=F, F_pt (1:2) Grad[F] where F=|A|&#94;2/2 !             at time level t&#94;{n+1/2} assigned to the x&#94;n positions case ( 2 ) do p = 1 , np pp ( 1 : 2 ) = sp_loc % part ( p , 3 : 4 ) !p&#94;{n+1/2} vp ( 1 : 2 ) = f_pt ( p , 1 : 2 ) !grad[F] !============================= gam2 = 1. + dot_product ( pp ( 1 : 2 ), pp ( 1 : 2 )) + f_pt ( p , 3 ) gam = sqrt ( gam2 ) gam3 = gam2 * gam b2 = 0.25 * dot_product ( pp ( 1 : 2 ), vp ( 1 : 2 )) !-------------------- def gamma_p gam_inv = 1. / gam gam_inv = gam_inv * ( 1. - dt_lp * b2 / gam3 ) !============================ vp ( 1 : 2 ) = dt_lp * gam_inv * pp ( 1 : 2 ) f_pt ( p , 3 : 4 ) = sp_loc % part ( p , 1 : 2 ) !old (x,y)&#94;n positions f_pt ( p , 5 ) = dt_lp * gam_inv ! dt/gamma sp_loc % part ( p , 1 : 2 ) = sp_loc % part ( p , 1 : 2 ) + vp ( 1 : 2 ) f_pt ( p , 1 : 2 ) = vp ( 1 : 2 ) ! dt*V&#94;{n+1/2}  velocities end do case ( 3 ) !============enter F_pt(4)=F, F_pt (1:3) Grad[F] where F=|A|&#94;2/2 at t&#94;{n+1/2} ! assigned at x&#94;n ch = 7 do p = 1 , np pp ( 1 : 3 ) = sp_loc % part ( p , 4 : 6 ) !p&#94;{n+1/2} vp ( 1 : 3 ) = f_pt ( p , 1 : 3 ) !grad[F] !============================= gam2 = 1. + dot_product ( pp ( 1 : 3 ), pp ( 1 : 3 )) + f_pt ( p , 4 ) gam = sqrt ( gam2 ) gam3 = gam2 * gam b2 = 0.25 * dot_product ( pp ( 1 : 3 ), vp ( 1 : 3 )) !-------------------- gam_inv = 1. / sqrt ( gam2 ) gam_inv = gam_inv * ( 1. - dt_lp * b2 / gam3 ) vp ( 1 : 3 ) = dt_lp * gam_inv * pp ( 1 : 3 ) f_pt ( p , 4 : 6 ) = sp_loc % part ( p , 1 : 3 ) !old positions f_pt ( p , 7 ) = dt_lp * gam_inv ! dt*gam_inv sp_loc % part ( p , 1 : 3 ) = sp_loc % part ( p , 1 : 3 ) + vp ( 1 : 3 ) f_pt ( p , 1 : 3 ) = vp ( 1 : 3 ) ! dt*V&#94;{n+1/2}  velocities end do end select if ( iform < 2 ) then do p = 1 , np f_pt ( p , ch ) = sp_loc % part ( p , ch ) end do end if !====================== vb=-wbet > 0 in comoving x-coordinate if ( vbeam > 0.0 ) then do p = 1 , np sp_loc % part ( p , 1 ) = sp_loc % part ( p , 1 ) - dt_lp * vbeam f_pt ( p , 1 ) = f_pt ( p , 1 ) - dt_lp * vbeam !new x-position end do end if end subroutine !===================== end module","tags":"","loc":"sourcefile/boris_push.f90.html"},{"title":"pic_evolve_in_time.f90 – ALaDyn","text":"This file depends on sourcefile~~pic_evolve_in_time.f90~~EfferentGraph sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~boris_push.f90 boris_push.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~pstruct_data.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_param.f90 sourcefile~boris_push.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~boris_push.f90->sourcefile~common_param.f90 sourcefile~boris_push.f90->sourcefile~fstruct_data.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~util.f90 util.f90 sourcefile~window.f90->sourcefile~util.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~window.f90->sourcefile~pstruct_data.f90 sourcefile~window.f90->sourcefile~common_param.f90 sourcefile~window.f90->sourcefile~fstruct_data.f90 sourcefile~window.f90->sourcefile~grid_param.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~mpi_part_interface.f90->sourcefile~code_util.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90->sourcefile~grid_param.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~ionize.f90->sourcefile~ionz_data.f90 sourcefile~ionize.f90->sourcefile~util.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 sourcefile~ionize.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~ionize.f90->sourcefile~mpi_var.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~run_data_info.f90->sourcefile~ionz_data.f90 sourcefile~run_data_info.f90->sourcefile~phys_param.f90 sourcefile~run_data_info.f90->sourcefile~code_util.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~common_param.f90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~run_data_info.f90->sourcefile~fstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~run_data_info.f90->sourcefile~control_bunch_input.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~grid_part_connect.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pic_evolve_in_time.f90~~AfferentGraph sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules pic_evolve Source Code pic_evolve_in_time.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module pic_evolve use window use boris_push use curr_and_fields_util use mpi_part_interface use init_grid_field use ionize use fluid_density_momenta implicit none contains subroutine lpf2_evolve ( iter_loc ) integer , intent ( in ) :: iter_loc integer :: ic , np , id_ch real ( dp ) :: ef2_ion ( 1 ), loc_ef2_ion ( 1 ) logical , parameter :: mw = . false . !============================ call pfields_prepare ( ebf , nfield , 2 , 2 ) if ( ionization ) then if ( iter_loc == 0 ) then call init_random_seed ( mype ) end if id_ch = nd2 + 1 do ic = 2 , nsp_ionz np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then call set_ion_efield ( ebf , spec ( ic ), ebfp , np ) if ( mod ( iter_loc , 100 ) == 0 ) then !refresh ionization tables, if needed loc_ef2_ion ( 1 ) = maxval ( ebfp ( 1 : np , id_ch )) loc_ef2_ion ( 1 ) = sqrt ( loc_ef2_ion ( 1 )) ef2_ion ( 1 ) = loc_ef2_ion ( 1 ) !if(prl)call allreduce_dpreal(MAXV,loc_ef2_ion,ef2_ion,1) if ( ef2_ion ( 1 ) > lp_max ) then lp_max = 1.1 * ef2_ion ( 1 ) call set_field_ioniz_wfunction ( ion_min ( ic - 1 ), & atomic_number ( ic - 1 ), ic , ionz_lev , ionz_model , lp_max ) end if end if call ionization_cycle ( spec ( ic ), ebfp , np , ic , iter_loc , 0 , de_inv ) end if !======== injects new electrons. end do end if !===================END IONIZATION MODULE============ !    ions enter with new ionization levels and new electrons !                   are injected !============================================= jc (:, :, :, :) = zero_dp !curr_clean do ic = 1 , nsp_run np = loc_npart ( imody , imodz , imodx , ic ) !============ call set_lpf_acc ( ebf , spec ( ic ), ebfp , np , nfield ) call field_charge_multiply ( spec ( ic ), ebfp , np , nfield ) if ( initial_time ) call init_lpf_momenta ( spec ( ic ), ebfp , np , ic ) call lpf_momenta_and_positions ( spec ( ic ), ebfp , np , ic ) ! For each species : ! ebfp(1:3) store (X&#94;{n+1}-X_n)=V&#94;{n+1/2}*dt ! ebfp(4:7) store old x&#94;n positions and dt/gam at t&#94;{n+1/2} if ( part ) call cell_part_dist ( mw ) ! np = loc_npart ( imody , imodz , imodx , ic ) call curr_accumulate ( spec ( ic ), ebfp , jc , np ) !================= only old ion charge saved end do !========================================== if ( part ) call curr_mpi_collect ( jc ) !================ sums and normalize currents if ( hybrid ) then call set_momentum_density_flux ( up , flux ) call update_adam_bash_fluid_variables ( up , up0 , flux , ebf ) ! In flux(1:curr_ndim+1) are stored fluid (P,den) at t&#94;{n+1/2} call fluid_curr_accumulate ( flux , jc ) !===================================== ! In jc(1:3) exit total current density array Dt*(Jx,Jy,Jz)&#94;{n+1/2} end if !======================= ! Inject fields at i=i1-1  for inflow Lp_inject=T !call wave_field_left_inject(xmn)  !(Bz=Ey By=Ez are injected at i1-1 point call advance_lpf_fields ( ebf , jc , 0 ) !============================ end subroutine !=============== ! END SECTION for Leap-frog one-cycle integrator in LP regime !=============== subroutine lp_run ( t_loc , iter_loc ) real ( dp ), intent ( in ) :: t_loc integer , intent ( in ) :: iter_loc real ( dp ) :: ts !================================ !========================= call lpf2_evolve ( iter_loc ) !=================================== ts = t_loc if ( w_speed > 0.0 ) then ! moves the computational box with w_speed>0. if ( ts >= wi_time . and . ts < wf_time ) then if ( mod ( iter_loc , w_sh ) == 0 ) then call lp_window_xshift ( w_sh , iter_loc ) end if end if end if if ( comoving ) then if ( ts >= wi_time . and . ts < wf_time ) then if ( mod ( iter_loc , w_sh ) == 0 ) then call comoving_coordinate ( vbeam , w_sh , iter_loc ) end if end if end if !============================== !vbeam=-w_speed !vbeam >0 uses the xw=(x+vbeam*t) !x=xi=(xw-vbeam*t) fixed !============================== end subroutine end module","tags":"","loc":"sourcefile/pic_evolve_in_time.f90.html"},{"title":"env_evolve_in_time.f90 – ALaDyn","text":"This file depends on sourcefile~~env_evolve_in_time.f90~~EfferentGraph sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~boris_push.f90 boris_push.f90 sourcefile~env_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~util.f90 util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~util.f90 sourcefile~window.f90 window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_param.f90 sourcefile~boris_push.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~boris_push.f90->sourcefile~common_param.f90 sourcefile~boris_push.f90->sourcefile~fstruct_data.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~window.f90->sourcefile~util.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~window.f90->sourcefile~pstruct_data.f90 sourcefile~window.f90->sourcefile~common_param.f90 sourcefile~window.f90->sourcefile~fstruct_data.f90 sourcefile~window.f90->sourcefile~grid_param.f90 sourcefile~mpi_part_interface.f90->sourcefile~code_util.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90->sourcefile~grid_param.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~ionize.f90->sourcefile~util.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~ionize.f90->sourcefile~ionz_data.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 sourcefile~ionize.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~ionize.f90->sourcefile~mpi_var.f90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~run_data_info.f90->sourcefile~ionz_data.f90 sourcefile~run_data_info.f90->sourcefile~code_util.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~common_param.f90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~run_data_info.f90->sourcefile~fstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~run_data_info.f90->sourcefile~phys_param.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~run_data_info.f90->sourcefile~control_bunch_input.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~grid_part_connect.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~env_evolve_in_time.f90~~AfferentGraph sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules env_evolve Source Code env_evolve_in_time.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module env_evolve use window , only : lp_window_xshift , comoving_coordinate use boris_push use curr_and_fields_util use mpi_part_interface , only : cell_part_dist use ionize , only : set_field_ioniz_wfunction , ionization_cycle , de_inv use fluid_density_momenta , only : fluid_curr_accumulate , & set_env_momentum_density_flux , update_adam_bash_fluid_variables use util , only : init_random_seed implicit none !=============================== contains !============================ ! ENVELOPE model in LP regime !============================ subroutine env_den_collect ( source_in ) real ( dp ), intent ( inout ) :: source_in (:, :, :, :) integer :: i , j , k , kk , jj , ic real ( dp ) :: dery , derz ic = 1 if ( prl ) then call fill_curr_yzxbdsdata ( source_in , ic ) end if call den_zyxbd ( source_in , ic ) !=======Enters normalized <w*n/gam> > 0 !================================== if ( stretch ) then ic = 1 if ( ndim == 2 ) then k = 1 do j = jy1 , jy2 jj = j - 2 dery = loc_yg ( jj , 3 , imody ) do i = ix1 , ix2 source_in ( i , j , k , ic ) = dery * source_in ( i , j , k , ic ) end do end do return end if do k = kz1 , kz2 kk = k - 2 derz = loc_zg ( kk , 3 , imodz ) do j = jy1 , jy2 jj = j - 2 dery = derz * loc_yg ( jj , 3 , imody ) do i = ix1 , ix2 source_in ( i , j , k , ic ) = dery * source_in ( i , j , k , ic ) end do end do end do end if !========================= !exit in source_in(ic)  the source terms chi() >0 of the envelope equation !----------------------------------------------- end subroutine !========================= subroutine env_two_fields_average ( evf , ev1f , av , spl_in , spr_in ) real ( dp ), intent ( in ) :: evf (:, :, :, :), ev1f (:, :, :, :) real ( dp ), intent ( out ) :: av (:, :, :, :) integer , intent ( in ) :: spl_in , spr_in integer :: ix , iy , iz real ( dp ) :: ar , ai !=================== do iz = kz1 , kz2 do iy = jy1 , jy2 do ix = ix1 , ix2 ar = 0.5 * ( evf ( ix , iy , iz , 1 ) + evf ( ix , iy , iz , 3 )) !A&#94;{n+1/2}=(A&#94;n+1+A&#94;n)/2 ai = 0.5 * ( evf ( ix , iy , iz , 2 ) + evf ( ix , iy , iz , 4 )) av ( ix , iy , iz , 1 ) = 0.5 * ( ar * ar + ai * ai ) ar = 0.5 * ( ev1f ( ix , iy , iz , 1 ) + ev1f ( ix , iy , iz , 3 )) !A&#94;{n+1/2}=(A&#94;n+1+A&#94;n)/2 ai = 0.5 * ( ev1f ( ix , iy , iz , 2 ) + ev1f ( ix , iy , iz , 4 )) av ( ix , iy , iz , 1 ) = av ( ix , iy , iz , 1 ) + 0.5 * ( ar * ar + ai * ai ) ! |A|&#94;2/2 at t&#94;{n+1/2}=> gamp&#94;{n+1/2} !  NO overlap assumed end do end do end do if ( prl ) call fill_ebfield_yzxbdsdata ( av , 1 , 1 , spr_in , spl_in ) !call field_xyzbd(av,i1,i2,j1,j2,k1,k2,1,spr_in,spl_in) !===================== end subroutine !=========================== subroutine env_fields_average ( evf , av , spl_in , spr_in ) real ( dp ), intent ( in ) :: evf (:, :, :, :) real ( dp ), intent ( out ) :: av (:, :, :, :) integer , intent ( in ) :: spl_in , spr_in integer :: ix , iy , iz , ord real ( dp ) :: ar , ai real ( dp ), parameter :: frac = one_dp / 8. !=================== ord = 2 ! |A|&#94;2/2 at t&#94;{n+1/2}=> gamp&#94;{n+1/2} av ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) = & frac * ( & ( evf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) + evf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 3 )) * & ( evf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) + evf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 3 )) + & ( evf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 2 ) + evf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 4 )) * & ( evf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 2 ) + evf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 4 ))) if ( prl ) call fill_ebfield_yzxbdsdata ( av , 1 , 1 , spr_in , spl_in ) call env_grad ( av ) !Exit staggered grad|A|&#94;2/2 in jc(2:4) or jc(2:3) if ( prl ) call fill_ebfield_yzxbdsdata ( av , 2 , curr_ndim + 1 , spr_in , & spl_in ) !===================== end subroutine !=========================== subroutine env_amp_prepare ( envf , av , ord , spl_in , spr_in ) real ( dp ), intent ( in ) :: envf (:, :, :, :) real ( dp ), intent ( out ) :: av (:, :, :, :) integer , intent ( in ) :: ord , spl_in , spr_in integer :: spl , spr !real(dp) :: ar,ai !=================== !|A|&#94;2/2 at current t&#94;n time level av ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) = 0.5 * & ( envf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) * envf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) + & envf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 2 ) * envf ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 2 )) spl = spl_in spr = spr_in if ( spl > 2 ) spl = 2 if ( spr > 2 ) spr = 2 if ( prl ) call fill_ebfield_yzxbdsdata ( av , 1 , 1 , spr , spl ) call env_grad ( av ) !Exit staggered grad|A|&#94;2/2 in jc(2:4) or jc(2:3) if ( prl ) call fill_ebfield_yzxbdsdata ( av , 1 , curr_ndim + 1 , spr , spl ) !call field_xyzbd(av,i1,i2,j1,j2,k1,k2,nj_dim,spr,spl) !===================== end subroutine !============================= subroutine env_amp_two_fields_prepare ( envf , env1f , av , ord , spl_in , & spr_in ) real ( dp ), intent ( in ) :: envf (:, :, :, :), env1f (:, :, :, :) real ( dp ), intent ( out ) :: av (:, :, :, :) integer , intent ( in ) :: ord , spl_in , spr_in integer :: ix , iy , iz , spl , spr !real(dp) :: ar,ai !=================== do iz = kz1 , kz2 do iy = jy1 , jy2 do ix = ix1 , ix2 av ( ix , iy , iz , 1 ) = 0.5 * ( envf ( ix , iy , iz , 1 ) * envf ( ix , iy , iz , 1 ) + envf ( ix & , iy , iz , 2 ) * envf ( ix , iy , iz , 2 )) av ( ix , iy , iz , 1 ) = av ( ix , iy , iz , 1 ) + 0.5 * ( env1f ( ix , iy , iz , 1 ) * & env1f ( ix , iy , iz , 1 ) + env1f ( ix , iy , iz , 2 ) * env1f ( ix , iy , iz , 2 )) !|A|&#94;2/2 at current t&#94;n time level end do end do end do spl = spl_in spr = spr_in if ( spl > 2 ) spl = 2 if ( spr > 2 ) spr = 2 if ( prl ) call fill_ebfield_yzxbdsdata ( av , 1 , 1 , spr , spl ) call env_grad ( av ) !Exit staggered grad|A|&#94;2/2 in jc(2:4) or jc(2:3) if ( prl ) call fill_ebfield_yzxbdsdata ( av , 2 , curr_ndim + 1 , spr , spl ) !call field_xyzbd(av,nj_dim,spr,spl) !===================== end subroutine !======================================= subroutine env_lpf2_evolve ( it_loc ) integer , intent ( in ) :: it_loc integer :: np , ic , id_ch real ( dp ) :: ef2_ion , loc_ef2_ion ( 2 ) logical , parameter :: mw = . false . !============================ ef2_ion = zero_dp !==================== if ( prl ) call fill_ebfield_yzxbdsdata ( ebf , 1 , nfield , 2 , 2 ) !====================================== if ( ionization ) then if ( it_loc == 0 ) then call init_random_seed ( mype ) end if id_ch = nd2 + 1 if ( enable_ionization ( 1 )) then if ( prl ) call pfields_prepare ( env , 2 , 2 , 2 ) do ic = 2 , nsp_ionz np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then call set_ion_env_field ( env , spec ( ic ), ebfp , np , oml ) if ( mod ( it_loc , 100 ) == 0 ) then loc_ef2_ion ( 1 ) = maxval ( ebfp ( 1 : np , id_ch )) loc_ef2_ion ( 1 ) = sqrt ( loc_ef2_ion ( 1 )) ef2_ion = max ( loc_ef2_ion ( 1 ), ef2_ion ) if ( ef2_ion > lp_max ) then lp_max = 1.1 * ef2_ion call set_field_ioniz_wfunction ( ion_min ( ic - 1 ), & atomic_number ( ic - 1 ), ic , ionz_lev , ionz_model , lp_max ) end if end if call ionization_cycle ( spec ( ic ), ebfp , np , ic , it_loc , 1 , de_inv ) end if end do end if if ( Two_color ) then if ( enable_ionization ( 2 )) then if ( prl ) call pfields_prepare ( env1 , 2 , 2 , 2 ) do ic = 2 , nsp_ionz np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then call set_ion_env_field ( env1 , spec ( ic ), ebfp , np , om1 ) if ( mod ( it_loc , 100 ) == 0 ) then loc_ef2_ion ( 1 ) = maxval ( ebfp ( 1 : np , id_ch )) loc_ef2_ion ( 1 ) = sqrt ( loc_ef2_ion ( 1 )) ef2_ion = max ( loc_ef2_ion ( 1 ), ef2_ion ) if ( ef2_ion > lp_max ) then write ( 6 , '(a22,i6,2E11.4)' ) 'reset high ionz field ' , mype , & ef2_ion , lp_max lp_max = 1.1 * ef2_ion call set_field_ioniz_wfunction ( ion_min ( ic - 1 ), & atomic_number ( ic - 1 ), ic , ionz_lev , ionz_model , lp_max ) end if end if call ionization_cycle ( spec ( ic ), ebfp , np , ic , it_loc , 1 , de_inv ) end if end do end if end if end if !================================= ic = 1 !=========================== jc (:, :, :, :) = 0.0 np = loc_npart ( imody , imodz , imodx , ic ) if ( Two_color ) then call env_amp_two_fields_prepare ( env , env1 , jc , 2 , 2 , 2 ) else call env_amp_prepare ( env , jc , 2 , 2 , 2 ) end if !====================================== ! exit jc(1)=|a|&#94;2/2 at t&#94;n !      jc(2:4)=grad|a|&#94;2/2 at t&#94;n ! For two-color |A|= |A_0|+|A_1| !====================================== ebfp (:, :) = 0.0 call set_env_acc ( ebf , jc , spec ( ic ), ebfp , np , dt_loc ) !===================================== !exit ebfp(1:3)=q*[E+F] ebfp(4:6)=q*B/gamp, ebfp(7)=wgh/gamp at t&#94;n !Lorentz force already multiplied by particle charge !jc(1:4) not modified !==================== call lpf_env_momenta ( spec ( ic ), ebfp , np , ic ) ! Updates particle momenta P&#94;{n-1/2} => P&#94;{n+1/2} ! stores in ebfp(1:3)=old (x,y,z)&#94;n ebfp(7)=wgh/gamp >0 !====================== if ( hybrid ) then !+++++++++++++++++++++++++++++++++++++++++++++++++++++++ call set_env_momentum_density_flux ( up , ebf , jc , ebf0 , flux ) !exit jc(1)=q&#94;2*n/gam, jc(2:4) ponderomotive force on a grid !ebf0= total fields flux(1:4)=(P,den)&#94;n !============================ call update_adam_bash_fluid_variables ( up , up0 , flux , ebf0 ) ! In up exit updated momenta-density variables u&#94;{n+1} ! in  u0&#94;{n} stores Dt*F(u&#94;n), in flux(1:fdim)=(P,den)&#94;{n+1/2} flux (:, :, :, curr_ndim + 2 ) = jc (:, :, :, 1 ) ! in flux(fdim+1) exit the fluid contribution of the sorce term q&#94;2*n/gam ! for the envelope field solver end if jc (:, :, :, 1 ) = 0.0 call set_env_density ( ebfp , jc , np , 1 ) call env_den_collect ( jc ) ! in jc(1)the particle contribution of the source term <q&#94;2*n/gamp> ! to be added to the fluid contribution if (Hybrid) jc (:, :, :, 3 ) = jc (:, :, :, 1 ) if ( hybrid ) then jc (:, :, :, 3 ) = jc (:, :, :, 3 ) + flux (:, :, :, curr_ndim + 2 ) end if !=================== ! in the envelope equation (A&#94;{n-1},A&#94;n)==> (A&#94;n,A&#94;{n+1}) ! jc(3) = <q&#94;2n/gam> ! Jc(1:2)=-ompe*jc(3)*A at level t&#94;n !================================================== !================================================== call advance_lpf_envelope ( jc , env , oml ) !advance (A&#94;n, J&#94;n) => A&#94;{n+1}, A&#94;{n-1}=> A&#94;n ! jc(3) not modified if ( Two_color ) call advance_lpf_envelope ( jc , env1 , om1 ) !advance (A_1&#94;n, J&#94;n) => A_1&#94;{n+1}, A_1&#94;{n-1}=> A_1&#94;n !======================= if ( Two_color ) then call env_two_fields_average ( env , env1 , jc , 2 , 2 ) else call env_fields_average ( env , jc , 2 , 2 ) end if ! In jc(1)= Phi= |A|&#94;2/2 +|A_1|/2 at t&#94;{n+1/2} if ( hybrid ) then flux (:, :, :, curr_ndim + 2 ) = jc (:, :, :, 1 ) !stores in flux() end if call set_env_grad_interp ( jc , spec ( ic ), ebfp , np , curr_ndim ) !============================= ! Exit p-interpolated |A| field variables ! at time level t&#94;{n+1/2} and positions at time t&#94;n ! in ebfp(1:3)=grad|A|&#94;2/2 ebfp(4)=|A|&#94;2/2 in 3D ! in ebfp(1:2)=grad|A|&#94;2/2 ebfp(3)=|A|&#94;2/2 in 2D !===================================== call lpf_env_positions ( spec ( ic ), ebfp , np ) !=========================== ! ebfp(1:3) dt*V&#94;{n+1/2}  ebfp(4:6) old positions for curr J&#94;{n+1/2} ! ebfp(7)=dt*gam_inv if ( part ) call cell_part_dist ( mw ) !  particle number has changed np = loc_npart ( imody , imodz , imodx , ic ) !=======collects in jc(1:curr_ndim) currents due to electrons jc (:, :, :, :) = 0.0 call curr_accumulate ( spec ( ic ), ebfp , jc , np ) !=========================== call curr_mpi_collect ( jc ) if ( hybrid ) then !In flux(1:curr_ndim+1) are stored fluid (P,den) at t&#94;{n+1/2} !In flux(curr_ndim+2) is stored |A|&#94;2/2 at t&#94;{n+1/2} call fluid_curr_accumulate ( flux , jc ) !Computes fluid contribution => J&#94;{n+1/2} and adds to particle contribution end if !==================== ! Jc(1:3) for total curr Dt*J&#94;{n+1/2} call advance_lpf_fields ( ebf , jc , 0 ) ! (E,B) fields at time t&#94;{n+1} !----------------------------- end subroutine !=============== END ENV PIC SECTION subroutine env_run ( t_loc , iter_loc ) real ( dp ), intent ( in ) :: t_loc integer , intent ( in ) :: iter_loc !========================= call env_lpf2_evolve ( iter_loc ) !================================ !+++++++++++++++++++++++++++++++++ !for vbeam >0 uses the xw=(x+vbeam*t) !x=xi=(xw-vbeam*t) fixed !+++++++++++++++++++++++++++++++++ if ( w_speed > 0.0 ) then ! moves the computational box with w_speed>0. if ( t_loc >= wi_time ) then if ( t_loc < wf_time ) then if ( mod ( iter_loc , w_sh ) == 0 ) then call lp_window_xshift ( w_sh , iter_loc ) end if end if end if end if if ( comoving ) then if ( t_loc >= wi_time ) then if ( t_loc < wf_time ) then if ( mod ( iter_loc , w_sh ) == 0 ) then call comoving_coordinate ( vbeam , w_sh , iter_loc ) end if end if end if end if end subroutine !============================ ! END ENVELOPE MODULE !============================== end module","tags":"","loc":"sourcefile/env_evolve_in_time.f90.html"},{"title":"pstruct_data.f90 – ALaDyn","text":"This file depends on sourcefile~~pstruct_data.f90~~EfferentGraph sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pstruct_data.f90~~AfferentGraph sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~boris_push.f90 boris_push.f90 sourcefile~boris_push.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~pstruct_data.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~init_laser_field.f90->sourcefile~pstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~pstruct_data.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~pstruct_data.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~psolve.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~grid_part_util.f90->sourcefile~pstruct_data.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~array_alloc.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~pic_dump.f90->sourcefile~array_alloc.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules pstruct_data Source Code pstruct_data.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! !-------------------------- module pstruct_data use precision_def use struct_def implicit none real ( dp ), allocatable :: ebfp (:, :), ebfb (:, :) real ( dp ), allocatable :: ebfp0 (:, :), ebfp1 (:, :) real ( dp ), allocatable :: pdata_tracking (:, :, :) real ( dp ), allocatable :: track_aux (:) real ( dp ), allocatable :: xpt (:, :), ypt (:, :), zpt (:, :), wghpt (:, :) real ( dp ), allocatable :: loc_ypt (:, :), loc_zpt (:, :), & loc_wghyz (:, :, :) real ( dp ), allocatable :: loc_xpt (:, :), loc_wghx (:, :) type ( species ) :: spec ( 4 ), bunch ( 5 ) integer ( hp_int ), parameter :: ihx = 3 end module","tags":"","loc":"sourcefile/pstruct_data.f90.html"},{"title":"control_bunch_input.f90 – ALaDyn","text":"This file depends on sourcefile~~control_bunch_input.f90~~EfferentGraph sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~control_bunch_input.f90~~AfferentGraph sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~control_bunch_input.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~control_bunch_input.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~control_bunch_input.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~control_bunch_input.f90 sourcefile~read_input.f90 read_input.f90 sourcefile~read_input.f90->sourcefile~control_bunch_input.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~read_input.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules control_bunch_input Source Code control_bunch_input.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module control_bunch_input use precision_def implicit none integer :: n_bunches , bunch_type ( 5 ), nb_tot ( 5 ), number_of_slices ( 4 ), & bunch_shape ( 5 ), nb_per_cell ( 5 ) integer :: np_1 , np_2 , np_3 , np_4 , np_5 integer :: bunch_type_1 , bunch_type_2 , bunch_type_3 , bunch_type_4 , & bunch_type_5 integer :: bunch_shape_1 , bunch_shape_2 , bunch_shape_3 , bunch_shape_4 , & bunch_shape_5 real ( dp ) :: bunch_charge ( 5 ), bunch_volume ( 5 ), jb_norm ( 5 ), & reduced_charge ( 5 ), lorentz_bfact ( 5 ) real ( dp ) :: charge_right ( 5 ), charge_left ( 5 ) real ( dp ) :: gam ( 5 ), rhob ( 5 ), particle_charge ( 5 ) real ( dp ) :: xc_bunch ( 5 ), yc_bunch ( 5 ), zc_bunch ( 5 ) real ( dp ) :: sxb ( 5 ), syb ( 5 ) real ( dp ) :: epsy ( 5 ), epsz ( 5 ), dg ( 5 ) real ( dp ) :: sigma_cut_bunch ( 5 ) real ( dp ) :: alpha_twiss ( 5 ), beta_twiss ( 5 ) real ( dp ) :: b_ex_poloidal , radius_poloidal integer :: ppc_x_bunch ( 5 ), ppc_y_bunch ( 5 ), ppc_z_bunch ( 5 ), & ppc_bunch ( 5 , 3 ) logical :: l_particles , l_twiss ( 5 ), l_bpoloidal , l_embunchevolution end module","tags":"","loc":"sourcefile/control_bunch_input.f90.html"},{"title":"common_param.f90 – ALaDyn","text":"This file depends on sourcefile~~common_param.f90~~EfferentGraph sourcefile~common_param.f90 common_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~common_param.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~common_param.f90~~AfferentGraph sourcefile~common_param.f90 common_param.f90 sourcefile~boris_push.f90 boris_push.f90 sourcefile~boris_push.f90->sourcefile~common_param.f90 sourcefile~read_input.f90 read_input.f90 sourcefile~read_input.f90->sourcefile~common_param.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~ionize.f90->sourcefile~common_param.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~common_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~common_param.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~common_param.f90 sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~set_grid_param.f90->sourcefile~common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~common_param.f90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~common_param.f90 sourcefile~pic_out.f90->sourcefile~parallel.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~psolve.f90->sourcefile~common_param.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~parallel.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~read_input.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~set_grid_param.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules common_param Source Code common_param.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! !Common parameters defined in !   1) input.nml list (=> START/read_input.f90) !   2) initial conditions (=> START/set_init_param.f90, init) !   3) during time evolution !================================ module common_param use precision_def implicit none integer , parameter :: ref_nlayer = 6 , ref_nlas = 8 , & ref_nspec = 8 !namelist input parameters integer :: nx , ny , nz , ny_targ integer :: n1ft , n2ft , n3ft integer :: n1ft_loc , n2ft_loc , n3ft_loc real ( dp ) :: k0 , yx_rat , zx_rat integer :: ibx , iby , ibz , ibeam integer :: lpf_ord , der_ord , str_flag , iform , model_id , dmodel_id integer :: nsp , nsb , ionz_lev , ionz_model , ion_min ( ref_nlayer ), & ion_max ( ref_nlayer ) integer :: atomic_number ( ref_nlayer ), n_mol_atoms ( ref_nlayer ) integer :: nb_laser , nb_1 , np_per_xc ( ref_nlayer ), & np_per_yc ( ref_nlayer ) real ( dp ) :: mass_number ( 3 ), t0_pl ( 4 ) real ( dp ) :: lpx ( 7 ), lpy ( 2 ), n_over_nc , np1 , np2 , r_c real ( dp ) :: t0_lp , xc_lp , tau_fwhm , w0_y , a0 , lam0 , & lp_delay ( ref_nlas ) real ( dp ) :: lp_offset , t1_lp , tau1_fwhm , w1_y , a1 , lam1 , a_symm_rat real ( dp ) :: xc_1 , gam_1 , sxb_1 , syb_1 , epsy_1 , epsz_1 , dg_1 , & charge_1 , ap1_twiss , bt1_twiss , t_inject integer :: nouts , iene , nvout , nden , npout , nbout , jump , pjump integer :: new_sim , id_new , dump real ( dp ) :: gam_min , xp0_out , xp1_out , yp_out !==================== real ( dp ) :: w_speed , wi_time , wf_time real ( dp ) :: tnow , tmax , tscale , dt_loc , dt , cfl logical :: initial_time !==================== integer :: tkjump , nkjump , track_tot_nstep real ( dp ) :: txmin , txmax , tymin , tymax , tzmin , tzmax , t_in , t_out integer :: nprocx , nprocy , nprocz logical :: g_prof , p_tracking , comoving logical :: beam , hybrid , wake , envelope , solid_target logical :: ionization , ions logical :: part , stretch , channel , inject_beam logical :: lp_active , lp_inject , plane_wave , lin_lp , circ_lp , & relativistic , Two_color logical :: enable_ionization ( 2 ), symmetrization_pulse logical :: charge_cons , high_gamma , test integer :: nx_loc , ny_loc , nz_loc , npty , nptz , nptx_max , ncmp_max , & nx_alloc integer :: loc_npty ( ref_nspec ), loc_nptz ( ref_nspec ), nptx ( ref_nspec ), & loc_nptx ( ref_nspec ), sptx_max ( ref_nspec ), nxf , npt_buffer ( ref_nspec ) integer :: sh_targ integer :: mp_per_cell ( ref_nlayer ), nref , np_per_zc ( ref_nlayer ), & ppc ( ref_nlayer ) integer :: loc_nyc_max , loc_nzc_max , loc_nxc_max , ndim_max real ( dp ) :: djc ( 3 ), ratio_mpc ( ref_nlayer ), pavg_npart ( 4 ), wgh_ion , & concentration ( ref_nlayer ) real ( dp ) :: mass ( 4 ), mass_rat ( 4 ), charge_to_mass ( 4 ), unit_charge ( 4 ), & lorentz_fact ( 4 ) real ( dp ) :: n0_ref , pmass , ompe , vbeam , curr_max ( 3 ), j0_norm , & ratio_mpfluid , chann_fact , n_plasma real ( dp ) :: gam0 , bet0 , u0_b , nb_over_np , b_charge real ( dp ) :: oml , e0 , lp_pow , zr , lp_intensity , lp_xsize , p_c real ( dp ) :: w0_x , lp_amp , xf , lp_max , eb_max , lp_energy , lp_rad real ( dp ) :: xc1_lp , xf1 , zr1 , lp1_rad , lp1_amp , om1 , w1_x real ( dp ) :: t0_b , el_lp , el_d , lambda_p , omega_p , lpvol real ( dp ) :: nc0 , ncrit , n1_over_n , n2_over_n real ( dp ) :: np_per_cell , np_per_nmacro , nmacro real ( dp ) :: targ_in , targ_end , lx_fwhm real ( dp ) :: lp_in ( ref_nlas ), lp_end ( ref_nlas ), lp_ionz_in , & lp_ionz_end , xf_loc ( ref_nlas ), xc_loc ( ref_nlas ) real ( dp ) :: y0_cent ( ref_nlas ), z0_cent ( ref_nlas ), y1_cent , z1_cent , & incid_angle real ( dp ) :: ymin_t , ymax_t , zmin_t , zmax_t , rmin_t , rmax_t ! tracking param integer :: track_tot_part integer :: pot_ndim , nb_max , pe_nbmax , nb_min , pe_nbmin integer :: tsc_ord , t_ord , spl_ord integer :: nsp_run , nsp_ionz integer :: ndim , curr_ndim , nj_dim , nd2 , nfield , nbfield , nfcomp , & mod_ord , w_sh real ( dp ) :: macro_charge real ( dp ) :: energy_in_targ integer ( kind = 8 ) :: nptot_global end module","tags":"","loc":"sourcefile/common_param.f90.html"},{"title":"precision_def.F90 – ALaDyn","text":"Files dependent on this one sourcefile~~precision_def.f90~~AfferentGraph sourcefile~precision_def.f90 precision_def.F90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90 util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~legacy_fft_lib.f90 legacy_fft_lib.F90 sourcefile~legacy_fft_lib.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~modern_fft_lib.f90 modern_fft_lib.F90 sourcefile~modern_fft_lib.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~ionz_data.f90 sourcefile~run_data_info.f90->sourcefile~phys_param.f90 sourcefile~run_data_info.f90->sourcefile~control_bunch_input.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~common_param.f90 sourcefile~run_data_info.f90->sourcefile~fstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~code_util.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~util.f90 sourcefile~boris_push.f90 boris_push.f90 sourcefile~env_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~window.f90 window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~init_laser_field.f90->sourcefile~pstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~set_grid_param.f90->sourcefile~mpi_var.f90 sourcefile~set_grid_param.f90->sourcefile~common_param.f90 sourcefile~set_grid_param.f90->sourcefile~grid_param.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~control_bunch_input.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~code_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~system_utilities.f90 system_utilities.f90 sourcefile~system_utilities.f90->sourcefile~mpi_var.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~init_part_distrib.f90->sourcefile~util.f90 sourcefile~init_part_distrib.f90->sourcefile~mpi_var.f90 sourcefile~init_part_distrib.f90->sourcefile~common_param.f90 sourcefile~init_part_distrib.f90->sourcefile~code_util.f90 sourcefile~init_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~grid_part_connect.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~psolve.f90->sourcefile~pstruct_data.f90 sourcefile~psolve.f90->sourcefile~common_param.f90 sourcefile~psolve.f90->sourcefile~fstruct_data.f90 sourcefile~psolve.f90->sourcefile~grid_param.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~boris_push.f90->sourcefile~pstruct_data.f90 sourcefile~boris_push.f90->sourcefile~common_param.f90 sourcefile~boris_push.f90->sourcefile~fstruct_data.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~phys_param.f90 sourcefile~diag_part_and_fields.f90->sourcefile~control_bunch_input.f90 sourcefile~diag_part_and_fields.f90->sourcefile~pstruct_data.f90 sourcefile~diag_part_and_fields.f90->sourcefile~fstruct_data.f90 sourcefile~diag_part_and_fields.f90->sourcefile~code_util.f90 sourcefile~diag_part_and_fields.f90->sourcefile~grid_param.f90 sourcefile~diag_part_and_fields.f90->sourcefile~parallel.f90 sourcefile~prl_fft.f90->sourcefile~modern_fft_lib.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~curr_and_fields_util.f90->sourcefile~pstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~fstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_param.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~window.f90->sourcefile~util.f90 sourcefile~window.f90->sourcefile~pstruct_data.f90 sourcefile~window.f90->sourcefile~common_param.f90 sourcefile~window.f90->sourcefile~fstruct_data.f90 sourcefile~window.f90->sourcefile~grid_param.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~ionz_data.f90 sourcefile~set_init_param.f90->sourcefile~phys_param.f90 sourcefile~set_init_param.f90->sourcefile~control_bunch_input.f90 sourcefile~set_init_param.f90->sourcefile~common_param.f90 sourcefile~set_init_param.f90->sourcefile~code_util.f90 sourcefile~set_init_param.f90->sourcefile~grid_param.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~common_param.f90 sourcefile~pic_dump.f90->sourcefile~code_util.f90 sourcefile~pic_dump.f90->sourcefile~grid_param.f90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~pic_dump.f90->sourcefile~array_alloc.f90 sourcefile~read_input.f90 read_input.f90 sourcefile~read_input.f90->sourcefile~control_bunch_input.f90 sourcefile~read_input.f90->sourcefile~mpi_var.f90 sourcefile~read_input.f90->sourcefile~common_param.f90 sourcefile~read_input.f90->sourcefile~code_util.f90 sourcefile~grid_part_util.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_util.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~phys_param.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~mpi_part_interface.f90->sourcefile~code_util.f90 sourcefile~mpi_part_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~pstruct_data.f90 sourcefile~pic_out.f90->sourcefile~common_param.f90 sourcefile~pic_out.f90->sourcefile~fstruct_data.f90 sourcefile~pic_out.f90->sourcefile~code_util.f90 sourcefile~pic_out.f90->sourcefile~grid_param.f90 sourcefile~pic_out.f90->sourcefile~parallel.f90 sourcefile~ionize.f90->sourcefile~ionz_data.f90 sourcefile~ionize.f90->sourcefile~util.f90 sourcefile~ionize.f90->sourcefile~mpi_var.f90 sourcefile~ionize.f90->sourcefile~common_param.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~set_grid_param.f90 sourcefile~start_all.f90->sourcefile~system_utilities.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~start_all.f90->sourcefile~read_input.f90 sourcefile~start_all.f90->sourcefile~array_alloc.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules precision_def Source Code precision_def.F90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module precision_def implicit none public integer , parameter :: sp = selected_real_kind ( 6 , 37 ) integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: dp_int = selected_int_kind ( 16 ) integer , parameter :: hp_int = selected_int_kind ( 4 ) integer , parameter :: qp = selected_real_kind ( 33 , 4931 ) logical ( kind = 1 ), dimension ( 8 ) :: res_string real ( dp ) :: wgh_cmp real ( sp ) :: wgh integer ( hp_int ) :: charge integer ( hp_int ) :: part_ind equivalence ( charge , res_string ( 1 )), ( part_ind , res_string ( 3 )), & ( wgh , res_string ( 5 )), ( wgh_cmp , res_string ( 1 )) real ( dp ), parameter :: zero_dp = 0.0 real ( sp ), parameter :: zero_sp = real ( 0.0 , sp ) real ( dp ), parameter :: one_dp = 1.0 real ( sp ), parameter :: one_sp = real ( 1.0 , sp ) integer , parameter :: zero = 0 integer , parameter :: one = 1 integer ( hp_int ), parameter :: one_int_hp = int ( 1 , hp_int ) contains function is_zero ( value ) result ( check ) real ( dp ), intent ( in ) :: value real ( dp ), parameter :: small_value = 0.1 logical :: check check = ( abs ( value ) < epsilon ( small_value )) end function end module","tags":"","loc":"sourcefile/precision_def.f90.html"},{"title":"phys_param.f90 – ALaDyn","text":"This file depends on sourcefile~~phys_param.f90~~EfferentGraph sourcefile~phys_param.f90 phys_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~phys_param.f90~~AfferentGraph sourcefile~phys_param.f90 phys_param.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~phys_param.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~phys_param.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~phys_param.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~phys_param.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules phys_param Source Code phys_param.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module phys_param use precision_def implicit none real ( dp ), parameter :: epsilon = 1.0e-8 !! Small parameter real ( dp ), parameter :: pi = 3.141592653589793 , & pi2 = 6.283185307179586 real ( dp ), parameter :: giant_field = 1.0e4 !! Large control parameter for fields real ( dp ), parameter :: electron_charge_norm = - 1.0 !! Normalized electron charge real ( dp ), parameter :: electron_mass_norm = 1.0 !! Normalized electron mass real ( dp ), parameter :: proton_charge_norm = 1.0 !! Normalized proton charge real ( dp ), parameter :: proton_mass_norm = 183 6.1527706 ! in units of electron mass !! Normalized proton mass real ( dp ), parameter :: size_of_stretch_along_x = 1. / 4. !! Stretch parameter along the x direction !! (1/4 of the cells are stretched) real ( dp ), parameter :: size_of_stretch_along_y = 1. / 6. !! Stretch parameter along the y and z direction !! (1/6 of the cells are stretched per side) real ( dp ), parameter :: e_charge = 1.6021766 * 1.e-7 !e charge in pC !! Electron charge in pC real ( dp ), parameter :: electron_mass = 0.510998928 !e mass in MeV !! Electron charge in MeV real ( dp ), parameter :: rc0 = 2.81794033 !rc0=e&#94;2/mc&#94;2 classical electron radius, in units 10&#94;-13[cm] !! classical electron radius \\frac{e&#94;2}{mc&#94;2} in units 10&#94;{-13} cm real ( dp ), parameter :: speed_of_light = 0.299792458 !mu/fs !! Speed of light in units \\mu m/fs real ( dp ), parameter :: energy_unit = electron_mass * 1.e+06 !mc&#94;2(eV) real ( dp ), parameter :: t_unit = 0.299792458 / 0.510998928 !Tesla in GV/m units real ( dp ), parameter :: mg_unit = 0.299792458 / 5.10998928 !MegaGauss in TV/m units real ( dp ), parameter :: fe_unit = 0.514 !field atomic unit TV/m real ( dp ), parameter :: reference_density = 1.e6 ! Reference density in parts/\\mu&#94;3 (equivalent to 10&#94;18 parts/cm&#94;3) !====================================== !10 eV =>  beta = 0.00625603 => gamma = 1.0000196 => beta*gamma = 0.00625615 !20 eV =>  beta = 0.00884723 => gamma = 1.0000391 => beta*gamma = 0.00884758 !30 eV =>  beta = 0.01083544 => gamma = 1.0000587 => beta*gamma = 0.01083608 end module","tags":"","loc":"sourcefile/phys_param.f90.html"},{"title":"util.f90 – ALaDyn","text":"This file depends on sourcefile~~util.f90~~EfferentGraph sourcefile~util.f90 util.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~util.f90~~AfferentGraph sourcefile~util.f90 util.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~util.f90 sourcefile~window.f90 window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~window.f90->sourcefile~util.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~util.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~util.f90 sourcefile~ionize.f90->sourcefile~util.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~parallel.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~parallel.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules util Source Code util.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module util use precision_def use code_util implicit none private public :: gasdev , init_random_seed , bunch_gen contains subroutine init_random_seed ( myrank ) integer , intent ( in ) :: myrank integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid , t ( 2 ), s integer ( 8 ) :: count , tms i = 0 call random_seed ( size = n ) allocate ( seed ( n )) if (. not . l_disable_rng_seed ) then un = 123 ! First try if the OS provides a random number generator open ( unit = un , file = '/dev/urandom' , access = 'stream' , & form = 'unformatted' , action = 'read' , status = 'old' , iostat = istat ) if ( istat == 0 ) then read ( un ) seed close ( un ) else ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( count ) if ( count /= 0 ) then t = transfer ( count , t ) else call date_and_time ( values = dt ) tms = ( dt ( 1 ) - 1970 ) * 365 _ 8 * 24 * 60 * 60 * 1000 + dt ( 2 ) * 31 _ 8 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24 * 60 * 60 * 60 * 1000 + dt ( 5 ) * 60 * 60 * 1000 + dt ( 6 ) * 60 * 1000 + & dt ( 7 ) * 1000 + dt ( 8 ) t = transfer ( tms , t ) end if s = ieor ( t ( 1 ), t ( 2 )) pid = myrank + 1099279 ! Add a prime s = ieor ( s , pid ) if ( n >= 3 ) then seed ( 1 ) = t ( 1 ) + 36269 seed ( 2 ) = t ( 2 ) + 72551 seed ( 3 ) = pid if ( n > 3 ) then seed ( 4 :) = s + 37 * [( i , i = 0 , n - 4 )] end if else seed = s + 37 * [( i , i = 0 , n - 1 )] end if end if else seed = myrank end if call random_seed ( put = seed ) end subroutine !======================== subroutine gasdev ( dev ) real ( dp ), intent ( out ) :: dev real ( dp ) :: v1 , v2 , rsq real ( dp ), save :: g logical , save :: gaus_store = . false . if ( gaus_store ) then dev = g gaus_store = . false . else do call random_number ( v1 ) call random_number ( v2 ) v1 = 2.0 * v1 - 1.0 v2 = 2.0 * v2 - 1.0 rsq = v1 * v1 + v2 * v2 if ( rsq < 1.0 ) exit end do rsq = sqrt ( - 2.0 * log ( rsq ) / rsq ) dev = v1 * rsq g = v2 * rsq gaus_store = . true . end if end subroutine !=============================== subroutine sort ( part , np ) real ( dp ), intent ( inout ) :: part (:) integer , intent ( in ) :: np integer :: ir , i , j , k , l , jstack integer , parameter :: m = 7 , nstack = 50 real ( dp ) :: a integer :: istack ( nstack ) jstack = 0 ir = np l = 1 do if ( ir - l < m ) then do j = l + 1 , ir a = part ( j ) do i = j - 1 , l , - 1 if ( part ( i ) <= a ) exit part ( i + 1 ) = part ( i ) end do part ( i + 1 ) = a end do if ( jstack == 0 ) return ir = istack ( jstack ) l = istack ( jstack - 1 ) jstack = jstack - 2 else k = ( l + ir ) / 2 call swap ( k , l + 1 ) if ( part ( l ) > part ( ir )) call swap ( l , ir ) if ( part ( l + 1 ) > part ( ir )) call swap ( l + 1 , ir ) if ( part ( l ) > part ( l + 1 )) call swap ( l , l + 1 ) i = l + 1 j = ir a = part ( l + 1 ) do do i = i + 1 if ( part ( i ) >= a ) exit end do do j = j - 1 if ( part ( j ) <= a ) exit end do if ( j < i ) exit call swap ( i , j ) end do part ( l + 1 ) = part ( j ) part ( j ) = a jstack = jstack + 2 if ( jstack > nstack ) exit if ( ir - i + 1 >= j - l ) then istack ( jstack ) = ir istack ( jstack - 1 ) = i ir = j - 1 else istack ( jstack ) = j - 1 istack ( jstack - 1 ) = l l = i end if end if end do contains subroutine swap ( i1 , i2 ) integer , intent ( in ) :: i1 , i2 real ( dp ) :: temp temp = part ( i1 ) part ( i1 ) = part ( i2 ) part ( i2 ) = temp end subroutine end subroutine !========================= subroutine vsort ( part , np , ndv , dir ) real ( dp ), intent ( inout ) :: part (:, :) integer , intent ( in ) :: np , ndv , dir integer :: ir , i , j , k , l , jstack integer , parameter :: m = 7 , nstack = 50 real ( dp ) :: a ( ndv ), temp ( ndv ) integer :: istack ( nstack ) jstack = 0 ir = np l = 1 do if ( ir - l < m ) then do j = l + 1 , ir a ( 1 : ndv ) = part ( 1 : ndv , j ) do i = j - 1 , l , - 1 if ( part ( dir , i ) <= a ( dir )) exit part ( 1 : ndv , i + 1 ) = part ( 1 : ndv , i ) end do part ( 1 : ndv , i + 1 ) = a ( 1 : ndv ) end do if ( jstack == 0 ) return ir = istack ( jstack ) l = istack ( jstack - 1 ) jstack = jstack - 2 else k = ( l + ir ) / 2 call swap ( k , l + 1 , ndv ) if ( part ( dir , l ) > part ( dir , ir )) call swap ( l , ir , ndv ) if ( part ( dir , l + 1 ) > part ( dir , ir )) call swap ( l + 1 , ir , ndv ) if ( part ( dir , l ) > part ( dir , l + 1 )) call swap ( l , l + 1 , ndv ) i = l + 1 j = ir a ( 1 : ndv ) = part ( 1 : ndv , l + 1 ) do do i = i + 1 if ( part ( dir , i ) >= a ( dir )) exit end do do j = j - 1 if ( part ( dir , j ) <= a ( dir )) exit end do if ( j < i ) exit call swap ( i , j , ndv ) end do part ( 1 : ndv , l + 1 ) = part ( 1 : ndv , j ) part ( 1 : ndv , j ) = a ( 1 : ndv ) jstack = jstack + 2 if ( jstack > nstack ) exit if ( ir - i + 1 >= j - l ) then istack ( jstack ) = ir istack ( jstack - 1 ) = i ir = j - 1 else istack ( jstack ) = j - 1 istack ( jstack - 1 ) = l l = i end if end if end do contains subroutine swap ( i1 , i2 , nd ) integer , intent ( in ) :: i1 , i2 , nd temp ( 1 : nd ) = part ( 1 : nd , i1 ) part ( 1 : nd , i1 ) = part ( 1 : nd , i2 ) part ( 1 : nd , i2 ) = temp ( 1 : nd ) end subroutine end subroutine !=========================== subroutine bunch_gen ( ndm , n1 , n2 , sx , sy , sz , gm , ey , ez , cut , dg , & bunch ) integer , intent ( in ) :: ndm , n1 , n2 real ( dp ), intent ( in ) :: sx , sy , sz , gm , ey , ez , cut , dg real ( dp ), intent ( inout ) :: bunch (:, :) integer :: i , j , np real ( dp ) :: sigs ( 6 ) real ( dp ) :: xm , ym , zm , pxm , pym , pzm real ( dp ) :: v1 , v2 , rnd , a , np_norm !============= ey,ez are emittances (in mm-microns) ! FIX emittances are ALWAYS a dimension times an angle... ! so this (in mm-micron) doesn't make any sense ! dg=d(gamma)/gamma (%) ! dp_y=ey/s_y dp_z=ez/s_z dp_x=d(gamma) !============================================= !Distribute (x,y,z,px,py,pz) centered on 0; px=> px+gamma select case ( ndm ) case ( 2 ) sigs ( 1 ) = sx sigs ( 2 ) = sy sigs ( 3 ) = sqrt ( 3.0 ) * 0.01 * dg * gm !dpz sigs ( 4 ) = ey / sy do i = n1 , n2 do call random_number ( v1 ) call random_number ( v2 ) v1 = 2.0 * v1 - 1.0 v2 = 2.0 * v2 - 1.0 rnd = v1 * v1 + v2 * v2 if ( rnd < 1.0 ) exit end do rnd = sqrt ( - 2.0 * log ( rnd ) / rnd ) bunch ( i , 2 ) = v1 * rnd bunch ( i , 4 ) = v2 * rnd call gasdev ( rnd ) bunch ( i , 1 ) = rnd do call random_number ( rnd ) rnd = 2. * rnd - 1. a = cut * rnd if ( a * a < 1. ) exit end do bunch ( i , 3 ) = a end do do j = 1 , 4 bunch ( n1 : n2 , j ) = sigs ( j ) * bunch ( n1 : n2 , j ) end do bunch ( n1 : n2 , 3 ) = bunch ( n1 : n2 , 3 ) + gm xm = 0.0 ym = 0.0 pxm = 0.0 pym = 0.0 ! Reset centering xm = sum ( bunch ( n1 : n2 , 1 )) ym = sum ( bunch ( n1 : n2 , 2 )) pxm = sum ( bunch ( n1 : n2 , 3 )) pym = sum ( bunch ( n1 : n2 , 4 )) np = n2 + 1 - n1 xm = xm / real ( np , dp ) ym = ym / real ( np , dp ) pxm = pxm / real ( np , dp ) pym = pym / real ( np , dp ) do i = n1 , n2 bunch ( i , 1 ) = bunch ( i , 1 ) - xm bunch ( i , 2 ) = bunch ( i , 2 ) - ym bunch ( i , 3 ) = bunch ( i , 3 ) - ( pxm - gm ) bunch ( i , 4 ) = bunch ( i , 4 ) - pym end do case ( 3 ) sigs ( 1 ) = sx sigs ( 2 ) = sy sigs ( 3 ) = sz sigs ( 4 ) = sqrt ( 3.0 ) * 0.01 * dg * gm !dpz sigs ( 5 ) = ey / sy sigs ( 6 ) = ez / sz do j = 2 , 5 , 3 do i = n1 , n2 do call random_number ( v1 ) call random_number ( v2 ) v1 = 2.0 * v1 - 1.0 v2 = 2.0 * v2 - 1.0 rnd = v1 * v1 + v2 * v2 if ( rnd < 1.0 ) exit end do rnd = sqrt ( - 2.0 * log ( rnd ) / rnd ) bunch ( i , j ) = v1 * rnd bunch ( i , j + 1 ) = v2 * rnd end do enddo j = 1 do i = n1 , n2 call gasdev ( rnd ) bunch ( i , j ) = rnd do call random_number ( rnd ) rnd = 2. * rnd - 1. a = cut * rnd if ( a * a < 1. ) exit end do bunch ( i , j + 3 ) = a end do !====================== do j = 1 , 6 do i = n1 , n2 bunch ( i , j ) = sigs ( j ) * bunch ( i , j ) end do end do bunch ( n1 : n2 , 4 ) = bunch ( n1 : n2 , 4 ) + gm xm = 0.0 ym = 0.0 zm = 0.0 pxm = 0.0 pym = 0.0 pzm = 0.0 ! Reset centering np = n2 + 1 - n1 np_norm = 1. / real ( np , dp ) xm = np_norm * sum ( bunch ( n1 : n2 , 1 )) ym = np_norm * sum ( bunch ( n1 : n2 , 2 )) zm = np_norm * sum ( bunch ( n1 : n2 , 3 )) pxm = np_norm * sum ( bunch ( n1 : n2 , 4 )) pym = np_norm * sum ( bunch ( n1 : n2 , 5 )) pzm = np_norm * sum ( bunch ( n1 : n2 , 6 )) do i = n1 , n2 bunch ( i , 1 ) = bunch ( i , 1 ) - xm bunch ( i , 2 ) = bunch ( i , 2 ) - ym bunch ( i , 3 ) = bunch ( i , 3 ) - zm bunch ( i , 4 ) = bunch ( i , 4 ) - ( pxm - gm ) bunch ( i , 5 ) = bunch ( i , 5 ) - pym bunch ( i , 6 ) = bunch ( i , 6 ) - pzm end do end select end subroutine end module","tags":"","loc":"sourcefile/util.f90.html"},{"title":"code_util.f90 – ALaDyn","text":"This file depends on sourcefile~~code_util.f90~~EfferentGraph sourcefile~code_util.f90 code_util.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~code_util.f90~~AfferentGraph sourcefile~code_util.f90 code_util.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~code_util.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~diag_part_and_fields.f90->sourcefile~parallel.f90 sourcefile~util.f90 util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~code_util.f90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~code_util.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~code_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~util.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~code_util.f90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~mpi_part_interface.f90->sourcefile~code_util.f90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~code_util.f90 sourcefile~init_part_distrib.f90->sourcefile~util.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~code_util.f90 sourcefile~pic_out.f90->sourcefile~parallel.f90 sourcefile~read_input.f90 read_input.f90 sourcefile~read_input.f90->sourcefile~code_util.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~window.f90->sourcefile~util.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~start_all.f90->sourcefile~read_input.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~ionize.f90->sourcefile~util.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules code_util Source Code code_util.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module code_util use precision_def implicit none integer , parameter :: major_version = 8 integer , parameter :: minor_version = 2 character ( 6 ) :: sw_name = 'ALaDyn' character ( 9 ) :: input_namelist_filename = 'input.nml' character ( 10 ) :: input_data_filename = 'input.data' integer , parameter :: maxv = 1 , sumv = 0 , minv = - 1 integer , parameter :: left = - 1 , right = 1 integer , parameter :: field = 0 , curr = 1 integer , parameter :: sh_ix = 3 integer :: time2dump ( 1 ) = 0 integer :: mem_size , mem_psize integer :: last_iter , iter_max , write_every integer :: t_ind , inject_ind , tk_ind integer :: ienout , iout , iter , ier real ( dp ) :: mem_psize_max , dump_t0 , dump_t1 real ( dp ) :: unix_time_begin , unix_time_now real ( dp ) :: time_interval_dumps , unix_time_last_dump real ( dp ) :: gamma_cut_min , weights_cut_min , weights_cut_max real ( dp ) :: tdia , dtdia , tout , dtout , tstart , mem_max_addr logical :: diag , tpart logical :: l_intdiagnostics_pwfa , l_intdiagnostics_classic logical :: l_force_singlefile_output logical :: l_print_j_on_grid logical :: l_first_output_on_restart logical :: l_use_unique_dumps logical :: l_disable_rng_seed logical :: l_intdiagnostics_background logical :: l_env_modulus end module","tags":"","loc":"sourcefile/code_util.f90.html"},{"title":"array_alloc.f90 – ALaDyn","text":"This file depends on sourcefile~~array_alloc.f90~~EfferentGraph sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~array_alloc.f90~~AfferentGraph sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~array_alloc.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~array_alloc.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules array_alloc Source Code array_alloc.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! !     Local grid structure under mpi domain decomposition !============== ! grid [1:n]   np=n+2  extended domain [1:np+2] ! interior [3,np]   ghost [1:2], [np+1:np+2] ! overlapping grid  structure: ! !==================================================================== !                                     1-----2---- 3--- 4   |      pey+1 !                 1-----2----[3-------np-1--np]--np+1--np+2|    pey !1-2--------------np-1--np---np+1                          |pey-1 !====================================================================== !      Right(pey+1)     [1:4]     overlap pey [np-1:np+2] !      Left(pey-1)      [np-1:np+2]overlap pey [1:4] !=================================== module array_alloc use pstruct_data use fstruct_data implicit none contains subroutine mpi_buffer_alloc ( n1_loc , n2_loc , n3_loc , nvd ) integer , intent ( in ) :: n1_loc , n2_loc , n3_loc , nvd integer :: lenw , n3m , stl stl = 5 n3m = max ( n2_loc , n3_loc ) lenw = nvd * ( n1_loc + 2 ) * n3m * stl allocate ( aux1 ( lenw ), aux2 ( lenw )) aux1 = 0.0 aux2 = 0.0 end subroutine subroutine v_alloc ( n1 , n2 , n3 , ncomp , njc , ndm , ifluid , lp , oder , & envlp , color , comv , fsize ) integer , intent ( in ) :: n1 , n2 , n3 , ncomp , njc , ndm , ifluid , lp , oder logical , intent ( in ) :: envlp , color , comv integer , intent ( inout ) :: fsize integer :: njdim , ng , ng0 , n1p , n2p , n3p , allocstatus , fsize_loc n1p = n1 + ihx n2p = n2 + ihx n3p = n3 ng0 = 1 + ( n1 - 2 ) * ( n2 - 2 ) if ( ndm == 3 ) then ng0 = 1 + ( n1 - 2 ) * ( n2 - 2 ) * ( n3 - 2 ) n3p = n3 + ihx end if ng = n1p * n2p * n3p fsize_loc = 0 ! allocates common arrays allocate ( ebf ( n1p , n2p , n3p , ncomp ), stat = allocstatus ) allocate ( jc ( n1p , n2p , n3p , njc ), stat = allocstatus ) fsize_loc = fsize_loc + ng * ncomp + ng * njc ebf = 0.0 jc = 0.0 if ( comv ) then if ( lp < 3 ) then !to handle backward advected fields allocate ( ebf0 ( n1p , n2p , n3p , ncomp ), stat = allocstatus ) fsize_loc = fsize_loc + ng * ncomp ebf0 = 0.0 end if end if if ( ifluid == 2 ) then if ( lp < 3 ) then !for 2th order lpf in fluid variables if (. not . allocated ( ebf0 )) then allocate ( ebf0 ( n1p , n2p , n3p , ncomp ), stat = allocstatus ) fsize_loc = fsize_loc + ng * ncomp ebf0 = 0.0 end if end if end if if ( lp > 2 ) then allocate ( ebf0 ( n1p , n2p , n3p , ncomp ), stat = allocstatus ) ebf0 = 0.0 fsize_loc = fsize_loc + ng * ncomp if ( lp > 3 ) then allocate ( ebf1 ( n1p , n2p , n3p , ncomp ), stat = allocstatus ) fsize_loc = fsize_loc + ng * ncomp ebf1 = 0.0 end if end if !=============ENV allocation section if ( envlp ) then njdim = 4 allocate ( env ( n1p , n2p , n3p , njdim ), stat = allocstatus ) env = 0.0 fsize_loc = fsize_loc + njdim * ng if ( lp == 4 ) then !RK4 for env solver allocate ( env0 ( n1p , n2p , n3p , 2 * njdim ), stat = allocstatus ) env0 = 0.0 fsize_loc = fsize_loc + 2 * njdim * ng end if if ( color ) then allocate ( env1 ( n1p , n2p , n3p , njdim ), stat = allocstatus ) env1 = 0.0 fsize_loc = fsize_loc + njdim * ng end if end if fsize = fsize + fsize_loc !sums all over memory alloc end subroutine !-------------------------- subroutine bv_alloc ( n1 , n2 , n3 , bcomp , ndm , ibch , fsize ) integer , intent ( in ) :: n1 , n2 , n3 , bcomp , ndm , ibch integer , intent ( inout ) :: fsize integer :: ng , n1p , n2p , n3p , allocstatus n1p = n1 + ihx !x-grid ix=1,2 bd, 3:nx+2=n1p data n1p+1 bd n2p = n2 + ihx n3p = n3 if ( ndm == 3 ) n3p = n3 + ihx ng = n1p * n2p * n3p allocate ( ebf_bunch ( n1p , n2p , n3p , bcomp ), stat = allocstatus ) allocate ( jb ( n1p , n2p , n3p , ndm ), stat = allocstatus ) ebf_bunch = 0.0 jb = 0.0 fsize = fsize + ng * ( bcomp + ndm ) if ( ibch > 0 ) then allocate ( ebf1_bunch ( n1p , n2p , n3p , bcomp ), stat = allocstatus ) ebf1_bunch = 0.0 fsize = fsize + ng * bcomp end if ! In 3D  nbcomp=6    in 2D nbcomp=nfield+1=4 end subroutine !================== subroutine fluid_alloc ( n1 , n2 , n3 , fcomp , ndm , lp , fsize ) integer , intent ( in ) :: n1 , n2 , n3 , fcomp , ndm , lp integer , intent ( inout ) :: fsize integer :: ng , n1p , n2p , n3p , flcomp , allocstatus n1p = n1 + ihx !x-grid ix=1,2 bd, 3:n1+2=n1p data n1+1 bd n2p = n2 + ihx !overlapping grid y=1,3 = n2-1,n2+1  y=n2+1=ihx n3p = n3 flcomp = 2 * fcomp - 1 if ( ndm == 3 ) n3p = n3 + ihx ng = n1p * n2p * n3p allocate ( up ( n1p , n2p , n3p , fcomp ), stat = allocstatus ) allocate ( up0 ( n1p , n2p , n3p , fcomp ), stat = allocstatus ) allocate ( flux ( n1p , n2p , n3p , flcomp ), stat = allocstatus ) allocate ( fluid_yz_profile ( n2p , n3p ), stat = allocstatus ) up = 0.0 flux = 0.0 up0 = 0.0 fluid_yz_profile = 0.0 fsize = fsize + ng * ( 2 * fcomp + flcomp ) + n2p * n3p if ( lp > 2 ) then allocate ( up1 ( n1p , n2p , n3p , fcomp ), stat = allocstatus ) up1 = 0.0 fsize = fsize + ng * fcomp end if end subroutine !============ external B-field allocated subroutine bext_alloc ( n1 , n2 , n3 , bcomp , fsize ) integer , intent ( in ) :: n1 , n2 , n3 , bcomp integer , intent ( inout ) :: fsize integer :: ng , n1p , n2p , n3p , allocstatus n1p = n1 + ihx !x-grid ix=1,2 bd, 3:n1+2=n1p data n1+1 bd n2p = n2 + ihx !overlapping grid y=1,3 = n2-1,n2+1  y=n2+1=ihx n3p = n3 ng = n1p * n2p * n3p allocate ( ebf0_bunch ( n1p , n2p , n3p , bcomp ), stat = allocstatus ) ebf0_bunch = 0.0 fsize = fsize + bcomp * ng end subroutine !=========================== subroutine p_alloc ( npt_max , ncmp , np_s , ns , lp , mid , r_type , msize ) integer , intent ( in ) :: npt_max , ncmp , np_s (:), ns , lp , mid , r_type integer , intent ( inout ) :: msize integer :: nsize , ic , npt , allocstatus npt = 1 select case ( r_type ) case ( 1 ) !Plasma particles nsize = 0 do ic = 1 , ns npt = max ( np_s ( ic ), 1 ) allocate ( spec ( ic )% part ( npt , ncmp ), stat = allocstatus ) nsize = nsize + ncmp * npt spec ( ic )% part ( 1 : npt , 1 : ncmp ) = 0.0 end do if ( mid > 0 ) then allocate ( ebfp ( npt_max , ncmp ), stat = allocstatus ) nsize = nsize + ncmp * npt_max ebfp ( 1 : npt_max , 1 : ncmp ) = 0.0 end if if ( lp > 2 ) then allocate ( ebfp0 ( npt_max , ncmp ), stat = allocstatus ) nsize = nsize + ncmp * npt ebfp0 ( 1 : npt_max , 1 : ncmp ) = 0.0 if ( lp == 4 ) then allocate ( ebfp1 ( npt_max , ncmp ), stat = allocstatus ) nsize = nsize + ncmp * npt ebfp1 ( 1 : npt_max , 1 : ncmp ) = 0.0 end if end if msize = msize + nsize case ( 2 ) !bunch particles are inside spec(1)%npart nsize = 0 msize = msize + nsize return end select end subroutine !============================ !DIR$ ATTRIBUTES INLINE :: p_realloc subroutine p_realloc ( pdata , npt_new , ndv ) type ( species ), intent ( inout ) :: pdata integer , intent ( in ) :: npt_new , ndv integer :: allocstatus , deallocstatus if ( allocated ( pdata % part )) then if ( size ( pdata % part , 1 ) < npt_new ) then deallocate ( pdata % part , stat = deallocstatus ) if ( deallocstatus == 0 ) allocate ( pdata % part ( 1 : npt_new , 1 : ndv ), & stat = allocstatus ) end if else allocate ( pdata % part ( 1 : npt_new , 1 : ndv ), stat = allocstatus ) end if pdata % part (:, :) = 0.0 end subroutine !======================== subroutine v_realloc ( vdata , npt_new , ndv ) real ( dp ), allocatable , intent ( inout ) :: vdata (:, :) integer , intent ( in ) :: npt_new , ndv integer :: allocstatus , deallocstatus if ( allocated ( vdata )) then if ( size ( vdata , 1 ) < npt_new ) then deallocate ( vdata , stat = deallocstatus ) allocate ( vdata ( 1 : npt_new , 1 : ndv ), stat = allocstatus ) end if else allocate ( vdata ( 1 : npt_new , 1 : ndv ), stat = allocstatus ) end if vdata (:, :) = 0.0 end subroutine !=========================== end module","tags":"","loc":"sourcefile/array_alloc.f90.html"},{"title":"struct_def.f90 – ALaDyn","text":"This file depends on sourcefile~~struct_def.f90~~EfferentGraph sourcefile~struct_def.f90 struct_def.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~struct_def.f90~~AfferentGraph sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~init_laser_field.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~set_grid_param.f90->sourcefile~grid_param.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~grid_part_connect.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~psolve.f90->sourcefile~pstruct_data.f90 sourcefile~psolve.f90->sourcefile~grid_param.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~boris_push.f90 boris_push.f90 sourcefile~boris_push.f90->sourcefile~pstruct_data.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~pstruct_data.f90 sourcefile~diag_part_and_fields.f90->sourcefile~grid_param.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~pstruct_data.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_param.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~pstruct_data.f90 sourcefile~window.f90->sourcefile~grid_param.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~grid_param.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~grid_param.f90 sourcefile~pic_dump.f90->sourcefile~array_alloc.f90 sourcefile~grid_part_util.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~mpi_part_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~pstruct_data.f90 sourcefile~pic_out.f90->sourcefile~grid_param.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~set_grid_param.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~start_all.f90->sourcefile~array_alloc.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules struct_def Source Code struct_def.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module struct_def use precision_def implicit none public type species real ( dp ), allocatable :: part (:, :) end type type grid integer :: ng !!Number of cells in a given direction of the grid integer :: p_ind ( 2 ) !!Minimum and maximum cell number of the grid real ( dp ) :: gmin !!Value of the corresponding axis at the minimum cell real ( dp ) :: gmax !!Value of the corresponding axis at the maximum cell integer :: min_cell !!Initial cell of the grid in absolute units (i.e. respect to the total grid) integer :: max_cell !!Final cell of the grid in absolute units (i.e. respect to the total grid) end type type sgrid integer :: sind ( 2 ) !!Initial and final stretched cell (sind(1) also coincides with the number of !!stretched cells) real ( dp ) :: smin !!Axis value on the boundary between stretched and unstretched grid (left side of the box) real ( dp ) :: smax !!Axis value on the boundary between stretched and unstretched grid (right side of the box) end type type index_array !! Type defining an array of consecutive integer numbers, useful as !! indices in arrays. integer , allocatable :: indices (:) contains procedure , public :: find_index end type interface index_array module procedure new_index_array end interface contains function new_index_array ( length ) result ( this ) !! Constructor for the index_array type integer , intent ( in ) :: length type ( index_array ) :: this integer :: i allocate ( this % indices ( length )) this % indices = [( i , i = 1 , length )] end function subroutine find_index ( index_in , mask ) !! Type bound procedure that finds and pack all the array indices !! according to the given mask class ( index_array ), intent ( inout ) :: index_in logical , intent ( in ) :: mask (:) index_in % indices = PACK ( index_in % indices , mask ) end subroutine end module","tags":"","loc":"sourcefile/struct_def.f90.html"},{"title":"fstruct_data.f90 – ALaDyn","text":"This file depends on sourcefile~~fstruct_data.f90~~EfferentGraph sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~fstruct_data.f90~~AfferentGraph sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~boris_push.f90 boris_push.f90 sourcefile~boris_push.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~fstruct_data.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~fstruct_data.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~init_laser_field.f90->sourcefile~fstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~fstruct_data.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~fstruct_data.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~psolve.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~grid_part_util.f90->sourcefile~fstruct_data.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~boris_push.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~array_alloc.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~pic_dump.f90->sourcefile~array_alloc.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules fstruct_data Source Code fstruct_data.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module fstruct_data use precision_def implicit none real ( dp ), allocatable :: ebf (:, :, :, :), ebf_bunch (:, :, :, :), & jc (:, :, :, :) real ( dp ), allocatable :: ebf0 (:, :, :, :), ebf1 (:, :, :, :) real ( dp ), allocatable :: ebf0_bunch (:, :, :, :), & ebf1_bunch (:, :, :, :), jb (:, :, :, :) real ( dp ), allocatable :: env (:, :, :, :), env0 (:, :, :, :), & env1 (:, :, :, :) real ( dp ), allocatable :: up (:, :, :, :), up0 (:, :, :, :), & up1 (:, :, :, :), flux (:, :, :, :) real ( dp ), allocatable :: pot (:, :, :, :), fluid_x_profile (:), & fluid_yz_profile (:, :) real ( dp ), allocatable :: aux1 (:), aux2 (:) end module","tags":"","loc":"sourcefile/fstruct_data.f90.html"},{"title":"set_grid_param.f90 – ALaDyn","text":"This file depends on sourcefile~~set_grid_param.f90~~EfferentGraph sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~set_grid_param.f90->sourcefile~mpi_var.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~set_grid_param.f90->sourcefile~common_param.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~set_grid_param.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~set_grid_param.f90~~AfferentGraph sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~set_grid_param.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules set_grid_param Source Code set_grid_param.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! !=================================================== !     Local grid structure under mpi domain decomposition !============== ! grid [1:n]   np=n+2  extended domain [1:np+2] ! interior [3,np]   ghost [1:2], [np+1:np+2] ! overlapping grid  structure: ! !==================================================================== !                                     1-----2---- 3--- 4   |      pey+1 !                 1-----2----[3-------np-1--np]--np+1--np+2|    pey !1-2--------------np-1--np---np+1                          |pey-1 !====================================================================== !      Right(pey+1)     [1:4]     overlap pey [np-1:np+2] !      Left(pey-1)      [np-1:np+2]overlap pey [1:4] !=================================== module set_grid_param use common_param use grid_param use mpi_var implicit none contains !=========================================================== ! allocates and defines global (x,y,z)coordinates for uniform or stretched ! configurations !=========================================================== subroutine set_grid ( n1 , n2 , n3 , ib , x_stretch , y_stretch , xres , yxres , & zxres ) integer , intent ( in ) :: n1 , n2 , n3 , ib , x_stretch , y_stretch real ( dp ), intent ( in ) :: xres , yxres , zxres integer :: i , ns1 real ( dp ) :: yy , yyh , smin , smax allocate ( x ( 0 : n1 + 1 ), xw ( n1 + 1 ), dx1 ( 0 : n1 + 1 ), y ( 0 : n2 + 1 ), z ( 0 : n3 + 1 ), dy1 ( 0 : n2 + 1 ), & dz1 ( 0 : n3 + 1 )) allocate ( dx1h ( 0 : n1 + 1 ), dy1h ( 0 : n2 + 1 ), dz1h ( 0 : n3 + 1 )) allocate ( xh ( 0 : n1 + 1 ), yh ( 0 : n2 + 1 ), zh ( 0 : n3 + 1 )) !----------------------------------- aph = acos ( - 1.0 ) * 0.4 dxi = 1. dyi = 1. dzi = 1. sx_rat = 1. sy_rat = 1. sz_rat = 1. smin = 0.0 smax = 0.0 dx = 1. if ( xres > 0.0 ) dx = 1. / xres dx_inv = 1.0 / dx do i = 0 , n1 + 1 x ( i ) = dx * real ( i - 1 , dp ) !xminx(1)=0,.....,xmax-dx=x(nx) xh ( i ) = x ( i ) + 0.5 * dx dx1 ( i ) = 1. dx1h ( i ) = 1. end do dxi = dx dxi_inv = dx_inv ns1 = n1 + 1 - x_stretch if ( x_stretch > 0 ) then dxi = aph / real ( x_stretch , dp ) dxi_inv = 1. / dxi lx_s = dx * dxi_inv sx_rat = dxi * dx_inv smax = x ( ns1 ) do i = ns1 , n1 + 1 yy = dxi * real ( i - ns1 , dp ) yyh = yy + dxi * 0.5 x ( i ) = smax + lx_s * tan ( yy ) xh ( i ) = smax + lx_s * tan ( yyh ) dx1h ( i ) = cos ( yyh ) * cos ( yyh ) dx1 ( i ) = cos ( yy ) * cos ( yy ) end do end if str_xgrid % sind ( 1 ) = x_stretch str_xgrid % sind ( 2 ) = ns1 str_xgrid % smin = x ( 1 ) str_xgrid % smax = x ( ns1 ) xw = x xmax = x ( n1 ) xmin = x ( 1 ) if ( ib == 2 ) xmax = x ( n1 + 1 ) lx_box = xmax - xmin xw_min = xmin xw_max = xmax dy = 1. dy_inv = 1. / dy dyi = dy dyi_inv = 1. / dy ymin = 0.0 ymax = 0.0 y = 0.0 yh = 0.0 dy1 = 1. dy1h = 1. ly_box = 1. if ( n2 > 1 ) then dy = yxres * dx dy_inv = 1. / dy dyi = dy dyi_inv = dy_inv do i = 0 , n2 + 1 y ( i ) = dy * real ( i - 1 - n2 / 2 , dp ) yh ( i ) = y ( i ) + 0.5 * dy dy1 ( i ) = 1. dy1h ( i ) = 1. end do !============== Stretched grid !   index      [1:y_stretch]              [ns1:n2+1] !   coordinate [y(1): smin=y(y_stretch+1]   [smax: y(n2+1)=ymax] !   unstretched: [y_stretch+1:ns1-1=n2+1-(y_stretch1)] !======================== ns1 = n2 + 1 - y_stretch if ( y_stretch > 0 ) then dyi = aph / real ( y_stretch , dp ) dyi_inv = 1. / dyi l_s = dy * dyi_inv sy_rat = dyi * dy_inv smin = y ( y_stretch + 1 ) smax = y ( ns1 ) str_ygrid % sind ( 1 ) = y_stretch str_ygrid % sind ( 2 ) = ns1 str_ygrid % smin = smin str_ygrid % smax = smax do i = 0 , y_stretch yy = dyi * real ( i - 1 - y_stretch , dp ) yyh = yy + 0.5 * dyi y ( i ) = smin + l_s * tan ( yy ) !y(xi)=y_s +(Dy/Dxi)*tan(xi) Dy=L_s*dxi uniform yh ( i ) = smin + l_s * tan ( yyh ) dy1h ( i ) = cos ( yyh ) * cos ( yyh ) ! dy(xi)= L_s/cos&#94;2(xi)=(Dy/Dxi)/cos&#94;2(xi) dy1 ( i ) = cos ( yy ) * cos ( yy ) ! dy1=cos&#94;2(xi)=(dy/dxi)&#94;{-1}*(Dy0/Dxi) end do do i = ns1 , n2 + 1 yy = dyi * real ( i - ns1 , dp ) yyh = yy + dyi * 0.5 y ( i ) = smax + l_s * tan ( yy ) yh ( i ) = smax + l_s * tan ( yyh ) dy1h ( i ) = cos ( yyh ) * cos ( yyh ) dy1 ( i ) = cos ( yy ) * cos ( yy ) end do end if ymin = y ( 1 ) ymax = y ( n2 + 1 ) ly_box = ymax - ymin end if dz = 1. dz_inv = 1. / dz dzi = dz dzi_inv = 1. / dz zmin = 0.0 zmax = 0.0 z = 0.0 zh = 0.0 dz1 = 1. dz1h = 1. lz_box = 1. if ( n3 > 1 ) then dz = zxres * dx dz_inv = 1. / dz do i = 0 , n3 + 1 z ( i ) = dz * real ( i - 1 - n3 / 2 , dp ) zh ( i ) = z ( i ) + 0.5 * dz dz1 ( i ) = 1. dz1h ( i ) = 1. end do ns1 = n3 + 1 - y_stretch if ( y_stretch > 0 ) then dzi = aph / real ( y_stretch , dp ) dzi_inv = 1. / dzi l_s = dz * dzi_inv sz_rat = dzi * dz_inv smin = z ( y_stretch + 1 ) smax = z ( ns1 ) str_zgrid % sind ( 1 ) = y_stretch str_zgrid % sind ( 2 ) = ns1 str_zgrid % smin = smin str_zgrid % smax = smax do i = 0 , y_stretch yy = dzi * real ( i - 1 - y_stretch , dp ) yyh = yy + 0.5 * dzi z ( i ) = smin + l_s * tan ( yy ) zh ( i ) = smin + l_s * tan ( yyh ) dz1h ( i ) = cos ( yyh ) * cos ( yyh ) dz1 ( i ) = cos ( yy ) * cos ( yy ) end do do i = ns1 , n3 + 1 yy = dzi * real ( i - ns1 , dp ) yyh = yy + dzi * 0.5 z ( i ) = smax + l_s * tan ( yy ) zh ( i ) = smax + l_s * tan ( yyh ) dz1h ( i ) = cos ( yyh ) * cos ( yyh ) dz1 ( i ) = cos ( yy ) * cos ( yy ) end do end if zmin = z ( 1 ) zmax = z ( n3 + 1 ) lz_box = zmax - zmin end if end subroutine !================ !================ subroutine mpi_loc_grid ( n1_loc , n2_loc , n3_loc , npex , npey , npez ) integer , intent ( in ) :: n1_loc , n2_loc , n3_loc , npex , npey , npez integer :: p allocate ( loc_ygrid ( 0 : npey - 1 ), loc_zgrid ( 0 : npez - 1 )) allocate ( loc_xgrid ( 0 : npex - 1 )) loc_xgr_max = n1_loc do p = 0 , npex - 1 loc_xgrid ( p )% ng = n1_loc end do loc_ygr_max = n2_loc loc_zgr_max = n3_loc do p = 0 , npey - 1 loc_ygrid ( p )% ng = n2_loc end do do p = 0 , npez - 1 loc_zgrid ( p )% ng = n3_loc end do allocate ( nxh ( npex ), nyh ( npey ), nzh ( npez )) allocate ( loc_yg ( 0 : loc_ygr_max + 1 , 4 , 0 : npey - 1 )) allocate ( loc_zg ( 0 : loc_zgr_max + 1 , 4 , 0 : npez - 1 )) allocate ( loc_xg ( 0 : loc_xgr_max + 1 , 4 , 0 : npex - 1 )) allocate ( str_indx ( 0 : npey - 1 , 0 : npez - 1 )) str_indx ( 0 : npey - 1 , 0 : npez - 1 ) = 0 end subroutine subroutine set_output_grid ( jmp , npex , npey , npez ) integer , intent ( in ) :: jmp , npex , npey , npez integer :: i1 , j1 , k1 , i2 , j2 , k2 integer :: ipe , ix , iix1 , iy1 , iz1 , ngyzx ( 3 ), ngout do ipe = 0 , npex - 1 i1 = loc_xgrid ( ipe )% p_ind ( 1 ) i2 = loc_xgrid ( ipe )% p_ind ( 2 ) iix1 = 0 do ix = i1 , i2 , jmp iix1 = iix1 + 1 end do nxh ( ipe + 1 ) = iix1 end do do ipe = 0 , npey - 1 j1 = loc_ygrid ( ipe )% p_ind ( 1 ) j2 = loc_ygrid ( ipe )% p_ind ( 2 ) iy1 = 0 do ix = j1 , j2 , jmp iy1 = iy1 + 1 end do nyh ( ipe + 1 ) = iy1 end do do ipe = 0 , npez - 1 k1 = loc_zgrid ( ipe )% p_ind ( 1 ) k2 = loc_zgrid ( ipe )% p_ind ( 2 ) iz1 = 0 do ix = k1 , k2 , jmp iz1 = iz1 + 1 end do nzh ( ipe + 1 ) = iz1 end do ngout = max ( nx , ny ) ngout = max ( ngout , nz ) allocate ( gwdata ( ngout )) ! ngyzx ( 1 ) = maxval ( nyh ( 1 : npey )) ngyzx ( 2 ) = maxval ( nzh ( 1 : npez )) ngyzx ( 3 ) = maxval ( nxh ( 1 : npex )) ngout = ngyzx ( 1 ) * ngyzx ( 2 ) * ngyzx ( 3 ) if ( ngout > 0 ) then allocate ( wdata ( ngout )) else allocate ( wdata ( 1 )) end if end subroutine !============================ subroutine set_ftyzgrid ( npey , npez , sh ) integer , intent ( in ) :: npey , npez , sh integer :: i , ii , p , ip , n_loc , last_ind ! defines local yftgrid and zftgrid loc_yftgrid ( 0 )% gmin = yft ( 1 ) ip = loc_yftgrid ( 0 )% ng n_loc = ip loc_yftgrid ( 0 )% gmax = yft ( ip + 1 ) loc_yftgrid ( 0 )% p_ind ( 1 ) = min ( sh , n_loc ) loc_yftgrid ( 0 )% p_ind ( 2 ) = n_loc + loc_yftgrid ( 0 )% p_ind ( 1 ) - 1 loc_yftgrid ( 0 )% min_cell = 0 loc_yftgrid ( 0 )% max_cell = loc_yftgrid ( 0 )% min_cell + n_loc - 1 p = 0 do i = 1 , n_loc + 1 loc_yft ( i , p ) = yft ( i ) end do if ( npey > 1 ) then ip = loc_yftgrid ( 0 )% ng if ( npey > 2 ) then do p = 1 , npey - 2 n_loc = loc_yftgrid ( p - 1 )% ng n_loc = loc_yftgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_yft ( i , p ) = yft ( ii ) end do loc_yftgrid ( p )% gmin = loc_yftgrid ( p - 1 )% gmax ip = ip + n_loc loc_yftgrid ( p )% gmax = yft ( ip + 1 ) loc_yftgrid ( p )% p_ind ( 1 ) = sh loc_yftgrid ( p )% p_ind ( 2 ) = n_loc + loc_yftgrid ( p )% p_ind ( 1 ) - 1 loc_yftgrid ( p )% min_cell = loc_yftgrid ( p - 1 )% min_cell + n_loc loc_yftgrid ( p )% max_cell = loc_yftgrid ( p - 1 )% max_cell + n_loc end do end if p = npey - 1 n_loc = loc_yftgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_yft ( i , p ) = yft ( ii ) end do loc_yftgrid ( p )% gmin = loc_yftgrid ( p - 1 )% gmax ip = ip + n_loc loc_yftgrid ( p )% gmax = yft ( ip + 1 ) loc_yftgrid ( p )% p_ind ( 1 ) = sh loc_yftgrid ( p )% p_ind ( 2 ) = n_loc + loc_yftgrid ( p )% p_ind ( 1 ) - 1 loc_yftgrid ( p )% min_cell = loc_yftgrid ( p - 1 )% min_cell + n_loc loc_yftgrid ( p )% max_cell = loc_yftgrid ( p - 1 )% max_cell + n_loc end if !      Now redefine loc_yft coordinate on an extended grid to be overset the !      strethed grid if ( npey > 3 ) then n_loc = loc_yftgrid ( 0 )% ng last_ind = 0 do p = 0 , npey / 2 - 1 do i = 1 , 4 * n_loc ii = i + last_ind loc_yft ( i , p ) = yft ( ii ) end do last_ind = last_ind + n_loc enddo !======================== last_ind = last_ind - n_loc do p = npey / 2 , npey / 2 + 1 do i = 1 , 4 * n_loc ii = i + last_ind loc_yft ( i , p ) = yft ( ii ) end do end do !================== do p = npey / 2 + 2 , npey - 1 do i = 1 , 4 * n_loc ii = i + last_ind loc_yft ( i , p ) = yft ( ii ) end do last_ind = last_ind + n_loc enddo endif !========================= loc_zftgrid ( 0 )% gmin = zft ( 1 ) ip = loc_zftgrid ( 0 )% ng n_loc = ip loc_zftgrid ( 0 )% gmax = zft ( ip + 1 ) loc_zftgrid ( 0 )% p_ind ( 1 ) = min ( sh , n_loc ) loc_zftgrid ( 0 )% p_ind ( 2 ) = n_loc + loc_zftgrid ( 0 )% p_ind ( 1 ) - 1 loc_zftgrid ( 0 )% min_cell = 0 loc_zftgrid ( 0 )% max_cell = loc_zftgrid ( 0 )% min_cell + n_loc - 1 p = 0 do i = 1 , n_loc + 1 loc_zft ( i , p ) = zft ( i ) end do if ( npez > 1 ) then ip = loc_zftgrid ( 0 )% ng if ( npez > 2 ) then do p = 1 , npez - 2 n_loc = loc_zftgrid ( p - 1 )% ng n_loc = loc_zftgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_zft ( i , p ) = zft ( ii ) end do loc_zftgrid ( p )% gmin = loc_zftgrid ( p - 1 )% gmax ip = ip + n_loc loc_zftgrid ( p )% gmax = zft ( ip + 1 ) loc_zftgrid ( p )% p_ind ( 1 ) = sh loc_zftgrid ( p )% p_ind ( 2 ) = n_loc + loc_zftgrid ( p )% p_ind ( 1 ) - 1 loc_zftgrid ( p )% min_cell = loc_zftgrid ( p - 1 )% min_cell + n_loc loc_zftgrid ( p )% max_cell = loc_zftgrid ( p - 1 )% max_cell + n_loc end do end if p = npez - 1 n_loc = loc_zftgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_zft ( i , p ) = zft ( ii ) end do loc_zftgrid ( p )% gmin = loc_zftgrid ( p - 1 )% gmax ip = ip + n_loc loc_zftgrid ( p )% gmax = zft ( ip + 1 ) loc_zftgrid ( p )% p_ind ( 1 ) = sh loc_zftgrid ( p )% p_ind ( 2 ) = n_loc + loc_zftgrid ( p )% p_ind ( 1 ) - 1 loc_zftgrid ( p )% min_cell = loc_zftgrid ( p - 1 )% min_cell + n_loc loc_zftgrid ( p )% max_cell = loc_zftgrid ( p - 1 )% max_cell + n_loc end if if ( npez > 3 ) then n_loc = loc_zftgrid ( 0 )% ng last_ind = 0 do p = 0 , npez / 2 - 1 do i = 1 , 4 * n_loc ii = i + last_ind loc_zft ( i , p ) = zft ( ii ) end do last_ind = last_ind + n_loc enddo last_ind = last_ind - n_loc do p = npez / 2 , npez / 2 + 1 do i = 1 , 4 * n_loc ii = i + last_ind loc_zft ( i , p ) = zft ( ii ) end do end do do p = npez / 2 + 2 , npez - 1 do i = 1 , 4 * n_loc ii = i + last_ind loc_zft ( i , p ) = zft ( ii ) end do last_ind = last_ind + n_loc enddo endif end subroutine subroutine set_fyzxgrid ( npey , npez , npex , sh ) integer , intent ( in ) :: npey , npez , npex , sh integer :: i , ii , p , ip , n_loc ! Defines initial local p-grid coordinate and loc n_cell ! y-grid decomposed on n2_loc uniform grid size loc_ygrid ( 0 )% gmin = y ( 1 ) ip = loc_ygrid ( 0 )% ng n_loc = ip loc_ygrid ( 0 )% gmax = y ( ip + 1 ) loc_ygrid ( 0 )% p_ind ( 1 ) = min ( sh , n_loc ) loc_ygrid ( 0 )% p_ind ( 2 ) = n_loc + loc_ygrid ( 0 )% p_ind ( 1 ) - 1 loc_ygrid ( 0 )% min_cell = 0 loc_ygrid ( 0 )% max_cell = loc_ygrid ( 0 )% min_cell + n_loc - 1 p = 0 do i = 0 , n_loc + 1 loc_yg ( i , 1 , p ) = y ( i ) loc_yg ( i , 2 , p ) = yh ( i ) loc_yg ( i , 3 , p ) = dy1 ( i ) loc_yg ( i , 4 , p ) = dy1h ( i ) end do if ( npey > 1 ) then ip = loc_ygrid ( 0 )% ng if ( npey > 2 ) then do p = 1 , npey - 2 n_loc = loc_ygrid ( p - 1 )% ng loc_yg ( 0 , 1 : 4 , p ) = loc_yg ( n_loc , 1 : 4 , p - 1 ) n_loc = loc_ygrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_yg ( i , 1 , p ) = y ( ii ) loc_yg ( i , 2 , p ) = yh ( ii ) loc_yg ( i , 3 , p ) = dy1 ( ii ) loc_yg ( i , 4 , p ) = dy1h ( ii ) end do loc_ygrid ( p )% gmin = loc_ygrid ( p - 1 )% gmax ip = ip + n_loc loc_ygrid ( p )% gmax = y ( ip + 1 ) loc_ygrid ( p )% p_ind ( 1 ) = sh loc_ygrid ( p )% p_ind ( 2 ) = n_loc + loc_ygrid ( p )% p_ind ( 1 ) - 1 loc_ygrid ( p )% min_cell = loc_ygrid ( p - 1 )% min_cell + n_loc loc_ygrid ( p )% max_cell = loc_ygrid ( p - 1 )% max_cell + n_loc end do end if p = npey - 1 n_loc = loc_ygrid ( p - 1 )% ng loc_yg ( 0 , 1 : 4 , p ) = loc_yg ( n_loc , 1 : 4 , p - 1 ) n_loc = loc_ygrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_yg ( i , 1 , p ) = y ( ii ) loc_yg ( i , 2 , p ) = yh ( ii ) loc_yg ( i , 3 , p ) = dy1 ( ii ) ! dy1=cos&#94;2(xi) =[dxi/dy] stretched  (=1 y=xi) loc_yg ( i , 4 , p ) = dy1h ( ii ) end do loc_ygrid ( p )% gmin = loc_ygrid ( p - 1 )% gmax ip = ip + n_loc loc_ygrid ( p )% gmax = y ( ip + 1 ) loc_ygrid ( p )% p_ind ( 1 ) = sh loc_ygrid ( p )% p_ind ( 2 ) = n_loc + loc_ygrid ( p )% p_ind ( 1 ) - 1 loc_ygrid ( p )% min_cell = loc_ygrid ( p - 1 )% min_cell + n_loc loc_ygrid ( p )% max_cell = loc_ygrid ( p - 1 )% max_cell + n_loc end if !========================= loc_zgrid ( 0 )% gmin = z ( 1 ) ip = loc_zgrid ( 0 )% ng n_loc = ip loc_zgrid ( 0 )% gmax = z ( ip + 1 ) loc_zgrid ( 0 )% p_ind ( 1 ) = min ( sh , n_loc ) loc_zgrid ( 0 )% p_ind ( 2 ) = n_loc + loc_zgrid ( 0 )% p_ind ( 1 ) - 1 loc_zgrid ( 0 )% min_cell = 0 loc_zgrid ( 0 )% max_cell = loc_zgrid ( 0 )% min_cell + n_loc - 1 p = 0 do i = 0 , n_loc + 1 loc_zg ( i , 1 , p ) = z ( i ) loc_zg ( i , 2 , p ) = zh ( i ) loc_zg ( i , 3 , p ) = dz1 ( i ) loc_zg ( i , 4 , p ) = dz1h ( i ) end do if ( npez > 1 ) then ip = loc_zgrid ( 0 )% ng if ( npez > 2 ) then do p = 1 , npez - 2 n_loc = loc_zgrid ( p - 1 )% ng loc_zg ( 0 , 1 : 4 , p ) = loc_zg ( n_loc , 1 : 4 , p - 1 ) n_loc = loc_zgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_zg ( i , 1 , p ) = z ( ii ) loc_zg ( i , 2 , p ) = zh ( ii ) loc_zg ( i , 3 , p ) = dz1 ( ii ) loc_zg ( i , 4 , p ) = dz1h ( ii ) end do loc_zgrid ( p )% gmin = loc_zgrid ( p - 1 )% gmax ip = ip + n_loc loc_zgrid ( p )% gmax = z ( ip + 1 ) loc_zgrid ( p )% p_ind ( 1 ) = sh loc_zgrid ( p )% p_ind ( 2 ) = n_loc + loc_zgrid ( p )% p_ind ( 1 ) - 1 loc_zgrid ( p )% min_cell = loc_zgrid ( p - 1 )% min_cell + n_loc loc_zgrid ( p )% max_cell = loc_zgrid ( p - 1 )% max_cell + n_loc end do end if p = npez - 1 n_loc = loc_zgrid ( p - 1 )% ng loc_zg ( 0 , 1 : 4 , p ) = loc_zg ( n_loc , 1 : 4 , p - 1 ) n_loc = loc_zgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_zg ( i , 1 , p ) = z ( ii ) loc_zg ( i , 2 , p ) = zh ( ii ) loc_zg ( i , 3 , p ) = dz1 ( ii ) loc_zg ( i , 4 , p ) = dz1h ( ii ) end do loc_zgrid ( p )% gmin = loc_zgrid ( p - 1 )% gmax ip = ip + n_loc loc_zgrid ( p )% gmax = z ( ip + 1 ) loc_zgrid ( p )% p_ind ( 1 ) = sh loc_zgrid ( p )% p_ind ( 2 ) = n_loc + loc_zgrid ( p )% p_ind ( 1 ) - 1 loc_zgrid ( p )% min_cell = loc_zgrid ( p - 1 )% min_cell + n_loc loc_zgrid ( p )% max_cell = loc_zgrid ( p - 1 )% max_cell + n_loc end if !====================== loc_xgrid ( 0 )% gmin = x ( 1 ) ip = loc_xgrid ( 0 )% ng n_loc = ip loc_xgrid ( 0 )% gmax = x ( ip + 1 ) loc_xgrid ( 0 )% p_ind ( 1 ) = min ( sh , n_loc ) loc_xgrid ( 0 )% p_ind ( 2 ) = n_loc + loc_xgrid ( 0 )% p_ind ( 1 ) - 1 loc_xgrid ( 0 )% min_cell = 0 loc_xgrid ( 0 )% max_cell = loc_xgrid ( 0 )% min_cell + n_loc - 1 p = 0 do i = 0 , n_loc + 1 loc_xg ( i , 1 , p ) = x ( i ) loc_xg ( i , 2 , p ) = xh ( i ) loc_xg ( i , 3 , p ) = dx1 ( i ) loc_xg ( i , 4 , p ) = dx1h ( i ) end do if ( npex > 1 ) then ip = loc_xgrid ( 0 )% ng if ( npex > 2 ) then do p = 1 , npex - 2 n_loc = loc_xgrid ( p - 1 )% ng loc_xg ( 0 , 1 : 4 , p ) = loc_xg ( n_loc , 1 : 4 , p - 1 ) n_loc = loc_xgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_xg ( i , 1 , p ) = x ( ii ) loc_xg ( i , 2 , p ) = xh ( ii ) loc_xg ( i , 3 , p ) = dx1 ( ii ) loc_xg ( i , 4 , p ) = dx1h ( ii ) end do loc_xgrid ( p )% gmin = loc_xgrid ( p - 1 )% gmax ip = ip + n_loc loc_xgrid ( p )% gmax = x ( ip + 1 ) loc_xgrid ( p )% p_ind ( 1 ) = sh loc_xgrid ( p )% p_ind ( 2 ) = n_loc + loc_xgrid ( p )% p_ind ( 1 ) - 1 loc_xgrid ( p )% min_cell = loc_xgrid ( p - 1 )% min_cell + n_loc loc_xgrid ( p )% max_cell = loc_xgrid ( p - 1 )% max_cell + n_loc end do end if p = npex - 1 n_loc = loc_xgrid ( p - 1 )% ng loc_xg ( 0 , 1 : 4 , p ) = loc_xg ( n_loc , 1 : 4 , p - 1 ) n_loc = loc_xgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_xg ( i , 1 , p ) = x ( ii ) loc_xg ( i , 2 , p ) = xh ( ii ) loc_xg ( i , 3 , p ) = dx1 ( ii ) loc_xg ( i , 4 , p ) = dx1h ( ii ) end do loc_xgrid ( p )% gmin = loc_xgrid ( p - 1 )% gmax ip = ip + n_loc loc_xgrid ( p )% gmax = x ( ip + 1 ) loc_xgrid ( p )% p_ind ( 1 ) = sh loc_xgrid ( p )% p_ind ( 2 ) = n_loc + loc_xgrid ( p )% p_ind ( 1 ) - 1 loc_xgrid ( p )% min_cell = loc_xgrid ( p - 1 )% min_cell + n_loc loc_xgrid ( p )% max_cell = loc_xgrid ( p - 1 )% max_cell + n_loc end if end subroutine !====================== subroutine set_fxgrid ( npex , sh ) integer , intent ( in ) :: npex , sh integer :: i , ii , p , ip , n_loc loc_xgrid ( 0 )% gmin = x ( 1 ) ip = loc_xgrid ( 0 )% ng n_loc = ip loc_xgrid ( 0 )% gmax = x ( ip + 1 ) loc_xgrid ( 0 )% p_ind ( 1 ) = min ( sh , n_loc ) loc_xgrid ( 0 )% p_ind ( 2 ) = n_loc + loc_xgrid ( 0 )% p_ind ( 1 ) - 1 p = 0 do i = 0 , n_loc + 1 loc_xg ( i , 1 , p ) = x ( i ) loc_xg ( i , 2 , p ) = xh ( i ) loc_xg ( i , 3 , p ) = dx1 ( i ) loc_xg ( i , 4 , p ) = dx1h ( i ) end do if ( npex > 1 ) then ip = loc_xgrid ( 0 )% ng if ( npex > 2 ) then do p = 1 , npex - 2 n_loc = loc_xgrid ( p - 1 )% ng loc_xg ( 0 , 1 : 4 , p ) = loc_xg ( n_loc , 1 : 4 , p - 1 ) n_loc = loc_xgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_xg ( i , 1 , p ) = x ( ii ) loc_xg ( i , 2 , p ) = xh ( ii ) loc_xg ( i , 3 , p ) = dx1 ( ii ) loc_xg ( i , 4 , p ) = dx1h ( ii ) end do loc_xgrid ( p )% gmin = loc_xgrid ( p - 1 )% gmax ip = ip + n_loc loc_xgrid ( p )% gmax = x ( ip + 1 ) loc_xgrid ( p )% p_ind ( 1 ) = sh loc_xgrid ( p )% p_ind ( 2 ) = n_loc + loc_xgrid ( p )% p_ind ( 1 ) - 1 end do end if p = npex - 1 n_loc = loc_xgrid ( p - 1 )% ng loc_xg ( 0 , 1 : 4 , p ) = loc_xg ( n_loc , 1 : 4 , p - 1 ) n_loc = loc_xgrid ( p )% ng do i = 1 , n_loc + 1 ii = i + ip loc_xg ( i , 1 , p ) = x ( ii ) loc_xg ( i , 2 , p ) = xh ( ii ) loc_xg ( i , 3 , p ) = dx1 ( ii ) loc_xg ( i , 4 , p ) = dx1h ( ii ) end do loc_xgrid ( p )% gmin = loc_xgrid ( p - 1 )% gmax ip = ip + n_loc loc_xgrid ( p )% gmax = x ( ip + 1 ) loc_xgrid ( p )% p_ind ( 1 ) = sh loc_xgrid ( p )% p_ind ( 2 ) = n_loc + loc_xgrid ( p )% p_ind ( 1 ) - 1 end if end subroutine subroutine set_str_ind ( npey , npez , ndm ) integer , intent ( in ) :: npey , npez , ndm integer :: p , q , ip ( 4 ) str_indx ( 0 : npey - 1 , 0 : npez - 1 ) = 0 ip = 0 if ( ndm < 3 ) then do p = 0 , npey - 1 if ( str_ygrid % smin > loc_ygrid ( p )% gmin ) ip ( 1 ) = p if ( str_ygrid % smax >= loc_ygrid ( p )% gmin ) ip ( 2 ) = p end do p = 0 do q = 0 , ip ( 1 ) str_indx ( q , p ) = 1 !selects mpi-tasks with stretched y< 0 up to ys_min end do do q = ip ( 2 ), npey - 1 str_indx ( q , p ) = 2 !selects mpi-tasks with stretched y>0 up to ys_max end do return end if do p = 0 , npey - 1 if ( str_ygrid % smin > loc_ygrid ( p )% gmin ) ip ( 1 ) = p if ( str_ygrid % smax >= loc_ygrid ( p )% gmin ) ip ( 2 ) = p end do do p = 0 , npez - 1 if ( str_zgrid % smin > loc_zgrid ( p )% gmin ) ip ( 3 ) = p if ( str_zgrid % smax >= loc_zgrid ( p )% gmin ) ip ( 4 ) = p end do do p = 0 , ip ( 3 ) str_indx ( 0 : npey - 1 , p ) = 2 do q = 0 , ip ( 1 ) str_indx ( q , p ) = 1 end do do q = ip ( 2 ), npey - 1 str_indx ( q , p ) = 3 end do end do do p = ip ( 3 ) + 1 , ip ( 4 ) - 1 do q = 0 , ip ( 1 ) str_indx ( q , p ) = 8 end do do q = ip ( 2 ), npey - 1 str_indx ( q , p ) = 4 end do end do do p = ip ( 4 ), npez - 1 str_indx ( 0 : npey - 1 , p ) = 6 do q = 0 , ip ( 1 ) str_indx ( q , p ) = 7 end do do q = ip ( 2 ), npey - 1 str_indx ( q , p ) = 5 end do end do end subroutine ! subroutine select_str_to_ft_grid ( npey , npez ) integer , intent ( in ) :: npey , npez integer :: ip , iy , iz , ii , nloc , loc_nft real ( dp ) :: yy , zz loc_nft = 4 * loc_yftgrid ( 0 )% ng !the local size of uniform grid do ip = 0 , npey - 1 !from negative to positive y coordinate nloc = loc_ygrid ( ip )% ng !the local size of stretched grid do iy = 1 , nloc yy = loc_yg ( iy , 1 , ip ) do ii = 1 , loc_nft if ( yy < loc_yft ( ii , ip )) exit end do yft_ind ( iy , ip ) = ii - 1 end do end do loc_nft = 4 * loc_zftgrid ( 0 )% ng do ip = 0 , npez - 1 !from negative to positive z coordinate nloc = loc_zgrid ( ip )% ng do iz = 1 , nloc zz = loc_zg ( iy , 1 , ip ) do ii = 1 , loc_nft if ( zz < loc_zft ( ii , ip )) exit end do zft_ind ( iy , ip ) = ii - 1 end do end do end subroutine subroutine set_loc_grid_param xmn = loc_xgrid ( imodx )% gmin ymn = loc_ygrid ( imody )% gmin zmn = loc_zgrid ( imodz )% gmin ix1 = loc_xgrid ( imodx )% p_ind ( 1 ) ix2 = loc_xgrid ( imodx )% p_ind ( 2 ) jy1 = loc_ygrid ( imody )% p_ind ( 1 ) jy2 = loc_ygrid ( imody )% p_ind ( 2 ) kz1 = loc_zgrid ( imodz )% p_ind ( 1 ) kz2 = loc_zgrid ( imodz )% p_ind ( 2 ) n_str = 0 if ( stretch ) n_str = str_indx ( imody , imodz ) nyp = loc_ygrid ( imody )% p_ind ( 2 ) !Ny_loc+2 nzp = loc_zgrid ( imodz )% p_ind ( 2 ) !Nz_loc+2 nxp = loc_xgrid ( imodx )% p_ind ( 2 ) !Nx_loc+2 end subroutine !==================== subroutine set_ftgrid ( str , npe1 , npe2 , npe3 ) logical , intent ( in ) :: str integer , intent ( in ) :: npe1 , npe2 , npe3 integer :: n1 , n2 , n3 integer :: i , ip real ( dp ) :: wkx , wky , wkz integer , parameter :: sh = 3 n1 = nx n2 = ny n3 = nz if ( str ) then n2 = nint ( dy_inv * ly_box ) n3 = nint ( dz_inv * lz_box ) if ( mod ( n2 , npe2 ) > 0 ) n2 = n2 + npe2 - mod ( n2 , npe2 ) if ( mod ( n3 , npe3 ) > 0 ) n3 = n3 + npe3 - mod ( n3 , npe3 ) endif !============= set grid point numbers in common.param n1ft = n1 n2ft = n2 n3ft = n3 n1ft_loc = n1ft / npe1 n2ft_loc = n2ft / npe2 n3ft_loc = n3ft / npe3 !======= set global ft (y,z) coorinates allocate ( yft ( n2 + 1 )) allocate ( zft ( n3 + 1 )) do i = 1 , n2 + 1 yft ( i ) = dy * real ( i - 1 - n2 / 2 , dp ) end do do i = 1 , n3 + 1 zft ( i ) = dz * real ( i - 1 - n3 / 2 , dp ) end do !=======  set loca locy_ftgrid loc_zftgrid parameters allocate ( loc_yftgrid ( 0 : npe2 - 1 ), loc_zftgrid ( 0 : npe3 - 1 )) allocate ( loc_yft ( 1 : 4 * n2ft_loc , 0 : npe2 - 1 ), loc_zft ( 1 : 4 * n3ft_loc , 0 : npe3 - 1 )) allocate ( yft_ind ( ny_loc , 0 : npe2 - 1 )) allocate ( zft_ind ( nz_loc , 0 : npe3 - 1 )) do ip = 0 , npe2 - 1 loc_yftgrid ( ip )% ng = n2ft_loc end do do ip = 0 , npe3 - 1 loc_zftgrid ( ip )% ng = n3ft_loc end do !=================== call set_ftyzgrid ( npe2 , npe3 , sh ) !=================== yft_min = loc_yftgrid ( imody )% gmin zft_min = loc_zftgrid ( imodz )% gmin call select_str_to_ft_grid ( nprocy , nprocz ) ! exit ii=yft_ind(y_str,pe) index  yft(ii) < y_str(pe) < yft(ii+1) !======================= allocate ( aky ( n2 + 2 , 0 : 2 ), akz ( n3 + 2 , 0 : 2 )) allocate ( sky ( n2 + 2 , 0 : 2 ), skz ( n3 + 2 , 0 : 2 )) allocate ( ak2y ( n2 + 2 , 0 : 2 ), ak2z ( n3 + 2 , 0 : 2 ), ak2x ( n1 + 1 , 0 : 2 )) allocate ( akx ( 1 : n1 + 1 , 0 : 2 ), skx ( 1 : n1 + 1 , 0 : 2 )) akx (:, 0 : 2 ) = 0.0 ak2x (:, 0 : 2 ) = 0.0 aky (:, 0 : 2 ) = 0.0 ak2y (:, 0 : 2 ) = 0.0 akz (:, 0 : 2 ) = 0.0 ak2z (:, 0 : 2 ) = 0.0 skx (:, 0 : 2 ) = 0.0 sky (:, 0 : 2 ) = 0.0 skz (:, 0 : 2 ) = 0.0 !================ !  Sets wave number grid for all configurations !============================================= !case(0)  ! staggered k-grid wkx = 2. * acos ( - 1. ) / lx_box !lxbox=x(n1+1)-x(1) wky = 2. * acos ( - 1. ) / ly_box !lybox=y(n2+1)-y(1) wkz = 2. * acos ( - 1. ) / lz_box !lzbox=z(n2+1)-z(1) do i = 1 , n1 / 2 akx ( i , 0 ) = wkx * ( real ( i , dp ) - 0.5 ) skx ( i , 0 ) = 2. * sin ( 0.5 * dx * akx ( i , 0 )) / dx end do ak2x ( 1 : n1 , 0 ) = akx ( 1 : n1 , 0 ) * akx ( 1 : n1 , 0 ) if ( n2 > 1 ) then do i = 1 , n2 / 2 aky ( i , 0 ) = wky * ( real ( i , dp ) - 0.5 ) aky ( n2 + 1 - i , 0 ) = - aky ( i , 0 ) end do ak2y ( 1 : n2 , 0 ) = aky ( 1 : n2 , 0 ) * aky ( 1 : n2 , 0 ) do i = 1 , n2 sky ( i , 0 ) = 2. * sin ( 0.5 * dy * aky ( i , 0 )) / dy end do end if if ( n3 > 1 ) then do i = 1 , n3 / 2 akz ( i , 0 ) = wkz * ( real ( i , dp ) - 0.5 ) akz ( n3 + 1 - i , 0 ) = - akz ( i , 0 ) end do do i = 1 , n3 skz ( i , 0 ) = 2. * sin ( 0.5 * dz * akz ( i , 0 )) / dz end do ak2z ( 1 : n3 , 0 ) = akz ( 1 : n3 , 0 ) * akz ( 1 : n3 , 0 ) end if !case(1)    !standard FT k-grid do i = 1 , n1 / 2 akx ( i , 1 ) = wkx * real ( i - 1 , dp ) akx ( n1 + 2 - i , 1 ) = - akx ( i , 1 ) end do ak2x ( 1 : n1 , 1 ) = akx ( 1 : n1 , 1 ) * akx ( 1 : n1 , 1 ) do i = 1 , n1 + 1 skx ( i , 1 ) = 2. * sin ( 0.5 * dx * akx ( i , 1 )) / dx end do if ( n2 > 1 ) then do i = 1 , n2 / 2 aky ( i , 1 ) = wky * real ( i - 1 , dp ) aky ( n2 + 2 - i , 1 ) = - aky ( i , 1 ) sky ( i , 1 ) = 2. * sin ( 0.5 * dy * aky ( i , 1 )) / dy end do ak2y ( 1 : n2 , 1 ) = aky ( 1 : n2 , 1 ) * aky ( 1 : n2 , 1 ) end if if ( n3 > 1 ) then do i = 1 , n3 / 2 akz ( i , 1 ) = wkz * real ( i - 1 , dp ) akz ( n3 + 2 - i , 1 ) = - akz ( i , 1 ) end do do i = 1 , n3 skz ( i , 1 ) = 2. * sin ( 0.5 * dz * akz ( i , 1 )) / dz end do ak2z ( 1 : n3 , 1 ) = akz ( 1 : n3 , 1 ) * akz ( 1 : n3 , 1 ) end if !case(2)  ! for the sine/cosine transform wkx = acos ( - 1.0 ) / lx_box wky = acos ( - 1.0 ) / ly_box wkz = acos ( - 1.0 ) / lz_box do i = 1 , n1 + 1 akx ( i , 2 ) = wkx * real ( i , dp ) skx ( i , 2 ) = 2. * sin ( 0.5 * dx * akx ( i , 2 )) / dx end do if ( n2 > 1 ) then do i = 1 , n2 + 1 aky ( i , 2 ) = wky * real ( i , dp ) sky ( i , 2 ) = 2. * sin ( 0.5 * dy * aky ( i , 2 )) / dy end do ak2y ( 1 : n2 , 2 ) = aky ( 1 : n2 , 2 ) * aky ( 1 : n2 , 2 ) end if if ( n3 > 1 ) then do i = 1 , n3 + 1 akz ( i , 2 ) = wkz * real ( i , dp ) skz ( i , 2 ) = 2. * sin ( 0.5 * dz * akz ( i , 2 )) / dz end do ak2z ( 1 : n3 , 2 ) = akz ( 1 : n3 , 2 ) * akz ( 1 : n3 , 2 ) end if end subroutine !============================= end module","tags":"","loc":"sourcefile/set_grid_param.f90.html"},{"title":"stretched_grid.f90 – ALaDyn","text":"This file depends on sourcefile~~stretched_grid.f90~~EfferentGraph sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stretched_grid.f90~~AfferentGraph sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stretched_grid Source Code stretched_grid.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module stretched_grid use common_param use grid_param use mpi_var , only : imody , imodz implicit none private type str_params real ( dp ) :: const , smin , smax , nl_stretch , xs , dli_inv , ratio , & dl_inv , init_cell end type type ( str_params ) :: y_params , z_params real ( dp ), parameter :: SYMM_CENTER = zero_dp public :: map2dy_part_sind , map3d_part_sind contains !============== Mapping for stretched grids========== pure function invert_stretched_grid ( yp_in , params ) result ( stretched ) real ( dp ), intent ( in ) :: yp_in type ( str_params ), intent ( in ) :: params real ( dp ) :: stretched real ( dp ) :: const , nl_stretch , xs , dli_inv , ratio const = params % const nl_stretch = params % nl_stretch xs = params % xs dli_inv = params % dli_inv ratio = params % ratio stretched = dli_inv * atan ( ratio * ( yp_in + const - xs )) + nl_stretch end function pure function invert_uniform_grid ( yp_in , params ) result ( uniform ) real ( dp ), intent ( in ) :: yp_in type ( str_params ), intent ( in ) :: params real ( dp ) :: uniform , const , dl_inv const = params % const dl_inv = params % dl_inv uniform = ( yp_in + const ) * dl_inv end function subroutine map2dy_part_sind ( np , ic1 , pt ) integer , intent ( in ) :: np , ic1 real ( dp ), intent ( inout ) :: pt (:, :) real ( dp ) :: yp , yp_loc integer :: n !======================== !  enter the y=part(ic1,n) particle position in stretched grid !            y=y(xi) !  exit      xi=part(ic1,n) the  particle position in uniform grid !               normalized to the Dxi cell size !========================================== y_params % const = one_dp * ny * dy / 2 y_params % smin = str_ygrid % smin y_params % smax = str_ygrid % smax y_params % xs = ny_stretch * dy y_params % dl_inv = dy_inv y_params % dli_inv = dyi_inv y_params % ratio = sy_rat y_params % nl_stretch = ny_stretch y_params % init_cell = loc_ygrid ( imody )% min_cell do n = 1 , np yp = pt ( n , ic1 ) if ( yp <= y_params % smin ) then yp_loc = invert_stretched_grid ( yp , y_params ) - y_params % init_cell else if ( yp >= y_params % smax ) then yp = 2 * SYMM_CENTER - yp yp_loc = invert_stretched_grid ( yp , y_params ) yp_loc = ny - yp_loc - y_params % init_cell else yp_loc = invert_uniform_grid ( yp , y_params ) - y_params % init_cell end if pt ( n , ic1 ) = yp_loc end do end subroutine subroutine map2dz_part_sind ( np , ic1 , pt ) integer , intent ( in ) :: np , ic1 real ( dp ), intent ( inout ) :: pt (:, :) real ( dp ) :: zp , zp_loc integer :: n !======================== !  enter the z=part(ic1,n) particle position in stretched grid !            z=y(xi) !  exit      xi=part(ic1,n) the  particle position in uniform grid !               normalized to the Dxi cell size !========================================== z_params % const = one_dp * nz * dz / 2 z_params % smin = str_zgrid % smin z_params % smax = str_zgrid % smax z_params % xs = nz_stretch * dz z_params % dl_inv = dz_inv z_params % dli_inv = dzi_inv z_params % ratio = sz_rat z_params % nl_stretch = nz_stretch z_params % init_cell = loc_zgrid ( imodz )% min_cell do n = 1 , np zp = pt ( n , ic1 ) if ( zp <= z_params % smin ) then zp_loc = invert_stretched_grid ( zp , z_params ) - z_params % init_cell else if ( zp >= z_params % smax ) then zp = 2 * SYMM_CENTER - zp zp_loc = invert_stretched_grid ( zp , z_params ) zp_loc = nz - zp_loc - z_params % init_cell else zp_loc = invert_uniform_grid ( zp , z_params ) - z_params % init_cell end if pt ( n , ic1 ) = zp_loc end do end subroutine subroutine map3d_part_sind ( pt , np , ic1 , ic2 ) integer , intent ( in ) :: np , ic1 , ic2 real ( dp ), intent ( inout ) :: pt (:, :) !======================== !  enter the y=part(n,ic1) z=part(n,ic2) particle positions !        in stretched grids    y=y(xi), z(zi) !  exit   xi=part(n,ic1) zi=part(n,ic2) !    particle positions in uniform grid !    normalized to the (Dxi Dzi) cell sizes !========================================== call map2dy_part_sind ( np , ic1 , pt ) call map2dz_part_sind ( np , ic2 , pt ) end subroutine !======================================== end module","tags":"","loc":"sourcefile/stretched_grid.f90.html"},{"title":"grid_param.f90 – ALaDyn","text":"This file depends on sourcefile~~grid_param.f90~~EfferentGraph sourcefile~grid_param.f90 grid_param.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid_param.f90~~AfferentGraph sourcefile~grid_param.f90 grid_param.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_param.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~grid_param.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~grid_param.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~grid_param.f90 sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~set_grid_param.f90->sourcefile~grid_param.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~grid_param.f90 sourcefile~mpi_part_interface.f90->sourcefile~grid_param.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~grid_param.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~psolve.f90->sourcefile~grid_param.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~set_grid_param.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid_param Source Code grid_param.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module grid_param use precision_def use struct_def implicit none !======================= type ( grid ), allocatable :: loc_ygrid (:) !!Contains the local (to the MPI process) y grid informations type ( grid ), allocatable :: loc_zgrid (:) !!Contains the local (to the MPI process) x grid informations type ( grid ), allocatable :: loc_xgrid (:) !!Contains the local (to the MPI process) x grid informations type ( sgrid ) :: str_xgrid , str_ygrid , str_zgrid real ( sp ), allocatable :: wdata (:), gwdata (:) integer , allocatable :: nxh (:), nyh (:), nzh (:) !fft grid type ( grid ), allocatable :: loc_yftgrid (:) type ( grid ), allocatable :: loc_zftgrid (:) real ( dp ), allocatable :: yft (:), zft (:) real ( dp ), allocatable :: loc_yft (:, :), loc_zft (:, :) !------------------- real ( dp ), allocatable :: akx (:, :), aky (:, :), akz (:, :), sty (:, :) real ( dp ), allocatable :: ak2x (:, :), ak2y (:, :), ak2z (:, :), kern (:), & kern2 (:, :) real ( dp ), allocatable :: skx (:, :), sky (:, :), skz (:, :) !================== real ( dp ), allocatable :: loc_yg (:, :, :), loc_zg (:, :, :), & loc_xg (:, :, :) real ( dp ), allocatable :: x (:), xw (:), y (:), z (:), dx1 (:), dy1 (:), & dz1 (:) real ( dp ), allocatable :: xh (:), yh (:), zh (:), dx1h (:), dy1h (:), & dz1h (:) integer , allocatable :: str_indx (:, :), yft_ind (:, :), zft_ind (:, :) real ( dp ), allocatable :: rpt (:), wgp (:) real ( dp ) :: xtot , xmax , xmin , ymax , ymin , zmax , zmin , xw_min , xw_max real ( dp ) :: lx_box , ly_box , lz_box real ( dp ) :: dx , dx_inv , dxi_inv , dy , dz , dy_inv , dyi_inv , dz_inv , & dzi_inv real ( dp ) :: aph , l_s , lx_s , dxi , dyi , dzi , sy_rat , sz_rat , sx_rat real ( dp ) :: xmn , ymn , zmn real ( dp ) :: yft_min , zft_min !============================= integer :: nxp , nyp , nzp integer :: loc_ygr_max , loc_zgr_max , loc_xgr_max integer :: ix1 , ix2 , jy1 , jy2 , kz1 , kz2 , n_str integer :: nx_stretch , ny_stretch , nz_stretch !-------------------------- end module","tags":"","loc":"sourcefile/grid_param.f90.html"},{"title":"init_beam_part_distrib.f90 – ALaDyn","text":"This file depends on sourcefile~~init_beam_part_distrib.f90~~EfferentGraph sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~util.f90 util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~util.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~control_bunch_input.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~code_util.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~psolve.f90->sourcefile~grid_param.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~psolve.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~psolve.f90->sourcefile~common_param.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~psolve.f90->sourcefile~fstruct_data.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~grid_part_util.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~grid_part_util.f90->sourcefile~fstruct_data.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~modern_fft_lib.f90 modern_fft_lib.F90 sourcefile~prl_fft.f90->sourcefile~modern_fft_lib.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~modern_fft_lib.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~init_beam_part_distrib.f90~~AfferentGraph sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules init_beam_part_distrib Source Code init_beam_part_distrib.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module init_beam_part_distrib use util use psolve use array_alloc use grid_param use mpi_field_interface use mpi_curr_interface use init_grid_field use grid_part_util use code_util , only : maxv , mem_psize use control_bunch_input use phys_param , only : t_unit implicit none real ( dp ), allocatable :: bpart (:, :) !-------------------------- contains !========================= subroutine beam_data ( ndm ) !generates bunch phase space distribution in !                             ebfb(npart,nch) integer , intent ( in ) :: ndm integer :: np_tot integer :: i , i1 , i2 , ip real ( dp ) :: cut , xb ( 5 ), jp_norm integer :: nch logical :: data_snd !========================================================== ! bconf defines only the configuration of bunch charges !======================= ! default values !======================= jp_norm = 1. np_tot = 0 do i = 1 , nsb np_tot = np_tot + nb_tot ( i ) end do cut = 3. nch = 2 * ndm + 1 allocate ( ebfb ( np_tot , nch )) !---! i1 = 1 charge = int ( unit_charge ( 1 ), hp_int ) !the particle charge of each electron bunche !=============================== if ( pe0 ) then !only pe0 generates particle distribution select case ( ndm ) case ( 2 ) do ip = 1 , nsb xb ( ip ) = xc_bunch ( ip ) wgh = real ( jp_norm * jb_norm ( ip ), sp ) !the bunch particle weight part_ind = int ( ip , hp_int ) i2 = i1 + nb_tot ( ip ) - 1 call bunch_gen ( ndm , i1 , i2 , sxb ( ip ), syb ( ip ), syb ( ip ), gam ( ip ), & epsy ( ip ), epsz ( ip ), cut , dg ( ip ), ebfb ) ebfb ( i1 : i2 , 1 ) = ebfb ( i1 : i2 , 1 ) + xb ( ip ) !x-shifting ebfb ( i1 : i2 , 2 ) = ebfb ( i1 : i2 , 2 ) + yc_bunch ( ip ) !y-shifting ebfb ( i1 : i2 , nch ) = wgh_cmp i1 = i2 + 1 end do case ( 3 ) do ip = 1 , nsb xb ( ip ) = xc_bunch ( ip ) wgh = real ( jp_norm * jb_norm ( ip ), sp ) !the bunch particle weights part_ind = int ( ip , hp_int ) i2 = i1 + nb_tot ( ip ) - 1 !==================== call bunch_gen ( ndm , i1 , i2 , sxb ( ip ), syb ( ip ), syb ( ip ), gam ( ip ), & epsy ( ip ), epsz ( ip ), cut , dg ( ip ), ebfb ) !===================== ebfb ( i1 : i2 , 1 ) = ebfb ( i1 : i2 , 1 ) + xb ( ip ) !x-shifting ebfb ( i1 : i2 , 2 ) = ebfb ( i1 : i2 , 2 ) + yc_bunch ( ip ) !y-shifting ebfb ( i1 : i2 , 3 ) = ebfb ( i1 : i2 , 3 ) + zc_bunch ( ip ) !y-shifting ebfb ( i1 : i2 , nch ) = wgh_cmp i1 = i2 + 1 end do end select data_snd = . true . !pe0 sends data to all mpi-task do ip = 1 , npe - 1 call exchange_2d_grdata ( data_snd , ebfb , nch , np_tot , ip , ip + 10 ) end do else data_snd = . false . !current mype mpi-task receves particle data for pe0 call exchange_2d_grdata ( data_snd , ebfb , nch , np_tot , 0 , mype + 10 ) end if !============================== end subroutine !=================== subroutine mpi_beam_ftgrid_distribute ( ndm ) integer , intent ( in ) :: ndm integer :: i , ii , i1 , j integer :: ic , p , ip , ipp , nb_loc real ( dp ) :: y1 , y2 , z1 , z2 , x1 , x2 integer :: nps_loc ( nsb ), npmax , np_tot !========= count bunch particles on each (yz) MPI domain in uniform ftgrid np_tot = sum ( nb_tot ( 1 : nsb )) ! ALL MPI tasks do x1 = loc_xgrid ( imodx )% gmin x2 = loc_xgrid ( imodx )% gmax i1 = 0 select case ( ndm ) !================== 1:   counts local bunch particles of each bunch case ( 2 ) ip = npe_zloc - 1 do ic = 1 , nsb do p = 0 , npe_xloc - 1 do ipp = 0 , npe_yloc - 1 y1 = loc_yftgrid ( ipp )% gmin y2 = loc_yftgrid ( ipp )% gmax loc_nbpart ( ipp , ip , p , ic ) = 0 do j = 1 , nb_tot ( ic ) i = i1 + j if ( ebfb ( i , 2 ) > y1 . and . ebfb ( i , 2 ) <= y2 ) then if ( ebfb ( i , 1 ) > x1 . and . ebfb ( i , 1 ) <= x2 ) then loc_nbpart ( ipp , ip , p , ic ) = loc_nbpart ( ipp , ip , p , ic ) + 1 end if end if end do end do end do i1 = i1 + nb_tot ( ic ) end do nb_max = maxval ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , & 1 : nsb )) nb_min = minval ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , & 1 : nsb )) do ic = 1 , nsb do p = 0 , npe_xloc - 1 do ipp = 0 , npe_yloc - 1 i = ipp + npe_yloc * ( ip + p * npe_zloc ) if ( loc_nbpart ( ipp , ip , p , ic ) == nb_max ) pe_nbmax = i if ( loc_nbpart ( ipp , ip , p , ic ) == nb_min ) pe_nbmin = i end do end do end do !================== ! The local particle number of each bunch nps_loc ( 1 : nsb ) = loc_nbpart ( imody , imodz , imodx , 1 : nsb ) npmax = maxval ( nps_loc ( 1 : nsb )) npmax = max ( npmax , 1 ) if (. not . allocated ( bunch ( 1 )% part )) then allocate ( bunch ( 1 )% part ( npmax , nd2 + 1 )) else deallocate ( bunch ( 1 )% part ) allocate ( bunch ( 1 )% part ( npmax , nd2 + 1 )) end if !================================= !                            2: selected particle coordinates are copied in !                            bunch%part array nb_loc = nps_loc ( 1 ) p = imodx ip = imodz ipp = imody y1 = loc_yftgrid ( ipp )% gmin y2 = loc_yftgrid ( ipp )% gmax !========================= ! Here 2D MPI decomp. allowed !=================================== i1 = 0 do ic = 1 , nsb ii = 0 do i = 1 , nb_tot ( ic ) j = i + i1 if ( ebfb ( i , 2 ) > y1 . and . ebfb ( i , 2 ) <= y2 ) then if ( ebfb ( i , 1 ) > x1 . and . ebfb ( i , 1 ) <= x2 ) then ii = ii + 1 bunch ( 1 )% part ( ii , 1 : nd2 + 1 ) = ebfb ( j , 1 : nd2 + 1 ) end if end if end do i1 = i1 + nb_tot ( ic ) end do !================== 1:   counts local bunch particles of each bunch case ( 3 ) do ic = 1 , nsb do p = 0 , npe_xloc - 1 do ip = 0 , npe_zloc - 1 z1 = loc_zftgrid ( ip )% gmin z2 = loc_zftgrid ( ip )% gmax do ipp = 0 , npe_yloc - 1 y1 = loc_yftgrid ( ipp )% gmin y2 = loc_yftgrid ( ipp )% gmax loc_nbpart ( ipp , ip , p , ic ) = 0 do j = 1 , nb_tot ( ic ) i = i1 + j if ( ebfb ( i , 2 ) > y1 . and . ebfb ( i , 2 ) <= y2 ) then if ( ebfb ( i , 3 ) > z1 . and . ebfb ( i , 3 ) <= z2 ) then if ( ebfb ( i , 1 ) > x1 . and . ebfb ( i , 1 ) <= x2 ) then loc_nbpart ( ipp , ip , p , ic ) = loc_nbpart ( ipp , ip , p , ic ) + 1 end if end if end if end do end do end do end do i1 = i1 + nb_tot ( ic ) end do nb_max = maxval ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , & 1 : nsb )) nb_min = minval ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , & 1 : nsb )) !================== ! The local MPI task nps_loc ( 1 : nsb ) = loc_nbpart ( imody , imodz , imodx , 1 : nsb ) npmax = maxval ( nps_loc ( 1 : nsb )) !================== npmax = max ( npmax , 1 ) if (. not . allocated ( bunch ( 1 )% part )) then allocate ( bunch ( 1 )% part ( npmax , nd2 + 1 )) else deallocate ( bunch ( 1 )% part ) allocate ( bunch ( 1 )% part ( npmax , nd2 + 1 )) end if !================================= !                            2: selected particle coordinates are copied in !                            bunch%part array nb_loc = nps_loc ( 1 ) p = imodx ip = imodz z1 = loc_zftgrid ( ip )% gmin z2 = loc_zftgrid ( ip )% gmax ipp = imody y1 = loc_yftgrid ( ipp )% gmin y2 = loc_yftgrid ( ipp )% gmax !========================= ! Here 3D MPI decomp. allowed !=================================== i1 = 0 do ic = 1 , nsb ii = 0 do i = 1 , nb_tot ( ic ) j = i + i1 if ( ebfb ( i , 2 ) > y1 . and . ebfb ( i , 2 ) <= y2 ) then if ( ebfb ( i , 3 ) > z1 . and . ebfb ( i , 3 ) <= z2 ) then if ( ebfb ( i , 1 ) > x1 . and . ebfb ( i , 1 ) <= x2 ) then ii = ii + 1 bunch ( ic )% part ( ii , 1 : nd2 + 1 ) = ebfb ( j , 1 : nd2 + 1 ) end if end if end if end do i1 = i1 + nb_tot ( ic ) end do end select end subroutine !================================= subroutine mpi_beam_distribute ( ndm ) integer , intent ( in ) :: ndm integer :: i , ii , i1 , j integer :: ic , p , ip , ipp , nb_loc real ( dp ) :: y1 , y2 , z1 , z2 , x1 , x2 integer :: nps_loc ( nsb ), npmax , np_tot !========= count bunch particles on each (yz) MPI domain np_tot = sum ( nb_tot ( 1 : nsb )) ! ALL MPI tasks do x1 = loc_xgrid ( imodx )% gmin x2 = loc_xgrid ( imodx )% gmax i1 = 0 select case ( ndm ) !================== 1:   counts local bunch particles of each bunch case ( 2 ) ip = npe_zloc - 1 do ic = 1 , nsb do p = 0 , npe_xloc - 1 do ipp = 0 , npe_yloc - 1 y1 = loc_ygrid ( ipp )% gmin y2 = loc_ygrid ( ipp )% gmax loc_nbpart ( ipp , ip , p , ic ) = 0 do j = 1 , nb_tot ( ic ) i = i1 + j if ( ebfb ( i , 2 ) > y1 . and . ebfb ( i , 2 ) <= y2 ) then if ( ebfb ( i , 1 ) > x1 . and . ebfb ( i , 1 ) <= x2 ) then loc_nbpart ( ipp , ip , p , ic ) = loc_nbpart ( ipp , ip , p , ic ) + 1 end if end if end do end do end do i1 = i1 + nb_tot ( ic ) end do nb_max = maxval ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , & 1 : nsb )) nb_min = minval ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , & 1 : nsb )) do ic = 1 , nsb do p = 0 , npe_xloc - 1 do ipp = 0 , npe_yloc - 1 i = ipp + npe_yloc * ( ip + p * npe_zloc ) if ( loc_nbpart ( ipp , ip , p , ic ) == nb_max ) pe_nbmax = i if ( loc_nbpart ( ipp , ip , p , ic ) == nb_min ) pe_nbmin = i end do end do end do !================== ! The local particle number of each bunch nps_loc ( 1 : nsb ) = loc_nbpart ( imody , imodz , imodx , 1 : nsb ) npmax = maxval ( nps_loc ( 1 : nsb )) npmax = max ( npmax , 1 ) if (. not . allocated ( bunch ( 1 )% part )) then allocate ( bunch ( 1 )% part ( npmax , nd2 + 1 )) end if !================================= !              2: selected particle coordinates are copied in !                            bunch%part array nb_loc = nps_loc ( 1 ) p = imodx ip = imodz ipp = imody y1 = loc_ygrid ( ipp )% gmin y2 = loc_ygrid ( ipp )% gmax !========================= ! Here 2D MPI decomp. allowed !=================================== i1 = 0 do ic = 1 , nsb ii = 0 do i = 1 , nb_tot ( ic ) j = i + i1 if ( ebfb ( i , 2 ) > y1 . and . ebfb ( i , 2 ) <= y2 ) then if ( ebfb ( i , 1 ) > x1 . and . ebfb ( i , 1 ) <= x2 ) then ii = ii + 1 bunch ( 1 )% part ( ii , 1 : nd2 + 1 ) = ebfb ( j , 1 : nd2 + 1 ) end if end if end do i1 = i1 + nb_tot ( ic ) end do !================== 1:   counts local bunch particles of each bunch case ( 3 ) do ic = 1 , nsb do p = 0 , npe_xloc - 1 do ip = 0 , npe_zloc - 1 z1 = loc_zgrid ( ip )% gmin z2 = loc_zgrid ( ip )% gmax do ipp = 0 , npe_yloc - 1 y1 = loc_ygrid ( ipp )% gmin y2 = loc_ygrid ( ipp )% gmax loc_nbpart ( ipp , ip , p , ic ) = 0 do j = 1 , nb_tot ( ic ) i = i1 + j if ( ebfb ( i , 2 ) > y1 . and . ebfb ( i , 2 ) <= y2 ) then if ( ebfb ( i , 3 ) > z1 . and . ebfb ( i , 3 ) <= z2 ) then if ( ebfb ( i , 1 ) > x1 . and . ebfb ( i , 1 ) <= x2 ) then loc_nbpart ( ipp , ip , p , ic ) = loc_nbpart ( ipp , ip , p , ic ) + 1 end if end if end if end do end do end do end do i1 = i1 + nb_tot ( ic ) end do nb_max = maxval ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , & 1 : nsb )) nb_min = minval ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , & 1 : nsb )) do ic = 1 , nsb do p = 0 , npe_xloc - 1 do ip = 0 , npe_zloc - 1 do ipp = 0 , npe_yloc - 1 i = ipp + npe_yloc * ( ip + p * npe_zloc ) if ( loc_nbpart ( ipp , ip , p , ic ) == nb_max ) pe_nbmax = i if ( loc_nbpart ( ipp , ip , p , ic ) == nb_min ) pe_nbmin = i end do end do end do end do !================== ! The local MPI task nps_loc ( 1 : nsb ) = loc_nbpart ( imody , imodz , imodx , 1 : nsb ) npmax = maxval ( nps_loc ( 1 : nsb )) !================== npmax = max ( npmax , 1 ) if (. not . allocated ( bunch ( 1 )% part )) then allocate ( bunch ( 1 )% part ( npmax , nd2 + 1 )) end if !================================= !                            2: selected particle coordinates are copied in !                            bunch%part array nb_loc = nps_loc ( 1 ) p = imodx ip = imodz z1 = loc_zgrid ( ip )% gmin z2 = loc_zgrid ( ip )% gmax ipp = imody y1 = loc_ygrid ( ipp )% gmin y2 = loc_ygrid ( ipp )% gmax !========================= ! Here 3D MPI decomp. allowed !=================================== i1 = 0 do ic = 1 , nsb ii = 0 do i = 1 , nb_tot ( ic ) j = i + i1 if ( ebfb ( i , 2 ) > y1 . and . ebfb ( i , 2 ) <= y2 ) then if ( ebfb ( i , 3 ) > z1 . and . ebfb ( i , 3 ) <= z2 ) then if ( ebfb ( i , 1 ) > x1 . and . ebfb ( i , 1 ) <= x2 ) then ii = ii + 1 bunch ( ic )% part ( ii , 1 : nd2 + 1 ) = ebfb ( j , 1 : nd2 + 1 ) end if end if end if end do i1 = i1 + nb_tot ( ic ) end do end select !================================= end subroutine !======================== subroutine beam_model_pot ( poten , sx , sy , sz , b_am , i1 , i2 , j1 , j2 , k1 , & k2 ) real ( dp ), intent ( inout ) :: poten (:, :, :, :) real ( dp ), intent ( in ) :: sx , sy , sz , b_am integer , intent ( in ) :: i1 , i2 , j1 , j2 , k1 , k2 integer :: i , j , k , jj , kk real ( dp ) :: r2 , brad2 , sx2_inv , fact , r2max , pot0 real ( dp ) :: xx , yy , zz !----------------------- brad2 = sy * sy + sz * sz r2max = ymax * ymax + zmax * zmax pot0 = log ( r2max / brad2 ) sx2_inv = 1. / ( 2. * sx * sx ) do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) r2 = zz * zz + yy * yy if ( r2 > brad2 ) then fact = log ( r2 / brad2 ) - pot0 else fact = ( r2 / brad2 - 1. ) - pot0 end if do i = i1 , i2 xx = ( x ( i1 ) - xc_bunch ( 1 )) poten ( i , j , k , 1 ) = 0.25 * brad2 * b_am * fact * exp ( - xx * xx * sx2_inv ) end do end do end do end subroutine !========================= subroutine beam_inject integer :: id_ch , np , nb , ic , ft_mod , ft_sym integer :: nps_loc ( nsb ), nb_loc ( 1 ), i1 integer :: y1 , y2 , z1 , z2 integer :: n , n1_alc , n2_alc , n3_alc real ( dp ) :: gam2 gam2 = gam0 * gam0 id_ch = nd2 + 1 !======================= n1_alc = size ( ebf , 1 ) n2_alc = size ( ebf , 2 ) n3_alc = size ( ebf , 3 ) if (. not . allocated ( ebf_bunch )) then allocate ( ebf_bunch ( n1_alc , n2_alc , n3_alc , nbfield )) ebf_bunch (:, :, :, :) = 0.0 end if !============================= ! The fields of a moving e-bunch in vacuum ! E_x=-(DPhi/Dx)/gamma&#94;2  , E_y=-DPhi/Dy   E_z=-DPhi/Dz ! Poisson eq.  D_xE_x+D_yE_y+D_zE_z=omp&#94;2\\rho (x-V_b*t_0,y,z) ! B_x=0   B_y=-V_b*E_z    B_z= V_b*E_y !========================================= call init_random_seed ( mype ) call beam_data ( ndim ) ! Generates phase space coordinates for bparticles on ebfb(np_tot,7) ! bpart() provisional storage in common to all MPI tasks !======================= call mpi_beam_distribute ( ndim ) !local bpart data are stored in bunch(1)%part struct for each MPI task nps_loc ( 1 : nsb ) = loc_nbpart ( imody , imodz , imodx , 1 : nsb ) nb = sum ( nps_loc ( 1 : nsb )) !the total bunch particle number !on each mpi_task !===================================== if ( allocated ( spec ( 1 )% part )) then np = loc_npart ( imody , imodz , imodx , 1 ) if ( nb > 0 ) then do n = 1 , np ebfp ( n , 1 : id_ch ) = spec ( 1 )% part ( n , 1 : id_ch ) end do deallocate ( spec ( 1 )% part ) allocate ( spec ( 1 )% part ( np + nb , id_ch )) do n = 1 , np spec ( 1 )% part ( n , 1 : id_ch ) = ebfp ( n , 1 : id_ch ) end do deallocate ( ebfp ) do n = 1 , nb i1 = n + np spec ( 1 )% part ( i1 , 1 : id_ch ) = bunch ( 1 )% part ( n , 1 : id_ch ) end do allocate ( ebfp ( np + nb , id_ch )) loc_npart ( imody , imodz , imodx , 1 ) = loc_npart ( imody , imodz , imodx , 1 ) + nb endif else nb_loc ( 1 ) = nb call p_alloc ( nb , nd2 + 1 , nb_loc , 1 , lpf_ord , 1 , 1 , mem_psize ) do n = 1 , nb spec ( 1 )% part ( n , 1 : id_ch ) = bunch ( 1 )% part ( n , 1 : id_ch ) end do loc_npart ( imody , imodz , imodx , 1 ) = nb_loc ( 1 ) end if ! Solves for beam potential UNIFORM GRIDS NEEDED !================================================== jc (:, :, :, 1 ) = 0.0 ft_mod = 2 !A sine transform along each coordinate ft_sym = 1 if ( stretch ) then if ( ndim > 2 ) then allocate ( pot ( n1ft + 5 , n2ft_loc + 5 , n3ft_loc + 5 , 1 )) else allocate ( pot ( n1ft + 5 , n2ft_loc + 5 , n3ft_loc , 1 )) endif pot (:, :, :, 1 ) = 0.0 call mpi_beam_ftgrid_distribute ( ndim ) !local bpart data are stored in bunch(1)%part in ftgrid nps_loc ( 1 : nsb ) = loc_nbpart ( imody , imodz , imodx , 1 : nsb ) nb = sum ( nps_loc ( 1 : nsb )) !the total bunch particle number if ( allocated ( ebfb )) deallocate ( ebfb ) allocate ( ebfb ( nb , nd2 + 1 )) do ic = 1 , nsb np = loc_nbpart ( imody , imodz , imodx , ic ) call set_charge_on_ftgrid ( bunch ( 1 ), ebfb , pot , np , 1 ) end do if ( prl ) call fill_ftcurr_yzbdsdata ( pot , 1 ) !============================ !In pot(1) beam density !===================================================== y1 = loc_yftgrid ( imody )% p_ind ( 1 ) y2 = loc_yftgrid ( imody )% p_ind ( 2 ) z1 = loc_zftgrid ( imodz )% p_ind ( 1 ) z2 = loc_zftgrid ( imodz )% p_ind ( 2 ) !============ ft uniform grid if ( ndim == 2 ) call fft_2d_psolv ( pot , jc , ompe , n1ft , n1ft_loc , n2ft , n2ft_loc , n3ft , & n3ft_loc , ix1 , ix2 , y1 , y2 , z1 , z2 , ft_mod , ft_sym , 1 ) if ( ndim == 3 ) call fft_3d_psolv ( pot , jc , gam2 , ompe , n1ft , n1ft_loc , n2ft , n2ft_loc , n3ft , & n3ft_loc , ix1 , ix2 , y1 , y2 , z1 , z2 , ft_mod , ft_sym , 1 ) !Solves Laplacian[poten]=ompe*rho in Fourier space using sin() transform !Exit beam potential in jc(1) !uniform to stretched grid interpolation inside !====================================== else do ic = 1 , nsb np = loc_nbpart ( imody , imodz , imodx , ic ) call set_grid_charge ( bunch ( 1 ), ebfp , jc , np , 1 ) end do if ( prl ) call fill_curr_yzxbdsdata ( jc , 1 ) !============================ !In jc(1) beam density !===================================================== y1 = jy1 y2 = jy2 z1 = kz1 z2 = kz2 if ( ndim == 2 ) call fft_2d_psolv ( jc , jc , ompe , nx , nx_loc , ny , ny_loc , nz , & nz_loc , ix1 , ix2 , y1 , y2 , z1 , z2 , ft_mod , ft_sym , 0 ) if ( ndim == 3 ) call fft_3d_psolv ( jc , jc , gam2 , ompe , nx , nx_loc , ny , ny_loc , nz , & nz_loc , ix1 , ix2 , y1 , y2 , z1 , z2 , ft_mod , ft_sym , 0 ) !Solves Laplacian[poten]=ompe*rho in Fourier space using sin() transform !Exit beam potential in jc(1) endif jc (:, :, :, 2 ) = bet0 * jc (:, :, :, 1 ) !========================== if ( allocated ( ebfb )) deallocate ( ebfb ) if ( allocated ( bunch ( 1 )% part )) deallocate ( bunch ( 1 )% part ) !=========================== call fill_ebfield_yzxbdsdata ( jc , 1 , 2 , 1 , 1 ) call initial_beam_fields ( jc , ebf_bunch , gam2 , bet0 ) ! generates (Ex,Ey,Ez,By,Bz) bunch fields  Bx=ebf_bunc(4)=0 ebf_bunch (:, :, :, 4 ) = 0.0 !========================================= Collect data ebf (:, :, :, 1 : nfield ) = ebf (:, :, :, 1 : nfield ) + & ebf_bunch (:, :, :, 1 : nfield ) !======================================== lp_end ( 1 ) = xc_bunch ( 1 ) + 2. * sxb ( 1 ) !===================================== if ( pe0 ) then !================== open ( 16 , file = 'Initial_bunch_info.dat' ) write ( 16 , '(a27,e11.4)' ) 'Initial target x-position =' , targ_in write ( 16 , '(a20,e11.4)' ) 'Plasma wave-length =' , lambda_p write ( 16 , * ) '-------------------------------------' write ( 16 , '(a17,i4)' ) 'Number of bunches' , nsb do i1 = 1 , nsb write ( 16 , * ) 'bunch number =' , i1 write ( 16 , '(a25,i6)' ) 'Bunch particles per cell ' , nb_per_cell ( i1 ) write ( 16 , '(a23,i8)' ) 'Bunch particle number  ' , nb_tot ( i1 ) write ( 16 , '(a15,2e14.6)' ) 'gamma and beta ' , gam ( i1 ), bet0 write ( 16 , '(a15,2e11.4)' ) 'Bunch  sizes   ' , sxb ( i1 ), syb ( i1 ) write ( 16 , '(a23,2e11.4)' ) 'Transverse emittances= ' , epsy ( i1 ), & epsz ( i1 ) write ( 16 , '(a21,e11.4)' ) 'Initial xc-position= ' , xc_bunch ( i1 ) write ( 16 , '(a20,e11.4)' ) 'B charge    [pC] =  ' , bunch_charge ( i1 ) write ( 16 , '(a21,e11.4)' ) 'B_density/P_density  ' , rhob ( i1 ) end do close ( 16 ) end if end subroutine !======================== end module","tags":"","loc":"sourcefile/init_beam_part_distrib.f90.html"},{"title":"pic_out_util.f90 – ALaDyn","text":"This file depends on sourcefile~~pic_out_util.f90~~EfferentGraph sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~pic_out_util.f90->sourcefile~phys_param.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~psolve.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~psolve.f90->sourcefile~common_param.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~psolve.f90->sourcefile~fstruct_data.f90 sourcefile~psolve.f90->sourcefile~grid_param.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~grid_part_util.f90->sourcefile~pstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~grid_part_util.f90->sourcefile~fstruct_data.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~modern_fft_lib.f90 modern_fft_lib.F90 sourcefile~prl_fft.f90->sourcefile~modern_fft_lib.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~modern_fft_lib.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pic_out_util.f90~~AfferentGraph sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules pic_out_util Source Code pic_out_util.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module pic_out_util use grid_part_util use mpi_curr_interface use mpi_field_interface use psolve use phys_param , only : electron_mass implicit none !=====Contains functions to prepare selected output variables======= contains !=============== Tracking particles============ subroutine initial_tparticles_select ( tx1 , ty1 ) real ( dp ), intent ( in ) :: tx1 , ty1 integer :: np , p , ik , ndv , ik_max integer ( hp_int ) :: plab , last_ind integer , parameter :: tp_numb = 10 real ( dp ) :: yy ( tp_numb ), ym , ymx !======================== ! Define track_tot_nstep p = 0 if ( dt_loc > 0.0 ) p = nint (( t_out - t_in ) / dt_loc ) track_tot_nstep = nint ( real ( p , dp ) / real ( tkjump , dp )) ndv = nd2 + 1 ! Select particles on each mpi_task ! xp defined by tx1 ! yp [-4,-3,-2.-1.,0,1,2,3,4], 9 test particles allocated ! yy ( 1 ) = ty1 do p = 2 , tp_numb yy ( p ) = yy ( p - 1 ) + 1. end do ym = loc_ygrid ( imody )% gmin ymx = loc_ygrid ( imody )% gmax np = loc_npart ( imody , imodz , imodx , 1 ) ik = 0 if ( allocated ( spec ( 1 )% part )) then deallocate ( spec ( 1 )% part ) deallocate ( ebfp ) loc_npart ( imody , imodz , imodx , 1 ) = 0 end if select case ( ndim ) case ( 2 ) do p = 1 , tp_numb if ( ym < yy ( p ) . and . ymx >= yy ( p )) then ik = ik + 1 end if end do if ( ik > 0 ) then loc_npart ( imody , imodz , imodx , 1 ) = ik allocate ( spec ( 1 )% part ( ik , 5 )) np = 0 do p = 1 , tp_numb if ( ym < yy ( p ) . and . ymx >= yy ( p )) then np = np + 1 spec ( 1 )% part ( np , 1 ) = tx1 spec ( 1 )% part ( np , 2 ) = yy ( p ) spec ( 1 )% part ( np , 3 : 4 ) = t0_pl ( 1 ) part_ind = int ( np , hp_int ) wgh = real ( 0.0 , sp ) charge = int ( - 1. , hp_int ) spec ( 1 )% part ( np , 5 ) = wgh_cmp end if end do end if case ( 3 ) return end select np = loc_npart ( imody , imodz , imodx , 1 ) loc_tpart ( mype + 1 ) = np call intvec_distribute ( np , loc_tpart , npe ) track_tot_part = sum ( loc_tpart ( 1 : npe )) ik_max = maxval ( loc_tpart ( 1 : npe )) last_ind = 0 if ( mype == 1 ) last_ind = loc_tpart ( 1 ) if ( mype > 1 ) last_ind = sum ( loc_tpart ( 1 : mype )) !if(loc_tpart(mype+1)>0)write(6,*)'last particle index',mype,last_ind if ( np > 0 ) then do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , ndv ) if ( part_ind > 0 ) part_ind = part_ind + last_ind spec ( 1 )% part ( p , ndv ) = wgh_cmp end do end if allocate ( track_aux ( 2 * ndv * ik_max )) if (. not . allocated ( ebfp )) allocate ( ebfp ( ik_max , ndv )) if ( pe0 ) then allocate ( pdata_tracking ( ndv , track_tot_part , track_tot_nstep )) write ( 6 , * ) '==== Initial track-Particle data===========' write ( 6 , '(a19,i6)' ) '  tot_track_steps  ' , track_tot_nstep write ( 6 , '(a19,2i6)' ) '  tot_track_parts  ' , track_tot_part , & tp_numb write ( 6 , '(a18,i8)' ) '  short_int size  ' , huge ( plab ) write ( 6 , '(a20,e11.4)' ) '  track memory(MB) ' , & 1.e-06 * real ( 4 * ndv * track_tot_nstep * track_tot_part , dp ) end if end subroutine !============================================ subroutine t_particles_collect ( time_ind ) integer , intent ( in ) :: time_ind integer :: np , ik , ik_max , ip , p , ndv , ndvp , ipe , kk , ik1 , ik2 , nst logical :: sr real :: xm , ym , zm if ( time_ind > track_tot_nstep ) return xm = loc_xgrid ( imodx )% gmin ym = loc_ygrid ( imody )% gmin zm = loc_zgrid ( imodz )% gmin np = loc_npart ( imody , imodz , imodx , 1 ) nst = 0 ndv = nd2 + 1 ndvp = ndv if ( stretch ) nst = str_indx ( imody , imodz ) !=================== np = loc_npart ( imody , imodz , imodx , 1 ) ik = 0 !=========== each pe counts track particle number do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , ndv ) if ( part_ind > 0 ) ik = ik + 1 end do loc_tpart ( mype + 1 ) = ik call intvec_distribute ( ik , loc_tpart , npe ) ik_max = maxval ( loc_tpart ( 1 : npe )) if ( ndvp * ik_max > size ( track_aux )) then deallocate ( track_aux ) allocate ( track_aux ( ndvp * ik_max )) end if !========= each pe stores tpart data in track_aux(ndv,loc_tpart) kk = 0 do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , ndv ) if ( part_ind > 0 ) then do ip = 1 , ndv kk = kk + 1 track_aux ( kk ) = spec ( 1 )% part ( p , ip ) end do end if end do !================= !  all data are gathered onto pe0 if ( pe0 ) then sr = . false . ik1 = 0 do ipe = 1 , npe - 1 ik = loc_tpart ( ipe + 1 ) if ( ik > 0 ) then call exchange_1d_grdata ( sr , track_aux , ik * ndvp , ipe , ipe + 10 ) !pe0 receives from ipe ik sp_aux data and collects on track array kk = 0 do p = 1 , ik ik2 = ik1 + p do ip = 1 , ndv - 1 kk = kk + 1 pdata_tracking ( ip , ik2 , time_ind ) = track_aux ( kk ) !pdata_tracking(ip,ik2,time_ind)=track_aux(kk) end do kk = kk + 1 wgh_cmp = track_aux ( kk ) pdata_tracking ( ndv , ik2 , time_ind ) = real ( part_ind , dp ) end do ik1 = ik2 end if end do loc_tpart ( 1 ) = ik2 else ik = loc_tpart ( mype + 1 ) if ( ik > 0 ) then sr = . true . call exchange_1d_grdata ( sr , track_aux , ik * ndvp , 0 , mype + 10 ) !sends ik data to pe0 end if end if end subroutine !================================================= subroutine fill_density_data ( den , ic ) real ( dp ), intent ( inout ) :: den (:, :, :, :) integer , intent ( in ) :: ic integer :: i , j , k , iy , iz , n_loc n_loc = loc_ygrid ( imody )% ng do k = kz1 , kz2 do j = jy1 , jy2 - 1 iy = j + imody * n_loc if ( y ( iy ) > ymin_t . and . y ( iy ) < ymax_t ) then do i = ix1 , ix2 - 1 if ( x ( i ) >= targ_in ) den ( i , j , k , ic ) = den ( i , j , k , ic ) + 1. end do end if end do end do if ( ndim < 3 ) return n_loc = loc_zgrid ( imodz )% ng do k = kz1 , kz2 - 1 iz = k + imodz * n_loc if ( z ( iz ) > zmin_t . and . z ( iz ) < zmax_t ) then do j = jy1 , jy2 - 1 do i = ix1 , ix2 - 1 den ( i , j , k , ic ) = den ( i , j , k , ic ) + 1. end do end do end if end do end subroutine !============================================= subroutine collect_bunch_and_plasma_density ( this_bunch , isp ) !========== bunch density and particles of species isp added on jc(ic) !========================================= integer , intent ( in ) :: this_bunch , isp real ( dp ) :: dery , derz integer :: np , nb , ik , i , j , k , jj , kk do i = 1 , 2 jc (:, :, :, i ) = 0.0 end do np = loc_npart ( imody , imodz , imodx , isp ) if ( this_bunch == 0 ) then do ik = 1 , nsb nb = loc_nbpart ( imody , imodz , imodx , ik ) if ( nb > 0 ) then call set_grid_charge ( bunch ( ik ), ebfb , jc , nb , 1 ) end if end do else ik = this_bunch !only the selected bunch density nb = loc_nbpart ( imody , imodz , imodx , ik ) if ( nb > 0 ) then call set_grid_charge ( bunch ( ik ), ebfb , jc , nb , 1 ) end if end if !=========== bunch data on jc(1) !==================== data of isp species on jc(2) if ( np > 0 ) then call set_grid_charge ( spec ( isp ), ebfp , jc , np , 2 ) end if if ( prl ) then do i = 1 , 2 call fill_curr_yzxbdsdata ( jc , i ) end do end if jc ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) = jc ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) + & jc ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 2 ) !============ on jc(1) bunch+ particles if ( stretch ) then kk = 1 do k = kz1 , kz2 derz = loc_zg ( kk , 3 , imodz ) jj = 1 do j = jy1 , jy2 dery = loc_yg ( jj , 3 , imody ) * derz do i = ix1 , ix2 jc ( i , j , k , 1 ) = dery * jc ( i , j , k , 2 ) jc ( i , j , k , 2 ) = dery * jc ( i , j , k , 2 ) end do jj = jj + 1 end do kk = kk + 1 end do end if !============================= end subroutine subroutine prl_bden_energy_interp ( ic ) integer , intent ( in ) :: ic real ( dp ) :: dery , derz integer :: np , ik , i , j , k , jj , kk !curr_clean do i = 1 , 2 jc (:, :, :, i ) = 0.0 end do if ( ic == 0 ) then !collects all bunch density do ik = 1 , nsb np = loc_nbpart ( imody , imodz , imodx , ik ) if ( np > 0 ) then call set_grid_den_energy ( bunch ( ik ), ebfb , jc , np ) end if end do else ik = ic !only the ic-bunch density np = loc_nbpart ( imody , imodz , imodx , ik ) if ( np > 0 ) then call set_grid_den_energy ( bunch ( ik ), ebfb , jc , np ) end if end if !========= den on [i1-1:i2+2,j1-1:nyp+2,k1-1:nzp+2] if ( prl ) then call fill_curr_yzxbdsdata ( jc , 2 ) end if !do ik=1,2 ! call den_zyxbd(jc,i1,i2,j1,nyf,k1,nzf,ik) !end do jc (:, :, :, 1 ) = - jc (:, :, :, 1 ) !positive for electrons if ( stretch ) then kk = 1 do k = kz1 , kz2 derz = loc_zg ( kk , 3 , imodz ) jj = 1 do j = jy1 , jy2 dery = loc_yg ( jj , 3 , imody ) * derz do i = ix1 , ix2 jc ( i , j , k , 1 ) = dery * jc ( i , j , k , 1 ) jc ( i , j , k , 2 ) = dery * jc ( i , j , k , 2 ) end do jj = jj + 1 end do kk = kk + 1 end do end if !============================= end subroutine !============================ subroutine prl_den_energy_interp ( ic , cmp_out ) integer , intent ( in ) :: ic , cmp_out real ( dp ) :: dery , derz , ar , ai integer :: np , i , j , k , jj , kk !============================= ! nden=1 only charge density ! nden =2 charge and energy <n(gamma-1)> density !============================= do i = 1 , cmp_out jc (:, :, :, i ) = 0.0 end do !=========================== np = loc_npart ( imody , imodz , imodx , ic ) if ( part ) then select case ( cmp_out ) case ( 1 ) call set_grid_charge ( spec ( ic ), ebfp , jc , np , 1 ) !nden=1 exit density for each ic species case ( 2 ) !nden=2 exit density and energy density for each species if ( envelope ) then if ( ic == 1 ) then do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 ar = . 5 * ( env ( i , j , k , 1 ) + env ( i , j , k , 3 )) ai = . 5 * ( env ( i , j , k , 2 ) + env ( i , j , k , 4 )) jc ( i , j , k , 3 ) = 0.5 * ( ar * ar + ai * ai ) end do end do end do if ( prl ) call fill_ebfield_yzxbdsdata ( jc , 3 , 3 , 2 , 2 ) call set_grid_env_den_energy ( spec ( ic ), ebfp , jc , np , 3 ) else call set_grid_den_energy ( spec ( ic ), ebfp , jc , np ) !ic >1 in envelope scheme endif else call set_grid_den_energy ( spec ( ic ), ebfp , jc , np ) ! in jc(1) is plasma norm density in jc(2) <(gam-1)density> using kinetic ! gamma  for each species end if end select if ( prl ) call fill_curr_yzxbdsdata ( jc , cmp_out ) do kk = 1 , cmp_out call den_zyxbd ( jc , kk ) end do if ( ic == 1 ) jc (:, :, :, 1 ) = - jc (:, :, :, 1 ) if ( cmp_out == 2 ) jc (:, :, :, 2 ) = mass ( ic ) * electron_mass * & jc (:, :, :, 2 ) !=========== energy density in Mev*n/n_0 if ( stretch ) then select case ( ndim ) case ( 2 ) k = 1 do j = jy1 , jy2 jj = j - 2 dery = loc_yg ( jj , 3 , imody ) do i = ix1 , ix2 jc ( i , j , k , 1 : cmp_out ) = dery * jc ( i , j , k , 1 : cmp_out ) end do end do case ( 3 ) do k = kz1 , kz2 kk = k - 2 derz = loc_zg ( kk , 3 , imodz ) do j = jy1 , jy2 jj = j - 2 dery = loc_yg ( jj , 3 , imody ) * derz do i = ix1 , ix2 jc ( i , j , k , 1 : cmp_out ) = dery * jc ( i , j , k , 1 : cmp_out ) end do end do end do end select end if endif !====================== end subroutine !===================== subroutine set_wake_potential integer :: np , ic , ft_mod , ft_sym integer :: i1 , i2 , j1 , j2 , k1 , k2 jc (:, :, :, 1 : 2 ) = 0.0 !curr_clean do ic = 1 , nsp np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) call set_grid_charge_and_jx ( spec ( ic ), ebfp , jc , np ) end do !========= jc(1)=charge density jc(2)= Jx at the same current t&#94;{n} time if ( prl ) then call fill_curr_yzxbdsdata ( jc , 2 ) end if if ( nsp == 1 ) then call fill_density_data ( jc , 1 ) else if ( dmodel_id == 3 ) call fill_density_data ( jc , 1 ) end if jc ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) = jc ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 1 ) - & jc ( ix1 : ix2 , jy1 : jy2 , kz1 : kz2 , 2 ) !============== jc(1)=rho-Jx======================= ft_mod = 2 !for cosine transform ft_sym = 2 call fft_2d_psolv ( jc , jc , ompe , nx , nx_loc , ny , ny_loc , nz , nz_loc , & i1 , i2 , j1 , j2 , k1 , k2 , ft_mod , ft_sym , 0 ) !================================== end subroutine !============================ end module","tags":"","loc":"sourcefile/pic_out_util.f90.html"},{"title":"init_laser_field.f90 – ALaDyn","text":"This file depends on sourcefile~~init_laser_field.f90~~EfferentGraph sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~pstruct_data.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~init_laser_field.f90~~AfferentGraph sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules init_laser_field Source Code init_laser_field.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module init_laser_field use pstruct_data use fstruct_data use init_grid_field use grid_fields , only : env_bds implicit none contains !========================================= subroutine lp_pulse ( lp_mod , part_in ) integer , intent ( in ) :: lp_mod real ( dp ), intent ( out ) :: part_in integer :: ic , lp_ind , i1 , i2 real ( dp ) :: angle , shx_lp , sigm , eps , xm , tt , tau , tau1 !=========================== ! field grid index defined on set_pgrid i1 = loc_xgrid ( imodx )% p_ind ( 1 ) i2 = loc_xgrid ( imodx )% p_ind ( 2 ) xm = loc_xgrid ( imodx )% gmin ! => field index i1 tt = 0.0 if ( g_prof ) then tau = w0_x * sqrt ( 2. ) tau1 = w1_x * sqrt ( 2. ) else tau = 0.5 * w0_x !cos&#94;2() profile_ tau1 = 0.5 * w1_x !cos&#94;2() profile_ end if lp_amp = oml * a0 lp1_amp = om1 * a1 !===================== lp_in ( 1 ) = xc_lp - tau lp_end ( 1 ) = xc_lp + tau eps = 1. / ( oml * w0_y ) sigm = lam0 / w0_x angle = incid_angle xf = xc_lp + t0_lp !======================= lp_ind = lp_mod shx_lp = 0.0 xc_loc ( 1 ) = xc_lp xf_loc ( 1 ) = xf if ( plane_wave ) lp_ind = 0 if ( angle > 0.0 ) then shx_lp = lpx ( 7 ) call init_lp_fields ( ebf , lp_amp , tt , t0_lp , w0_x , w0_y , xf , oml , & angle , shx_lp , lp_ind , i1 , i2 , y0_cent ( 1 ), z0_cent ( 1 )) else !normal incidence call init_lp_inc0_fields ( ebf , lp_amp , tt , t0_lp , w0_x , w0_y , xf , & oml , lp_ind , i1 , i2 , y0_cent ( 1 ), z0_cent ( 1 )) end if if ( nb_laser > 1 ) then do ic = 2 , nb_laser lp_in ( ic ) = lp_in ( ic - 1 ) - lp_delay ( ic - 1 ) lp_end ( ic ) = lp_end ( ic - 1 ) - lp_delay ( ic - 1 ) xc_loc ( ic ) = xc_loc ( ic - 1 ) - lp_delay ( ic - 1 ) xf_loc ( ic ) = xc_loc ( ic ) + t0_lp call init_lp_inc0_fields ( ebf , lp_amp , tt , t0_lp , & w0_x , w0_y , xf_loc ( ic ), oml , lp_ind , i1 , i2 , y0_cent ( ic ), & z0_cent ( ic )) end do end if !=================TWO-COLOR if ( Two_color ) then xc1_lp = xc_loc ( nb_laser ) - lp_offset xf1 = xc1_lp + t1_lp lp_ionz_in = xc1_lp - tau1 lp_ionz_end = xc1_lp + tau1 call init_lp_inc0_fields ( ebf , lp1_amp , tt , t1_lp , w1_x , w1_y , xf1 , & om1 , lp_ind , i1 , i2 , y1_cent , z1_cent ) if ( pe0 ) write ( 6 , '(a30,e11.4)' ) 'two-color activated at xc1_lp=' , & xc1_lp end if !================================== part_in = lp_end ( 1 ) + lpx ( 7 ) end subroutine !=========================== subroutine cp_pulse ( cp_mod , part_in ) real ( dp ), intent ( out ) :: part_in integer , intent ( in ) :: cp_mod integer :: i1 , i2 , cp_ind real ( dp ) :: angle , shx_cp , eps , sigm , xm , tau , tt lp_amp = oml * a0 / sqrt ( 2. ) !=========================== i1 = loc_xgrid ( imodx )% p_ind ( 1 ) i2 = loc_xgrid ( imodx )% p_ind ( 2 ) xm = loc_xgrid ( imodx )% gmin ! => field index i1 tt = 0.0 tau = 0.5 * w0_x lp_in ( 1 ) = xc_lp - tau !Pulse centroid xc_lp=xf-ts at time t=0 lp_in=xc-tau lp_end ( 1 ) = lp_in ( 1 ) + w0_x eps = 1. / ( oml * w0_y ) sigm = lam0 / w0_x angle = incid_angle xf = xc_lp + t0_lp shx_cp = 0.0 if ( angle > 0.0 ) shx_cp = lpx ( 7 ) if ( lp_amp > 0.0 ) then cp_ind = cp_mod if ( plane_wave ) cp_ind = 0 !======================= call init_cp_fields ( ebf , lp_amp , tt , t0_lp , w0_x , w0_y , xf , angle , & shx_cp , cp_ind , i1 , i2 ) !=================def part distr points lp_end = xm end if !====================== part_in = lp_end ( 1 ) + lpx ( 7 ) end subroutine !====================== subroutine set_envelope ( part_in ) real ( dp ), intent ( out ) :: part_in integer :: ic , pw_ind , i1 , i2 , j1 , k1 real ( dp ) :: eps , sigm , xm , tt , tau , tau1 , loc_delay ( 3 ) integer :: str , stl lp_amp = a0 lp1_amp = a1 !=========================== ! field grid index defined on set_pgrid j1 = jy1 k1 = kz1 i1 = ix1 i2 = nxp xm = loc_xgrid ( imodx )% gmin !========================= tt = 0.0 pw_ind = 1 if ( plane_wave ) pw_ind = 0 if ( g_prof ) then tau = w0_x * sqrt ( 2. ) tau1 = w1_x * sqrt ( 2. ) else tau = 0.5 * w0_x !cos&#94;2() profile_ tau1 = 0.5 * w1_x !cos&#94;2() profile_ end if lp_in ( 1 ) = xc_lp - tau lp_end ( 1 ) = xc_lp + tau eps = 1. / ( oml * w0_y ) sigm = lam0 / w0_x xf = xc_lp + t0_lp !======================= xc_loc ( 1 ) = xc_lp xf_loc ( 1 ) = xf env (:, :, :, :) = 0.0 if ( g_prof ) then call init_gprof_envelope_field ( env , a0 , tt , t0_lp , w0_x , w0_y , & xf , oml , pw_ind , i1 , i2 , y0_cent ( 1 ), z0_cent ( 1 )) else call init_envelope_field ( env , a0 , tt , t0_lp , w0_x , w0_y , xf , & oml , pw_ind , i1 , i2 , y0_cent ( 1 ), z0_cent ( 1 )) !call init_env_filtering(env,i1,i2,j1,nyp,k1,nzp) end if if ( nb_laser > 1 ) then do ic = 2 , nb_laser lp_in ( ic ) = lp_in ( ic - 1 ) - lp_delay ( ic - 1 ) lp_end ( ic ) = lp_end ( ic - 1 ) - lp_delay ( ic - 1 ) xc_loc ( ic ) = xc_loc ( ic - 1 ) - lp_delay ( ic - 1 ) xf_loc ( ic ) = xc_loc ( ic ) + t0_lp if ( lp_end ( ic ) > xm ) then if ( g_prof ) then call init_gprof_envelope_field ( env , a0 , tt , t0_lp , w0_x , & w0_y , xf_loc ( ic ), oml , pw_ind , i1 , i2 , y0_cent ( ic ), & z0_cent ( ic )) else call init_envelope_field ( env , a0 , tt , t0_lp , w0_x , w0_y , & xf_loc ( ic ), oml , pw_ind , i1 , i2 , y0_cent ( ic ), z0_cent ( ic )) end if end if end do end if if ( lpf_ord == 4 ) then !set initial first derivative env ( i1 : i2 , j1 : nyp , k1 : nzp , 3 : 4 ) = ( env ( i1 : i2 , j1 : nyp , k1 : nzp , 1 : 2 ) - env ( & i1 : i2 , j1 : nyp , k1 : nzp , 3 : 4 )) / dt end if !=================TWO-COLOR if ( Two_color ) then env1 (:, :, :, :) = 0.0 xc1_lp = xc_loc ( nb_laser ) - lp_offset xf1 = xc1_lp + t1_lp lp_ionz_in = xc1_lp - tau1 lp_ionz_end = xc1_lp + tau1 if ( lp_ionz_end > xm ) then if ( g_prof ) then call init_gprof_envelope_field ( env1 , a1 , tt , t1_lp , w1_x , & w1_y , xf1 , om1 , pw_ind , i1 , i2 , y1_cent , z1_cent ) else call init_envelope_field ( env1 , a1 , tt , t1_lp , w1_x , w1_y , xf1 , & om1 , pw_ind , i1 , i2 , y1_cent , z1_cent ) end if end if end if !======================= ebf = 0.0 !===================== if ( pe0 ) then open ( 26 , file = 'Initial_env_info.dat' ) write ( 26 , * ) 'number ' , nb_laser , 'LP envelope injected ' write ( 26 , * ) ' First pulse parameters' write ( 26 , '(a21,e11.4)' ) ' Focal x-position xf=' , xf write ( 26 , '(a21,e11.4)' ) ' Centr x-position xc=' , xc_lp write ( 26 , '(a20,e11.4)' ) ' Size (microns) lx=' , w0_x write ( 26 , '(a14,e11.4)' ) ' FWHM (fs) lx=' , tau_fwhm write ( 26 , '(a19,e11.4)' ) ' Waist(microns) ly=' , w0_y write ( 26 , '(a17,e11.4)' ) ' FWHM(microns) = ' , lp_rad if ( nb_laser > 1 ) write ( 26 , '(a21,3e11.4)' ) ' Delay among pulses= ' , & loc_delay ( 1 : 3 ) if ( Two_color ) then write ( 26 , * ) ' Injection pulse parameters' write ( 26 , '(a16,e11.4)' ) ' amplitude  a1 =' , a1 write ( 26 , '(a21,e11.4)' ) ' Focal x-position xf=' , xf1 write ( 26 , '(a21,e11.4)' ) ' Centr x-position xc=' , xc1_lp write ( 26 , '(a20,e11.4)' ) ' Size (microns) lx=' , w1_x write ( 26 , '(a19,e11.4)' ) ' Waist(microns) ly=' , w1_y end if close ( 26 ) end if part_in = lp_end ( 1 ) + lpx ( 7 ) !=================def part distr points end subroutine end module","tags":"","loc":"sourcefile/init_laser_field.f90.html"},{"title":"pic_in.f90 – ALaDyn","text":"This file depends on sourcefile~~pic_in.f90~~EfferentGraph sourcefile~pic_in.f90 pic_in.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~fstruct_data.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~init_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~util.f90 util.f90 sourcefile~init_part_distrib.f90->sourcefile~util.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~init_part_distrib.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~init_part_distrib.f90->sourcefile~mpi_var.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~init_part_distrib.f90->sourcefile~code_util.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~init_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pic_in.f90~~AfferentGraph sourcefile~pic_in.f90 pic_in.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules pic_in Source Code pic_in.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module pic_in use init_laser_field use init_part_distrib implicit none real ( dp ) :: xf0 contains subroutine init !====================================== if ( model_id < 3 ) then call lp_pulse ( model_id , xf0 ) !Linear polarization along y (1)   z(2) else select case ( model_id ) case ( 3 ) call cp_pulse ( model_id , xf0 ) !Circular polarization case ( 4 ) call set_envelope ( xf0 ) !Envelope  approximation for laser ! vector potential Ay end select end if call part_distribute ( dmodel_id , xf0 ) if ( hybrid ) call init_fluid_density_momenta ( dmodel_id , xf0 ) end subroutine end module","tags":"","loc":"sourcefile/pic_in.f90.html"},{"title":"init_part_distrib.f90 – ALaDyn","text":"This file depends on sourcefile~~init_part_distrib.f90~~EfferentGraph sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~init_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~util.f90 util.f90 sourcefile~init_part_distrib.f90->sourcefile~util.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~init_part_distrib.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~init_part_distrib.f90->sourcefile~mpi_var.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~init_part_distrib.f90->sourcefile~code_util.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~init_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~init_part_distrib.f90~~AfferentGraph sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules init_part_distrib Source Code init_part_distrib.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2019  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module init_part_distrib use common_param use util use grid_param use array_alloc use mpi_var use code_util , only : maxv , mem_psize use phys_param , only : pi implicit none private public :: part_distribute integer , allocatable :: loc_imax (:, :), loc_jmax (:, :), loc_kmax (:, :) contains subroutine set_pgrid_xind ( npx , ic ) integer , intent ( in ) :: npx , ic integer :: i , p , ip real ( dp ) :: xp , x1 , x2 !Defines the the number of particles on each mpi x-domain ! Enter the total particle number npx and the particle species ic ! Particle x-distribution is already defined by xpt(nptx,ic) ! Exit loc_imax(pex,ic) for each pex task !================================================= loc_imax ( 0 : npe_xloc - 1 , ic ) = 1 p = 0 ip = 0 x1 = loc_xgrid ( 0 )% gmin x2 = loc_xgrid ( 0 )% gmax do i = 1 , npx xp = xpt ( i , ic ) if ( xp >= x1 . and . xp < x2 ) ip = ip + 1 end do loc_imax ( p , ic ) = ip !number of grid points in [loc_xmin,loc_xmax] if ( npe_xloc > 1 ) then do p = 1 , npe_xloc - 1 x1 = loc_xgrid ( p )% gmin x2 = loc_xgrid ( p )% gmax ip = 0 do i = 1 , npx xp = xpt ( i , ic ) if ( xp >= x1 . and . xp < x2 ) ip = ip + 1 end do loc_imax ( p , ic ) = ip end do end if end subroutine subroutine set_pgrid_ind ( npy , npz , ic ) integer , intent ( in ) :: npy , npz , ic integer :: i , p , ip real ( dp ) :: yp , y1 , y2 ! Particles number index on each y-z mpi domain ! Enter the total particle number npy, npz and the particle species ic ! Particle y-z-distributions are ypt(npy,ic), zpt(npz,ic) ! Exit loc_jmax(pey,ic) loc_kmax(pez,ic)for each pey peztask !======================================= loc_jmax ( 0 : npe_yloc - 1 , ic ) = 1 loc_kmax ( 0 : npe_zloc - 1 , ic ) = 1 p = 0 ip = 0 do i = 1 , npy yp = ypt ( i , ic ) y1 = ymin_t y2 = loc_ygrid ( p )% gmax if ( yp >= y1 . and . yp < y2 ) ip = ip + 1 end do loc_jmax ( p , ic ) = ip !number of particle y-positions in [loc_ymin,loc_ymax] if ( npe_yloc > 2 ) then do p = 1 , npe_yloc - 2 ip = 0 do i = 1 , npy yp = ypt ( i , ic ) y1 = loc_ygrid ( p )% gmin y2 = loc_ygrid ( p )% gmax if ( yp >= y1 . and . yp < y2 ) ip = ip + 1 end do loc_jmax ( p , ic ) = ip end do end if p = npe_yloc - 1 ip = 0 do i = 1 , npy yp = ypt ( i , ic ) y1 = loc_ygrid ( p )% gmin y2 = ymax_t if ( yp >= y1 . and . yp < y2 ) ip = ip + 1 end do loc_jmax ( p , ic ) = ip if ( npz == 1 ) return p = 0 ip = 0 do i = 1 , npz yp = zpt ( i , ic ) y1 = zmin_t y2 = loc_zgrid ( p )% gmax if ( yp >= y1 . and . yp < y2 ) ip = ip + 1 end do loc_kmax ( p , ic ) = ip if ( npe_zloc > 2 ) then do p = 1 , npe_zloc - 2 ip = 0 do i = 1 , npz yp = zpt ( i , ic ) y1 = loc_zgrid ( p )% gmin y2 = loc_zgrid ( p )% gmax if ( yp >= y1 . and . yp < y2 ) ip = ip + 1 end do loc_kmax ( p , ic ) = ip end do end if p = npe_zloc - 1 ip = 0 do i = 1 , npz yp = zpt ( i , ic ) y1 = loc_zgrid ( p )% gmin y2 = zmax_t if ( yp >= y1 . and . yp < y2 ) ip = ip + 1 end do loc_kmax ( p , ic ) = ip end subroutine !-------------------------- subroutine pspecies_distribute ( loc_sp , t_x , ch , q , ic , i2 , p ) type ( species ), intent ( inout ) :: loc_sp real ( dp ), intent ( in ) :: t_x , ch integer , intent ( in ) :: q , ic , i2 integer , intent ( out ) :: p integer :: i , j , k , j2 , k2 real ( dp ) :: u , whz call init_random_seed ( mype ) p = q charge = int ( ch , hp_int ) part_ind = 0 k2 = loc_nptz ( ic ) j2 = loc_npty ( ic ) if ( curr_ndim > 2 ) then do k = 1 , k2 do j = 1 , j2 do i = 1 , i2 whz = loc_wghx ( i , ic ) * loc_wghyz ( j , k , ic ) wgh = real ( whz , sp ) p = p + 1 loc_sp % part ( p , 1 ) = loc_xpt ( i , ic ) loc_sp % part ( p , 2 ) = loc_ypt ( j , ic ) loc_sp % part ( p , 3 ) = loc_zpt ( k , ic ) call gasdev ( u ) loc_sp % part ( p , 4 ) = t_x * u call gasdev ( u ) loc_sp % part ( p , 5 ) = t_x * u call gasdev ( u ) loc_sp % part ( p , 6 ) = t_x * u loc_sp % part ( p , 7 ) = wgh_cmp end do end do end do return end if do j = 1 , j2 do i = 1 , i2 whz = loc_wghx ( i , ic ) * loc_wghyz ( j , 1 , ic ) wgh = real ( whz , sp ) p = p + 1 loc_sp % part ( p , 1 ) = loc_xpt ( i , ic ) loc_sp % part ( p , 2 ) = loc_ypt ( j , ic ) call gasdev ( u ) loc_sp % part ( p , 3 ) = t_x * u call gasdev ( u ) loc_sp % part ( p , 4 ) = t_x * u loc_sp % part ( p , 5 ) = wgh_cmp end do end do end subroutine !============================== subroutine mpi_x_part_distrib ( nc ) !Local to imodx distribution integer , intent ( in ) :: nc integer :: ic , i2 , ix_min real ( dp ) :: x1 x1 = loc_xgrid ( imodx )% gmin do ic = 1 , nc ix_min = 0 do i2 = 1 , nptx ( ic ) !the total particle number if ( xpt ( i2 , ic ) < x1 ) ix_min = i2 end do do i2 = 1 , loc_nptx ( ic ) !the local particle number ix_min = ix_min + 1 loc_xpt ( i2 , ic ) = xpt ( ix_min , ic ) loc_wghx ( i2 , ic ) = wghpt ( ix_min , ic ) end do end do end subroutine !===================================== subroutine mpi_yz_part_distrib ( nc , ky2_in , kz2_in , nyc , nzc , ymt , zmt , whyz ) integer , intent ( in ) :: nc , ky2_in (:), kz2_in (:), nyc (:), nzc (:) real ( dp ), intent ( in ) :: ymt , zmt , whyz (:, :, :) integer :: ic , i2 , k1 , j1 , j2 real ( dp ) :: loc_ym , loc_zm if ( ndim < 3 ) then loc_ym = loc_ygrid ( imody )% gmin if ( imody == 0 ) loc_ym = ymt do ic = 1 , nc k1 = 0 do i2 = 1 , nyc ( ic ) if ( ypt ( i2 , ic ) < loc_ym ) k1 = i2 end do do i2 = 1 , ky2_in ( ic ) k1 = k1 + 1 loc_ypt ( i2 , ic ) = ypt ( k1 , ic ) loc_wghyz ( i2 , 1 , ic ) = whyz ( k1 , 1 , ic ) end do end do zpt ( 1 , 1 : nc ) = 0.0 return end if !========================== loc_zm = loc_zgrid ( imodz )% gmin if ( imodz == 0 ) loc_zm = zmt loc_ym = loc_ygrid ( imody )% gmin if ( imody == 0 ) loc_ym = ymt do ic = 1 , nc k1 = 0 do i2 = 1 , nzc ( ic ) if ( zpt ( i2 , ic ) < loc_zm ) k1 = i2 end do do i2 = 1 , kz2_in ( ic ) k1 = k1 + 1 loc_zpt ( i2 , ic ) = zpt ( k1 , ic ) j1 = 0 do j2 = 1 , nyc ( ic ) if ( ypt ( j2 , ic ) < loc_ym ) j1 = j2 end do do j2 = 1 , ky2_in ( ic ) j1 = j1 + 1 loc_ypt ( j2 , ic ) = ypt ( j1 , ic ) loc_wghyz ( j2 , i2 , ic ) = whyz ( j1 , k1 , ic ) end do end do end do end subroutine !-------------------------- subroutine set_uniform_yz_distrib ( nyh_in , nc ) integer , intent ( in ) :: nyh_in , nc integer :: j , i , i1 , i2 , ic integer :: npyc ( 6 ), npzc ( 6 ), npty_ne , nptz_ne real ( dp ) :: yy , zz , dxip , dpy , dpz real ( dp ) :: zp_min , zp_max , yp_min , yp_max integer :: nyl1 , nzl1 real ( dp ), allocatable :: wy (:, :), wz (:, :), wyz (:, :, :) !================= !========= gridding the transverse target size nyl1 = 1 + ny / 2 - nyh_in / 2 !=1 if nyh_in=ny nzl1 = 1 + nz / 2 - nyh_in / 2 !=1 if nyh_in=nz yp_min = ymin_t yp_max = ymax_t !============================= ! Multispecies !============================= do ic = 1 , nc npyc ( ic ) = nyh_in * np_per_yc ( ic ) end do npty = maxval ( npyc ( 1 : nc )) nptz = 1 zp_min = zero_dp zp_max = zero_dp if ( ndim == 3 ) then npzc ( 1 : nc ) = nyh_in * np_per_zc ( 1 : nc ) zp_min = zmin_t !-Lz zp_max = zmax_t !+Lz nptz = maxval ( npzc ( 1 : nc )) end if allocate ( ypt ( npty , nc )) allocate ( zpt ( nptz , nc )) allocate ( wy ( npty , nc )) allocate ( wz ( nptz , nc )) allocate ( wyz ( npty , nptz , nc )) ypt = 0. zpt = 0. wyz = 1. wy = 1. wz = 1. !================== allocate ( loc_jmax ( 0 : npe_yloc - 1 , 1 : nc )) allocate ( loc_kmax ( 0 : npe_zloc - 1 , 1 : nc )) allocate ( loc_imax ( 0 : npe_xloc - 1 , 1 : nc )) !==================== ! Uniform layers along y-z coordinates !=============== do ic = 1 , nc npty_ne = npyc ( ic ) if ( npty_ne > 0 ) then dpy = ( yp_max - yp_min ) / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i , ic ) = yp_min + dpy * ( real ( i , dp ) - 0.5 ) end do if ( stretch ) then yy = str_ygrid % smin if ( yy > yp_min ) then dpy = dyi / real ( np_per_yc ( ic ), dp ) i1 = ( str_ygrid % sind ( 1 ) - nyl1 + 1 ) * np_per_yc ( ic ) i2 = npty_ne - i1 do i = 1 , i1 dxip = dpy * ( real ( i - i1 , dp ) - 0.5 ) ypt ( i , ic ) = str_ygrid % smin + l_s * tan ( dxip ) wy ( i , ic ) = 1. / ( cos ( dxip ) * cos ( dxip )) end do dxip = dy / real ( np_per_yc ( ic ), dp ) do i = i1 + 1 , i2 ypt ( i , ic ) = str_ygrid % smin + dxip * ( real ( i - i1 , dp ) - 0.5 ) end do do i = i2 + 1 , npty_ne dxip = dpy * ( real ( i - i2 , dp ) - 0.5 ) ypt ( i , ic ) = str_ygrid % smax + l_s * tan ( dxip ) wy ( i , ic ) = 1. / ( cos ( dxip ) * cos ( dxip )) end do end if end if do i = 1 , npty_ne wyz ( i , 1 , ic ) = wy ( i , ic ) * wz ( 1 , ic ) end do end if ! end np_per_yc >0 nptz_ne = 1 if ( ndim == 3 ) then nptz_ne = npzc ( ic ) if ( nptz_ne > 0 ) then dpz = ( zp_max - zp_min ) / real ( nptz_ne , dp ) do i = 1 , nptz_ne zpt ( i , ic ) = zp_min + dpz * ( real ( i , dp ) - 0.5 ) end do if ( stretch ) then zz = str_zgrid % smin if ( zz > zp_min ) then dpz = dzi / real ( np_per_zc ( ic ), dp ) i1 = ( str_zgrid % sind ( 1 ) - nzl1 + 1 ) * np_per_zc ( ic ) i2 = nptz_ne - i1 do i = 1 , i1 dxip = dpy * ( real ( i - i1 , dp ) - 0.5 ) zpt ( i , ic ) = str_zgrid % smin + l_s * tan ( dxip ) wz ( i , ic ) = 1. / ( cos ( dxip ) * cos ( dxip )) end do dxip = dz / real ( np_per_zc ( ic ), dp ) do i = i1 + 1 , i2 zpt ( i , ic ) = str_zgrid % smin + dxip * ( real ( i - i1 , dp ) - 0.5 ) end do do i = i2 + 1 , nptz_ne dxip = dpy * ( real ( i - i2 , dp ) - 0.5 ) zpt ( i , ic ) = str_zgrid % smax + l_s * tan ( dxip ) wz ( i , ic ) = 1. / ( cos ( dxip ) * cos ( dxip )) end do end if end if end if do i = 1 , nptz_ne do j = 1 , npty_ne wyz ( j , i , ic ) = wy ( j , ic ) * wz ( i , ic ) end do end do if ( chann_fact > 0.0 ) then do i = 1 , nptz_ne zz = zpt ( i , ic ) do j = 1 , npty_ne yy = ypt ( j , ic ) wyz ( j , i , ic ) = 1. + chann_fact * ( yy * yy + zz * zz ) / ( w0_y * w0_y ) end do end do end if end if !end ndim=3 call set_pgrid_ind ( npty_ne , nptz_ne , ic ) !exit loc_jmax,loc_kmax end do !=========================== loc_npty ( 1 : nc ) = loc_jmax ( imody , 1 : nc ) loc_nptz ( 1 : nc ) = loc_kmax ( imodz , 1 : nc ) !============================= npty_ne = 1 nptz_ne = 1 npty_ne = maxval ( loc_npty ( 1 : nc )) nptz_ne = maxval ( loc_nptz ( 1 : nc )) !====================== allocate ( loc_wghyz ( npty_ne , nptz_ne , nc )) allocate ( loc_ypt ( npty_ne , nc )) allocate ( loc_zpt ( nptz_ne , nc )) loc_wghyz = 1. call mpi_yz_part_distrib ( nc , loc_npty , loc_nptz , npyc , npzc , ymin_t , & zmin_t , wyz ) !=EXIT local to mpi (imody,imodz) tasks (loc_ypt,loc_zpt), weights (loc_wghyz) ! => set in common in pstruct_data.f90 file/ ! and particle numbers (loc_npty,loc_nptz) ! => set in common in grid_and_partices.f90 file/ !===================================== !================== end subroutine !=========================================== subroutine multi_layer_gas_target ( layer_mod , nyh_in , xf0 ) integer , intent ( in ) :: layer_mod , nyh_in real ( dp ), intent ( in ) :: xf0 integer :: p , i , j , i1 , i2 , ic integer :: n_peak , npmax , nxtot , len_conc real ( dp ) :: uu , u2 , xp_min , xp_max , u3 , ramp_prefactor real ( dp ) :: xfsh , un ( 2 ), wgh_sp ( nsp ) real ( dp ), allocatable :: conc (:) integer :: nxl ( 6 ) integer :: nps_loc ( 4 ), last_particle_index ( 4 ), nptx_alloc ( 4 ) !========================== p = 0 i = 0 j = 0 i1 = 0 i2 = 0 ic = 0 call set_uniform_yz_distrib ( nyh_in , nsp ) !========================== xp_min = xmin xp_max = xmax !========================== nxl = 0 !============================ ! Parameters for particle distribution along the x-coordinate !============================ ! Layers nxl(1:5) all containing the same ion species len_conc = size ( concentration ) allocate ( conc ( len_conc )) conc (:) = concentration (:) xtot = 0.0 nxtot = 0 do i = 1 , 6 nxl ( i ) = nint ( dx_inv * lpx ( i )) lpx ( i ) = nxl ( i ) * dx xtot = xtot + lpx ( i ) nxtot = nxtot + nxl ( i ) end do if ( xf0 > 0.0 ) then targ_in = xf0 targ_end = targ_in + xtot else targ_in = xmin targ_end = xtot + xf0 end if xfsh = xf0 !============================= loc_nptx = 0 loc_nptx ( 1 : nsp ) = ( nxl ( 1 ) + nxl ( 2 ) + nxl ( 3 ) + nxl ( 4 ) + nxl ( 5 ) + nxl ( 6 )) * & np_per_xc ( 1 : nsp ) nptx_max = maxval ( loc_nptx ( 1 : nsp )) allocate ( xpt ( nptx_max , nsp )) allocate ( wghpt ( nptx_max , nsp )) allocate ( loc_xpt ( nptx_max , nsp )) !============================= wghpt = one_dp un = one_dp ramp_prefactor = one_dp !=================================== ! WARNING for charge distribution !==================================== ! wgh_sp(1:nsp) already set by initial conditions !===================================================== ! Longitudinal distribution nptx = 0 !Weights for multispecies target !wgh_sp(1:3)=j0_norm !if(nsp==2)then !wgh_sp(2)=1./(real(mp_per_cell(2),dp)) wgh_sp ( 1 ) = j0_norm * n0_ref * n_plasma do i = 2 , nsp if ( mp_per_cell ( i ) > 0 ) wgh_sp ( i ) = n0_ref / real ( mp_per_cell ( i ), dp ) wgh_sp ( i ) = conc ( i - 1 ) * wgh_sp ( i ) end do select case ( layer_mod ) !================ first uniform layer np1================= case ( 1 ) if ( nxl ( 1 ) > 0 ) then ramp_prefactor = one_dp - np1 do ic = 1 , nsp n_peak = nxl ( 1 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 1 ) * uu wghpt ( i1 , ic ) = np1 * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 1 ) end if !================ first CUBIC ramp np1 => 1 --linear or exponential still available but commented ================= if ( nxl ( 2 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 2 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 2 ) * uu !u2=(uu-1.)*(uu-1.) u2 = uu * uu u3 = u2 * uu !wghpt(i1,ic)=(np1+exp(-4.5*u2)*(1.-np1))*wgh_sp(ic) !wghpt(i1,ic)=exp(-4.5*u2)*wgh_sp(ic) wghpt ( i1 , ic ) = ( - 2. * ramp_prefactor * u3 + 3. * ramp_prefactor * u2 + & one_dp - ramp_prefactor ) * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 2 ) end if !================ Central layer================= if ( nxl ( 3 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 3 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 3 ) * uu wghpt ( i1 , ic ) = wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 3 ) end if !================ second linear ramp ================= if ( nxl ( 4 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 4 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 4 ) * uu wghpt ( i1 , ic ) = ( 1. - uu * ( 1. - np2 )) * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 4 ) end if if ( nxl ( 5 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 5 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 5 ) * uu wghpt ( i1 , ic ) = np2 * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 5 ) end if do ic = 1 , nsp nptx_alloc ( ic ) = min ( nptx ( ic ) + 10 , nx * np_per_xc ( ic )) end do !========================================= case ( 2 ) !                 two bumps  (n1/n_c, n2/n_c) of length x_1 and x_2 !                 n_over_nc enters as average n_over nc= (n1* x_1+n2*x_2)/(x_1+x_2) !                 weight j0_norm =>> j0_norm*np1 in x_1       =>> j0_norm*np2 in x_2 !                 particle per cell uniform !================================================ !================ first linear ramp to first plateau n1/n_c ================= if ( nxl ( 1 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 1 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 1 ) * uu wghpt ( i1 , ic ) = uu * np1 * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 1 ) end if if ( nxl ( 2 ) > 0 ) then !first plateau do ic = 1 , nsp n_peak = nxl ( 2 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 2 ) * uu wghpt ( i1 , ic ) = np1 * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 2 ) end if !================ np1 => np2 down-ramp ================= if ( nxl ( 3 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 3 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 3 ) * uu wghpt ( i1 , ic ) = wgh_sp ( ic ) * ( np1 + uu * ( np2 - np1 )) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 3 ) end if !================ second plateau n2/n_c < n1/n_c ================= if ( nxl ( 4 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 4 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 4 ) * uu wghpt ( i1 , ic ) = np2 * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 4 ) end if if ( nxl ( 5 ) > 0 ) then !second down-ramp n2/n_c ==> 0 do ic = 1 , nsp n_peak = nxl ( 5 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 5 ) * uu wghpt ( i1 , ic ) = ( 1. - uu ) * np2 * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 5 ) end if do ic = 1 , nsp nptx_alloc ( ic ) = min ( nptx ( ic ) + 10 , nx * np_per_xc ( ic )) end do !===================================== case ( 3 ) !                 three layers !                 lpx(1)[ramp]+lpx(2)[plateau]  and lpx(4) plateu lpx(5) downramp n_ion=0 n_e=n_0 !                 lpx(3)[plateau]  with a (A1-Z1) dopant with % density np1=n1_per_nc/n_per_nc !                 and electronic density n_e=n_0+Z1*n_ion  n0=n_H(+) !--------------- !================================================ !Z1 electrons are accounted for by a larger electron weight un ( 1 ) = 1. + ion_min ( 1 ) * np1 un ( 2 ) = np1 !float(mp_per_cell(1))/float(mp_per_cell(ic)) if ( nxl ( 1 ) > 0 ) then do ic = 1 , nsp_run n_peak = nxl ( 1 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 1 ) * uu wghpt ( i1 , ic ) = uu * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 1 ) end if if ( nxl ( 2 ) > 0 ) then !first plateau do ic = 1 , nsp_run n_peak = nxl ( 2 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 2 ) * uu wghpt ( i1 , ic ) = wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 2 ) end if !================ if ( nxl ( 3 ) > 0 ) then !el+H(+) + dopant un(1:2) correct (electron,Z1) weights do ic = 1 , nsp n_peak = nxl ( 3 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 3 ) * uu wghpt ( i1 , ic ) = un ( ic ) * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 3 ) end if !================ second plateau only electrons ================= if ( nxl ( 4 ) > 0 ) then do ic = 1 , nsp_run n_peak = nxl ( 4 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 4 ) * uu wghpt ( i1 , ic ) = wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 4 ) end if if ( nxl ( 5 ) > 0 ) then !second down-ramp ==> 0 do ic = 1 , nsp_run n_peak = nxl ( 5 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 5 ) * uu wghpt ( i1 , ic ) = ( 1. - uu ) * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 5 ) end if do ic = 1 , nsp nptx_alloc ( ic ) = min ( nptx ( ic ) + 10 , nx * np_per_xc ( ic )) end do !=================================== case ( 4 ) !================ cos&#94;2 upramp with peak n0 ================= if ( nxl ( 1 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 1 ) * np_per_xc ( ic ) if ( n_peak > 0 ) then do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 1 ) * uu uu = uu - 1. wghpt ( i1 , ic ) = one_dp * cos ( 0.5 * pi * ( uu )) * cos ( 0.5 * pi * ( uu )) * & wgh_sp ( ic ) end do end if nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 1 ) end if !================ uniform layer n0================= if ( nxl ( 2 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 2 ) * np_per_xc ( ic ) if ( n_peak > 0 ) then do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 2 ) * uu wghpt ( i1 , ic ) = one_dp * wgh_sp ( ic ) end do end if nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 2 ) end if !================ cos&#94;2 downramp to the plateau np1*n0 ================= if ( nxl ( 3 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 3 ) * np_per_xc ( ic ) if ( n_peak > 0 ) then do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 3 ) * uu uu = uu - 1. wghpt ( i1 , ic ) = ( np1 + ( one_dp - np1 ) * sin ( 0.5 * pi * ( uu )) * sin ( 0.5 * pi * ( & uu ))) * wgh_sp ( ic ) end do end if nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 3 ) end if !================ Central layer of density np1*n0 ================= if ( nxl ( 4 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 4 ) * np_per_xc ( ic ) if ( n_peak > 0 ) then do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 4 ) * uu wghpt ( i1 , ic ) = np1 * wgh_sp ( ic ) end do end if nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 4 ) end if !================ cos&#94;2 downramp to second plateau np2*n0 ================= if ( nxl ( 5 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 5 ) * np_per_xc ( ic ) if ( n_peak > 0 ) then do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 5 ) * uu wghpt ( i1 , ic ) = ( np2 + ( np1 - np2 ) * cos ( 0.5 * pi * ( uu )) * cos ( 0.5 * pi * ( & uu ))) * wgh_sp ( ic ) end do end if nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 5 ) end if !================ Second plateau of density np2*n0 ================= if ( nxl ( 6 ) > 0 ) then do ic = 1 , nsp n_peak = nxl ( 6 ) * np_per_xc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) i1 = nptx ( ic ) + i xpt ( i1 , ic ) = xfsh + lpx ( 6 ) * uu wghpt ( i1 , ic ) = np2 * wgh_sp ( ic ) end do nptx ( ic ) = nptx ( ic ) + n_peak end do xfsh = xfsh + lpx ( 6 ) end if do ic = 1 , nsp nptx_alloc ( ic ) = min ( nptx ( ic ) + 10 , nx * np_per_xc ( ic )) end do !========================================= end select if ( xf0 < 0. ) then do ic = 1 , nsp i1 = 0 if ( pe0 ) write ( 6 , * ) 'tot part number' , ic , nptx ( ic ) do i = 1 , nptx ( ic ) if ( xpt ( i , ic ) > xmin ) then i1 = i1 + 1 xpt ( i1 , ic ) = xpt ( i , ic ) wghpt ( i1 , ic ) = wghpt ( i , ic ) end if end do nptx ( ic ) = i1 if ( pe0 ) write ( 6 , * ) 'new tot part number' , ic , nptx ( ic ) end do end if !============================= do ic = 1 , nsp nptx_alloc ( ic ) = min ( nptx ( ic ) + 10 , nx * np_per_xc ( ic )) end do do ic = 1 , nsp sptx_max ( ic ) = nptx ( ic ) end do !================================ ! END of section setting global coordinates !================================= ! Restricts to the computational box !================================= if ( pe0 ) then open ( 12 , file = 'Initial_gas_target_x-profiles' , form = 'formatted' ) do ic = 1 , nsp i1 = sptx_max ( ic ) write ( 12 , * ) 'species ' , ic , 'max x-coordinate' , i1 write ( 12 , * ) 'particle x-coordinate' write ( 12 , '(6e11.4)' ) xpt ( 1 : i1 , ic ) write ( 12 , * ) 'particle weight' write ( 12 , '(6e11.4)' ) wghpt ( 1 : i1 , ic ) end do close ( 12 ) end if !================================ ! END of section setting global coordinates !================================= !Resets nptx(ic)=last particle coordinate inside the computational box !in the initial condition: for t>0  nptx(ic) updated by mowing window !============================== do ic = 1 , nsp i1 = 0 do j = 1 , nptx ( ic ) if ( xpt ( j , ic ) < xmax ) i1 = i1 + 1 end do nptx ( ic ) = i1 end do !=========== Local x-distribution !Local to the x-cordinate MPI domain particle number !================== allocate ( loc_wghx ( nptx_max , nsp )) do ic = 1 , nsp call set_pgrid_xind ( nptx ( ic ), ic ) end do loc_nptx ( 1 : nsp ) = loc_imax ( imodx , 1 : nsp ) ! Alocation using a large buffer npt_max=mp_per_cell(1)*nx_loc*ny_loc*nz_loc do ic = 1 , nsp nptx_alloc ( ic ) = min ( loc_nptx ( ic ) + 10 , nx_loc * np_per_xc ( ic )) end do do ic = 1 , nsp nps_loc ( ic ) = nptx_alloc ( ic ) * loc_jmax ( imody , ic ) * loc_kmax ( imodz , ic ) end do npmax = maxval ( nps_loc ( 1 : nsp )) call p_alloc ( npmax , nd2 + 1 , nps_loc , nsp , lpf_ord , 1 , 1 , mem_psize ) !================================== !==================== Local distribution of nptx particles================== call mpi_x_part_distrib ( nsp ) !=========================== last_particle_index = 0 !============ !Particles are distributed according to the local ![loc_xpt,loc_ypt,loc_zpt] coordinates do ic = 1 , nsp p = 0 i2 = loc_nptx ( ic ) if ( i2 > 0 ) call pspecies_distribute ( spec ( ic ), t0_pl ( ic ), & unit_charge ( ic ), p , ic , i2 , last_particle_index ( ic )) loc_npart ( imody , imodz , imodx , ic ) = last_particle_index ( ic ) end do end subroutine !============================= !=============================== subroutine preplasma_multisp ( nyh_in , xf0 ) integer , intent ( in ) :: nyh_in real ( dp ), intent ( in ) :: xf0 integer :: p , ip integer :: l , i , i1 , i2 , ic integer :: n_peak , nptx_loc ( 6 ) integer :: npmax , nps_loc ( 4 ) real ( dp ) :: uu , np1_loc real ( dp ) :: xp_min , xp_max real ( dp ) :: xfsh , l_inv integer :: nxl ( 6 ) integer :: ip_ion , ip_el , ip_pr !================= xp_min = xmin xp_max = xmax nxl = 0 !========== uniform y-z distribution of El-Ion layers call set_uniform_yz_distrib ( nyh_in , 6 ) !=============== xtot = 0.0 do i = 1 , 5 nxl ( i ) = nint ( dx_inv * lpx ( i )) lpx ( i ) = nxl ( i ) * dx xtot = xtot + lpx ( i ) end do nxl ( 4 ) = 0 !attached coating if ( nsp < 3 ) then nxl ( 5 ) = 0 if ( pe0 ) then write ( 6 , * ) & 'Warning : for nsp=2 nxl(5) forced to zero => NO coating layer' end if end if xfsh = xf0 + lpx ( 7 ) targ_in = xfsh targ_end = targ_in + xtot !               nsp=4 species x-distribution !               preplasma !================================== !            lx(2:3) (Z1-A1+El) central target nptx_loc ( 1 : 2 ) = ( nxl ( 2 ) + nxl ( 3 )) * np_per_xc ( 1 : 2 ) !            lx(1) (Z1-A1-El) uniform with np1 density pre-plasma nptx_loc ( 3 : 4 ) = nxl ( 1 ) * np_per_xc ( 3 : 4 ) !            lx(5) (Z2-A2+El) ) uniform with np2 density coating nptx_loc ( 5 : 6 ) = nxl ( 5 ) * np_per_xc ( 5 : 6 ) !======================== nptx ( 1 ) = nptx_loc ( 1 ) + nptx_loc ( 3 ) + nptx_loc ( 5 ) !electrons nptx ( 2 ) = nptx_loc ( 2 ) !Z1-A1 species nptx ( 3 ) = nptx_loc ( 4 ) !Z1-A1 species nptx ( 4 ) = nptx_loc ( 6 ) !Z2-A2  species nlx(5) nptx_max = maxval ( nptx_loc ( 1 : 6 )) !======================= allocate ( xpt ( nptx_max , 6 )) allocate ( wghpt ( nptx_max , 6 )) allocate ( loc_xpt ( nptx_max , 6 )) allocate ( loc_wghx ( nptx_max , 6 )) wghpt ( 1 : nptx_max , 1 : 6 ) = one_dp !============================= ! first layer: electrons and Z1 ions !x distribution loc_imax ( imodx , 1 : 6 ) = nptx_loc ( 1 : 6 ) nps_loc = 0 if ( nxl ( 1 ) > 0 ) then do ic = 3 , 4 n_peak = nptx_loc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) xpt ( i , ic ) = xfsh + lpx ( 1 ) * uu end do end do wghpt ( 1 : nptx_loc ( 3 ), 3 ) = np1 * j0_norm wghpt ( 1 : nptx_loc ( 4 ), 4 ) = np1 * j0_norm if ( mp_per_cell ( 3 ) > 0 ) then uu = ratio_mpc ( 3 ) !float(mp_per_cell(1))/float(mp_per_cell(3)) wghpt ( 1 : nptx_loc ( 3 ), 3 ) = wghpt ( 1 : nptx_loc ( 3 ), 3 ) * uu uu = ratio_mpc ( 4 ) / unit_charge ( 2 ) !float(mp_per_cell(1))/float(mp_per_cell(4)) wghpt ( 1 : nptx_loc ( 4 ), 4 ) = wghpt ( 1 : nptx_loc ( 4 ), 4 ) * uu end if xfsh = xfsh + lpx ( 1 ) !=========== Distributes on x-MPI tasks the first layer do ic = 3 , 4 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do !======================== !======================== p = imodx l = imody ip = imodz ! Counts particles in first layer nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 3 ) * loc_jmax ( l , 3 ) * loc_kmax ( ip , & 3 ) nps_loc ( 2 ) = nps_loc ( 2 ) + loc_imax ( p , 4 ) * loc_jmax ( l , 4 ) * loc_kmax ( ip , & 4 ) end if !------------------------------ ! Electrons and Z1_ions : central layer ! x distribution !==================== do ic = 1 , 2 n_peak = nptx_loc ( ic ) do i = 1 , n_peak xpt ( i , ic ) = xfsh + ( lpx ( 2 ) + lpx ( 3 )) * ( real ( i , dp ) - 0.5 ) / real ( n_peak , & dp ) wghpt ( i , ic ) = j0_norm end do end do uu = ratio_mpc ( 2 ) / real ( ion_min ( 1 ), dp ) ic = 2 n_peak = nptx_loc ( ic ) wghpt ( 1 : n_peak , ic ) = j0_norm * uu !================================ ! Electrons and Z1 ions have the same weight if uu=1 !================================= xfsh = xfsh + lpx ( 3 ) + lpx ( 2 ) if ( np1 > 0.0 ) then np1_loc = np1 else np1_loc = 0.005 end if !======== a preplasma rump if ( nxl ( 2 ) > 0 ) then do ic = 1 , 2 n_peak = nxl ( 2 ) * np_per_xc ( ic ) l_inv = log ( 1. / np1_loc ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) ! rampa esponenziale v1 ! wghpt(i,ic)=wghpt(i,ic)*exp(-5.*(1.-uu)) ! rampa esponenziale v2 ! Same species as later 2 (electrons+Z1-ions) wghpt ( i , ic ) = wghpt ( i , ic ) * np1_loc * exp ( uu * l_inv ) ! rampa lineare ! wghpt(i,ic)=wghpt(i,ic)*uu end do end do end if !=========== Distributes on x-MPI tasks do ic = 1 , 2 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . xpt ( i , ic ) < loc_xgrid ( & imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do p = imodx l = imody ip = imodz nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 1 ) * loc_jmax ( l , 1 ) * loc_kmax ( ip , & 1 ) nps_loc ( 2 ) = nps_loc ( 2 ) + loc_imax ( p , 2 ) * loc_jmax ( l , 2 ) * loc_kmax ( ip , & 2 ) !============================ if ( nptx_loc ( 5 ) > 0.0 ) then do ic = 5 , 6 n_peak = nptx_loc ( ic ) do i = 1 , n_peak xpt ( i , ic ) = xfsh + lpx ( 5 ) * ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) end do wghpt ( 1 : n_peak , ic ) = np2 * j0_norm end do do ic = 5 , 6 if ( mp_per_cell ( ic ) > 0 ) then uu = ratio_mpc ( ic ) !float(mp_per_cell(1))/float(mp_per_cell(ic)) n_peak = nptx_loc ( ic ) wghpt ( 1 : n_peak , ic ) = wghpt ( 1 : n_peak , ic ) * uu end if end do xfsh = xfsh + lpx ( 5 ) !=============================== ! Warning : holds for Z2_ion= H(+) !=============================== do ic = 5 , 6 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do p = imodx l = imody ip = imodz nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 5 ) * loc_jmax ( l , 5 ) * loc_kmax ( ip , & 5 ) nps_loc ( 3 ) = nps_loc ( 3 ) + loc_imax ( p , 6 ) * loc_jmax ( l , 6 ) * loc_kmax ( ip , & 6 ) end if !====================== npmax = maxval ( nps_loc ( 1 : nsp )) npmax = max ( npmax , 1 ) call p_alloc ( npmax , nd2 + 1 , nps_loc , nsp , lpf_ord , 1 , 1 , mem_psize ) !=========================== ip_el = 0 ip_pr = 0 ip_ion = 0 !============ ! The first electron-proton(or C) foam layer if ( nxl ( 1 ) > 0 ) then p = 0 i2 = loc_imax ( imodx , 3 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 3 , & i2 , ip_el ) p = 0 i2 = loc_imax ( imodx , 4 ) call pspecies_distribute ( spec ( 2 ), t0_pl ( 2 ), unit_charge ( 2 ), p , 4 , & i2 , ip_ion ) end if !========================= ! The second electron-ion solid electron-Z1 layer p = ip_el i2 = loc_imax ( imodx , 1 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 1 , i2 , & ip_el ) p = ip_ion i2 = loc_imax ( imodx , 2 ) call pspecies_distribute ( spec ( 2 ), t0_pl ( 2 ), unit_charge ( 2 ), p , 2 , i2 , & ip_ion ) !============ ! The third electron-proton layer !========================= if ( nxl ( 5 ) > 0.0 ) then p = ip_el i2 = loc_imax ( imodx , 5 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 5 , & i2 , ip_el ) p = 0 i2 = loc_imax ( imodx , 6 ) call pspecies_distribute ( spec ( 3 ), t0_pl ( 3 ), unit_charge ( 3 ), p , 6 , & i2 , ip_pr ) end if do ic = 1 , nsp loc_npart ( imody , imodz , imodx , ic ) = nps_loc ( ic ) end do !============ end subroutine !===================== subroutine multi_layer_twosp_target ( nyh_in , xf0 ) integer , intent ( in ) :: nyh_in real ( dp ), intent ( in ) :: xf0 integer :: p , ip , l , i , i1 , i2 , ic , n_peak , nptx_loc ( 6 ) integer :: npmax , nps_loc ( 4 ) real ( dp ) :: l_inv , uu , np1_loc , xp_min , xp_max real ( dp ) :: xfsh , wgh_sp ( 6 ) integer :: nxl ( 6 ) integer :: ip_ion , ip_el , ip_pr !================= xp_min = xmin xp_max = xmax call set_uniform_yz_distrib ( nyh_in , 6 ) !============================== nxl = 0 !x- distribution xtot = 0.0 do i = 1 , 5 nxl ( i ) = nint ( dx_inv * lpx ( i )) lpx ( i ) = nxl ( i ) * dx xtot = xtot + lpx ( i ) end do xfsh = xf0 + lpx ( 7 ) targ_in = xfsh targ_end = targ_in + xtot if ( nsp < 3 ) then nxl ( 1 ) = 0 nxl ( 5 ) = 0 if ( pe0 ) then write ( 6 , * ) 'Warning : for nsp=2 nxl(1) and nxl(5) forced to zero' end if end if ! Species x-distribution !=========np_per_xc(1:2) electrons and Z1-ions in   ramp +  central layer !sizes lpx(2)+lpx(3) !========= np_per_xc(3:4) electrons and Z2-ions in layer 1 !size lpx(1) !========= np_per_xc(5:6) electrons and Z3-ions in layer 3 +ramp !                                                  sizes lpx(4)+lpx(5) nptx_loc ( 1 : 2 ) = ( nxl ( 2 ) + nxl ( 3 )) * np_per_xc ( 1 : 2 ) !Z1 ions nptx_loc ( 3 : 4 ) = nxl ( 1 ) * np_per_xc ( 3 : 4 ) !Z2 ions nptx_loc ( 5 : 6 ) = nxl ( 5 ) * np_per_xc ( 5 : 6 ) !Z3 ions nptx ( 1 ) = nptx_loc ( 1 ) + nptx_loc ( 3 ) + nptx_loc ( 5 ) !electrons nptx ( 2 ) = nptx_loc ( 2 ) !Z1-A1 species nptx ( 3 ) = nptx_loc ( 4 ) + nptx_loc ( 6 ) !Z2-A2  species nxl(1)+nlx(4) nptx_max = maxval ( nptx_loc ( 1 : 6 )) !======================= allocate ( xpt ( nptx_max , 6 )) allocate ( wghpt ( nptx_max , 6 )) allocate ( loc_xpt ( nptx_max , 6 )) allocate ( loc_wghx ( nptx_max , 6 )) wghpt ( 1 : nptx_max , 1 : 6 ) = 1. !================== ! nsp=1-4 ordering: electrons+ Z1 ions + Z2 ions +Z3 ions !Weights for multilayer multisp targets ! first layer: electrons and Z2 (protons) ions wgh_sp ( 3 ) = 1. / real ( mp_per_cell ( 3 ), dp ) wgh_sp ( 4 ) = 1. / ( real ( ion_min ( 2 ), dp ) * real ( mp_per_cell ( 4 ), dp )) ! central layer: electrons and Z1 ions wgh_sp ( 1 ) = j0_norm wgh_sp ( 2 ) = wgh_ion !ion spec 1 (ionizable) ! coiating layer: electrons and Z3 (H+) wgh_sp ( 5 ) = 1. / real ( mp_per_cell ( 5 ), dp ) wgh_sp ( 6 ) = 1. / ( real ( ion_min ( 2 ), dp ) * real ( mp_per_cell ( 6 ), dp )) !================================================ !x distribution loc_imax ( imodx , 1 : 6 ) = nptx_loc ( 1 : 6 ) nps_loc = 0 if ( nxl ( 1 ) > 0 ) then do ic = 3 , 4 n_peak = nptx_loc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) xpt ( i , ic ) = xfsh + lpx ( 1 ) * uu wghpt ( i , ic ) = np1 * wgh_sp ( ic ) end do end do xfsh = xfsh + lpx ( 1 ) !=========== Distributes on x-MPI tasks do ic = 3 , 4 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do !======================== !======================== p = imodx l = imody ip = imodz ! Counts particles (e+Z2 ions) nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 3 ) * loc_jmax ( l , 3 ) * loc_kmax ( ip , & 3 ) nps_loc ( 3 ) = nps_loc ( 3 ) + loc_imax ( p , 4 ) * loc_jmax ( l , 4 ) * loc_kmax ( ip , & 4 ) end if !------------------------------ ! Electrons and Z1_ions : central layer ! x distribution !==================== do ic = 1 , 2 n_peak = nptx_loc ( ic ) n_peak = max ( 1 , n_peak ) do i = 1 , n_peak xpt ( i , ic ) = xfsh + ( lpx ( 2 ) + lpx ( 3 )) * ( real ( i , dp ) - 0.5 ) / real ( n_peak , & dp ) wghpt ( i , ic ) = wgh_sp ( ic ) end do end do !================================ ! WARNING : electrons and Z1 ions have the same weight ! if mp_per_cell(1)=Z1*mp_per_cell(2) !================================= xfsh = xfsh + lpx ( 3 ) + lpx ( 2 ) if ( np1 > 0.0 ) then np1_loc = np1 else np1_loc = 0.005 end if !======== a preplasma rump if ( nxl ( 2 ) > 0 ) then do ic = 1 , 2 n_peak = nxl ( 2 ) * np_per_xc ( ic ) l_inv = log ( 1. / np1_loc ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) ! rampa esponenziale v1 ! wghpt(i,ic)=wghpt(i,ic)*exp(-5.*(1.-uu)) ! rampa esponenziale v2 ! Same species as later 2 (electrons+Z1-ions) wghpt ( i , ic ) = wghpt ( i , ic ) * np1_loc * exp ( uu * l_inv ) ! rampa lineare ! wghpt(i,ic)=wghpt(i,ic)*uu end do end do end if !=========== Distributes on x-MPI tasks do ic = 1 , 2 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . xpt ( i , ic ) < loc_xgrid ( & imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do p = imodx l = imody ip = imodz nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 1 ) * loc_jmax ( l , 1 ) * loc_kmax ( ip , & 1 ) nps_loc ( 2 ) = nps_loc ( 2 ) + loc_imax ( p , 2 ) * loc_jmax ( l , 2 ) * loc_kmax ( ip , & 2 ) !============================ if ( nptx_loc ( 5 ) > 0.0 ) then do ic = 5 , 6 n_peak = nptx_loc ( ic ) do i = 1 , n_peak xpt ( i , ic ) = xfsh + lpx ( 5 ) * ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) wghpt ( i , ic ) = np2 * wgh_sp ( ic ) end do end do xfsh = xfsh + lpx ( 5 ) !=================================== do ic = 5 , 6 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do p = imodx l = imody ip = imodz nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 5 ) * loc_jmax ( l , 5 ) * loc_kmax ( ip , & 5 ) nps_loc ( 3 ) = nps_loc ( 3 ) + loc_imax ( p , 6 ) * loc_jmax ( l , 6 ) * loc_kmax ( ip , & 6 ) end if !====================== npmax = maxval ( nps_loc ( 1 : nsp )) npmax = max ( npmax , 1 ) call p_alloc ( npmax , nd2 + 1 , nps_loc , nsp , lpf_ord , 1 , 1 , mem_psize ) !=========================== ip_el = 0 ip_pr = 0 ip_ion = 0 !============ ! The first electron-proton(or C) foam layer if ( nxl ( 1 ) > 0 ) then p = 0 i2 = loc_imax ( imodx , 3 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 3 , & i2 , ip_el ) p = 0 i2 = loc_imax ( imodx , 4 ) call pspecies_distribute ( spec ( 3 ), t0_pl ( 3 ), unit_charge ( 3 ), p , 4 , & i2 , ip_pr ) end if !========================= ! The second electron-ion solid electron-Z1 layer p = ip_el i2 = loc_imax ( imodx , 1 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 1 , i2 , & ip_el ) p = 0 i2 = loc_imax ( imodx , 2 ) call pspecies_distribute ( spec ( 2 ), t0_pl ( 2 ), unit_charge ( 2 ), p , 2 , i2 , & ip_ion ) !============ ! The third electron-proton layer !========================= if ( nxl ( 5 ) > 0.0 ) then p = ip_el i2 = loc_imax ( imodx , 5 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 5 , & i2 , ip ) p = ip_pr i2 = loc_imax ( imodx , 6 ) call pspecies_distribute ( spec ( 3 ), t0_pl ( 3 ), unit_charge ( 3 ), p , 6 , & i2 , ip ) end if do ic = 1 , nsp loc_npart ( imody , imodz , imodx , ic ) = nps_loc ( ic ) end do !============ end subroutine !======================= subroutine multi_layer_threesp_target ( nyh_in , xf0 ) integer , intent ( in ) :: nyh_in real ( dp ), intent ( in ) :: xf0 integer :: p , ip integer :: l , i , i1 , i2 , ic integer :: n_peak , nptx_loc ( 7 ) integer :: npmax , nps_loc ( 4 ) real ( dp ) :: uu , xp_min , xp_max , np1_loc real ( dp ) :: xfsh , l_inv , wgh_sp ( 7 ) integer :: nxl ( 6 ) integer :: ip_ion , ip_el , ip_pr !================= call set_uniform_yz_distrib ( nyh_in , 7 ) !=========================== xp_min = xmin xp_max = xmax !============= ! weights in central layer are wgh_sp(1:3) nxl = 0 !============================= ! Multispecies  designed for nsp >2 ! Particles distribution np_per_yc(1:3) and np_per_xc(1:3) central target ! (El+Z1+ Z2 !                        np_per_yc(5:6) and np_per_xc(5:6) !                        contaminants (El+Z3) in front and rear layers !                        if contaminants: nsp=4(Z3/= Z2) if nps=3 Z3=Z2 !============================================= !WARNING  nm_per_cell(1:3) and mp_per_cell(5:6) have to be set in a way global !zero charge per cell is assured ! In central layer: ! Electron number mp_per_cell(1)= Z1*mp_per_cell(2) +Z2*mp_per_cell(3) !============================= xtot = 0.0 do i = 1 , 5 nxl ( i ) = nint ( dx_inv * lpx ( i )) lpx ( i ) = nxl ( i ) * dx xtot = xtot + lpx ( i ) end do xfsh = xf0 + lpx ( 7 ) targ_in = xfsh targ_end = targ_in + xtot ! Species x-distribution !=  np_per_xc(1:3) electrons, Z1 and Z2 ions in central layer lpx(2)+lpx(3) !=  np_per_xc(5:6) electrons and Z3-ions front and rear side contaminants (same !composition) If nsp=3 Z3=Z2 !====================================== nptx_loc ( 1 : 3 ) = ( nxl ( 2 ) + nxl ( 3 )) * np_per_xc ( 1 : 3 ) nptx_loc ( 4 : 5 ) = nxl ( 1 ) * np_per_xc ( 5 : 6 ) nptx_loc ( 6 : 7 ) = nxl ( 5 ) * np_per_xc ( 5 : 6 ) !============ nptx(nsp)  distribution nptx ( 1 ) = nptx_loc ( 1 ) + nptx_loc ( 4 ) + nptx_loc ( 6 ) !electrons nptx ( 2 ) = nptx_loc ( 2 ) !Z1-A1 species nptx ( 3 ) = nptx_loc ( 3 ) !Z2-A2 species nptx ( 4 ) = nptx_loc ( 5 ) + nptx_loc ( 7 ) !Z3-A3  species in nxl(1) and nxl(5) layer nptx_max = maxval ( nptx_loc ( 1 : 7 )) !======================= allocate ( xpt ( nptx_max , 7 )) allocate ( wghpt ( nptx_max , 7 )) allocate ( loc_xpt ( nptx_max , 7 )) allocate ( loc_wghx ( nptx_max , 7 )) wghpt ( 1 : nptx_max , 1 : 7 ) = 1. !============================= ! nsp ordering: electrons+ Z1 ions + Z2 ions ! first and last layers: electrons and Z3 (protons) ions loc_imax ( imodx , 1 : 7 ) = nptx_loc ( 1 : 7 ) nps_loc = 0 !========================================== wgh_sp ( 1 ) = j0_norm * ratio_mpc ( 5 ) wgh_sp ( 2 ) = j0_norm * ratio_mpc ( 6 ) / real ( ion_min ( nsp - 1 ), dp ) wgh_sp ( 3 : 5 ) = j0_norm !=================================== if ( nxl ( 1 ) > 0 ) then !first contaminant layer El+Z(nsp-1) do ic = 4 , 5 n_peak = nptx_loc ( ic ) do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) xpt ( i , ic ) = xfsh + lpx ( 1 ) * uu wghpt ( i , ic ) = np1 * wgh_sp ( ic ) !pp weights using mp_per_cell(5:6) end do end do xfsh = xfsh + lpx ( 1 ) !=========== Distributes on x-MPI tasks do ic = 4 , 5 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do !======================== !======================== p = imodx l = imody ip = imodz ! Counts particles (e+Z3 ions) nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 4 ) * loc_jmax ( l , 4 ) * loc_kmax ( ip , & 4 ) nps_loc ( nsp ) = nps_loc ( nsp ) + loc_imax ( p , 5 ) * loc_jmax ( l , 5 ) * loc_kmax & ( ip , 5 ) end if !==================== ! Electrons and (Z1+Z2)_ions : central layer with lpx(2) preplasma ! x distribution !==================== np1_loc = 0.005 if ( np1 > 0.0 ) np1_loc = np1 l_inv = log ( 1. / np1_loc ) do ic = 1 , 3 n_peak = nptx_loc ( ic ) !central target do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) xpt ( i , ic ) = xfsh + ( lpx ( 2 ) + lpx ( 3 )) * uu wghpt ( i , ic ) = wgh_sp ( ic ) !weights usig mp_per_cell(1:3)  (El, Z1, Z2) ions end do if ( nxl ( 2 ) > 0 ) then n_peak = nxl ( 2 ) * np_per_xc ( ic ) !preplasma do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) wghpt ( i , ic ) = wghpt ( i , ic ) * np1_loc * exp ( uu * l_inv ) end do end if end do xfsh = xfsh + lpx ( 3 ) + lpx ( 2 ) !============================= ! Charge equilibria mp_per_cell(4)*Z1 +mp_per_cell(5)*Z3= mp_per_cell(1) !========================== !=========== Distributes on x-MPI tasks do ic = 1 , 3 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . xpt ( i , ic ) < loc_xgrid ( & imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do p = imodx l = imody ip = imodz nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 1 ) * loc_jmax ( l , 1 ) * loc_kmax ( ip , & 1 ) nps_loc ( 2 ) = nps_loc ( 2 ) + loc_imax ( p , 2 ) * loc_jmax ( l , 2 ) * loc_kmax ( ip , & 2 ) nps_loc ( 3 ) = nps_loc ( 3 ) + loc_imax ( p , 3 ) * loc_jmax ( l , 3 ) * loc_kmax ( ip , & 3 ) !============================ if ( lpx ( 5 ) > 0.0 ) then do ic = 6 , 7 n_peak = nptx_loc ( ic ) do i = 1 , n_peak xpt ( i , ic ) = xfsh + lpx ( 5 ) * ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) wghpt ( i , ic ) = np2 * wgh_sp ( ic - 5 ) !weights using mp_per_cell(5:6) as in layer lpx(1) end do end do xfsh = xfsh + lpx ( 5 ) !=============================== do ic = 6 , 7 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do p = imodx l = imody ip = imodz nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 6 ) * loc_jmax ( l , 6 ) * loc_kmax ( ip , & 6 ) nps_loc ( nsp ) = nps_loc ( nsp ) + loc_imax ( p , 7 ) * loc_jmax ( l , 7 ) * loc_kmax & ( ip , 7 ) end if !====================== npmax = maxval ( nps_loc ( 1 : nsp )) npmax = max ( npmax , 1 ) call p_alloc ( npmax , nd2 + 1 , nps_loc , nsp , lpf_ord , 1 , 1 , mem_psize ) !=========================== ip_el = 0 ip_pr = 0 ip_ion = 0 !============ ! The first electron-Z3 layer if ( nxl ( 1 ) > 0 ) then p = 0 i2 = loc_imax ( imodx , 4 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 4 , & i2 , ip_el ) p = 0 i2 = loc_imax ( imodx , 5 ) call pspecies_distribute ( spec ( nsp ), t0_pl ( nsp ), unit_charge ( nsp ), p , & 5 , i2 , ip_pr ) !Z3 for nsp=4  Z3=Z2 for nsp=3 end if !========================= ! The second solid electron-Z1-Z2 layer p = ip_el i2 = loc_imax ( imodx , 1 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 1 , i2 , & ip_el ) p = 0 i2 = loc_imax ( imodx , 2 ) call pspecies_distribute ( spec ( 2 ), t0_pl ( 2 ), unit_charge ( 2 ), p , 2 , i2 , & ip_ion ) p = 0 if ( nsp == 3 ) p = ip_pr i2 = loc_imax ( imodx , 3 ) call pspecies_distribute ( spec ( 3 ), t0_pl ( 3 ), unit_charge ( 3 ), p , 3 , i2 , & ip_ion ) !============ ! The third electron-proton layer !========================= if ( nxl ( 5 ) > 0.0 ) then p = ip_el i2 = loc_imax ( imodx , 6 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 6 , & i2 , ip ) p = ip_pr if ( nsp == 3 ) p = ip_ion i2 = loc_imax ( imodx , 7 ) call pspecies_distribute ( spec ( nsp ), t0_pl ( nsp ), unit_charge ( nsp ), p , & 7 , i2 , ip ) end if do ic = 1 , nsp loc_npart ( imody , imodz , imodx , ic ) = nps_loc ( ic ) end do !============ end subroutine !===================== subroutine one_layer_nano_wires ( nyh_in , xf0 ) integer , intent ( in ) :: nyh_in real ( dp ), intent ( in ) :: xf0 integer :: p , ip integer :: l , i , i1 , i2 , ic integer :: np_per_zcell ( 6 ), n_peak integer :: nptx_loc ( 8 ) integer :: npty_layer ( 8 ), npyc ( 8 ), npty_ne , nptz_ne integer :: npmax , nps_loc ( 4 ) real ( dp ) :: uu , yy , dxip , dpy real ( dp ) :: zp_min , zp_max , yp_min , yp_max , xp_min , xp_max real ( dp ) :: xfsh , dlpy , tot_lpy , loc_ymp integer :: z2 , nxl ( 6 ), nyl1 , nlpy , nholes integer :: ip_ion , ip_el , ip_pr , nwires real ( dp ), allocatable :: wy (:, :), wz (:, :), wyz (:, :, :) !================= !++++++++++++++++ WARNING ! ONLY layers (3) and (4) n_over_nc, np2*n_over_nc layer (5) !============================ xp_min = xmin xp_max = xmax np_per_zcell ( 1 : 6 ) = 1 !============================ nxl = 0 z2 = ion_min ( nsp - 1 ) !========= gridding the transverese target size nyl1 = 1 + ny / 2 - nyh_in / 2 !=1 if nyh_in=ny yp_min = ymin_t yp_max = ymax_t dlpy = lpy ( 1 ) !nanowire (y,z) thickness tot_lpy = dlpy + lpy ( 2 ) !distance among elements (void+nanowire)` nwires = nint (( yp_max - yp_min ) / tot_lpy ) !numbers of lpy elements nlpy = nint ( dy_inv * dlpy ) ! cell numbers in dlpy nholes = nint ( dy_inv * lpy ( 2 )) ! cell number in the lpy(2) interwire region if ( pe0 ) then write ( 6 , '(a18,i6)' ) ' Nanowires number ' , nwires write ( 6 , '(a23,i6)' ) ' Grid-points per nanow ' , nlpy end if !============================= ! Multispecies !============================= npty = maxval ( np_per_yc ( 1 : 6 )) npty = nyh_in * npty nptz = 1 if ( ndim == 3 ) then np_per_zcell ( 1 : 6 ) = np_per_yc ( 1 : 6 ) zp_min = zmin_t !-Lz zp_max = zmax_t !+Lz nptz = maxval ( np_per_zc ( 1 : 6 )) nptz = nyh_in * nptz end if allocate ( ypt ( npty + 1 , 8 )) allocate ( zpt ( nptz + 1 , 8 )) allocate ( wy ( npty + 1 , 8 )) allocate ( wz ( nptz + 1 , 8 )) allocate ( wyz ( npty + 1 , nptz + 1 , 8 )) ypt = 0. zpt = 0. wy = 1. wz = 1. wyz = 1. !================== allocate ( loc_jmax ( 0 : npe_yloc - 1 , 1 : 8 )) allocate ( loc_kmax ( 0 : npe_zloc - 1 , 1 : 8 )) allocate ( loc_imax ( 0 : npe_xloc - 1 , 1 : 8 )) !==================== !layers in y-z transverse coordinates !==================================== npyc ( 1 : 2 ) = np_per_yc ( 1 : 2 ) !layer of nano_wires electron+Z1_ion npyc ( 3 : 4 ) = np_per_yc ( 1 : 2 ) !layer of inter wire plasma of np1 density layer[1:4] of x-length=lpx(3) npyc ( 5 : 6 ) = np_per_yc ( 3 : 4 ) !bulk of electron-Z1_ion      x-length lpx(4) npyc ( 7 : 8 ) = np_per_yc ( 5 : 6 ) ! coating of electron-Z2_ion      x-length lpx(5) nptz_ne = 1 if ( nwires > 2 ) then do ic = 1 , 2 npty_ne = nlpy * npyc ( ic ) !number of yp points in a dlpy layer i2 = 0 loc_ymp = yp_min + lpy ( 2 ) do i1 = 1 , nwires !layers of lpy=dlpy(1+rat) length dpy = dlpy / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i + i2 , ic ) = loc_ymp + dpy * ( real ( i , dp ) - 0.1 ) end do i2 = i2 + npty_ne loc_ymp = loc_ymp + tot_lpy end do npty_layer ( ic ) = i2 end do do ic = 3 , 4 npty_ne = nholes * npyc ( ic ) !number of yp points in a lpy(2) layer i2 = 0 loc_ymp = yp_min do i1 = 1 , nwires dpy = lpy ( 2 ) / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i + i2 , ic ) = loc_ymp + dpy * ( real ( i , dp ) - 0.1 ) end do i2 = i2 + npty_ne loc_ymp = loc_ymp + tot_lpy end do npty_layer ( ic ) = i2 !=========================== end do if ( lpx ( 4 ) <= 0 ) then do ic = 7 , 8 npty_ne = nlpy * npyc ( ic ) !number of yp points in a dlpy layer i2 = 0 loc_ymp = yp_min + lpy ( 2 ) do i1 = 1 , nwires !layers of lpy=dlpy(1+rat) length dpy = dlpy / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i + i2 , ic ) = loc_ymp + dpy * ( real ( i , dp ) - 0.1 ) end do i2 = i2 + npty_ne loc_ymp = loc_ymp + tot_lpy end do npty_layer ( ic ) = i2 end do end if else !two nanowires filled with n1_over_nc (el+Z1) plasma do ic = 1 , 2 npty_ne = nlpy * npyc ( ic ) !number of yp points in a dlpy layer i2 = 0 loc_ymp = - 0.5 * tot_lpy dpy = dlpy / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i + i2 , ic ) = loc_ymp + dpy * ( real ( i , dp ) - 0.1 ) end do loc_ymp = loc_ymp + lpy ( 2 ) !first layer i2 = i2 + npty_ne !=========================== do i = 1 , npty_ne ypt ( i + i2 , ic ) = loc_ymp + dpy * ( real ( i , dp ) - 0.1 ) end do i2 = i2 + npty_ne !==================== npty_layer ( ic ) = i2 end do do ic = 3 , 4 npty_ne = nholes * npyc ( ic ) !number of yp points in a lpy(2) layer loc_ymp = - 0.5 * lpy ( 2 ) dpy = lpy ( 2 ) / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i , ic ) = loc_ymp + dpy * ( real ( i , dp ) - 0.1 ) end do npty_layer ( ic ) = npty_ne !=========================== end do if ( lpx ( 4 ) <= 0 ) then do ic = 7 , 8 npty_ne = nlpy * npyc ( ic ) !number of yp points in a dlpy layer i2 = 0 loc_ymp = - 0.5 * tot_lpy dpy = dlpy / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i + i2 , ic ) = loc_ymp + dpy * ( real ( i , dp ) - 0.1 ) end do loc_ymp = loc_ymp + lpy ( 2 ) !first layer i2 = i2 + npty_ne !=========================== do i = 1 , npty_ne ypt ( i + i2 , ic ) = loc_ymp + dpy * ( real ( i , dp ) - 0.1 ) end do i2 = i2 + npty_ne !==================== npty_layer ( ic ) = i2 end do end if end if !============= Uniform y-z distribution in layers [5-8] do ic = 5 , 6 npty_layer ( ic ) = nyh_in * npyc ( ic ) npty_ne = npty_layer ( ic ) dpy = ( yp_max - yp_min ) / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i , ic ) = yp_min + dpy * ( real ( i , dp ) - 0.5 ) end do end do if ( lpx ( 4 ) > 0 ) then do ic = 7 , 8 npty_layer ( ic ) = nyh_in * npyc ( ic ) npty_ne = npty_layer ( ic ) dpy = ( yp_max - yp_min ) / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i , ic ) = yp_min + dpy * ( real ( i , dp ) - 0.5 ) end do end do end if !========= For all (y,z) coordinates do ic = 1 , 8 npty_ne = npty_layer ( ic ) if ( stretch ) then yy = str_ygrid % smin if ( yy > yp_min ) then dpy = dyi / real ( npyc ( ic ), dp ) i1 = ( str_ygrid % sind ( 1 ) - nyl1 + 1 ) * npyc ( ic ) i2 = npty_ne - i1 do i = 1 , i1 dxip = dpy * ( real ( i - i1 , dp ) - 0.5 ) ypt ( i , ic ) = str_ygrid % smin + l_s * tan ( dxip ) wy ( i , ic ) = 1. / ( cos ( dxip ) * cos ( dxip )) end do dxip = dy / real ( npyc ( ic ), dp ) do i = i1 + 1 , i2 ypt ( i , ic ) = str_ygrid % smin + dxip * ( real ( i - i1 , dp ) - 0.5 ) end do do i = i2 + 1 , npty_ne dxip = dpy * ( real ( i - i2 , dp ) - 0.5 ) ypt ( i , ic ) = str_ygrid % smax + l_s * tan ( dxip ) wy ( i , ic ) = 1. / ( cos ( dxip ) * cos ( dxip )) end do end if end if !============= end stretching correction nptz_ne = 1 if ( ndim == 3 ) then zpt ( 1 : npty_ne , ic ) = ypt ( 1 : npty_ne , ic ) wz ( 1 : npty_ne , ic ) = wy ( 1 : npty_ne , ic ) nptz_ne = npty_ne end if call set_pgrid_ind ( npty_ne , nptz_ne , ic ) end do !=================== y-z data on local arrays loc_npty ( 1 : 8 ) = loc_jmax ( imody , 1 : 8 ) loc_nptz ( 1 : 8 ) = loc_kmax ( imodz , 1 : 8 ) npty_ne = 1 nptz_ne = 1 npty_ne = maxval ( loc_npty ( 1 : 8 )) nptz_ne = maxval ( loc_nptz ( 1 : 8 )) !====================== allocate ( loc_wghyz ( npty_ne , nptz_ne , 8 )) allocate ( loc_ypt ( npty_ne , 8 )) allocate ( loc_zpt ( nptz_ne , 8 )) loc_wghyz = 1. call mpi_yz_part_distrib ( 8 , loc_npty , loc_nptz , npty_layer , & npty_layer , ymin_t , zmin_t , wyz ) !======================= !Longitudinal layer distribution !=========================== xtot = 0.0 lpx ( 1 : 2 ) = 0.0 !only layers 3-4-5 do i = 1 , 5 nxl ( i ) = nint ( dx_inv * lpx ( i )) lpx ( i ) = nxl ( i ) * dx xtot = xtot + lpx ( i ) end do xfsh = xf0 targ_in = xfsh targ_end = targ_in + xtot ! Input particles !====np_per_xc(1:2) electrons and Z1 ions in the nanowires target + !internanow-plasma => lpx(3) !====np_per_xc(3:4) electrons and Z1 ions in bulk layer !=== np_per_xc(5:6) electrons and Z2=proton in contaminant layer !  Particles grid ordering !  only nxl(3) nxl(4) and nxl(5) layers activated nptx_loc ( 1 : 2 ) = nxl ( 3 ) * np_per_xc ( 1 : 2 ) !inter-wire  electrons+Z1-ion plasma nptx_loc ( 3 : 4 ) = nptx_loc ( 1 : 2 ) !nanowires electron-Z1 ions nptx_loc ( 5 : 6 ) = nxl ( 4 ) * np_per_xc ( 3 : 4 ) !bulk layer electrons +Z1 ions nptx_loc ( 7 : 8 ) = nxl ( 5 ) * np_per_xc ( 5 : 6 ) !contaminant electrons +Z2 ions (proton) nptx_max = maxval ( nptx_loc ( 1 : 8 )) !======================= allocate ( xpt ( nptx_max , 8 )) allocate ( wghpt ( nptx_max , 8 )) allocate ( loc_xpt ( nptx_max , 8 )) allocate ( loc_wghx ( nptx_max , 8 )) wghpt ( 1 : nptx_max , 1 : 8 ) = 1. !================= !======================== loc_imax ( imodx , 1 : 8 ) = nptx_loc ( 1 : 8 ) nps_loc ( 1 : nsp ) = 0 ! Nanowires x-layer: electrons and Z1-ions ! nanowires density is the reference density if ( nxl ( 3 ) > 0 ) then do ic = 1 , 2 n_peak = nptx_loc ( ic ) if ( n_peak > 0 ) then do i = 1 , n_peak uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) xpt ( i , ic ) = xfsh + lpx ( 3 ) * uu wghpt ( i , ic ) = ratio_mpc ( ic ) * j0_norm xpt ( i , ic + 2 ) = xpt ( i , ic ) wghpt ( i , ic + 2 ) = np1 * wghpt ( i , ic ) !inter-wire plasma (or vacuum) end do end if !========================= np1>0 a low density  interwire plasma end do xfsh = xfsh + lpx ( 3 ) !============= first x-layer distributed on locx mpi tasks do ic = 1 , 2 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) loc_xpt ( i1 , ic + 2 ) = xpt ( i , ic + 2 ) loc_wghx ( i1 , ic + 2 ) = wghpt ( i , ic + 2 ) end if end do loc_imax ( imodx , ic ) = i1 loc_imax ( imodx , ic + 2 ) = i1 end do !======================== p = imodx l = imody ip = imodz nps_loc = 0 ! Counts particles nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 1 ) * loc_jmax ( l , 1 ) * loc_kmax ( ip , & 1 ) nps_loc ( 2 ) = nps_loc ( 2 ) + loc_imax ( p , 2 ) * loc_jmax ( l , 2 ) * loc_kmax ( ip , & 2 ) if ( np1 > 0.0 ) then nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 3 ) * loc_jmax ( l , 3 ) * loc_kmax ( ip & , 3 ) nps_loc ( 2 ) = nps_loc ( 2 ) + loc_imax ( p , 4 ) * loc_jmax ( l , 4 ) * loc_kmax ( ip & , 4 ) end if end if !------------------------------ !  Electrons and Z1_ions: bulk layer !     x distribution. Density given by the particle density mpc(3:4) !==================== if ( nxl ( 4 ) > 0 ) then do ic = 5 , 6 n_peak = nptx_loc ( ic ) if ( n_peak > 0 ) then do i = 1 , n_peak xpt ( i , ic ) = xfsh + lpx ( 4 ) * ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) uu = j0_norm * ratio_mpc ( ic - 2 ) wghpt ( i , ic ) = uu end do end if end do xfsh = xfsh + lpx ( 4 ) do ic = 5 , 6 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 end do p = imodx l = imody ip = imodz nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 5 ) * loc_jmax ( l , 5 ) * loc_kmax ( ip , & 5 ) nps_loc ( 2 ) = nps_loc ( 2 ) + loc_imax ( p , 6 ) * loc_jmax ( l , 6 ) * loc_kmax ( ip , & 6 ) end if !  Electrons and Z3_ions contaminants !     x distribution density given by np2 !==================== if ( nxl ( 5 ) > 0 ) then do ic = 7 , 8 n_peak = nptx_loc ( ic ) if ( n_peak > 0 ) then do i = 1 , n_peak xpt ( i , ic ) = xfsh + lpx ( 5 ) * ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) uu = j0_norm * ratio_mpc ( ic - 2 ) wghpt ( i , ic ) = uu * np2 end do end if end do ic = 8 n_peak = nptx_loc ( ic ) wghpt ( 1 : n_peak , ic ) = wghpt ( 1 : n_peak , ic ) / real ( ion_min ( nsp - 1 ), dp ) xfsh = xfsh + lpx ( 5 ) !=============== do ic = 7 , 8 i1 = 0 do i = 1 , nptx_loc ( ic ) if ( xpt ( i , ic ) >= loc_xgrid ( imodx )% gmin . and . & xpt ( i , ic ) < loc_xgrid ( imodx )% gmax ) then i1 = i1 + 1 loc_xpt ( i1 , ic ) = xpt ( i , ic ) loc_wghx ( i1 , ic ) = wghpt ( i , ic ) end if end do loc_imax ( imodx , ic ) = i1 - 1 end do p = imodx l = imody ip = imodz nps_loc ( 1 ) = nps_loc ( 1 ) + loc_imax ( p , 7 ) * loc_jmax ( l , 7 ) * loc_kmax ( ip , & 7 ) nps_loc ( nsp ) = nps_loc ( nsp ) + loc_imax ( p , 8 ) * loc_jmax ( l , 8 ) * loc_kmax & ( ip , 8 ) end if !==============END target x-distribution !============== npmax = maxval ( nps_loc ( 1 : nsp )) npmax = max ( npmax , 1 ) call p_alloc ( npmax , nd2 + 1 , nps_loc , nsp , lpf_ord , 1 , 1 , mem_psize ) !=========================== ip_el = 0 ip_pr = 0 ip_ion = 0 ! The first electron-Z1-ions nanowires layer if ( nxl ( 3 ) > 0 ) then p = 0 i2 = loc_imax ( imodx , 1 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 1 , & i2 , ip_el ) p = 0 i2 = loc_imax ( imodx , 2 ) call pspecies_distribute ( spec ( 2 ), t0_pl ( 2 ), unit_charge ( 2 ), p , 2 , & i2 , ip_ion ) if ( np1 > 0.0 ) then p = ip_el i2 = loc_imax ( imodx , 3 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 3 , & i2 , ip_el ) p = ip_ion i2 = loc_imax ( imodx , 4 ) call pspecies_distribute ( spec ( 2 ), t0_pl ( 2 ), unit_charge ( 2 ), p , 4 , & i2 , ip_ion ) end if end if !========================= ! The second electron-ion solid layer with Z1 A1 ion element if ( nxl ( 4 ) > 0 ) then p = ip_el i2 = loc_imax ( imodx , 5 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 5 , & i2 , ip_el ) p = ip_ion i2 = loc_imax ( imodx , 6 ) call pspecies_distribute ( spec ( 2 ), t0_pl ( 2 ), unit_charge ( 2 ), p , 6 , & i2 , ip_ion ) end if !============ ! The contaminant electron-ion solid layer Z3=proton ion element if ( nxl ( 5 ) > 0 ) then p = ip_el i2 = loc_imax ( imodx , 7 ) call pspecies_distribute ( spec ( 1 ), t0_pl ( 1 ), unit_charge ( 1 ), p , 7 , & i2 , ip_el ) p = 0 i2 = loc_imax ( imodx , 8 ) call pspecies_distribute ( spec ( nsp ), t0_pl ( nsp ), unit_charge ( nsp ), p , & 8 , i2 , ip_ion ) end if do ic = 1 , nsp loc_npart ( imody , imodz , imodx , ic ) = nps_loc ( ic ) end do end subroutine !============ subroutine one_layer_nano_tubes ( nyh_in , xf0 ) integer , intent ( in ) :: nyh_in real ( dp ), intent ( in ) :: xf0 integer :: p integer :: i , j , i1 , i2 , ic , k1 , k2 integer :: np_per_zcell ( 2 ), n_peak , ntubes integer :: npty_ne , nptz_ne integer :: npmax , nps_loc ( 2 ) real ( dp ) :: uu , dpy , dlpy , rat real ( dp ) :: zp_min , zp_max , yp_min , yp_max , xp_min , xp_max real ( dp ) :: loc_ym , loc_ymx , loc_zm , loc_zmx real ( dp ) :: xfsh , r_int , r_ext , ffactor integer :: nxl ( 5 ), npt_nano ( 4 ) integer :: nlpy integer :: npty_layer ( 2 ), nptz_layer ( 2 ) real ( dp ), allocatable :: wy (:, :), wz (:, :), wyz (:, :, :) real ( dp ), allocatable :: yc (:), ypt_nano (:, :), zpt_nano (:, :) real ( dp ), allocatable :: locy_nano (:, :), locz_nano (:, :) !================= xp_min = xmin xp_max = xmax np_per_zcell ( 1 : 2 ) = 1 !============================ nxl = 0 !========= gridding the transverese target size yp_min = ymin_t yp_max = ymax_t !=============================== ! Geometry |--s/2--|======v=====|---s/2--| ! total size L=s+v=s*(1+v/s)=s(1+rat) ! Filling factor f=(1-(v/L)&#94;2) !=========================== ! Two-species Electrons + Z ions !============================= npty = maxval ( np_per_yc ( 1 : 2 )) npty = nyh_in * npty !particles number in 3 nlpy slabs nptz = 1 if ( ndim == 3 ) then np_per_zcell ( 1 : 2 ) = np_per_zc ( 1 : 2 ) zp_min = yp_min !-Lz zp_max = yp_max !+Lz nptz = maxval ( np_per_zc ( 1 : 6 )) nptz = nyh_in * nptz end if allocate ( ypt ( npty , 2 )) allocate ( wy ( npty , 2 )) allocate ( zpt ( nptz , 2 )) allocate ( wz ( nptz , 2 )) wy = 1. wz = 1. !================== allocate ( loc_jmax ( 0 : npe_yloc - 1 , 1 : 2 )) allocate ( loc_kmax ( 0 : npe_zloc - 1 , 1 : 2 )) !==================== ! Uniform yp grid of size npty_ne do ic = 1 , 2 npty_ne = nyh_in * np_per_yc ( ic ) !number of yp points in 2*ymax size dpy = ( yp_max - yp_min ) / real ( npty_ne , dp ) do i = 1 , npty_ne ypt ( i , ic ) = yp_min + dpy * ( real ( i , dp ) - 0.5 ) end do npty_layer ( ic ) = npty_ne nptz_layer ( ic ) = 1 if ( ndim == 3 ) then i2 = npty_ne zpt ( 1 : i2 , ic ) = ypt ( 1 : i2 , ic ) wz ( 1 : i2 , ic ) = wy ( 1 : i2 , ic ) nptz_layer ( ic ) = i2 end if call set_pgrid_ind ( npty_layer ( ic ), nptz_layer ( ic ), ic ) end do !=========================== ! Layer lpx(3) for nanotubes lpx(4) for target xtot = 0.0 do i = 3 , 4 nxl ( i ) = nint ( dx_inv * lpx ( i )) lpx ( i ) = nxl ( i ) * dx xtot = xtot + lpx ( i ) end do xfsh = xf0 + lpx ( 7 ) targ_in = xfsh targ_end = targ_in + xtot !======================= ! Only layers 3 and 4 in x loc_nptx ( 1 : 2 ) = nxl ( 3 ) * np_per_xc ( 1 : 2 ) loc_nptx ( 3 : 4 ) = nxl ( 4 ) * np_per_xc ( 3 : 4 ) nptx_max = maxval ( loc_nptx ( 1 : 4 )) allocate ( xpt ( nptx_max , nsp )) allocate ( loc_xpt ( nptx_max , nsp )) allocate ( wghpt ( nptx_max , nsp )) !====================================== ! Uses the yp,zp=yp for ic=1,2 uniform p-grid ! to select a three-layer array of circular nanotubes !=============== dlpy = lpy ( 1 ) !2*dr  lpy(2)=2*r_int nlpy = nint ( dy_inv * dlpy ) ! cell numbers in [dlpy layer] rat = lpy ( 2 ) / dlpy r_int = 0.5 * lpy ( 2 ) r_ext = r_int + 0.5 * dlpy uu = ( yp_max - yp_min - 0.5 * dlpy ) / ( lpy ( 2 ) + 1.5 * dlpy ) ntubes = nint ( uu ) allocate ( yc ( ntubes )) !========================= yc ( 1 ) = yp_min + 0.5 * dlpy + r_ext do ic = 2 , ntubes yc ( ic ) = yc ( ic - 1 ) + lpy ( 2 ) + 1.5 * dlpy end do !========= filling factor ffactor = acos ( - 1. ) * ( r_ext * r_ext - r_int * r_int ) / ( lpy ( 2 ) + 1.5 * dlpy ) ** 2 !============================= do ic = 1 , 2 npty_ne = nyh_in * np_per_yc ( ic ) !number of yp points in Ly=2*ymax size nptz_ne = nyh_in * np_per_zc ( ic ) !number of zp points in Lz=2*zmax size npt_nano ( ic ) = 0 do k1 = 1 , ntubes do k2 = 1 , ntubes do i = 1 , nptz_ne do j = 1 , npty_ne dpy = sqrt (( ypt ( j , ic ) - yc ( k2 )) ** 2 + ( zpt ( i , ic ) - yc ( k1 )) ** 2 ) if ( dpy >= r_int . and . dpy < r_ext ) npt_nano ( ic ) = npt_nano ( ic ) + 1 end do end do end do end do end do ! npt_nano(ic) nanotubes section !==================== npty_ne = npt_nano ( 1 ) allocate ( ypt_nano ( npty_ne , nsp ), zpt_nano ( npty_ne , nsp )) loc_ym = loc_ygrid ( imody )% gmin loc_ymx = loc_ygrid ( imody )% gmax loc_zm = loc_zgrid ( imodz )% gmin loc_zmx = loc_zgrid ( imodz )% gmax do ic = 1 , 2 npty_ne = nyh_in * np_per_yc ( ic ) !number of yp points in 2*ymax size nptz_ne = nyh_in * np_per_zc ( ic ) !number of yp points in 2*ymax size i2 = 0 do k1 = 1 , ntubes do k2 = 1 , ntubes do i = 1 , nptz_ne do j = 1 , npty_ne dpy = sqrt (( ypt ( j , ic ) - yc ( k2 )) ** 2 + ( zpt ( i , ic ) - yc ( k1 )) ** 2 ) if ( dpy >= r_int . and . dpy < r_ext ) then i2 = i2 + 1 ypt_nano ( i2 , ic ) = ypt ( j , ic ) zpt_nano ( i2 , ic ) = zpt ( i , ic ) end if end do end do end do end do loc_npty ( ic ) = 0 do i = 1 , i2 uu = ypt_nano ( i , ic ) if ( uu >= loc_ym . and . uu < loc_ymx ) then uu = zpt_nano ( i , ic ) if ( uu >= loc_zm . and . uu < loc_zmx ) loc_npty ( ic ) = loc_npty ( ic ) + 1 end if end do end do npty_ne = loc_npty ( 1 ) nptz_ne = npty_ne !========================== if ( npty_ne > 0 ) then allocate ( locy_nano ( npty_ne , 2 )) allocate ( locz_nano ( nptz_ne , 2 )) end if !========================== !========== Nanotubes layer do ic = 1 , 2 if ( loc_nptx ( ic ) > 0 ) then k1 = 0 do i = 1 , npt_nano ( ic ) uu = ypt_nano ( i , ic ) if ( uu >= loc_ym . and . uu < loc_ymx ) then uu = zpt_nano ( i , ic ) if ( uu >= loc_zm . and . uu < loc_zmx ) then k1 = k1 + 1 locy_nano ( k1 , ic ) = ypt_nano ( i , ic ) locz_nano ( k1 , ic ) = zpt_nano ( i , ic ) end if end if end do loc_npty ( ic ) = k1 end if end do !============================ Flat target !==================================== loc_npty ( 1 : nsp ) = loc_jmax ( imody , 1 : nsp ) loc_nptz ( 1 : nsp ) = loc_kmax ( imodz , 1 : nsp ) npty_ne = 1 nptz_ne = 1 npty_ne = maxval ( loc_npty ( 1 : nsp )) nptz_ne = maxval ( loc_nptz ( 1 : nsp )) !====================== allocate ( loc_wghyz ( npty_ne , nptz_ne , nsp )) allocate ( loc_ypt ( npty_ne , nsp )) allocate ( loc_zpt ( nptz_ne , nsp )) loc_wghyz = 1. !============================ Uniform target call mpi_yz_part_distrib ( 2 , loc_npty , loc_nptz , npty_layer , & nptz_layer , ymin_t , zmin_t , wyz ) !========================== nptx ( 1 : nsp ) = 0 !======================== do ic = 1 , nsp i1 = nptx ( ic ) n_peak = nxl ( 3 ) * np_per_xc ( ic ) do i = 1 , n_peak i1 = i1 + 1 uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) xpt ( i1 , ic ) = xfsh + lpx ( 3 ) * uu wghpt ( i1 , ic ) = j0_norm if ( ic == 2 ) wghpt ( i1 , ic ) = wghpt ( i1 , ic ) * wgh_ion loc_xpt ( i1 , ic ) = xpt ( i1 , ic ) end do nptx ( ic ) = i1 end do xfsh = xfsh + lpx ( 3 ) if ( nxl ( 4 ) > 0 ) then !a bulk do ic = 1 , nsp i1 = nptx ( ic ) n_peak = nxl ( 4 ) * np_per_xc ( ic ) do i = 1 , n_peak i1 = i1 + 1 uu = ( real ( i , dp ) - 0.5 ) / real ( n_peak , dp ) xpt ( i1 , ic ) = xfsh + lpx ( 4 ) * uu wghpt ( i1 , ic ) = j0_norm loc_xpt ( i , ic ) = xpt ( i1 , ic ) end do nptx ( ic ) = i1 end do xfsh = xfsh + lpx ( 4 ) end if !=================== on index ic=2 are ions with charge Z_i=npc_e/npc_i !====================== do ic = 1 , nsp j = nptx ( ic ) if ( xpt ( j , ic ) > xmax ) then p = 0 do i = 1 , nptx_max if ( xpt ( i , ic ) <= xmax ) p = i !inside the box xpt[1:nptx(ic)] end do nptx ( ic ) = p end if end do !============ count partuckes of nano-tubes do ic = 1 , nsp nps_loc ( ic ) = 0 i2 = loc_nptx ( ic ) do k1 = 1 , loc_npty ( ic ) do i = 1 , i2 nps_loc ( ic ) = nps_loc ( ic ) + 1 end do end do if ( nptx ( ic ) > i2 ) then do i1 = 1 , loc_kmax ( imodz , ic ) do k1 = 1 , loc_jmax ( imody , ic ) do i = i2 + 1 , nptx ( ic ) nps_loc ( ic ) = nps_loc ( ic ) + 1 end do end do end do end if end do loc_npart ( imody , imodz , imodx , 1 : nsp ) = nps_loc ( 1 : nsp ) npmax = maxval ( nps_loc ( 1 : nsp )) npmax = max ( npmax , 1 ) call p_alloc ( npmax , nd2 + 1 , nps_loc , nsp , lpf_ord , 1 , 1 , mem_psize ) !=========================== call init_random_seed ( mype ) !============ do ic = 1 , nsp i2 = loc_nptx ( ic ) charge = int ( unit_charge ( ic )) p = 0 do k1 = 1 , loc_npty ( ic ) do i = 1 , i2 wgh = real ( wghpt ( i , ic ), sp ) p = p + 1 spec ( ic )% part ( p , 1 ) = xpt ( i , ic ) spec ( ic )% part ( p , 2 ) = locy_nano ( k1 , ic ) spec ( ic )% part ( p , 3 ) = locz_nano ( k1 , ic ) call gasdev ( uu ) spec ( ic )% part ( p , 4 ) = t0_pl ( ic ) * uu call gasdev ( uu ) spec ( ic )% part ( p , 5 ) = t0_pl ( ic ) * uu call gasdev ( uu ) spec ( ic )% part ( p , 6 ) = t0_pl ( ic ) * uu spec ( ic )% part ( p , 7 ) = wgh_cmp end do end do if ( nptx ( ic ) > loc_nptx ( ic )) then i2 = nptx ( ic ) + 1 - loc_nptx ( ic ) call pspecies_distribute ( spec ( ic ), t0_pl ( ic ), unit_charge ( ic ), p , & ic , i2 , i1 ) end if end do !============ end subroutine !==================================== subroutine part_distribute ( id , xf0 ) integer , intent ( in ) :: id real ( dp ), intent ( in ) :: xf0 integer :: ip , pp , l , p integer :: tot_nploc ( npe ) !================= if ( wake ) then !nps_run =1 !if nsp > 1 ions active only for ionization call multi_layer_gas_target ( id , ny_targ , xf0 ) !====================== !model id=1 !lpx(1) first plateau np1 density !ramp lpx(2)+ plateau lpx(3) + downramp lpx(4)] density 1 !lpx(5) last plateau np2 density !all densities normalized to n_0=n_over_nc !==================================== !model id=2  target with two central plateau (for shocked gas-jet) !lpx(1) first ramp up to lpx(2) first plateau at density np1 !lpx(3) downramp to !lpx(4) second plateau density np2 and to final downramp lpx(5) !n_0=n_over_nc can be an average, or n0_=n1_over_nc or n0_=n2_over_nc !Multispecies implementation ! target in models id=1 and id=2 contain (implicitely) an ion species id_sp=1 !as a neutralizing background. If ionization is on, nsp=2 and ionizing species !is loaded and activated for ionization. !==================================== !model id=3 as id=2, with two ion species, one as local dopant and the other !as a neutralizing background: ! layer(1) + layer(2) only electrons and H+ with ne=n0=n_over_nc ! layer(3) is a plateau with an added dopant (A1,Z1) with density ! np1=n1_over_n/n0 (few %) ! layer(4)+layer(5) as layer(1)+layer(2) !---------- else !SOLID MULTISPECIES TARGETS !flag id=1,2 allowed not even implemented select case ( id ) case ( 3 ) call preplasma_multisp ( ny_targ , xf0 ) ! (e+Z1) preplasma and central target !+ (e+Z2)coating case ( 4 ) call multi_layer_twosp_target ( ny_targ , xf0 ) !(e+Z2) foam !(e+Z1) central layer !(e+Z2)coating !============warning exponential ramp (in layer 2) always using (e+Z1) species case ( 5 ) call multi_layer_threesp_target ( ny_targ , xf0 ) !(e+Z3) coating !(e+Z1+Z2) central multispecies layer with lpx(2) preplasma !+ (e+Z3)coating case ( 6 ) call one_layer_nano_wires ( ny_targ , xf0 ) !e+Z1 wires, e+Z2 bulk. interwire low density (e+Z1) plasma allowed case ( 7 ) call one_layer_nano_tubes ( ny_targ , xf0 ) end select end if !===================Data for all models=============== tot_nploc = 0 pp = 0 do p = 0 , npe_xloc - 1 do ip = 0 , npe_zloc - 1 do l = 0 , npe_yloc - 1 pp = pp + 1 tot_nploc ( pp ) = sum ( loc_npart ( l , ip , p , 1 : nsp )) end do end do end do np_max = maxval ( tot_nploc ( 1 : npe )) np_min = minval ( tot_nploc ( 1 : npe )) do ip = 1 , npe if ( tot_nploc ( ip ) == np_max ) pe_npmax = ip - 1 if ( tot_nploc ( ip ) == np_min ) pe_npmin = ip - 1 end do !=============== end subroutine subroutine clean_field ( ef , lp1 , i1 , j1 , j2 , k1 , k2 , nc ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: lp1 integer , intent ( in ) :: i1 , j1 , j2 , k1 , k2 , nc integer :: ilp , i , j , k , ic ilp = int ( dx_inv * lp1 ) do ic = 1 , nc do k = k1 , k2 do j = j1 , j2 do i = i1 , ilp ef ( i , j , k , ic ) = 0.0 end do end do end do end do end subroutine !========================= end module","tags":"","loc":"sourcefile/init_part_distrib.f90.html"},{"title":"pic_out.f90 – ALaDyn","text":"This file depends on sourcefile~~pic_out.f90~~EfferentGraph sourcefile~pic_out.f90 pic_out.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~pic_out.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~pic_out.f90->sourcefile~common_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~pic_out.f90->sourcefile~parallel.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~pic_out.f90->sourcefile~fstruct_data.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~pic_out.f90->sourcefile~code_util.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~pic_out.f90->sourcefile~grid_param.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pic_out.f90~~AfferentGraph sourcefile~pic_out.f90 pic_out.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules pic_out Source Code pic_out.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module pic_out use pstruct_data use fstruct_data use code_util use common_param use grid_param use parallel implicit none integer , parameter , private :: par_dim = 20 integer , private :: int_par ( par_dim ), part_int_par ( par_dim ) real ( sp ), private :: real_par ( par_dim ), part_real_par ( par_dim ) character ( 13 ), dimension ( 20 ), parameter , private :: rpar = [ ' time =      ' , & ' xmin =      ' , ' xmax =      ' , ' ymin =      ' , ' ymax =      ' , & ' zmin =      ' , ' zmax =      ' , ' w0_x =      ' , ' w0_y =      ' , & ' a0 =        ' , ' lam0 =      ' , ' mc2(MeV) =  ' , ' n0(e18) =   ' , & ' np/cell =   ' , ' weight =    ' , ' mass =      ' , ' xmin_out =  ' , & ' xmax_out =  ' , ' ymax_out =  ' , ' gam_min =   ' ] character ( 12 ), dimension ( 20 ), parameter , private :: ipar = [ ' npe =      ' , & ' nx =       ' , ' ny =       ' , ' nz =       ' , ' model =    ' , & ' dmodel =   ' , ' nsp =      ' , ' curr_ndim =' , ' mp/cell =  ' , & ' ion_ch =   ' , ' tsch_ord = ' , ' der_ord =  ' , ' iform =    ' , & ' ph_sp_nc = ' , ' f_version =' , ' i_end =    ' , ' nx_loc =   ' , & ' ny_loc =   ' , ' nz_loc =   ' , ' pjump  =   ' ] contains subroutine endian ( iend ) implicit none integer , intent ( out ) :: iend integer , parameter :: ik1 = selected_int_kind ( 2 ) integer , parameter :: ik4 = selected_int_kind ( 9 ) iend = 0 if ( btest ( transfer ( int ([ 1 , 0 , 0 , 0 ], ik1 ), 1_ik4 ), 0 )) then iend = 1 else iend = 2 end if end subroutine subroutine fluid_den_mom_out ( fvar , cmp , flcomp ) real ( dp ), intent ( in ) :: fvar (:, :, :, :) integer , intent ( in ) :: cmp , flcomp character ( 9 ) :: fname = '         ' character ( 7 ), dimension ( 4 ), parameter :: flvar = [ 'Fdenout' , & 'Flpxout' , 'Flpyout' , 'Flpzout' ] integer :: ix , iy , iz , iq , ipe integer :: lenw , kk , nx1 , ny1 , nz1 integer :: gr_dim ( 3 ), i_end , cmp_name integer :: lun , i1 , j1 , k1 logical :: sd character ( 4 ) :: foldername integer , parameter :: file_version = 2 !======================== ! ns_index select ion species ! cmp select components (density, energy,..) ! cmp_loc is the index of output data:  jc(cmp_loc) write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 lun = 0 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( fvar ( ix , iy , iz , cmp ), sp ) end do end do end do if ( cmp == flcomp ) then cmp_name = 1 else cmp_name = cmp + 1 end if if ( pe0 ) then call endian ( i_end ) nx1 = sum ( nxh ( 1 : npe_xloc )) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , & loc_nyc_max , nz1 , loc_nzc_max , jump , iby , iform , model_id , & dmodel_id , nsp , curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , & file_version , i_end ] write ( fname , '(a7,i2.2)' ) flvar ( cmp_name ), iout open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Integer parameters' write ( 10 , '(4i14)' ) int_par write ( 10 , * ) ' Real parameters' write ( 10 , '(4e14.5)' ) real_par close ( 10 ) write ( 6 , * ) 'Field data written on file: ' // foldername // '/' // & fname // '.dat' gr_dim ( 1 ) = nxh ( 1 ) gr_dim ( 2 ) = nyh ( 1 ) gr_dim ( 3 ) = nzh ( 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) lun = 10 open ( 10 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) write ( 10 ) par_dim write ( 10 ) int_par write ( 10 ) real_par write ( 10 ) gr_dim write ( 10 ) wdata ( 1 : lenw ) end if if ( mype > 0 ) then gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) sd = . true . call exchange_pdata ( sd , wdata , lenw , pe_min , mype + 100 ) else sd = . false . do ix = 0 , npe_xloc - 1 gr_dim ( 1 ) = nxh ( ix + 1 ) do iz = 0 , npe_zloc - 1 gr_dim ( 3 ) = nzh ( iz + 1 ) do iy = 0 , npe_yloc - 1 gr_dim ( 2 ) = nyh ( iy + 1 ) ipe = iy + npe_yloc * ( iz + npe_zloc * ix ) if ( ipe > 0 ) then lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) call exchange_pdata ( sd , wdata , lenw , ipe , ipe + 100 ) write ( lun ) gr_dim write ( lun ) wdata ( 1 : lenw ) end if end do end do end do kk = 0 do iq = 1 , nx , jump kk = kk + 1 gwdata ( kk ) = real ( x ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , ny , jump kk = kk + 1 gwdata ( kk ) = real ( y ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , nz , jump kk = kk + 1 gwdata ( kk ) = real ( z ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) close ( 10 ) write ( 6 , * ) 'Fluid density-momenta written on file: ' // & foldername // '/' // fname // '.bin' end if end subroutine !================================== subroutine den_energy_out ( ns_ind , cmp , cmp_loc ) integer , intent ( in ) :: ns_ind , cmp , cmp_loc !================ character ( 9 ) :: fname = '         ' character ( 7 ), dimension ( 1 ), parameter :: bpot = [ 'Beampot' ] character ( 7 ), dimension ( 2 ), parameter :: el1 = [ 'Edenout' , & 'Elenout' ] character ( 7 ), dimension ( 2 ), parameter :: pr1 = [ 'Pdenout' , & 'Prenout' ] character ( 7 ), dimension ( 2 ), parameter :: io1 = [ 'H1dnout' , & 'H1enout' ] character ( 7 ), dimension ( 2 ), parameter :: io2 = [ 'H2dnout' , & 'H2enout' ] integer :: ix , iy , iz , iq , ipe integer :: lenw , kk , nx1 , ny1 , nz1 integer :: gr_dim ( 3 ), i_end integer :: lun , i1 , j1 , k1 logical :: sd character ( 4 ) :: foldername integer , parameter :: file_version = 2 !======================== ! ns_index select ion species (electron,ions) ! cmp select components name in output script for each species ! [Eden,Elen],[H1dn,H1en]..... ! cmp_loc is the index where output data are stored in jc(cmp_loc) array !============================ write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 lun = 0 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( jc ( ix , iy , iz , cmp_loc ), sp ) end do end do end do if ( pe0 ) then call endian ( i_end ) nx1 = sum ( nxh ( 1 : npe_xloc )) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , & loc_nyc_max , nz1 , loc_nzc_max , jump , iby , iform , model_id , & dmodel_id , nsp , curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , & file_version , i_end ] select case ( ns_ind ) case ( 0 ) write ( fname , '(a7,i2.2)' ) bpot , iout case ( 1 ) write ( fname , '(a7,i2.2)' ) el1 ( cmp ), iout case ( 2 ) if ( atomic_number ( 1 ) == 1 ) then write ( fname , '(a7,i2.2)' ) pr1 ( cmp ), iout else write ( fname , '(a7,i2.2)' ) io1 ( cmp ), iout end if case ( 3 ) if ( atomic_number ( 2 ) == 1 ) then write ( fname , '(a7,i2.2)' ) pr1 ( cmp ), iout else write ( fname , '(a7,i2.2)' ) io2 ( cmp ), iout end if case ( 4 ) write ( fname , '(a7,i2.2)' ) io2 ( cmp ), iout end select open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Integer parameters' write ( 10 , '(4i14)' ) int_par write ( 10 , * ) ' Real parameters' write ( 10 , '(4e14.5)' ) real_par close ( 10 ) write ( 6 , * ) 'Field data written on file: ' // foldername // '/' // & fname // '.dat' gr_dim ( 1 ) = nxh ( 1 ) gr_dim ( 2 ) = nyh ( 1 ) gr_dim ( 3 ) = nzh ( 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) lun = 10 open ( 10 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) write ( 10 ) par_dim write ( 10 ) int_par write ( 10 ) real_par write ( 10 ) gr_dim write ( 10 ) wdata ( 1 : lenw ) end if if ( mype > 0 ) then gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) sd = . true . call exchange_pdata ( sd , wdata , lenw , pe_min , mype + 100 ) else sd = . false . do ix = 0 , npe_xloc - 1 gr_dim ( 1 ) = nxh ( ix + 1 ) do iz = 0 , npe_zloc - 1 gr_dim ( 3 ) = nzh ( iz + 1 ) do iy = 0 , npe_yloc - 1 gr_dim ( 2 ) = nyh ( iy + 1 ) ipe = iy + npe_yloc * ( iz + npe_zloc * ix ) if ( ipe > 0 ) then lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) call exchange_pdata ( sd , wdata , lenw , ipe , ipe + 100 ) write ( lun ) gr_dim write ( lun ) wdata ( 1 : lenw ) end if end do end do end do kk = 0 do iq = 1 , nx , jump kk = kk + 1 gwdata ( kk ) = real ( x ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , ny , jump kk = kk + 1 gwdata ( kk ) = real ( y ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , nz , jump kk = kk + 1 gwdata ( kk ) = real ( z ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) close ( 10 ) write ( 6 , * ) 'Den_Energy_Momenta written on file: ' // foldername // & '/' // fname // '.bin' end if end subroutine !============================ subroutine bden_energy_out ( cmp_loc ) integer , intent ( in ) :: cmp_loc character ( 9 ) :: fname = '         ' integer :: ix , iy , iz , ip , iq , ipe integer :: lenw , kk , nx1 , ny1 , nz1 integer :: i_end , i1 , j1 , k1 integer :: lun , gr_dim ( 3 ) character ( 4 ) :: foldername integer , parameter :: file_version = 2 logical :: sd write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 lun = 10 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( jc ( ix , iy , iz , cmp_loc ), sp ) end do end do end do if ( pe0 ) then call endian ( i_end ) nx1 = sum ( nxh ( 1 : npe_xloc )) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , & loc_nyc_max , nz1 , loc_nzc_max , jump , iby , iform , model_id , & dmodel_id , nsp , curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , & file_version , i_end ] write ( fname , '(a7,i2.2)' ) 'Bdenout' , iout open ( 20 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 20 , * ) ' Integer parameters' write ( 20 , '(4i14)' ) int_par write ( 20 , * ) ' Real parameters' write ( 20 , '(4e14.5)' ) real_par close ( 20 ) write ( 6 , * ) 'Field data written on file: ' // foldername // '/' // & fname // '.dat' gr_dim ( 1 ) = nxh ( 1 ) gr_dim ( 2 ) = nyh ( 1 ) gr_dim ( 3 ) = nzh ( 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) lun = 10 open ( 10 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) !qui write ( 10 ) par_dim write ( 10 ) int_par write ( 10 ) real_par write ( 10 ) gr_dim write ( 10 ) wdata ( 1 : lenw ) end if if ( prl ) then if ( mype > 0 ) then gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) sd = . true . call exchange_pdata ( sd , wdata , lenw , pe_min , mype + 100 ) else sd = . false . do ix = 0 , npe_xloc - 1 gr_dim ( 1 ) = nxh ( ix + 1 ) do ip = 0 , npe_zloc - 1 gr_dim ( 3 ) = nzh ( ip + 1 ) do iq = 0 , npe_yloc - 1 gr_dim ( 2 ) = nyh ( iq + 1 ) ipe = iq + npe_yloc * ( ip + npe_zloc * ix ) if ( ipe > 0 ) then lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) call exchange_pdata ( sd , wdata , lenw , ipe , ipe + 100 ) write ( lun ) gr_dim write ( lun ) wdata ( 1 : lenw ) end if end do end do end do end if end if if ( pe0 ) then kk = 0 do iq = 1 , nx , jump kk = kk + 1 gwdata ( kk ) = real ( x ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , ny , jump kk = kk + 1 gwdata ( kk ) = real ( y ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , nz , jump kk = kk + 1 gwdata ( kk ) = real ( z ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) close ( 10 ) write ( 6 , * ) 'Den_Energy_Momenta written on file: ' // foldername // & '/' // fname // '.bin' end if end subroutine !========================== subroutine ext_bfield_out ( ef , f_ind ) real ( dp ), intent ( in ) :: ef (:, :, :, :) character ( 8 ) :: fname = '        ' integer , intent ( in ) :: f_ind integer :: ix , iy , iz , iq , ipe integer :: lun , lenw , kk , nx1 , ny1 , nz1 integer :: i1 , j1 , k1 , i_end integer :: gr_dim ( 3 ) logical :: sd character ( 4 ) :: foldername integer , parameter :: file_version = 2 write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 lun = 0 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( ef ( ix , iy , iz , f_ind ), sp ) end do end do end do if ( pe0 ) then call endian ( i_end ) nx1 = sum ( nxh ( 1 : npe_xloc )) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , & loc_nyc_max , nz1 , loc_nzc_max , jump , iby , iform , model_id , & dmodel_id , nsp , curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , & file_version , i_end ] select case ( f_ind ) case ( 1 ) write ( fname , '(a6,i2.2)' ) 'Bx0out' , iout case ( 2 ) write ( fname , '(a6,i2.2)' ) 'By0out' , iout case ( 3 ) write ( fname , '(a6,i2.2)' ) 'Bz0out' , iout end select open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Integer parameters' write ( 10 , '(4i10)' ) int_par write ( 10 , * ) ' Real parameters' write ( 10 , '(4e14.5)' ) real_par close ( 10 ) write ( 6 , * ) 'Field data written on file: ' // foldername // '/' // & fname // '.dat' gr_dim ( 1 ) = nxh ( 1 ) gr_dim ( 2 ) = nyh ( 1 ) gr_dim ( 3 ) = nzh ( 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) lun = 10 open ( 10 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) write ( 10 ) par_dim write ( 10 ) int_par write ( 10 ) real_par write ( 10 ) gr_dim write ( 10 ) wdata ( 1 : lenw ) end if if ( mype > 0 ) then gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) sd = . true . call exchange_pdata ( sd , wdata , lenw , pe_min , mype + 100 ) else sd = . false . do ix = 0 , npe_xloc - 1 gr_dim ( 1 ) = nxh ( ix + 1 ) do iz = 0 , npe_zloc - 1 gr_dim ( 3 ) = nzh ( iz + 1 ) do iy = 0 , npe_yloc - 1 gr_dim ( 2 ) = nyh ( iy + 1 ) ipe = iy + npe_yloc * ( iz + npe_zloc * ix ) if ( ipe > 0 ) then lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) call exchange_pdata ( sd , wdata , lenw , ipe , ipe + 100 ) write ( lun ) gr_dim write ( lun ) wdata ( 1 : lenw ) end if end do end do end do kk = 0 do iq = 1 , nx , jump kk = kk + 1 gwdata ( kk ) = real ( x ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , ny , jump kk = kk + 1 gwdata ( kk ) = real ( y ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , nz , jump kk = kk + 1 gwdata ( kk ) = real ( z ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) close ( 10 ) write ( 6 , * ) 'Fields written on file: ' // foldername // '/' // & fname // '.bin' end if end subroutine subroutine fields_out ( ef , f_ind , f_var ) real ( dp ), intent ( in ) :: ef (:, :, :, :) character ( 8 ) :: fname = '        ' integer , intent ( in ) :: f_ind , f_var integer :: ix , iy , iz , iq , ipe integer :: lun , lenw , kk , nx1 , ny1 , nz1 integer :: i1 , j1 , k1 , i_end integer :: gr_dim ( 3 ) logical :: sd character ( 4 ) :: foldername integer , parameter :: file_version = 2 write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 lun = 0 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( ef ( ix , iy , iz , f_ind ), sp ) end do end do end do if ( pe0 ) then call endian ( i_end ) nx1 = sum ( nxh ( 1 : npe_xloc )) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , & loc_nyc_max , nz1 , loc_nzc_max , jump , iby , iform , model_id , & dmodel_id , nsp , curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , & file_version , i_end ] select case ( f_var ) case ( 0 ) write ( fname , '(a6,i2.2)' ) 'Jxfout' , iout case ( 1 ) write ( fname , '(a6,i2.2)' ) 'Exfout' , iout case ( 2 ) write ( fname , '(a6,i2.2)' ) 'Eyfout' , iout case ( 3 ) if ( nfield == 3 ) then write ( fname , '(a6,i2.2)' ) 'Bzfout' , iout else write ( fname , '(a6,i2.2)' ) 'Ezfout' , iout end if case ( 4 ) write ( fname , '(a6,i2.2)' ) 'Bxfout' , iout case ( 5 ) write ( fname , '(a6,i2.2)' ) 'Byfout' , iout case ( 6 ) write ( fname , '(a6,i2.2)' ) 'Bzfout' , iout end select open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Integer parameters' write ( 10 , '(4i14)' ) int_par write ( 10 , * ) ' Real parameters' write ( 10 , '(4e14.5)' ) real_par close ( 10 ) write ( 6 , * ) 'Field data written on file: ' // foldername // '/' // & fname // '.dat' gr_dim ( 1 ) = nxh ( 1 ) gr_dim ( 2 ) = nyh ( 1 ) gr_dim ( 3 ) = nzh ( 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) lun = 10 open ( 10 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) write ( 10 ) par_dim write ( 10 ) int_par write ( 10 ) real_par write ( 10 ) gr_dim write ( 10 ) wdata ( 1 : lenw ) end if if ( mype > 0 ) then gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) sd = . true . call exchange_pdata ( sd , wdata , lenw , pe_min , mype + 100 ) else sd = . false . do ix = 0 , npe_xloc - 1 gr_dim ( 1 ) = nxh ( ix + 1 ) do iz = 0 , npe_zloc - 1 gr_dim ( 3 ) = nzh ( iz + 1 ) do iy = 0 , npe_yloc - 1 gr_dim ( 2 ) = nyh ( iy + 1 ) ipe = iy + npe_yloc * ( iz + npe_zloc * ix ) if ( ipe > 0 ) then lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) call exchange_pdata ( sd , wdata , lenw , ipe , ipe + 100 ) write ( lun ) gr_dim write ( lun ) wdata ( 1 : lenw ) end if end do end do end do kk = 0 do iq = 1 , nx , jump kk = kk + 1 gwdata ( kk ) = real ( x ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , ny , jump kk = kk + 1 gwdata ( kk ) = real ( y ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , nz , jump kk = kk + 1 gwdata ( kk ) = real ( z ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) close ( 10 ) write ( 6 , * ) 'Fields written on file: ' // foldername // '/' // & fname // '.bin' end if end subroutine !========================== subroutine fields_out_new ( ef , f_ind , var_ind ) real ( dp ), intent ( in ) :: ef (:, :, :, :) character ( 8 ) :: fname = '        ' character ( 12 ) :: fnamel = '            ' character ( 17 ) :: fname_out = '                 ' character ( 21 ) :: fname_outl = '                     ' integer , intent ( in ) :: f_ind , var_ind integer :: ix , iy , iz , iq integer :: lenw , kk , nx1 , ny1 , nz1 integer :: i1 , j1 , k1 , i_end integer ( offset_kind ) :: disp , disp_col integer :: num_header_int , gr_dim ( 3 ), header ( 3 ) real ( dp ), allocatable :: ascii_grid (:) integer :: gridsize_x , gridsize_y , gridsize_z character ( 4 ) :: foldername integer , parameter :: file_version = 4 write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 gr_dim = 0 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( ef ( ix , iy , iz , f_ind ), sp ) end do end do end do !================================ call endian ( i_end ) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) nx1 = sum ( nxh ( 1 : npe_xloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , nz1 , & loc_nyc_max , jump , ibx , iby , iform , model_id , dmodel_id , nsp , & curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , file_version , i_end ] select case ( var_ind ) case ( 0 ) write ( fname , '(a6,i2.2)' ) 'dvEout' , iout case ( 1 ) write ( fname , '(a6,i2.2)' ) 'Exfout' , iout case ( 2 ) write ( fname , '(a6,i2.2)' ) 'Eyfout' , iout case ( 3 ) if ( nfield == 3 ) then write ( fname , '(a6,i2.2)' ) 'Bzfout' , iout else write ( fname , '(a6,i2.2)' ) 'Ezfout' , iout end if case ( 4 ) write ( fname , '(a6,i2.2)' ) 'Bxfout' , iout case ( 5 ) write ( fname , '(a6,i2.2)' ) 'Byfout' , iout case ( 6 ) write ( fname , '(a6,i2.2)' ) 'Bzfout' , iout case ( 7 ) write ( fname , '(a6,i2.2)' ) 'Exbout' , iout case ( 8 ) write ( fname , '(a6,i2.2)' ) 'Eybout' , iout case ( 9 ) if ( nfield == 3 ) then write ( fname , '(a6,i2.2)' ) 'Bzbout' , iout else write ( fname , '(a6,i2.2)' ) 'Ezbout' , iout end if case ( 10 ) write ( fname , '(a6,i2.2)' ) 'Jxbout' , iout case ( 11 ) write ( fname , '(a6,i2.2)' ) 'Bybout' , iout case ( 12 ) write ( fname , '(a6,i2.2)' ) 'Bzbout' , iout end select if ( pe0 ) then open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Integer parameters' write ( 10 , '(4i14)' ) int_par write ( 10 , * ) ' Real parameters' write ( 10 , '(4e14.5)' ) real_par write ( 10 , * ) ' Coordinates' gridsize_x = int ( nx / jump ) gridsize_y = int ( ny / jump ) gridsize_z = int ( nz / jump ) allocate ( ascii_grid ( gridsize_x + 1 )) kk = 0 do iq = 1 , nx , jump kk = kk + 1 ascii_grid ( kk ) = x ( iq ) end do do iq = 1 , kk write ( 10 , '(es14.5)' , advance = 'no' ) ascii_grid ( iq ) if ( mod ( iq , 8 ) == 0 ) write ( 10 , * ) '' end do deallocate ( ascii_grid ) allocate ( ascii_grid ( gridsize_y + 1 )) kk = 0 do iq = 1 , ny , jump kk = kk + 1 ascii_grid ( kk ) = y ( iq ) end do do iq = 1 , kk write ( 10 , '(es14.5)' , advance = 'no' ) ascii_grid ( iq ) if ( mod ( iq , 8 ) == 0 ) write ( 10 , * ) '' end do deallocate ( ascii_grid ) allocate ( ascii_grid ( gridsize_z + 1 )) kk = 0 do iq = 1 , nz , jump kk = kk + 1 ascii_grid ( kk ) = z ( iq ) end do do iq = 1 , kk write ( 10 , '(es14.5)' , advance = 'no' ) ascii_grid ( iq ) if ( mod ( iq , 8 ) == 0 ) write ( 10 , * ) '' end do close ( 10 ) write ( 6 , * ) 'Fields parameters written on file: ' // foldername // & '/' // fname // '.dat' end if gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) write ( fnamel , '(a8,a1,i3.3)' ) fname , '_' , imodz fname_out = foldername // '/' // fname // '.bin' fname_outl = foldername // '/' // fnamel // '.bin' num_header_int = 3 header ( 1 : 3 ) = gr_dim ( 1 : 3 ) disp = 4 * mype * ( num_header_int + lenw ) ! da usare con mpi_write !assuming that all procs have the same grid size disp_col = 4 * imody * ( num_header_int + lenw ) ! con mpi_write_col !assuming that all procs have the same grid size call mpi_write_field ( wdata , lenw , header , num_header_int , disp , 17 , & fname_out ) if ( pe0 ) then write ( 6 , * ) 'Fields written on file: ' // foldername // '/' // & fname // '.bin' end if end subroutine !========================== subroutine bfields_out ( ef , ef1 , f_ind ) real ( dp ), intent ( in ) :: ef (:, :, :, :), ef1 (:, :, :, :) character ( 8 ) :: fname = '        ' integer , intent ( in ) :: f_ind integer :: ix , iy , iz , iq , ipe integer :: lun , lenw , kk , nx1 , ny1 , nz1 integer :: i1 , j1 , k1 , i_end integer :: gr_dim ( 3 ) logical :: sd character ( 4 ) :: foldername integer , parameter :: file_version = 2 write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 lun = 0 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 select case ( ibeam ) case ( 0 ) do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( ef ( ix , iy , iz , f_ind ), sp ) end do end do end do case ( 1 ) do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 if ( abs ( ef ( ix , iy , iz , f_ind ) + ef1 ( ix , iy , iz , f_ind )) > 1 d34 ) then write ( * , * ) 'Error :: overflow in file output' write ( * , '(A,4I4)' ) 'index:' , ix , iy , iz , f_ind end if wdata ( kk ) = real ( ef ( ix , iy , iz , f_ind ) + ef1 ( ix , iy , iz , f_ind ), sp ) end do end do end do end select if ( pe0 ) then call endian ( i_end ) nx1 = sum ( nxh ( 1 : npe_xloc )) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , & loc_nyc_max , nz1 , loc_nzc_max , jump , iby , iform , model_id , & dmodel_id , nsp , curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , & file_version , i_end ] select case ( f_ind ) case ( 1 ) write ( fname , '(a6,i2.2)' ) 'Exbout' , iout case ( 2 ) write ( fname , '(a6,i2.2)' ) 'Eybout' , iout case ( 3 ) if ( nfield == 3 ) then write ( fname , '(a6,i2.2)' ) 'Bzbout' , iout else write ( fname , '(a6,i2.2)' ) 'Ezbout' , iout end if case ( 4 ) write ( fname , '(a6,i2.2)' ) 'Jxbout' , iout case ( 5 ) write ( fname , '(a6,i2.2)' ) 'Bybout' , iout case ( 6 ) write ( fname , '(a6,i2.2)' ) 'Bzbout' , iout end select open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Integer parameters' write ( 10 , '(4i14)' ) int_par write ( 10 , * ) ' Real parameters' write ( 10 , '(4e14.5)' ) real_par close ( 10 ) write ( 6 , * ) 'Field data written on file: ' // foldername // '/' // & fname // '.dat' gr_dim ( 1 ) = nxh ( 1 ) gr_dim ( 2 ) = nyh ( 1 ) gr_dim ( 3 ) = nzh ( 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) lun = 10 open ( 10 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) write ( 10 ) par_dim write ( 10 ) int_par write ( 10 ) real_par write ( 10 ) gr_dim write ( 10 ) wdata ( 1 : lenw ) end if if ( mype > 0 ) then gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) sd = . true . call exchange_pdata ( sd , wdata , lenw , pe_min , mype + 200 ) else sd = . false . do ix = 0 , npe_xloc - 1 gr_dim ( 1 ) = nxh ( ix + 1 ) do iz = 0 , npe_zloc - 1 gr_dim ( 3 ) = nzh ( iz + 1 ) do iy = 0 , npe_yloc - 1 gr_dim ( 2 ) = nyh ( iy + 1 ) ipe = iy + npe_yloc * ( iz + npe_zloc * ix ) if ( ipe > 0 ) then lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) call exchange_pdata ( sd , wdata , lenw , ipe , ipe + 200 ) write ( lun ) gr_dim write ( lun ) wdata ( 1 : lenw ) end if end do end do end do kk = 0 do iq = 1 , nx , jump kk = kk + 1 gwdata ( kk ) = real ( x ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , ny , jump kk = kk + 1 gwdata ( kk ) = real ( y ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , nz , jump kk = kk + 1 gwdata ( kk ) = real ( z ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) close ( 10 ) write ( 6 , * ) 'Fields written on file: ' // foldername // '/' // & fname // '.bin' end if end subroutine !========================== subroutine env_two_fields_out ( ef , ef1 , f_ind ) real ( dp ), intent ( in ) :: ef (:, :, :, :), ef1 (:, :, :, :) character ( 9 ) :: fname = '         ' integer , intent ( in ) :: f_ind integer :: ix , iy , iz , iq , ipe integer :: lenw , kk , nx1 , ny1 , nz1 integer :: gr_dim ( 3 ) integer :: i1 , j1 , k1 , lun logical :: sd real ( dp ) :: a2 , avec character ( 4 ) :: foldername integer , parameter :: file_version = 2 write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 lun = 0 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 if ( f_ind == 0 ) then do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 a2 = ef ( ix , iy , iz , 1 ) * ef ( ix , iy , iz , 1 ) + & ef ( ix , iy , iz , 2 ) * ef ( ix , iy , iz , 2 ) avec = sqrt ( a2 ) a2 = ef1 ( ix , iy , iz , 1 ) * ef1 ( ix , iy , iz , 1 ) + & ef1 ( ix , iy , iz , 2 ) * ef1 ( ix , iy , iz , 2 ) avec = avec + sqrt ( a2 ) wdata ( kk ) = real ( avec , sp ) end do end do end do else do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( ef ( ix , iy , iz , f_ind ), sp ) wdata ( kk ) = wdata ( kk ) + real ( ef1 ( ix , iy , iz , f_ind ), sp ) end do end do end do end if if ( pe0 ) then nx1 = sum ( nxh ( 1 : npe_xloc )) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , & loc_nyc_max , nz1 , loc_nzc_max , jump , iby , iform , model_id , & dmodel_id , nsp , curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , & file_version , ibeam ] select case ( f_ind ) case ( 0 ) write ( fname , '(a7,i2.2)' ) 'Aenvout' , iout case ( 1 ) write ( fname , '(a7,i2.2)' ) 'Renvout' , iout case ( 2 ) write ( fname , '(a7,i2.2)' ) 'Ienvout' , iout end select gr_dim ( 1 ) = nxh ( 1 ) gr_dim ( 2 ) = nyh ( 1 ) gr_dim ( 3 ) = nzh ( 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) lun = 10 open ( 10 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) write ( 10 ) par_dim write ( 10 ) int_par write ( 10 ) real_par write ( 10 ) gr_dim write ( 10 ) wdata ( 1 : lenw ) end if if ( mype > 0 ) then gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) sd = . true . call exchange_pdata ( sd , wdata , lenw , pe_min , mype + 100 ) else sd = . false . do ix = 0 , npe_xloc - 1 gr_dim ( 1 ) = nxh ( ix + 1 ) do iz = 0 , npe_zloc - 1 gr_dim ( 3 ) = nzh ( iz + 1 ) do iy = 0 , npe_yloc - 1 gr_dim ( 2 ) = nyh ( iy + 1 ) ipe = iy + npe_yloc * ( iz + npe_zloc * ix ) if ( ipe > 0 ) then lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) call exchange_pdata ( sd , wdata , lenw , ipe , ipe + 100 ) write ( lun ) gr_dim write ( lun ) wdata ( 1 : lenw ) end if end do end do end do kk = 0 do iq = 1 , nx , jump kk = kk + 1 gwdata ( kk ) = real ( x ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , ny , jump kk = kk + 1 gwdata ( kk ) = real ( y ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , nz , jump kk = kk + 1 gwdata ( kk ) = real ( z ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) close ( 10 ) write ( 6 , * ) 'Fields written on file: ' // foldername // '/' // & fname // '.bin' end if end subroutine subroutine env_fields_out ( ef , f_ind ) real ( dp ), intent ( in ) :: ef (:, :, :, :) character ( 9 ) :: fname = '         ' integer , intent ( in ) :: f_ind integer :: ix , iy , iz , iq , ipe integer :: lenw , kk , nx1 , ny1 , nz1 integer :: gr_dim ( 3 ) integer :: i1 , j1 , k1 , lun logical :: sd character ( 4 ) :: foldername integer , parameter :: file_version = 2 real ( dp ) :: a2 , avec write ( foldername , '(i4.4)' ) iout int_par = 0 real_par = 0.0 lun = 0 j1 = jy1 k1 = kz1 i1 = ix1 kk = 0 if ( f_ind < 1 ) then do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 a2 = ef ( ix , iy , iz , 1 ) * ef ( ix , iy , iz , 1 ) + & ef ( ix , iy , iz , 2 ) * ef ( ix , iy , iz , 2 ) avec = sqrt ( a2 ) wdata ( kk ) = real ( avec , sp ) end do end do end do else do iz = k1 , nzp , jump do iy = j1 , nyp , jump do ix = i1 , nxp , jump kk = kk + 1 wdata ( kk ) = real ( ef ( ix , iy , iz , f_ind ), sp ) end do end do end do end if if ( pe0 ) then nx1 = sum ( nxh ( 1 : npe_xloc )) ny1 = sum ( nyh ( 1 : npe_yloc )) nz1 = sum ( nzh ( 1 : npe_zloc )) real_par ( 1 : 20 ) = [ real ( tnow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( n_over_nc , sp ), real ( a0 , sp ), & real ( lam0 , sp ), real ( e0 , sp ), real ( ompe , sp ), real ( targ_in , sp ), & real ( targ_end , sp ), real ( gam0 , sp ), real ( nb_over_np , sp ), & real ( b_charge , sp ), real ( vbeam , sp )] int_par ( 1 : 20 ) = [ npe_yloc , npe_zloc , npe_xloc , nx1 , ny1 , & loc_nyc_max , nz1 , loc_nzc_max , jump , iby , iform , model_id , & dmodel_id , nsp , curr_ndim , mp_per_cell ( 1 ), lpf_ord , der_ord , & file_version , ibeam ] select case ( f_ind ) case ( - 1 ) write ( fname , '(a7,i2.2)' ) 'aenvout' , iout case ( 0 ) write ( fname , '(a7,i2.2)' ) 'Aenvout' , iout case ( 1 ) write ( fname , '(a7,i2.2)' ) 'Renvout' , iout case ( 2 ) write ( fname , '(a7,i2.2)' ) 'Ienvout' , iout end select gr_dim ( 1 ) = nxh ( 1 ) gr_dim ( 2 ) = nyh ( 1 ) gr_dim ( 3 ) = nzh ( 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) lun = 10 open ( 10 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) write ( 10 ) par_dim write ( 10 ) int_par write ( 10 ) real_par write ( 10 ) gr_dim write ( 10 ) wdata ( 1 : lenw ) end if if ( mype > 0 ) then gr_dim ( 1 ) = nxh ( imodx + 1 ) gr_dim ( 2 ) = nyh ( imody + 1 ) gr_dim ( 3 ) = nzh ( imodz + 1 ) lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) sd = . true . call exchange_pdata ( sd , wdata , lenw , pe_min , mype + 100 ) else sd = . false . do ix = 0 , npe_xloc - 1 gr_dim ( 1 ) = nxh ( ix + 1 ) do iz = 0 , npe_zloc - 1 gr_dim ( 3 ) = nzh ( iz + 1 ) do iy = 0 , npe_yloc - 1 gr_dim ( 2 ) = nyh ( iy + 1 ) ipe = iy + npe_yloc * ( iz + npe_zloc * ix ) if ( ipe > 0 ) then lenw = gr_dim ( 1 ) * gr_dim ( 2 ) * gr_dim ( 3 ) call exchange_pdata ( sd , wdata , lenw , ipe , ipe + 100 ) write ( lun ) gr_dim write ( lun ) wdata ( 1 : lenw ) end if end do end do end do kk = 0 do iq = 1 , nx , jump kk = kk + 1 gwdata ( kk ) = real ( x ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , ny , jump kk = kk + 1 gwdata ( kk ) = real ( y ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) kk = 0 do iq = 1 , nz , jump kk = kk + 1 gwdata ( kk ) = real ( z ( iq ), sp ) end do write ( 10 ) gwdata ( 1 : kk ) close ( 10 ) write ( 6 , * ) 'Fields written on file: ' // foldername // '/' // & fname // '.bin' end if end subroutine !================================ subroutine part_pdata_out ( timenow , xmin_out , xmax_out , ymax_out , pid , & jmp ) character ( 6 ), dimension ( 4 ), parameter :: part_files = [ 'Elpout' , & 'H1pout' , 'Prpout' , 'H2pout' ] character ( 8 ) :: fname character ( 17 ) :: fname_out character ( 12 ) :: fnamel character ( 21 ) :: fname_outl real ( dp ), intent ( in ) :: timenow , xmin_out , xmax_out , ymax_out integer , intent ( in ) :: pid , jmp real ( sp ), allocatable :: pdata (:) integer ( dp ) :: nptot_global_reduced integer :: ik , p , q , np , ip , ip_max , nptot integer :: lenp , ip_loc ( npe ), ndv , i_end integer ( offset_kind ) :: disp , disp_col real ( dp ) :: xx , yy , zz character ( 4 ) :: foldername integer , parameter :: file_version = 4 write ( foldername , '(i4.4)' ) iout ndv = nd2 + 2 np = loc_npart ( imody , imodz , imodx , pid ) ip = 0 if ( np > 0 ) then if ( ndim > 2 ) then do p = 1 , np , jmp yy = spec ( pid )% part ( p , 2 ) zz = spec ( pid )% part ( p , 3 ) if ( abs ( yy ) <= ymax_out . and . abs ( zz ) <= ymax_out ) then xx = spec ( pid )% part ( p , 1 ) if ( xx >= xmin_out . and . xx <= xmax_out ) then ip = ip + 1 do q = 1 , nd2 + 1 ebfp ( ip , q ) = spec ( pid )% part ( p , q ) end do end if end if end do else zz = 1. do p = 1 , np , jmp yy = spec ( pid )% part ( p , 2 ) if ( abs ( yy ) <= ymax_out ) then xx = spec ( pid )% part ( p , 1 ) if ( xx >= xmin_out . and . xx <= xmax_out ) then ip = ip + 1 do q = 1 , nd2 + 1 ebfp ( ip , q ) = spec ( pid )% part ( p , q ) end do end if end if end do end if end if ip_loc ( mype + 1 ) = ip ip = ip_loc ( mype + 1 ) call intvec_distribute ( ip , ip_loc , npe ) ! this differs from nptot_global since it represents just the reduced number of particles ! that will be present in the output (should be equal to nptot_global for p_jump=1)! nptot_global_reduced = 0 do ik = 1 , npe nptot_global_reduced = nptot_global_reduced + ip_loc ( ik ) end do if ( nptot_global < 1e9 ) then nptot = int ( nptot_global_reduced ) else nptot = - 1 end if ip_max = ip if ( pe0 ) ip_max = maxval ( ip_loc ( 1 : npe )) lenp = ndv * ip_loc ( mype + 1 ) allocate ( pdata ( lenp )) ik = 0 do p = 1 , ip_loc ( mype + 1 ) do q = 1 , nd2 ik = ik + 1 pdata ( ik ) = real ( ebfp ( p , q ), sp ) end do wgh_cmp = ebfp ( p , nd2 + 1 ) ik = ik + 1 pdata ( ik ) = wgh ik = ik + 1 pdata ( ik ) = real ( charge , sp ) end do if ( ik /= lenp ) write ( 6 , '(a16,3i8)' ) 'wrong pdata size' , mype , lenp , & ik call endian ( i_end ) part_real_par ( 1 : 20 ) = [ real ( timenow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( a0 , sp ), real ( lam0 , sp ), & real ( e0 , sp ), real ( n0_ref , sp ), real ( np_per_cell , sp ), & real ( j0_norm , sp ), real ( mass ( pid ), sp ), real ( xmin_out , sp ), & real ( xmax_out , sp ), real ( ymax_out , sp ), real ( gam_min , sp )] part_int_par ( 1 : 20 ) = [ npe , nx , ny , nz , model_id , dmodel_id , nsp , & curr_ndim , mp_per_cell ( pid ), ion_min ( 1 ), lpf_ord , der_ord , iform , ndv , & file_version , i_end , nx_loc , ny_loc , nz_loc , pjump ] write ( fname , '(a6,i2.2)' ) part_files ( pid ), iout !serve sempre write ( fnamel , '(a6,i2.2,a1,i3.3)' ) part_files ( pid ), iout , '_' , imodz !usare con mpi_write_part_col fname_out = foldername // '/' // fname // '.bin' fname_outl = foldername // '/' // fnamel // '.bin' disp = 0 disp_col = 0 if ( pe0 ) then open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Real parameters' do q = 1 , 20 write ( 10 , '(a13,e11.4)' ) rpar ( q ), part_real_par ( q ) end do write ( 10 , * ) ' Integer parameters' do p = 1 , 20 write ( 10 , '(a12,i8)' ) ipar ( p ), part_int_par ( p ) end do write ( 10 , * ) ' Number of particles in the output box' write ( 10 , '(4i20)' ) nptot_global_reduced close ( 10 ) write ( 6 , * ) 'Particles param written on file: ' // foldername // & '/' // fname // '.dat' else disp = mype + ndv * sum ( ip_loc ( 1 : mype )) ! da usare con mpi_write_part end if if ( mod ( mype , npe_yloc ) > 0 ) disp_col = ndv * sum ( ip_loc ( imodz * npe_yloc + 1 : & mype )) ! da usare con mpi_write_part_col disp = disp * 4 ! sia gli int che i float sono di 4 bytes disp_col = disp_col * 4 call mpi_write_part ( pdata , lenp , ip , disp , 17 , fname_out ) if ( allocated ( pdata )) deallocate ( pdata ) if ( pe0 ) then write ( 6 , * ) 'Particles data written on file: ' // foldername // & '/' // fname // '.bin' write ( 6 , * ) ' Output logical flag ' , l_force_singlefile_output end if end subroutine !========================== subroutine part_high_gamma_out ( gam_in , timenow ) character ( 8 ), dimension ( 1 ), parameter :: part_files = [ 'E_hg_out' ] character ( 10 ) :: fname character ( 19 ) :: fname_out real ( dp ), intent ( in ) :: gam_in , timenow real ( sp ), allocatable :: pdata (:) integer ( dp ) :: nptot_global_reduced integer :: id_ch , ik , p , q , ip , ip_max , nptot integer :: jmp , ne , lenp , ip_loc ( npe ), ndv , i_end integer ( offset_kind ) :: disp real ( dp ) :: gam , pp ( 3 ) character ( 4 ) :: foldername integer , parameter :: file_version = 4 write ( foldername , '(i4.4)' ) iout jmp = 1 id_ch = nd2 + 1 ndv = nd2 + 2 ne = loc_npart ( imody , imodz , imodx , 1 ) select case ( nd2 ) case ( 4 ) ip = 0 if ( ne > 0 ) then do p = 1 , ne pp ( 1 : 2 ) = spec ( 1 )% part ( p , 3 : 4 ) gam = sqrt ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 )) if ( gam > gam_in ) then ip = ip + 1 do q = 1 , nd2 + 1 ebfp ( ip , q ) = spec ( 1 )% part ( p , q ) end do end if end do end if case ( 6 ) ip = 0 if ( ne > 0 ) then do p = 1 , ne pp ( 1 : 3 ) = spec ( 1 )% part ( p , 4 : 6 ) gam = sqrt ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) + pp ( 3 ) * pp ( 3 )) if ( gam > gam_in ) then ip = ip + 1 do q = 1 , nd2 + 1 ebfp ( ip , q ) = spec ( 1 )% part ( p , q ) end do end if end do end if end select ip_loc ( mype + 1 ) = ip ip = ip_loc ( mype + 1 ) call intvec_distribute ( ip , ip_loc , npe ) nptot_global_reduced = 0 !nptot_global_reduced=sum(ip_loc(1:npe)) do ik = 1 , npe nptot_global_reduced = nptot_global_reduced + ip_loc ( ik ) end do if ( nptot_global < 1e9 ) then nptot = int ( nptot_global_reduced ) else nptot = - 1 end if ip_max = ip if ( pe0 ) ip_max = maxval ( ip_loc ( 1 : npe )) lenp = ndv * ip ik = max ( 1 , lenp ) allocate ( pdata ( lenp )) ik = 0 do p = 1 , ip do q = 1 , nd2 ik = ik + 1 pdata ( ik ) = real ( ebfp ( p , q ), sp ) end do wgh_cmp = ebfp ( p , nd2 + 1 ) ik = ik + 1 pdata ( ik ) = wgh ik = ik + 1 pdata ( ik ) = real ( charge , sp ) end do if ( ik /= lenp ) write ( 6 , '(a16,3i8)' ) 'wrong pdata size' , mype , lenp , & ik int_par = 0 call endian ( i_end ) part_real_par ( 1 : 20 ) = [ real ( timenow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( a0 , sp ), real ( lam0 , sp ), & real ( e0 , sp ), real ( n0_ref , sp ), real ( np_per_cell , sp ), & real ( wgh_ion , sp ), real ( mass ( 1 ), sp ), real ( xp0_out , sp ), & real ( xp1_out , sp ), real ( yp_out , sp ), real ( gam_in , sp )] part_int_par ( 1 : 20 ) = [ npe , nx , ny , nz , model_id , dmodel_id , nsp , & curr_ndim , mp_per_cell ( 1 ), ion_min ( 1 ), lpf_ord , der_ord , iform , & ndv , file_version , i_end , nx_loc , ny_loc , nz_loc , 0 ] write ( fname , '(a8,i2.2)' ) part_files ( 1 ), iout !serve sempre fname_out = foldername // '/' // fname // '.bin' disp = 0 if ( pe0 ) then open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Real parameters' do q = 1 , 20 write ( 10 , '(a13,e11.4)' ) rpar ( q ), part_real_par ( q ) end do write ( 10 , * ) ' Integer parameters' do p = 1 , 20 write ( 10 , '(a12,i8)' ) ipar ( p ), part_int_par ( p ) end do write ( 10 , * ) ' Number of particles in the output box' write ( 10 , '(4i20)' ) nptot_global_reduced close ( 10 ) write ( 6 , * ) 'Particles param written on file: ' // foldername // & '/' // fname // '.dat' else disp = mype + ndv * sum ( ip_loc ( 1 : mype )) ! da usare con mpi_write_part end if disp = disp * 4 ! sia gli int che i float sono di 4 bytes call mpi_write_part ( pdata , lenp , ip , disp , 19 , fname_out ) if ( allocated ( pdata )) deallocate ( pdata ) if ( pe0 ) then write ( 6 , * ) 'Particles data written on file: ' // foldername // & '/' // fname // '.bin' end if end subroutine subroutine part_bdata_out ( timenow , pid , jmp ) character ( 11 ), dimension ( 1 ), parameter :: part_files = [ 'E_bunch_out' ] character ( 13 ) :: fname character ( 22 ) :: fname_out real ( dp ), intent ( in ) :: timenow integer , intent ( in ) :: pid , jmp real ( sp ), allocatable :: pdata (:) integer ( dp ) :: nptot_global_reduced integer :: id_ch , ik , p , q , ip , ip_max , nptot integer :: ne , lenp , ip_loc ( npe ), ndv , i_end integer ( offset_kind ) :: disp character ( 4 ) :: foldername integer , parameter :: file_version = 4 write ( foldername , '(i4.4)' ) iout id_ch = nd2 + 1 ndv = nd2 + 2 ne = loc_npart ( imody , imodz , imodx , 1 ) ip = 0 if ( ne > 0 ) then do p = 1 , ne , jmp wgh_cmp = spec ( 1 )% part ( p , id_ch ) if ( part_ind == pid ) then ip = ip + 1 do q = 1 , nd2 + 1 ebfp ( ip , q ) = spec ( 1 )% part ( p , q ) end do end if end do end if ip_loc ( mype + 1 ) = ip ip = ip_loc ( mype + 1 ) call intvec_distribute ( ip , ip_loc , npe ) nptot_global_reduced = 0 !nptot_global_reduced=sum(ip_loc(1:npe)) do ik = 1 , npe nptot_global_reduced = nptot_global_reduced + ip_loc ( ik ) end do if ( nptot_global < 1e9 ) then nptot = int ( nptot_global_reduced ) else nptot = - 1 end if ip_max = ip if ( pe0 ) ip_max = maxval ( ip_loc ( 1 : npe )) lenp = ndv * ip ik = max ( 1 , lenp ) allocate ( pdata ( lenp )) ik = 0 do p = 1 , ip do q = 1 , nd2 ik = ik + 1 pdata ( ik ) = real ( ebfp ( p , q ), sp ) end do wgh_cmp = ebfp ( p , nd2 + 1 ) ik = ik + 1 pdata ( ik ) = wgh ik = ik + 1 pdata ( ik ) = real ( charge , sp ) end do if ( ik /= lenp ) write ( 6 , '(a16,3i8)' ) 'wrong pdata size' , mype , lenp , & ik int_par = 0 call endian ( i_end ) part_real_par ( 1 : 20 ) = [ real ( timenow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( a0 , sp ), real ( lam0 , sp ), & real ( e0 , sp ), real ( n0_ref , sp ), real ( np_per_cell , sp ), & real ( wgh_ion , sp ), real ( mass ( 1 ), sp ), real ( xp0_out , sp ), & real ( xp1_out , sp ), real ( yp_out , sp ), real ( gam_min , sp )] part_int_par ( 1 : 20 ) = [ npe , nx , ny , nz , model_id , dmodel_id , nsp , & curr_ndim , mp_per_cell ( 1 ), ion_min ( 1 ), lpf_ord , der_ord , iform , ndv , & file_version , i_end , nx_loc , ny_loc , nz_loc , pjump ] write ( fname , '(a11,i2.2)' ) part_files ( 1 ), iout !serve sempre fname_out = foldername // '/' // fname // '.bin' disp = 0 if ( pe0 ) then open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Real parameters' do q = 1 , 20 write ( 10 , '(a13,e11.4)' ) rpar ( q ), part_real_par ( q ) end do write ( 10 , * ) ' Integer parameters' do p = 1 , 20 write ( 10 , '(a12,i8)' ) ipar ( p ), part_int_par ( p ) end do write ( 10 , * ) ' Number of particles in the output box' write ( 10 , '(4i20)' ) nptot_global_reduced close ( 10 ) write ( 6 , * ) 'Particles param written on file: ' // foldername // & '/' // fname // '.dat' else disp = mype + ndv * sum ( ip_loc ( 1 : mype )) ! da usare con mpi_write_part end if disp = disp * 4 ! sia gli int che i float sono di 4 bytes call mpi_write_part ( pdata , lenp , ip , disp , 22 , fname_out ) if ( allocated ( pdata )) deallocate ( pdata ) if ( pe0 ) then write ( 6 , * ) 'Particles data written on file: ' // foldername // & '/' // fname // '.bin' end if end subroutine !============================================== subroutine part_ionz_out ( timenow ) character ( 8 ), dimension ( 1 ), parameter :: part_files = [ 'Eionzout' ] character ( 10 ) :: fname character ( 19 ) :: fname_out real ( dp ), intent ( in ) :: timenow real ( sp ), allocatable :: pdata (:) integer ( dp ) :: nptot_global_reduced integer :: id_ch , ik , p , q , ip , ip_max , nptot integer :: jmp , ne , lenp , ip_loc ( npe ), ndv , i_end integer ( offset_kind ) :: disp real ( sp ) :: ch_ion character ( 4 ) :: foldername integer , parameter :: file_version = 4 write ( foldername , '(i4.4)' ) iout jmp = 1 id_ch = nd2 + 1 ndv = nd2 + 2 ch_ion = real ( wgh_ion , sp ) ne = loc_npart ( imody , imodz , imodx , 1 ) ip = 0 if ( ne > 0 ) then do p = 1 , ne wgh_cmp = spec ( 1 )% part ( p , id_ch ) if ( part_ind < 0 ) then ip = ip + 1 do q = 1 , nd2 + 1 ebfp ( ip , q ) = spec ( 1 )% part ( p , q ) end do end if end do end if ip_loc ( mype + 1 ) = ip ip = ip_loc ( mype + 1 ) call intvec_distribute ( ip , ip_loc , npe ) nptot_global_reduced = 0 !nptot_global_reduced=sum(ip_loc(1:npe)) do ik = 1 , npe nptot_global_reduced = nptot_global_reduced + ip_loc ( ik ) end do if ( nptot_global < 1e9 ) then nptot = int ( nptot_global_reduced ) else nptot = - 1 end if ip_max = ip if ( pe0 ) ip_max = maxval ( ip_loc ( 1 : npe )) lenp = ndv * ip ik = max ( 1 , lenp ) allocate ( pdata ( lenp )) ik = 0 do p = 1 , ip do q = 1 , nd2 ik = ik + 1 pdata ( ik ) = real ( ebfp ( p , q ), sp ) end do wgh_cmp = ebfp ( p , nd2 + 1 ) ik = ik + 1 pdata ( ik ) = wgh ik = ik + 1 pdata ( ik ) = real ( charge , sp ) end do if ( ik /= lenp ) write ( 6 , '(a16,3i8)' ) 'wrong pdata size' , mype , lenp , & ik int_par = 0 call endian ( i_end ) part_real_par ( 1 : 20 ) = [ real ( timenow , sp ), real ( xmin , sp ), real ( xmax , sp ), & real ( ymin , sp ), real ( ymax , sp ), real ( zmin , sp ), real ( zmax , sp ), & real ( w0_x , sp ), real ( w0_y , sp ), real ( a0 , sp ), real ( lam0 , sp ), & real ( e0 , sp ), real ( n0_ref , sp ), real ( np_per_cell , sp ), & real ( wgh_ion , sp ), real ( mass ( 1 ), sp ), real ( xp0_out , sp ), & real ( xp1_out , sp ), real ( yp_out , sp ), real ( gam_min , sp )] part_int_par ( 1 : 20 ) = [ npe , nx , ny , nz , model_id , dmodel_id , nsp , & curr_ndim , mp_per_cell ( 1 ), ion_min ( 1 ), lpf_ord , der_ord , iform , & ndv , file_version , i_end , nx_loc , ny_loc , nz_loc , pjump ] write ( fname , '(a8,i2.2)' ) part_files ( 1 ), iout !serve sempre fname_out = foldername // '/' // fname // '.bin' disp = 0 if ( pe0 ) then open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Real parameters' do q = 1 , 20 write ( 10 , '(a13,e11.4)' ) rpar ( q ), part_real_par ( q ) end do write ( 10 , * ) ' Integer parameters' do p = 1 , 20 write ( 10 , '(a12,i8)' ) ipar ( p ), part_int_par ( p ) end do write ( 10 , * ) ' Number of particles in the output box' write ( 10 , '(4i20)' ) nptot_global_reduced close ( 10 ) write ( 6 , * ) 'Particles param written on file: ' // foldername // & '/' // fname // '.dat' else disp = mype + ndv * sum ( ip_loc ( 1 : mype )) ! da usare con mpi_write_part end if disp = disp * 4 ! sia gli int che i float sono di 4 bytes call mpi_write_part ( pdata , lenp , ip , disp , 19 , fname_out ) if ( allocated ( pdata )) deallocate ( pdata ) if ( pe0 ) then write ( 6 , * ) 'Particles data written on file: ' // foldername // & '/' // fname // '.bin' end if end subroutine !================================ end module","tags":"","loc":"sourcefile/pic_out.f90.html"},{"title":"psolve.f90 – ALaDyn","text":"This file depends on sourcefile~~psolve.f90~~EfferentGraph sourcefile~psolve.f90 psolve.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~psolve.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~psolve.f90->sourcefile~common_param.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~psolve.f90->sourcefile~fstruct_data.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~psolve.f90->sourcefile~grid_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~modern_fft_lib.f90 modern_fft_lib.F90 sourcefile~prl_fft.f90->sourcefile~modern_fft_lib.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~modern_fft_lib.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~psolve.f90~~AfferentGraph sourcefile~psolve.f90 psolve.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psolve Source Code psolve.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module psolve use pstruct_data use fstruct_data use common_param use grid_param use prl_fft use grid_fields implicit none private public :: fft_3d_psolv , fft_2d_psolv real ( dp ), allocatable :: wb (:, :, :), wa (:, :, :) !========================== contains subroutine beam_2d_potential ( poten , nxf_in , n2_loc , n3_loc , ft_ind ) real ( dp ), intent ( inout ) :: poten (:, :, :) integer , intent ( in ) :: nxf_in , n2_loc , n3_loc , ft_ind real ( dp ) :: ak2p integer :: ix , iy , iy1 , iz , iz1 !_________________________________ ! Laplacian(y,z)(poten)=-rho =>  [k&#94;2_y+k&#94;2_z][poten(ky,kz)]=rho[ky,kz] ! Solves Poisson equation in Fourier space ! ft_ind >1  sin/cosine transform ! ft_mod=0,1   periodic fft do iz = 1 , n3_loc iz1 = iz + imodz * n3_loc do iy = 1 , n2_loc iy1 = iy + imody * n2_loc ak2p = skz ( iz1 , ft_ind ) * skz ( iz1 , ft_ind ) + sky ( iy1 , ft_ind ) * sky ( iy1 & , ft_ind ) if ( ak2p > 0.0 ) then do ix = 1 , nxf_in poten ( ix , iy , iz ) = poten ( ix , iy , iz ) / ak2p !poten end do else poten ( 1 : nxf_in , iy , iz ) = 0.0 end if end do end do end subroutine !========================== subroutine beam_potential ( poten , gam2 , nxf_in , n2_loc , n3_loc , ft_ind ) real ( dp ), intent ( inout ) :: poten (:, :, :) real ( dp ), intent ( in ) :: gam2 integer , intent ( in ) :: nxf_in , n2_loc , n3_loc , ft_ind real ( dp ) :: ak2 , ak2p integer :: ix , iy , iy1 , iz , iz1 !_________________________________ ! ft_ind=0,1 solves Poisson equation in Fourier space (kx/gam,ky,kz) ! ft_ind=2 solves Poisson equation in sin/cosine Fourier space (kx/gam,ky,kz) ! Laplacian(poten)=-rho =>  K&#94;2[poten(kx,ky,kz]=rho[kx,ky,kz] if ( n3_loc == 1 ) then iz = 1 do iy = 1 , n2_loc iy1 = iy + imody * n2_loc ak2p = sky ( iy1 , ft_ind ) * sky ( iy1 , ft_ind ) if ( ak2p > 0.0 ) then do ix = 1 , nxf_in ak2 = ak2p + skx ( ix , ft_ind ) * skx ( ix , ft_ind ) / gam2 poten ( ix , iy , iz ) = poten ( ix , iy , iz ) / ak2 !pot_b end do else do ix = 2 , nxf_in ak2 = skx ( ix , ft_ind ) * skx ( ix , ft_ind ) / gam2 poten ( ix , iy , iz ) = poten ( ix , iy , iz ) / ak2 !pot_b end do end if end do else do iz = 1 , n3_loc iz1 = iz + imodz * n3_loc do iy = 1 , n2_loc iy1 = iy + imody * n2_loc ak2p = skz ( iz1 , ft_ind ) * skz ( iz1 , ft_ind ) + & sky ( iy1 , ft_ind ) * sky ( iy1 , ft_ind ) if ( ak2p > 0.0 ) then do ix = 1 , nxf_in ak2 = ak2p + skx ( ix , ft_ind ) * skx ( ix , ft_ind ) / gam2 poten ( ix , iy , iz ) = poten ( ix , iy , iz ) / ak2 !pot_b end do else do ix = 2 , nxf_in ak2 = skx ( ix , ft_ind ) * skx ( ix , ft_ind ) / gam2 poten ( ix , iy , iz ) = poten ( ix , iy , iz ) / ak2 !pot_b end do end if end do end do end if !================= end subroutine !=============================================== subroutine fft_3d_psolv ( rho , pot1 , g2 , omp0 , n1 , n1_loc , n2 , n2_loc , n3 , & n3_loc , i1 , i2 , j1 , j2 , k1 , k2 , ft_mod , sym , s_ind ) real ( dp ), intent ( inout ) :: rho (:, :, :, :), pot1 (:, :, :, :) real ( dp ), intent ( in ) :: g2 , omp0 integer , intent ( in ) :: n1 , n1_loc , n2 , n2_loc , n3 , n3_loc , ft_mod , sym , s_ind integer , intent ( in ) :: i1 , i2 , j1 , j2 , k1 , k2 integer :: i , ii , j , k ! ft_mod=0,1 for standard fft in periodic BC ! ft_mod=2  for sin(sym=1) cos(sym=2) transforms ! In rho(1) enters charge density rho(x,y,z)=q*n(x,y,z) ! In rho(1) exit pot(x,y,z) !=========================== allocate ( wb ( n1 , n2_loc , n3_loc )) call mpi_ftw_alloc ( n1 , n2 , n2_loc , n3 , n3_loc ) call ftw_init ( n1 , n2 , n3 , ft_mod ) !set wavenumber grid wb = 0.0 if ( prlx ) then do k = k1 , k2 do j = j1 , j2 aux1 ( 1 : n1 ) = 0.0 do i = i1 , i2 ii = i - 2 aux1 ( ii ) = rho ( i , j , k , 1 ) end do call all_gather_dpreal ( aux1 , aux2 , 3 , n1_loc ) do i = 1 , n1 wb ( i , j - 2 , k - 2 ) = aux2 ( i ) end do end do end do else wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) = rho ( i1 : i2 , j1 : j2 , k1 : k2 , 1 ) end if if ( ft_mod > 1 ) then call pftw3d_sc ( wb , n1 , n2 , n2_loc , n3 , n3_loc , - 1 , sym ) wb ( 1 : n1_loc , 1 : n2_loc , 1 : n3_loc ) = omp0 * wb ( 1 : n1_loc , 1 : n2_loc , 1 : n3_loc ) !========================== call beam_potential ( wb , g2 , n1 , n2_loc , n3_loc , ft_mod ) !exit sin/cos fourier components for beam potential call pftw3d_sc ( wb , n1 , n2 , n2_loc , n3 , n3_loc , 1 , sym ) else call pftw3d ( wb , n1 , n2 , n2_loc , n3 , n3_loc , - 1 ) wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) = omp0 * wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) !========================== call beam_potential ( wb , g2 , n1 , n2_loc , n3_loc , ft_mod ) !exit fourier components for beam potential call pftw3d ( wb , n1 , n2 , n2_loc , n3 , n3_loc , 1 ) end if call mpi_ftw_dalloc if ( s_ind > 0 ) then !Two new routines added allocate ( wa ( n1 , 4 * n2_loc , 4 * n3_loc )) if (. not . allocated ( fp1 )) allocate ( fp1 ( n1 , n2_loc , n3_loc )) call mpi_yzft_ord ( n2_loc , n3_loc ) call ft_overset_grid ( wb , wa , n1 , n2_loc , n3_loc ) !in fft/prl_fft  module call unif_to_str_field_interp ( wa , pot1 , 1 ) !put data in in fields/grid_fields module if ( allocated ( wa )) deallocate ( wa ) deallocate ( fp1 ) else rho ( i1 : i2 , j1 : j2 , k1 : k2 , 1 ) = wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) end if !EXIT rho(1) 3D beam potential if ( allocated ( wb )) deallocate ( wb ) call ftw_end end subroutine !=============================== subroutine fft_2d_psolv ( rho , pot1 , omp0 , n1 , n1_loc , n2 , n2_loc , n3 , n3_loc , & i1 , i2 , j1 , j2 , k1 , k2 , ft_mod , sym , sind ) real ( dp ), intent ( inout ) :: rho (:, :, :, :), pot1 (:, :, :, :) real ( dp ), intent ( in ) :: omp0 integer , intent ( in ) :: n1 , n1_loc , n2 , n2_loc , n3 , n3_loc integer , intent ( in ) :: ft_mod , sym , sind integer , intent ( in ) :: i1 , i2 , j1 , j2 , k1 , k2 integer :: i , ii , j , k allocate ( wb ( n1 , n2_loc , n3_loc )) call mpi_ftw_alloc ( n1 , n2 , n2_loc , n3 , n3_loc ) call ftw_init ( n1 , n2 , n3 , ft_mod ) wb = 0.0 if ( prlx ) then do k = k1 , k2 do j = j1 , j2 aux1 ( 1 : n1 ) = 0.0 do i = i1 , i2 ii = i - 2 aux1 ( ii ) = rho ( i , j , k , 1 ) end do call all_gather_dpreal ( aux1 , aux2 , 3 , n1_loc ) do i = 1 , n1 wb ( i , j - 2 , k - 2 ) = aux2 ( i ) end do end do end do else wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) = rho ( i1 : i2 , j1 : j2 , k1 : k2 , 1 ) end if if ( ft_mod > 1 ) then !sin/cosine transform call pftw2d_sc ( wb , n1 , n2 , n2_loc , n3 , n3_loc , - 1 , sym ) wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) = omp0 * wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) !========================== call beam_2d_potential ( wb , n1 , n2_loc , n3_loc , ft_mod ) !exit fourier components for potential call pftw2d_sc ( wb , n1 , n2 , n2_loc , n3 , n3_loc , 1 , sym ) else !periodic fft transform call pftw2d ( wb , n1 , n2 , n2_loc , n3 , n3_loc , - 1 ) wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) = omp0 * wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) !========================== call beam_2d_potential ( wb , n1 , n2_loc , n3_loc , ft_mod ) !exit fourier components for potential call pftw2d ( wb , n1 , n2 , n2_loc , n3 , n3_loc , 1 ) end if call mpi_ftw_dalloc if ( sind > 0 ) then !Two new routines added allocate ( wa ( n1 , 4 * n2_loc , n3_loc )) if (. not . allocated ( fp1 )) allocate ( fp1 ( n1 , n2_loc , n3_loc )) call mpi_yzft_ord ( n2_loc , n3_loc ) call ft_overset_grid ( wb , wa , n1 , n2_loc , n3_loc ) !in fft/prl_fft  module call unif_to_str_field_interp ( wa , pot1 , 1 ) !in fields/grid_fields module if ( allocated ( wa )) deallocate ( wa ) deallocate ( fp1 ) else rho ( i1 : i2 , j1 : j2 , k1 : k2 , 1 ) = wb ( 1 : n1 , 1 : n2_loc , 1 : n3_loc ) end if !EXIT rho(1) 2D beam potential if ( allocated ( wb )) deallocate ( wb ) call ftw_end end subroutine !========================== end module","tags":"","loc":"sourcefile/psolve.f90.html"},{"title":"grid_field_param.f90 – ALaDyn","text":"This file depends on sourcefile~~grid_field_param.f90~~EfferentGraph sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid_field_param.f90~~AfferentGraph sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid_field_param Source Code grid_field_param.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module grid_field_param use common_param use mpi_var use grid_param implicit none real ( dp ), allocatable :: ww1 (:), ww2 (:), ww0 (:, :), wr (:, :), & wl (:, :), var (:, :) real ( dp ) :: hord_der2 , opt_der2 , opt_der1 , aph_der , avg_cmp , & cmp_coeff ( 2 ), se_coeff ( 2 ), se4_coeff ( 2 ), upw ( 4 ) contains !========================================== subroutine set_field_param real ( dp ) :: nu integer :: ndmx , ng !================== nu = cfl if ( ndim > 1 ) nu = cfl * yx_rat / sqrt ( yx_rat * yx_rat + float ( ndim ) - 1. ) ndmx = max ( nx , ny , nz ) allocate ( ww1 ( ndmx + 5 ), ww2 ( ndmx + 5 ), ww0 ( ndmx + 5 , 5 + max ( ny_loc , nz_loc ))) allocate ( wr ( ndmx + 6 , 10 ), wl ( ndmx + 6 , 10 )) allocate ( var ( ndmx + 5 , 10 )) var (:, :) = 0.0 wr (:, :) = 0.0 wl (:, :) = 0.0 ww1 (:) = 0.0 ww2 (:) = 0.0 ww0 (:, :) = 0.0 ng = nx select case ( der_ord ) case ( 2 ) cmp_coeff ( 1 ) = 1. cmp_coeff ( 2 ) = 0. avg_cmp = 1.0 aph_der = cmp_coeff ( 2 ) * avg_cmp opt_der1 = 1. case ( 3 ) !                        nu=cfl*rat/sqrt(rat*rat+nd-1) multi-D optimized !                        coefficient !===================================== !For der_rder=3 opt first derivative on Yee grid cmp_coeff ( 1 ) = 1. + 0.125 * ( 1. - nu * nu ) !rot(E) and rot(B) Modified along x-coord cmp_coeff ( 2 ) = ( 1. - cmp_coeff ( 1 )) / 3. !-(1-nu*nu)/24 opt_der2 = - ( 1. - nu * nu ) / 1 2. hord_der2 = opt_der2 !For der_order=3 opt second derivative opt_der1 = ( 4. - nu * nu ) / 3. !For der_rder=3 opt for centered first derivative !========================= avg_cmp = 1. / ( cmp_coeff ( 1 ) + cmp_coeff ( 2 )) aph_der = cmp_coeff ( 2 ) * avg_cmp if ( comoving ) then cmp_coeff ( 1 ) = 5. / 8. cmp_coeff ( 2 ) = 1. / 8. end if case ( 4 ) !For forth-order first derivative on Yee grid cmp_coeff ( 1 ) = 1.125 !9/8(SE4) cmp_coeff ( 2 ) = ( 1. - cmp_coeff ( 1 )) / 3. !-1./24 !For forth-order second derivative hord_der2 = - 1. / 1 2. !=================================== avg_cmp = 1. / ( cmp_coeff ( 1 ) + cmp_coeff ( 2 )) aph_der = cmp_coeff ( 2 ) * avg_cmp se4_coeff ( 1 ) = 4. / 3. se4_coeff ( 2 ) = - 1. / 6. upw ( 1 ) = 1. / 3. upw ( 2 ) = 0.5 upw ( 3 ) = - 1. upw ( 4 ) = - ( upw ( 1 ) + upw ( 2 ) + upw ( 3 )) !------------------------------ end select se_coeff ( 1 : 2 ) = cmp_coeff ( 1 : 2 ) end subroutine end module","tags":"","loc":"sourcefile/grid_field_param.f90.html"},{"title":"grid_fields.f90 – ALaDyn","text":"This file depends on sourcefile~~grid_fields.f90~~EfferentGraph sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid_fields.f90~~AfferentGraph sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid_fields Source Code grid_fields.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module grid_fields use grid_field_param use parallel implicit none integer , parameter , private :: x_parity ( 6 ) = [ - 1 , 1 , 1 , - 1 , 1 , 1 ] integer , parameter , private :: y_parity ( 6 ) = [ 1 , - 1 , 1 , 1 , - 1 , 1 ] integer , parameter , private :: z_parity ( 6 ) = [ 1 , 1 , - 1 , 1 , 1 , - 1 ] integer , dimension ( 2 , 3 ), protected , private :: COEFF_2 integer , dimension ( 2 , 2 ), protected , private :: COEFF_1 integer , dimension ( 2 , 1 ), protected , private :: COEFF_0 contains subroutine trid_der1 ( a , b , c , b1 , c1 , an , bn , n , ic1 , ic2 , ord ) real ( dp ), intent ( in ) :: a , b , c , b1 , c1 , an , bn integer , intent ( in ) :: n , ic1 , ic2 , ord integer :: k , ic real ( dp ) :: bet !========================== ! Solves ! a*ww(i-1)+b*ww(i)+c*ww(i+1)=u(i), i=2,3,..,n-1 ! at the first row b1*ww(1)+c1*ww(2)=u(1) ! at the n-last row an*ww(n-1)+bn*ww(n)=u(n) ! first order boundary clusure !=============================== if ( ord > 0 ) then do ic = ic1 , ic2 ww0 ( 1 , ic ) = ww0 ( 1 , ic ) + ww0 ( 2 , ic ) ww0 ( n , ic ) = ww0 ( n , ic ) + ww0 ( n - 1 , ic ) end do end if !=================== do ic = ic1 , ic2 ww1 ( 1 ) = 0.0 bet = b1 ww0 ( 1 , ic ) = ww0 ( 1 , ic ) / bet k = 2 ww1 ( k ) = c1 / bet bet = b - a * ww1 ( k ) ww0 ( k , ic ) = ( ww0 ( k , ic ) - a * ww0 ( k - 1 , ic )) / bet do k = 3 , n - 1 ww1 ( k ) = c / bet bet = b - a * ww1 ( k ) ww0 ( k , ic ) = ( ww0 ( k , ic ) - a * ww0 ( k - 1 , ic )) / bet end do k = n ww1 ( k ) = c / bet bet = bn - an * ww1 ( k ) ww0 ( k , ic ) = ( ww0 ( k , ic ) - an * ww0 ( k - 1 , ic )) / bet do k = n - 1 , 1 , - 1 ww0 ( k , ic ) = ww0 ( k , ic ) - ww1 ( k + 1 ) * ww0 ( k + 1 , ic ) end do end do end subroutine !================================= subroutine unif_to_str_field_interp ( unif_field , str_field , ic ) real ( dp ), intent ( in ) :: unif_field (:, :, :) real ( dp ), intent ( inout ) :: str_field (:, :, :, :) integer , intent ( in ) :: ic real ( dp ) :: shy , shz , shy2 , shz2 integer :: i , ii , j , jj , k , kk integer :: jsize , ksize !======================================= jsize = size ( unif_field , 2 ) ksize = size ( unif_field , 3 ) !===================== select case ( ndim ) case ( 2 ) k = kz1 kk = 1 do j = jy1 , jy2 jj = yft_ind ( j - 2 , imody ) shy = dy_inv * ( loc_yg ( j - 2 , 1 , imody ) - loc_yft ( jj , imody )) shy2 = 0.5 * shy * shy shy = 0.5 * shy do i = ix1 , ix2 ii = i - 2 str_field ( i , j , k , ic ) = unif_field ( ii , jj , kk ) + & shy * ( unif_field ( ii , jj + 1 , kk ) - unif_field ( ii , jj - 1 , kk )) + & shy2 * ( unif_field ( ii , jj + 1 , kk ) + unif_field ( ii , jj - 1 , kk ) - 2 * unif_field ( ii , jj , kk )) end do end do case ( 3 ) do k = kz1 , kz2 kk = zft_ind ( k - 2 , imodz ) shz = dz_inv * ( loc_zg ( k - 2 , 1 , imodz ) - loc_zft ( kk , imodz )) shz2 = 0.5 * shz * shz shz = 0.5 * shz do j = jy1 , jy2 jj = yft_ind ( j - 2 , imody ) shy = dy_inv * ( loc_yg ( j - 2 , 1 , imody ) - loc_yft ( jj , imody )) shy2 = 0.5 * shy * shy shy = 0.5 * shy do i = ix1 , ix2 ii = i - 2 str_field ( i , j , k , ic ) = unif_field ( ii , jj , kk ) + & shy * ( unif_field ( ii , jj + 1 , kk ) - unif_field ( ii , jj - 1 , kk )) + & shz * ( unif_field ( ii , jj , kk + 1 ) - unif_field ( ii , jj , kk - 1 )) str_field ( i , j , k , ic ) = str_field ( i , j , k , ic ) + & shy2 * ( unif_field ( ii , jj + 1 , kk ) + unif_field ( ii , jj - 1 , kk ) - 2 * unif_field ( ii , jj , kk )) str_field ( i , j , k , ic ) = str_field ( i , j , k , ic ) + & shz2 * ( unif_field ( ii , jj , kk + 1 ) + unif_field ( ii , jj , kk - 1 ) - 2 * unif_field ( ii , jj , kk )) end do end do end do end select end subroutine subroutine enforce_continuity ( curr ) real ( dp ), intent ( inout ) :: curr (:, :, :, :) real ( dp ) :: aphy , aphz , shy , shz integer :: i , ii , j , k , jj , j01 , k01 !===================== 3D Cartesian !Solves DJ_x/Dx =-[DJ_y/Dy+DJ_z/Dz +[Rho&#94;{n+1}-Rho&#94;n]/Dt]= ! Eneter curr(1)= Drho, curr(2)=J_y*Dt  curr(3)= J_z*Dt !======================================= aphy = dy_inv aphz = dz_inv j01 = jy1 k01 = kz1 !shy(3)=Dxi/Dy centered on node y_j if ( ndim == 1 ) return if ( pe0y ) then j = jy1 shy = loc_yg ( j - 1 , 3 , imody ) * aphy do k = kz1 , kz2 do i = ix1 , ix2 curr ( i , j , k , 1 ) = curr ( i , j , k , 1 ) + shy * ( curr ( i , j + 1 , k , 2 ) - curr ( i , & j , k , 2 )) end do end do j01 = jy1 + 1 end if do k = kz1 , kz2 do j = j01 , jy2 jj = j - 2 shy = loc_yg ( jj , 3 , imody ) * aphy do i = ix1 , ix2 curr ( i , j , k , 1 ) = curr ( i , j , k , 1 ) + shy * ( curr ( i , j , k , 2 ) - curr ( i , j - & 1 , k , 2 )) end do end do end do !================ ndim >2 if ( ndim == 3 ) then if ( pe0z ) then k = kz1 shz = loc_zg ( k - 1 , 3 , imodz ) * aphz do j = jy1 , jy2 do i = ix1 , ix2 curr ( i , j , k , 1 ) = curr ( i , j , k , 1 ) + shz * ( curr ( i , j , k + 1 , 3 ) - curr ( i & , j , k , 3 )) end do end do k01 = kz1 + 1 end if do k = k01 , kz2 shz = loc_zg ( k - 2 , 3 , imodz ) * aphz do j = jy1 , jy2 do i = ix1 , ix2 curr ( i , j , k , 1 ) = curr ( i , j , k , 1 ) + shz * ( curr ( i , j , k , 3 ) - curr ( i , j & , k - 1 , 3 )) end do end do end do end if !=============== 1D invertion of first derivative ww0 (:, :) = 0.0 do k = kz1 , kz2 do j = jy1 , jy2 do i = ix2 , ix1 , - 1 ii = i - 2 ww0 ( ii , 1 ) = ww0 ( ii + 1 , 1 ) + dx * curr ( i + 1 , j , k , 1 ) end do do i = ix1 , ix2 ii = i - 2 curr ( i , j , k , 1 ) = ww0 ( ii , 1 ) end do end do end do end subroutine subroutine field_xadvect ( ef , dth , v_adv , ic1 , ic2 , isch ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: dth , v_adv integer , intent ( in ) :: ic1 , ic2 , isch integer :: i1 , n1p , i , j , k , ii , ic , ind real ( dp ) :: aphx , aphx_exp , aphx_impl , a , b , c , b1 , c1 , an , bn real ( dp ), dimension ( 3 ), parameter :: RDER = [ - 3. , 4. , - 1. ] !===================== ! APPLIES also for prlx=.true. (MPI x decomposition) !============================================= ! Solves Df/Dt=-v_adv*Df/Dx    Df/Dx =[f_{i+1}-f_{i-1}]/(2Dx) ! forward advection for v_adv > 0 ! backward advection for v_adv <0 ! In comoving system in the Maxwell eqs. enters v_adv <0 !================== !Explicit first order advection scheme !          E&#94;{n+1}=(1-aphx_exp*D_x)E&#94;n !Semi-implicit advection scheme in x-coordinate !          E&#94;n+1=E&#94;n-aphx_impl*[D_xE&#94;n+D_xE&#94;{n+1}] !          (1+aphx_impl*D_x)E&#94;{n+1}=(1-aphx_impl*D_x)E&#94;n !Fully-implicit advection scheme in x-coordinate !          (1+aphx_exp*D_x)E&#94;{n+1}=E&#94;n !================================ aphx = dth * dx_inv aphx_exp = 0.5 * v_adv * aphx !v_adv*dt/2Dx aphx_impl = 0.5 * aphx_exp !v_adv*(dt/2Dx)/2 ind = 1 b1 = 1. c1 = 0.0 bn = 1. an = 0.0 !bn = 1.-2.*aphx_adv !cn = 2.*aphx_adv !===================== i1 = ix1 n1p = ix2 !========================= if ( pe0x ) then do ic = ic1 , ic2 do k = kz1 , kz2 do j = jy1 , jy2 ef ( i1 - 1 , j , k , ic ) = ef ( i1 + 1 , j , k , ic ) end do end do end do end if if ( pe1x ) then do ic = ic1 , ic2 do k = kz1 , kz2 do j = jy1 , jy2 ef ( n1p + 1 , j , k , ic ) = ef ( n1p , j , k , ic ) end do end do end do end if !=============================== select case ( isch ) case ( 0 ) !pure explicit do ic = ic1 , ic2 do k = kz1 , kz2 do j = jy1 , jy2 do i = i1 , n1p ii = i - 2 ww0 ( ii , 1 ) = ef ( i , j , k , ic ) - aphx_exp * ( ef ( i + 1 , j , k , ic ) - ef ( i - 1 , j & , k , ic )) end do do i = i1 , n1p ii = i - 2 ef ( i , j , k , ic ) = ww0 ( ii , 1 ) end do end do end do end do case ( 1 ) !semi-implicit a = - aphx_impl b = 1. c = - a do ic = ic1 , ic2 do k = kz1 , kz2 do j = jy1 , jy2 do i = i1 , n1p ii = i - 2 ww0 ( ii , 1 ) = ef ( i , j , k , ic ) - aphx_impl * ( ef ( i + 1 , j , k , ic ) - ef ( i - 1 , & j , k , ic )) end do call trid_der1 ( a , b , c , b1 , c1 , an , bn , ii , 1 , 1 , 0 ) do i = i1 , n1p ii = i - 2 ef ( i , j , k , ic ) = ww0 ( ii , 1 ) end do end do end do end do case ( 2 ) !fully implicit (1+aphx_exp)*Dx]ef=ef a = - aphx_exp b = 1. c = - a do ic = ic1 , ic2 do k = kz1 , kz2 do j = jy1 , jy2 do i = i1 , n1p ii = i - 2 ww0 ( ii , 1 ) = ef ( i , j , k , ic ) end do call trid_der1 ( a , b , c , b1 , c1 , an , bn , ii , 1 , 1 , 0 ) do i = i1 , n1p ii = i - 2 ef ( i , j , k , ic ) = ww0 ( ii , 1 ) end do end do end do end do end select end subroutine !================================== subroutine pp_lapl ( av , source , ic1 , ic2 ) real ( dp ), intent ( inout ) :: av (:, :, :, :) real ( dp ), intent ( inout ) :: source (:, :, :, :) integer , intent ( in ) :: ic1 , ic2 integer :: i , j , k , ic , jj , j01 , j02 , k01 , k02 , i01 , i02 real ( dp ) :: dy2_inv , dz2_inv , cf ( 2 ), shy , shz , sphy , smhy , sphz , & smhz real ( dp ) :: dy4_inv ( 2 ), dz4_inv ( 2 ) !========================== ! is=1 adds  is=-1 subtracts the laaplacian term !========================== dy2_inv = dy_inv * dy_inv dz2_inv = dz_inv * dz_inv cf ( 1 ) = 1. cf ( 2 ) = . 0 if ( der_ord == 4 ) then cf ( 1 ) = 4. / 3. !1-8*hord_der2/3 cf ( 2 ) = - 1. / 1 2. !2*(2*hord_der2-1) end if dy4_inv ( 1 ) = cf ( 1 ) * dy2_inv dy4_inv ( 2 ) = cf ( 2 ) * dy2_inv dz4_inv ( 1 ) = cf ( 1 ) * dz2_inv dz4_inv ( 2 ) = cf ( 2 ) * dz2_inv !=========================== !Second order derivative. At boundaries D&#94;3[av]=0 i01 = ix1 i02 = ix2 j01 = jy1 j02 = jy2 k01 = kz1 k02 = kz2 do ic = ic1 , ic2 do k = k01 , k02 do j = j01 , j02 jj = j - 2 shy = dy4_inv ( 1 ) * loc_yg ( jj , 3 , imody ) sphy = loc_yg ( jj , 4 , imody ) smhy = loc_yg ( jj - 1 , 4 , imody ) do i = i01 , i02 source ( i , j , k , ic ) = source ( i , j , k , ic ) + shy * ( sphy * ( av ( i , j + 1 , k , ic ) - av ( i , j , k , ic )) - & smhy * ( av ( i , j , k , ic ) - av ( i , j - 1 , k , ic ))) end do end do end do end do if ( der_ord == 4 ) then do ic = ic1 , ic2 do k = k01 , k02 do j = j01 , j02 jj = j - 2 shy = dy4_inv ( 2 ) * loc_yg ( jj , 3 , imody ) sphy = loc_yg ( jj + 1 , 3 , imody ) smhy = loc_yg ( jj - 1 , 3 , imody ) do i = i01 , i02 source ( i , j , k , ic ) = source ( i , j , k , ic ) + shy * ( sphy * ( av ( i , j + 2 , k , ic ) - av ( i , j , k , ic )) - & smhy * ( av ( i , j , k , ic ) - av ( i , j - 2 , k , ic ))) end do end do end do end do end if if ( ndim < 3 ) return !==================== do ic = ic1 , ic2 do k = k01 , k02 jj = k - 2 shz = dz4_inv ( 1 ) * loc_zg ( jj , 3 , imodz ) sphz = loc_zg ( jj , 4 , imodz ) smhz = loc_zg ( jj - 1 , 4 , imodz ) do j = j01 , j02 do i = i01 , i02 source ( i , j , k , ic ) = source ( i , j , k , ic ) + shz * ( sphz * ( av ( i , j , k + 1 , ic ) - av ( i , j , k , ic )) - & smhz * ( av ( i , j , k , ic ) - av ( i , j , k - 1 , ic ))) end do end do end do end do if ( der_ord == 4 ) then do ic = ic1 , ic2 do k = k01 , k02 jj = k - 2 shz = dz4_inv ( 2 ) * loc_zg ( jj , 3 , imodz ) sphz = loc_zg ( jj + 1 , 3 , imodz ) smhz = loc_zg ( jj - 1 , 3 , imodz ) do j = j01 , j02 do i = i01 , i02 source ( i , j , k , ic ) = source ( i , j , k , ic ) + shz * ( sphz * ( av ( i , j , k + 2 , ic ) - av ( i , j , k , ic )) - & smhz * ( av ( i , j , k , ic ) - av ( i , j , k - 2 , ic ))) end do end do end do end do end if !====================================== end subroutine !======================== subroutine env_grad ( envg ) real ( dp ), intent ( inout ) :: envg (:, :, :, :) integer :: i , j , k , i01 , i02 , j01 , j02 , k01 , k02 real ( dp ) :: ax1 , ax2 , ay1 , ay2 , az1 , az2 , shz , shy , shp , shm real ( dp ), parameter :: a_hcd = 1 3. / 1 2. , b_hcd = - 1. / 2 4. !=== second or fourth order central flux derivatives !========================== ! Enters envg(1)= |A|&#94;2/2 exit grad|A|&#94;2/2 if ( der_ord < 4 ) then ax1 = dx_inv ay1 = dy_inv az1 = dz_inv ax2 = 0. ay2 = 0. az2 = 0. else ax1 = dx_inv * a_hcd ay1 = dy_inv * a_hcd az1 = dz_inv * a_hcd ax2 = dx_inv * b_hcd ay2 = dy_inv * b_hcd az2 = dz_inv * b_hcd end if i01 = ix1 i02 = ix2 j01 = jy1 j02 = jy2 k01 = kz1 k02 = kz2 !================ if ( xl_bd ) then i = ix1 do k = kz1 , kz2 do j = jy1 , jy2 envg ( i , j , k , 2 ) = dx_inv * ( envg ( i + 1 , j , k , 1 ) - envg ( i , j , k , 1 )) !at i+1/2 end do end do i01 = ix1 + 1 endif if ( xr_bd ) then do k = kz1 , kz2 do j = jy1 , jy2 i = ix2 - 1 envg ( i , j , k , 2 ) = dx_inv * ( envg ( i + 1 , j , k , 1 ) - envg ( i , j , k , 1 )) envg ( i + 1 , j , k , 2 ) = dx_inv * ( 2. * envg ( i , j , k , 1 ) - 3. * envg ( i - 1 , j , k , 1 ) + & envg ( i - 2 , j , k , 1 )) end do end do i02 = ix2 - 2 endif do k = kz1 , kz2 do j = jy1 , jy2 do i = i01 , i02 envg ( i , j , k , 2 ) = ax1 * ( envg ( i + 1 , j , k , 1 ) - envg ( i , j , k , 1 )) !at i+1/2 end do end do end do if ( der_ord == 4 ) then do k = kz1 , kz2 do j = jy1 , jy2 do i = i01 , i02 envg ( i , j , k , 2 ) = envg ( i , j , k , 2 ) + ax2 * ( envg ( i + 2 , j , k , 1 ) - envg ( i + 1 , j , k , 1 ) + & envg ( i , j , k , 1 ) - envg ( i - 1 , j , k , 1 )) end do end do end do end if if ( yr_bd ) then do k = kz1 , kz2 j = jy2 shy = loc_yg ( j - 2 , 4 , imody ) * dy_inv do i = ix1 , ix2 envg ( i , j , k , 3 ) = shy * ( 2. * envg ( i , j , k , 1 ) - 3. * envg ( i , j - 1 , k , 1 ) + envg ( i & , j - 2 , k , 1 )) end do j = jy2 - 1 shy = loc_yg ( j - 2 , 4 , imody ) * dy_inv do i = ix1 , ix2 envg ( i , j , k , 3 ) = shy * ( envg ( i , j + 1 , k , 1 ) - envg ( i , j , k , 1 )) end do end do j02 = jy2 - 2 end if !=================== if ( yl_bd ) then j = jy1 shy = loc_yg ( j - 2 , 4 , imody ) * dy_inv do k = kz1 , kz2 do i = ix1 , ix2 envg ( i , j , k , 3 ) = shy * ( envg ( i , j + 1 , k , 1 ) - envg ( i , j , k , 1 )) end do end do j01 = jy1 + 1 end if do k = kz1 , kz2 do j = j01 , j02 shy = loc_yg ( j - 2 , 4 , imody ) * ay1 do i = ix1 , ix2 envg ( i , j , k , 3 ) = shy * ( envg ( i , j + 1 , k , 1 ) - envg ( i , j , k , 1 )) end do end do end do if ( der_ord == 4 ) then do k = kz1 , kz2 do j = j01 , j02 shp = loc_yg ( j - 1 , 4 , imody ) * ay2 shm = loc_yg ( j - 3 , 4 , imody ) * ay2 do i = ix1 , ix2 envg ( i , j , k , 3 ) = envg ( i , j , k , 3 ) + shp * ( envg ( i , j + 2 , k , 1 ) - envg ( i , j + 1 , k , 1 )) + & shm * ( envg ( i , j , k , 1 ) - envg ( i , j - 1 , k , 1 )) end do end do end do end if if ( ndim == 2 ) return if ( zr_bd ) then k = kz2 shz = loc_zg ( k - 2 , 4 , imodz ) * dz_inv do j = jy1 , jy2 do i = ix1 , ix2 envg ( i , j , k + 1 , 1 ) = 2. * envg ( i , j , k , 1 ) - envg ( i , j , k - 1 , 1 ) envg ( i , j , k , 4 ) = shz * ( envg ( i , j , k + 1 , 1 ) - envg ( i , j , k , 1 )) end do end do k02 = kz2 - 1 end if if ( zl_bd ) then k = kz1 shz = loc_zg ( k - 2 , 4 , imodz ) * dz_inv do j = jy1 , jy2 do i = ix1 , ix2 envg ( i , j , k - 1 , 1 ) = 2. * envg ( i , j , k , 1 ) - envg ( i , j , k + 1 , 1 ) envg ( i , j , k , 4 ) = shz * ( envg ( i , j , k + 1 , 1 ) - envg ( i , j , k , 1 )) end do end do k01 = kz1 + 1 end if !================== do k = k01 , k02 shz = loc_zg ( k - 2 , 4 , imodz ) * az1 do j = jy1 , jy2 do i = ix1 , ix2 envg ( i , j , k , 4 ) = shz * ( envg ( i , j , k + 1 , 1 ) - envg ( i , j , k , 1 )) end do end do end do if ( der_ord == 4 ) then do k = k01 , k02 shp = loc_zg ( k - 1 , 4 , imodz ) * az2 shm = loc_zg ( k - 3 , 4 , imodz ) * az2 do j = jy1 , jy2 do i = ix1 , ix2 envg ( i , j , k , 4 ) = envg ( i , j , k , 4 ) + shp * ( envg ( i , j , k + 2 , 1 ) - envg ( i , j , k + 1 , 1 )) + & shm * ( envg ( i , j , k , 1 ) - envg ( i , j , k - 1 , 1 )) end do end do end do end if end subroutine !==================================== subroutine env_maxw_solve ( curr , evf , om0 , dtl ) real ( dp ), intent ( inout ) :: curr (:, :, :, :), evf (:, :, :, :) real ( dp ), intent ( in ) :: om0 , dtl integer :: i , j , k , ic real ( dp ) :: dt2 , dx1_inv , dhx1_inv , aph_opt ( 2 ) real ( dp ) :: kfact , k2_fact , skfact real ( dp ), dimension ( 0 : 2 ), parameter :: LDER = [ 1.0 , - 4.0 , 3.0 ] !========================== ! EXPLICIT INTEGRATION of Maxwell ENVELOPE EVOLUTION EQUATION ! See: D.Terzani P. Londrillo \" A fast and accurate numerical ! implementation of the envelope model for laser–plasma dynamics \" !         CPC 2019 !============================ dt2 = dtl * dtl !khfact=2.*sin(0.5*om0*dt_loc)/dt_loc !kh2_fact=khfact*khfact !khfact=2.*dhx*sin(0.5*om0*dx) !kh2_sfact=khfact*khfact !kfact=sin(om0*dt_loc) kfact = om0 * dtl k2_fact = 1. / ( 1. + kfact * kfact ) skfact = om0 !skfact=dhx*sin(om0*dx) dx1_inv = skfact * dx_inv dhx1_inv = 2. * dx1_inv aph_opt ( 1 ) = 1. aph_opt ( 2 ) = 0. if ( der_ord == 3 ) then aph_opt ( 1 ) = dx1_inv * opt_der1 aph_opt ( 2 ) = dx1_inv * 0.5 * ( 1. - opt_der1 ) end if ic = 2 !========Enter  jc(1:2)= - omp2*<q&#94;2*chi*env(1:2) !                        chi <q&#94;2*wgh*n/gam_p> >0 ! Computes the full Laplacian of A&#94;{n}=env(1:2) components !========and adds to  jc(1:2) call potential_lapl ( evf , curr , 1 , ic ) !===================== ! =>   jc(1:2)=[D&#94;2-omp&#94;2*chi]A= S(A); !================= !  Computes D_{x} centered first derivatives of A and adds to S(A) call first_ader !S_R => S_R -2*k0[D_xA_I] !S_I => S_I +2*k0[D_xA_R] ! do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 curr ( i , j , k , 1 ) = dt2 * curr ( i , j , k , 1 ) + 2. * evf ( i , j , k , 1 ) - & evf ( i , j , k , 3 ) + kfact * evf ( i , j , k , 4 ) curr ( i , j , k , 2 ) = dt2 * curr ( i , j , k , 2 ) + 2. * evf ( i , j , k , 2 ) - & evf ( i , j , k , 4 ) - kfact * evf ( i , j , k , 3 ) end do end do end do !==================== !curr(1)=F_R=dt2*S_R+2*A_R&#94;n-A_R&#94;{n-1}-kfact*A_I&#94;{n-1} !curr(2)=F_I=dt2*S_I+2*A_I&#94;n-A_I&#94;{n-1}+kfact*A_R&#94;{n-1} do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 evf ( i , j , k , 3 ) = evf ( i , j , k , 1 ) !A&#94;{n}=> A&#94;{n-1} evf ( i , j , k , 4 ) = evf ( i , j , k , 2 ) evf ( i , j , k , 1 ) = k2_fact * ( curr ( i , j , k , 1 ) - kfact * curr ( i , j , k , 2 )) evf ( i , j , k , 2 ) = k2_fact * ( curr ( i , j , k , 2 ) + kfact * curr ( i , j , k , 1 )) end do end do end do contains subroutine first_ader !============ integer :: i01 , i02 ! explicit second order [-2isin(k0dx)*Dx]A and add to S(A) i01 = ix1 i02 = ix2 if ( der_ord < 3 ) then do k = kz1 , kz2 do j = jy1 , jy2 do i = i01 , i02 curr ( i , j , k , 1 ) = curr ( i , j , k , 1 ) - dx1_inv * ( evf ( i + 1 , j , k , 2 ) - & evf ( i - 1 , j , k , 2 )) curr ( i , j , k , 2 ) = curr ( i , j , k , 2 ) + dx1_inv * ( evf ( i + 1 , j , k , 1 ) - & evf ( i - 1 , j , k , 1 )) end do end do end do else do k = kz1 , kz2 do j = jy1 , jy2 do i = i01 , i02 curr ( i , j , k , 1 ) = curr ( i , j , k , 1 ) - aph_opt ( 1 ) * ( evf ( i + 1 , j , k , 2 ) - & evf ( i - 1 , j , k , 2 )) - & aph_opt ( 2 ) * ( evf ( i + 2 , j , k , 2 ) - & evf ( i - 2 , j , k , 2 )) curr ( i , j , k , 2 ) = curr ( i , j , k , 2 ) + aph_opt ( 1 ) * ( evf ( i + 1 , j , k , 1 ) - & evf ( i - 1 , j , k , 1 )) + & aph_opt ( 2 ) * ( evf ( i + 2 , j , k , 1 ) - & evf ( i - 2 , j , k , 1 )) end do end do end do end if end subroutine end subroutine !================================== subroutine env_lpf_solve ( curr , evf , ib , om0 , dtl ) real ( dp ), intent ( inout ) :: curr (:, :, :, :), evf (:, :, :, :) integer , intent ( in ) :: ib real ( dp ), intent ( in ) :: om0 , dtl integer :: i , j , k , ii , ic , ic1 , n1 real ( dp ) :: dhx , dx1_inv , om2 , aph1 , dx_norm , dx2_norm real ( dp ) :: adv , an , bn , der2_norm !========================== ! EXPLICIT INTEGRATION of REDUCED ENVELOPE FIELD SOLVER !============================ ! Fourth order first derivative ! D_xu= 2/3[u_{i+1}-u_{i-1}]- [u_{i+2}-u_{i-2}]/12 !==================== dhx = dx_inv om2 = om0 * om0 dx1_inv = 0.5 * dx_inv aph1 = dx1_inv n1 = ix2 + 1 - ix1 dx_norm = dhx / om0 dx2_norm = dx_norm * dx_norm der2_norm = 0.25 * dx2_norm !========Enter  jc(1:2)= -om2*<q&#94;2*chi*env(1:2) !        chi <q&#94;2*wgh*n/gam_p> >0 ! Computes the transverse Laplacian of A&#94;{n}=env(1:2) components !========and adds to jc(1:2) ic = 2 call pp_lapl ( evf , curr , 1 , 2 ) !===================== do ic = 1 , 2 do k = kz1 , kz2 do j = jy1 , jy1 do i = ix1 , ix2 curr ( i , j , k , ic ) = - dtl * curr ( i , j , k , ic ) end do end do end do end do !======================================================= ! =>   jc(1:2)=2*Delta t*S(A)=-dt*[D&#94;2_{pp}-omp&#94;2*chi]A; !================= !  Computes D_{xi} centered first derivatives of S(A) !      ww0(1)= k0*S(A_I) + D_xi[A_R]= F_R !      ww0(2)= -k0*S(A_R) + D_xi[A_I]= F_I !==================== call first_der !curr(1)=F&#94;R !curr(2)=F&#94;I !================== ! The M operator M=[k0*k0+D_xD_x]X = F   X=DA/Dtau !   Explicit inversion !M&#94;{-1}=([1-Dx_norm&#94;2]F)/k0*k0 !=============== call explicit_mat_inv !curr=M&#94;{-1}F if ( ib > 0 ) then !fixed coordinate system (x,t) !======================= !(1+Dt*D_x)A&#94;{n+1}=(1-Dt*D_x)A&#94;{n-1}+ M&#94;{-1}F !================================== select case ( ib ) !ib=der-1 case ( 1 ) !================= Explicit second order adv = dtl * dhx !cfl=dt/dx do ic = 1 , 2 ic1 = ic + 2 do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 curr ( i , j , k , ic ) = curr ( i , j , k , ic ) + evf ( i , j , k , ic1 ) - & adv * ( evf ( i + 1 , j , k , ic ) - evf ( i - 1 , j , k , ic )) end do do i = ix1 , ix2 evf ( i , j , k , ic1 ) = evf ( i , j , k , ic ) evf ( i , j , k , ic ) = curr ( i , j , k , ic ) end do end do end do end do case ( 2 ) !Explicit  optimized !======================= ! u&#94;{n+1}=u&#94;{n-1}+adv*(u_{i+1}-u_{i-1})+0.5*adv*( !adv=dt_loc*dhx     !cfl=dt/dx !======================================== adv = dtl * dhx an = ( 4. - adv * adv ) / 3. bn = 0.5 * adv * ( 1. - an ) an = an * adv do ic = 1 , 2 ic1 = ic + 2 do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 curr ( i , j , k , ic ) = curr ( i , j , k , ic ) + evf ( i , j , k , ic1 ) - & an * ( evf ( i + 1 , j , k , ic ) - evf ( i - 1 , j , k , ic )) - & bn * ( evf ( i + 2 , j , k , ic ) - evf ( i - 2 , j , k , ic )) end do do i = ix1 , ix2 evf ( i , j , k , ic1 ) = evf ( i , j , k , ic ) evf ( i , j , k , ic ) = curr ( i , j , k , ic ) end do end do end do end do end select else !ib=0 comoving coordinate system do ic = 1 , 2 ic1 = ic + 2 do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 curr ( i , j , k , ic ) = curr ( i , j , k , ic ) + evf ( i , j , k , ic1 ) !Curr=A&#94;{n-1}+curr evf ( i , j , k , ic1 ) = evf ( i , j , k , ic ) !A&#94;{n-1}=> A&#94;n evf ( i , j , k , ic ) = curr ( i , j , k , ic ) !A&#94;{n+1}=curr end do end do end do end do end if contains subroutine first_der !============ ! explicit second order do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 ii = i - 2 ww0 ( ii , 1 ) = om0 * curr ( i , j , k , 2 ) + dx1_inv * ( curr ( i + 1 , j , k , 1 ) - curr & ( i - 1 , j , k , 1 )) ww0 ( ii , 2 ) = - om0 * curr ( i , j , k , 1 ) + dx1_inv * ( curr ( i + 1 , j , k , 2 ) - & curr ( i - 1 , j , k , 2 )) end do do i = ix1 , ix2 ii = i - 2 curr ( i , j , k , 1 ) = ww0 ( ii , 1 ) curr ( i , j , k , 2 ) = ww0 ( ii , 2 ) end do end do end do end subroutine !============================ subroutine explicit_mat_inv integer :: iic !================== Uses three-point numerical secon derivative do iic = 1 , 2 do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 ii = i - 2 ww0 ( ii , 1 ) = dx2_norm * ( curr ( i + 1 , j , k , iic ) - 2. * curr ( i , j , k , iic ) + curr ( i & - 1 , j , k , iic )) end do do i = ix1 , ix2 ii = i - 2 curr ( i , j , k , iic ) = ( curr ( i , j , k , iic ) - ww0 ( ii , 1 )) / om2 end do end do end do end do end subroutine !======================= end subroutine !======================== ! END ENV SECTION !========== LASER FIELDS SECTION !            (E,B) BC in open boundaries (lowest order Yee method !========================================== subroutine env_bds ( ef , ptrght , ptlft , init_ic , end_ic ) !! Boundary conditions for the envelope field. !! Empirically set to be continuous with continuous first derivative. real ( dp ), intent ( inout ) :: ef (:, :, :, :) integer , intent ( in ) :: ptlft , ptrght integer , optional , intent ( in ) :: init_ic , end_ic real ( dp ) :: shx , shy , shz , smy , smz , alpha integer :: i , j , k , iic , i1 , i2 , j1 , j2 , k1 , k2 , point integer :: comp1 , comp2 integer , dimension ( 1 , 2 ) :: COEFF integer :: stenc COEFF_2 ( 1 , :) = [ 3 , - 3 , 1 ] COEFF_2 ( 2 , :) = [ 6 , - 8 , 3 ] COEFF_1 ( 1 , :) = [ 2 , - 1 ] COEFF_1 ( 2 , :) = [ 3 , - 2 ] COEFF_0 ( 1 , :) = 1 COEFF_0 ( 2 , :) = 1 comp1 = 1 comp2 = 2 if ( present ( init_ic )) then comp1 = init_ic endif if ( present ( end_ic )) then comp2 = end_ic endif j1 = jy1 j2 = jy2 k1 = kz1 k2 = kz2 i1 = ix1 i2 = ix2 shx = dx_inv stenc = 1 COEFF = TRANSPOSE ( COEFF_0 ) if ( xl_bd ) then if ( ibx == 0 ) then do iic = comp1 , comp2 do k = k1 , k2 do j = j1 , j2 do point = ptlft , 1 , - 1 i = i1 - point ef ( i , j , k , iic ) = DOT_PRODUCT ( COEFF ( 1 : stenc , point ), ef ( i1 :( i1 + stenc - 1 ), j , k , iic )) end do end do end do end do end if if ( ibx == 1 ) then do iic = comp1 , comp2 do k = k1 , k2 do j = j1 , j2 do i = i1 - ptlft , i1 - 1 ef ( i , j , k , iic ) = x_parity ( iic ) * ef ( 2 * i1 - i , j , k , iic ) end do end do end do end do end if i1 = i1 - ptlft end if if ( xr_bd ) then if ( ibx == 0 ) then do iic = comp1 , comp2 do k = k1 , k2 do j = j1 , j2 do point = 1 , ptrght i = i2 + point ef ( i , j , k , iic ) = DOT_PRODUCT ( COEFF ( 1 : stenc , point ), ef ( i2 :( i2 - stenc + 1 ), j , k , iic )) end do end do end do end do end if if ( ibx == 1 ) then do iic = comp1 , comp2 do k = k1 , k2 do j = j1 , j2 do i = i2 + 1 , i2 + ptrght ef ( i , j , k , iic ) = x_parity ( iic ) * ef ( 2 * i2 - i , j , k , iic ) end do end do end do end do end if i2 = i2 + ptrght end if if ( ndim < 2 ) return if ( yl_bd ) then if ( iby == 0 ) then do j = j1 - ptlft , j1 - 1 shy = loc_yg ( j1 - 2 , 4 , imody ) smy = loc_yg ( j1 - 1 , 4 , imody ) alpha = shy / smy ef ( i1 : i2 , j , k1 : k2 , comp1 : comp2 ) = alpha * ( ef ( i1 : i2 , j1 + 2 , k1 : k2 , comp1 : comp2 ) - & ef ( i1 : i2 , j1 + 1 , k1 : k2 , comp1 : comp2 )) - & 2 * ef ( i1 : i2 , j1 + 1 , k1 : k2 , comp1 : comp2 ) + & 3 * ef ( i1 : i2 , j1 , k1 : k2 , comp1 : comp2 ) end do end if if ( iby == 1 ) then do iic = comp1 , comp2 do k = k1 , k2 do j = j1 - ptlft , j1 - 1 do i = i1 , i2 ef ( i , j , k , iic ) = y_parity ( iic ) * ef ( i , 2 * j1 - j , k , iic ) end do end do end do end do end if j1 = j1 - ptlft end if if ( yr_bd ) then if ( iby == 0 ) then do j = j2 + 1 , j2 + ptrght shy = loc_yg ( j2 - 1 , 4 , imody ) smy = loc_yg ( j2 - 2 , 4 , imody ) alpha = shy / smy ef ( i1 : i2 , j , k1 : k2 , comp1 : comp2 ) = alpha * ( ef ( i1 : i2 , j2 - 2 , k1 : k2 , comp1 : comp2 ) - & ef ( i1 : i2 , j2 - 1 , k1 : k2 , comp1 : comp2 )) - & 2 * ef ( i1 : i2 , j2 - 1 , k1 : k2 , comp1 : comp2 ) + & 3 * ef ( i1 : i2 , j2 , k1 : k2 , comp1 : comp2 ) end do end if if ( iby == 1 ) then do iic = comp1 , comp2 do k = k1 , k2 do j = j2 + 1 , j2 + ptrght do i = i1 , i2 ef ( i , j , k , iic ) = y_parity ( iic ) * ef ( i , 2 * j2 - j , k , iic ) end do end do end do end do end if j2 = j2 + ptrght end if if ( ndim < 3 ) return if ( zl_bd ) then if ( ibz == 0 ) then do k = k1 - ptlft , k1 - 1 shz = loc_zg ( k1 - 2 , 4 , imodz ) smz = loc_zg ( k1 - 1 , 4 , imodz ) alpha = shz / smz ef ( i1 : i2 , j1 : j2 , k , comp1 : comp2 ) = alpha * ( ef ( i1 : i2 , j1 : j2 , k1 + 2 , comp1 : comp2 ) - & ef ( i1 : i2 , j1 : j2 , k1 + 1 , comp1 : comp2 )) - & 2 * ef ( i1 : i2 , j1 : j2 , k1 + 1 , comp1 : comp2 ) + & 3 * ef ( i1 : i2 , j1 : j2 , k1 , comp1 : comp2 ) end do end if if ( ibz == 1 ) then do iic = comp1 , comp2 do k = k1 - ptlft , k1 - 1 do j = j1 , j2 do i = i1 , i2 ef ( i , j , k , iic ) = z_parity ( iic ) * ef ( i , j , 2 * k1 - k , iic ) end do end do end do end do end if k1 = k1 - ptlft end if if ( zr_bd ) then if ( ibz == 0 ) then do k = k2 + 1 , k2 + ptrght shz = loc_zg ( k2 - 1 , 4 , imodz ) smz = loc_zg ( k2 - 2 , 4 , imodz ) alpha = shz / smz ef ( i1 : i2 , j1 : j2 , k , comp1 : comp2 ) = alpha * ( ef ( i1 : i2 , j1 : j2 , k2 - 2 , comp1 : comp2 ) - & ef ( i1 : i2 , j1 : j2 , k2 - 1 , comp1 : comp2 )) - & 2 * ef ( i1 : i2 , j1 : j2 , k2 - 1 , comp1 : comp2 ) + & 3 * ef ( i1 : i2 , j1 : j2 , k2 , comp1 : comp2 ) end do end if if ( ibz == 1 ) then do iic = comp1 , comp2 do k = k2 + 1 , k2 + ptrght do j = j1 , j2 do i = i1 , i2 ef ( i , j , k , iic ) = z_parity ( iic ) * ef ( i , j , 2 * k2 - k , iic ) end do end do end do end do end if k2 = k2 + ptrght end if end subroutine subroutine bf_bds ( ef , dtl , imbd ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) integer , intent ( in ) :: imbd real ( dp ), intent ( in ) :: dtl integer :: i , j , k , ii real ( dp ) :: aphx , aphy , aphz !================= ! Enter bf(4:6)=[Bx,By,Bz] !============================ !========= Engquist-Majda ABC (=>> Mur) ===================== !=============== ! Ey+Bz are right-moving !at x=0 minim. reflection (d/dt-d/dx)&#94;{p-1}(Ey+Bz)=0 ! first order p=1 Bz=-Ey at x=0 and equal time ! Ey-Bz are left-moving !at x=L minim. reflection (d/dt+d/dx)&#94;{p-1}(Ey-Bz)=0 ! first order p=1 Bz=Ey at x=L and equal time !============================ ! B[i1,n1p]=> extended to [i1-1,n1p] ! boundaries for E_t=rotB !======================== ! aphx centered as Ey at ii=1 ii = 1 if ( xl_bd ) then if ( ibx < 2 ) then aphx = loc_xg ( 1 , 3 , imodx ) * dx_inv * dtl do k = kz1 , kz2 do j = jy1 , jy2 ef ( ix1 - 1 , j , k , nfield ) = - ( 2. * ef ( ix1 , j , k , 2 ) + ( 1. - aphx ) * ef ( ix1 , j , k & , nfield )) / ( 1. + aphx ) end do end do if ( nfield > 3 ) then !========================== !at x=0 minim. reflection (d/dt-d/dx)&#94;{p-1}(Ez-By)=0 ! first order p=1 By=Ez at x=0 and equal time !========================== do k = kz1 , kz2 do j = jy1 , jy2 ef ( ix1 - 1 , j , k , 5 ) = ( 2. * ef ( ix1 , j , k , 3 ) - ( 1. - aphx ) * ef ( ix1 , j , k , 5 )) / & ( 1. + aphx ) end do end do end if end if end if if ( ndim < 2 ) return !------------------------------------ !++++++++++++++++++++++++++++++++++++++ (Bz,Ex) !at y=-Ly minim. reflection (d/dt-d/dy)&#94;{p-1}(Ex-Bz)=0 ! first order p=1 Bz=Ex at y=-Ly and equal time !======================== !============================== ! aphy centered as Ex j=1 (the Bz derivative) ii = 1 if ( iby < 2 ) then if ( yl_bd ) then select case ( imbd ) case ( 0 ) aphy = loc_yg ( ii , 3 , imody ) * dy_inv * dtl do k = kz1 , kz2 do i = ix1 , ix2 ef ( i , jy1 - 1 , k , nfield ) = 2. * ef ( i , jy1 , k , 1 ) - & ( 1. - aphy ) * ef ( i , jy1 , k , nfield ) ef ( i , jy1 - 1 , k , nfield ) = ef ( i , jy1 - 1 , k , nfield ) / ( 1. + aphy ) end do end do if ( nfield > 3 ) then !================================== (Bx,Ez) !at y=-Ly minim. reflection (d/dt-d/dy)&#94;{p-1}(Ez+Bx)=0 ! first order p=1 Bx=-Ez at y=-Ly and equal time !========================================== do k = kz1 , kz2 do i = ix1 , ix2 ef ( i , jy1 - 1 , k , 4 ) = - 2. * ef ( i , jy1 , k , 3 ) - & ( 1. - aphy ) * ef ( i , jy1 , k , 4 ) ef ( i , jy1 - 1 , k , 4 ) = ef ( i , jy1 - 1 , k , 4 ) / ( 1. + aphy ) end do end do end if case ( 1 ) !symmetric bds for (Bz,Bx) at ymin do k = kz1 , kz2 do i = ix1 , ix2 ef ( i , jy1 - 1 , k , nfield ) = ef ( i , jy1 , k , nfield ) !ef(i,j1-1,k,nfield)=2.*ef(i,j1,k,nfield)-ef(i,j1+1,k,nfield) end do end do if ( nfield > 3 ) then do k = kz1 , kz2 do i = ix1 , ix2 ef ( i , jy1 - 1 , k , 4 ) = ef ( i , jy1 , k , 4 ) !ef(i,j1-1,k,4)=2.*ef(i,j1,k,4)-ef(i,j1+1,k,4) end do end do end if end select end if end if if ( ndim < 3 ) return !at z=-Lz minim. reflection (d/dt-d/dz)&#94;{p-1}(Bx-Ey)=0 ! first order p=1 Bx=Ey at z=-Lz and equal time !at z=-Lz minim. reflection (d/dt-d/dz)&#94;{p-1}(By+Ex)=0 ! first order p=1 By=-Ex at z=-Lz and equal time !============================== ii = 1 if ( ibz < 2 ) then if ( zl_bd ) then select case ( imbd ) case ( 0 ) aphz = loc_zg ( ii , 3 , imodz ) * dz_inv * dtl do j = jy1 , jy2 do i = ix1 , ix2 ef ( i , j , kz1 - 1 , 4 ) = 2. * ef ( i , j , kz1 , 2 ) - & ( 1. - aphz ) * ef ( i , j , kz1 , 4 ) ef ( i , j , kz1 - 1 , 4 ) = ef ( i , j , kz1 - 1 , 4 ) / ( 1. + aphz ) ef ( i , j , kz1 - 1 , 5 ) = - 2. * ef ( i , j , kz1 , 1 ) - & ( 1. - aphz ) * ef ( i , j , kz1 , 5 ) ef ( i , j , kz1 - 1 , 5 ) = ef ( i , j , kz1 - 1 , 5 ) / ( 1. + aphz ) end do end do case ( 1 ) !symmetric bds for (Nx,By) at zmin do j = jy1 , jy2 do i = ix1 , ix2 ef ( i , j , kz1 - 1 , 4 ) = ef ( i , j , kz1 , 4 ) ef ( i , j , kz1 - 1 , 5 ) = ef ( i , j , kz1 , 5 ) end do end do end select end if end if end subroutine !==================================== subroutine ef_bds ( ef , dtl , imbd ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) integer , intent ( in ) :: imbd real ( dp ), intent ( in ) :: dtl integer :: i , j , k , ii real ( dp ) :: aphx , aphy , aphz aphx = 1 aphy = 1 aphz = 1 ! Enter ebf(1:3)=[Ex,Ey,Ez] ! DATA: ef[1:n1p][1:n2p+1][1:n3p+1] bds are on the right !=============== ! to be used to advance B_t=-rot(E) !========= Engquist-Majda ABC (=>> Mur) ===================== !=============== ! Ey+Bz are right-moving, Ey-Bz left-moving !at x=0 minim. reflection (d/dt-d/dx)&#94;{p-1}(Ey+Bz)=0 ! first order p=1 Ey=-Bz at x=0 !at x=Lx minim. reflection (d/dt+d/dx)&#94;{p-1}(Ey-Bz)=0 ! first order p=1 Ey=Bz at x=L and equal time level !===================== ! aphx centered as Bz nx+1/2 if ( ibx < 2 ) then if ( xr_bd ) then ii = ix2 - 2 select case ( ibx ) case ( 0 ) aphx = loc_xg ( ii , 4 , imodx ) * dx_inv * dtl do k = kz1 , kz2 do j = jy1 , jy2 ef ( ix2 + 1 , j , k , 2 ) = ( 2. * ef ( ix2 , j , k , nfield ) - ( 1. - aphx ) * ef ( ix2 , j , k & , 2 )) / ( 1. + aphx ) end do end do case ( 1 ) !reflecting  only on the right boundary: (Ey,Ez, By,Bz) symmetric (continuous) do k = kz1 , kz2 do j = jy1 , jy2 ef ( ix2 + 1 , j , k , 2 ) = ef ( ix2 , j , k , 2 ) end do end do end select if ( nfield > 3 ) then !==================== !at x=Lx minim. reflection (d/dt+d/dx)&#94;{p-1}(Ez+By)=0 ! first order p=1 Ez=-Bz at x=L and equal time level !=========================== select case ( ibx ) case ( 0 ) do k = kz1 , kz2 do j = jy1 , jy2 ef ( ix2 + 1 , j , k , 3 ) = - ( 2. * ef ( ix2 , j , k , 5 ) + ( 1. - aphx ) * ef ( ix2 , j , k , 3 ) & ) / ( 1. + aphx ) end do end do case ( 1 ) !reflecting do k = kz1 , kz2 do j = jy1 , jy2 ef ( ix2 + 1 , j , k , 3 ) = ef ( ix2 , j , k , 3 ) end do end do end select end if end if end if !=========================== if ( ndim < 2 ) return !=========================== (Bz,Ex) !at y=Ly minim. reflection (d/dt+d/dy)&#94;{p-1}(Ex+Bz)=0 ! first order p=1 Ex=-Bz at y=Ly and equal time level !======================== ! aphy centered as Bz field ny+1/2 if ( iby < 2 ) then if ( yr_bd ) then select case ( imbd ) case ( 0 ) ii = jy2 - 2 aphy = loc_yg ( ii , 4 , imody ) * dy_inv * dtl do k = kz1 , kz2 do i = ix1 , ix2 ef ( i , jy2 + 1 , k , 1 ) = - ( 2. * ef ( i , jy2 , k , nfield ) + ( 1. - aphy ) * ef ( i , jy2 , & k , 1 )) / ( 1. + aphy ) end do end do if ( nfield > 3 ) then !====================== (Bz,Ex) !at y=Ly minim. reflection (d/dt+d/dy)&#94;{p-1}(Ez-Bx)=0 ! first order p=1 Ez=Bx at y=Ly and equal time level !================================ do k = kz1 , kz2 do i = ix1 , ix2 ef ( i , jy2 + 1 , k , 3 ) = ( 2. * ef ( i , jy2 , k , 4 ) - ( 1. - aphy ) * ef ( i , jy2 , k , 3 )) & / ( 1. + aphy ) end do end do end if case ( 1 ) !symmetric bds for (Ex,Ez) at ymax boundary do k = kz1 , kz2 do i = ix1 , ix2 ef ( i , ix2 + 1 , k , 1 ) = ef ( i , ix2 , k , 1 ) !ef(i,n2p+1,k,1)=2.*ef(i,n2p,k,1)-ef(i,n2p-1,k,1) end do end do if ( nfield > 3 ) then do k = kz1 , kz2 do i = ix1 , ix2 ef ( i , ix2 + 1 , k , 3 ) = ef ( i , ix2 , k , 3 ) !ef(i,n2p+1,k,3)=2.*ef(i,n2p,k,3)-ef(i,n2p-1,k,3) end do end do end if end select end if end if !============================== if ( ndim < 3 ) return !============================== !at z=Lz minim. reflection ! (d/dt+d/dz)&#94;{p-1}(Ex-By)=0 ! first order p=1 Ex=By at z=Lz and equal time level ! (d/dt+d/dz)&#94;{p-1}(Ey+Bx)=0 ! first order p=1 Ey=-Bx at z=Lz and equal time level !================================ !======================================== ! aphz centered as Bx,By at nz+1/2 if ( ibz < 2 ) then if ( zr_bd ) then select case ( imbd ) case ( 0 ) ii = loc_zgrid ( imodz )% ng != kz2-2 aphz = loc_zg ( ii , 4 , imodz ) * dz_inv * dtl do j = jy1 , jy2 do i = ix1 , ix2 ef ( i , j , kz2 + 1 , 1 ) = ( 2. * ef ( i , j , kz2 , 5 ) - ( 1. - aphz ) * ef ( i , j , kz2 , 1 )) / & ( 1. + aphz ) ef ( i , j , kz2 + 1 , 2 ) = - ( 2. * ef ( i , j , kz2 , 4 ) + ( 1. - aphz ) * ef ( i , j , kz2 , 2 )) & / ( 1. + aphz ) end do end do case ( 1 ) !symmetric bds for (Ex,Ey) at zmax boundary do j = jy1 , jy2 do i = ix1 , ix2 ef ( i , j , kz2 + 1 , 1 ) = ef ( i , j , kz2 , 1 ) ef ( i , j , kz2 + 1 , 2 ) = ef ( i , j , kz2 , 2 ) end do end do end select end if end if end subroutine !========================================= subroutine potential_lapl ( apf , curr , ic1 , ic2 ) real ( dp ), intent ( inout ) :: apf (:, :, :, :), curr (:, :, :, :) integer , intent ( in ) :: ic1 , ic2 integer :: i , j , k , ic , i01 , i02 real ( dp ) :: dx2 , cf ( 2 ), dx4 ( 2 ) !Computes the Laplacian(apf) and accumulates on the source array curr !                 curr=laplcian(apf)+curr !======================================== dx2 = dx_inv * dx_inv !1/(dx*dx) i01 = ix1 i02 = ix2 !============= ALL FIELDS ic=ic1,ic2 cf ( 1 ) = 1. cf ( 2 ) = 0.0 ! Holds opt-second order or fourth order ! for second derivative with: ! dord=3  hord_der2=-(1-nu*nu)/12  dord=4 hord_der2=-1/12 if ( der_ord > 2 ) then cf ( 1 ) = 1. - 4. * hord_der2 cf ( 2 ) = hord_der2 end if dx4 ( 1 ) = cf ( 1 ) * dx2 dx4 ( 2 ) = cf ( 2 ) * dx2 do ic = ic1 , ic2 do k = kz1 , kz2 do j = jy1 , jy2 do i = i01 , i02 curr ( i , j , k , ic ) = curr ( i , j , k , ic ) + dx4 ( 1 ) * ( apf ( i + 1 , j , k , ic ) + & apf ( i - 1 , j , k , ic ) - 2. * apf ( i , j , k , ic )) end do end do end do end do if ( der_ord > 2 ) then do ic = ic1 , ic2 do k = kz1 , kz2 do j = jy1 , jy2 do i = i01 , i02 curr ( i , j , k , ic ) = curr ( i , j , k , ic ) + dx4 ( 2 ) * ( apf ( i + 2 , j , k , ic ) + & apf ( i - 2 , j , k , ic ) - 2. * apf ( i , j , k , ic )) end do end do end do end do end if if ( ndim > 1 ) call pp_lapl ( apf , curr , ic1 , ic2 ) end subroutine !=========================== subroutine rote ( ef , dtf ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: dtf real ( dp ) :: aphx , aphy , aphz real ( dp ) :: sdhy , sdhz integer :: i , j , k , jj , kk real ( dp ) :: aph1 , aph2 ! Enter ef(1:3)=[Ex,Ey,Ez], ef(4:6)=[Bx,By,Bz] ! SOLVES B=B-DT*rot[E] ! enter boundary fields !==================== B=B-dt*rot(E) interior domain========== aphx = dtf * dx_inv aphy = dtf * dy_inv aphz = dtf * dz_inv aph1 = aphx * se_coeff ( 1 ) aph2 = aphx * se_coeff ( 2 ) !============================ if ( ndim == 1 ) then k = 1 j = 1 do i = ix1 , ix2 ef ( i , j , k , nfield ) = ef ( i , j , k , nfield ) - & aph1 * ( ef ( i + 1 , j , k , 2 ) - ef ( i , j , k , 2 )) - & aph2 * ( ef ( i + 2 , j , k , 2 ) - ef ( i - 1 , j , k , 2 )) end do return end if !================================= do k = kz1 , kz2 do j = jy1 , jy2 jj = j - 2 sdhy = loc_yg ( jj , 4 , imody ) * aphy do i = ix1 , ix2 ef ( i , j , k , nfield ) = ef ( i , j , k , nfield ) - & aph1 * ( ef ( i + 1 , j , k , 2 ) - ef ( i , j , k , 2 )) + & sdhy * ( ef ( i , j + 1 , k , 1 ) - ef ( i , j , k , 1 )) - & aph2 * ( ef ( i + 2 , j , k , 2 ) - ef ( i - 1 , j , k , 2 )) end do end do end do if ( nfield < 6 ) return if ( ndim == 3 ) then do k = kz1 , kz2 kk = k - 2 sdhz = loc_zg ( kk , 4 , imodz ) * aphz do j = jy1 , jy2 jj = j - 2 sdhy = loc_yg ( jj , 4 , imody ) * aphy do i = ix1 , ix2 ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) - sdhy * ( ef ( i , j + 1 , k , 3 ) - ef ( i , j , k , 3 ) & ) + sdhz * ( ef ( i , j , k + 1 , 2 ) - ef ( i , j , k , 2 )) ef ( i , j , k , 5 ) = ef ( i , j , k , 5 ) + & aph1 * ( ef ( i + 1 , j , k , 3 ) - ef ( i , j , k , 3 )) - & sdhz * ( ef ( i , j , k + 1 , 1 ) - ef ( i , j , k , 1 )) + & aph2 * ( ef ( i + 2 , j , k , 3 ) - ef ( i - 1 , j , k , 3 )) end do end do end do else k = 1 do j = jy1 , jy2 jj = j - 2 sdhy = loc_yg ( jj , 4 , imody ) * aphy do i = ix1 , ix2 ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) - sdhy * ( ef ( i , j + 1 , k , 3 ) - ef ( i , j , k , 3 )) ef ( i , j , k , 5 ) = ef ( i , j , k , 5 ) + aph1 * ( ef ( i + 1 , j , k , 3 ) - ef ( i , j , k , 3 )) & + aph2 * ( ef ( i + 2 , j , k , 3 ) - ef ( i - 1 , j , k , 3 )) end do end do end if !================== interior domains end subroutine !=============================== subroutine rotb ( ef , dtf ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: dtf real ( dp ) :: sdy , sdz , aph1 , aph2 real ( dp ) :: aphx , aphy , aphz integer :: i , j , k , ii , jj , kk ! E=E+DT*rot[B]          Two-point Second order derivatives !==================== B=B-dt*rot(E) interior domain========== ! enter boundary fields !=================== interior domains aphx = dtf * dx_inv aphy = dtf * dy_inv aphz = dtf * dz_inv aph1 = aphx * se_coeff ( 1 ) aph2 = aphx * se_coeff ( 2 ) if ( ndim == 1 ) then k = 1 j = 1 do i = ix1 , ix2 ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) - aphx * ( ef ( i , j , k , nfield ) - ef ( i - 1 , j , k & , nfield )) end do end if !=========================== NDIM > 1 do k = kz1 , kz2 do j = jy1 , jy2 jj = j - 2 sdy = loc_yg ( jj , 3 , imody ) * aphy do i = ix1 , ix2 ii = i - 2 ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + sdy * ( ef ( i , j , k , nfield ) - ef ( i , j - 1 , k & , nfield )) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) - & aph1 * ( ef ( i , j , k , nfield ) - ef ( i - 1 , j , k , nfield )) - & aph2 * ( ef ( i + 1 , j , k , nfield ) - ef ( i - 2 , j , k , nfield )) end do end do end do if ( nfield < 6 ) return if ( ndim == 3 ) then do k = kz1 , kz2 kk = k - 2 sdz = aphz * loc_zg ( kk , 3 , imodz ) do j = jy1 , jy2 jj = j - 2 sdy = aphy * loc_yg ( jj , 3 , imody ) do i = ix1 , ix2 ii = i - 2 ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) - sdz * ( ef ( i , j , k , 5 ) - ef ( i , j , k - 1 , 5 )) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + sdz * ( ef ( i , j , k , 4 ) - ef ( i , j , k - 1 , 4 )) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + & aph1 * ( ef ( i , j , k , 5 ) - ef ( i - 1 , j , k , 5 )) - & sdy * ( ef ( i , j , k , 4 ) - ef ( i , j - 1 , k , 4 )) + & aph2 * ( ef ( i + 1 , j , k , 5 ) - ef ( i - 2 , j , k , 5 )) end do end do end do else k = 1 do j = jy1 , jy2 jj = j - 2 sdy = aphy * loc_yg ( jj , 3 , imody ) do i = ix1 , ix2 ii = i - 2 ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + & aph1 * ( ef ( i , j , k , 5 ) - ef ( i - 1 , j , k , 5 )) - & sdy * ( ef ( i , j , k , 4 ) - ef ( i , j - 1 , k , 4 )) + & aph2 * ( ef ( i + 1 , j , k , 5 ) - ef ( i - 2 , j , k , 5 )) end do end do end if end subroutine !===================================== !================================= subroutine nc_fluid_density_momenta ( flx , ef , dt_step , fcomp ) real ( dp ), intent ( in ) :: flx (:, :, :, :) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: dt_step integer , intent ( in ) :: fcomp integer ( kind = 4 ) :: flux_ind real ( dp ) :: aphx , aphy , aphz integer :: i , j , k , ic , i01 , i02 , j01 , j02 , k01 , k02 , fcomp_tot real ( dp ) :: shy , shz real ( dp ) :: dw ( 3 ), sl ( 2 ), sr ( 2 ), omgl ( 2 ), vv , s0 real ( dp ), parameter :: EPS = 1.e-06 real ( dp ), dimension ( 2 ), parameter :: W03 = [ 1. / 3. , 2. / 3. ] real ( dp ), dimension ( 3 ), parameter :: LDER = [ 0.5 , - 2. , 1.5 ] real ( dp ), dimension ( 3 ), parameter :: RDER = [ - 1.5 , 2. , - 0.5 ] ! Fourth order derivatives !real(dp), dimension(4), parameter :: LDER4 = [ 1./6., -1., 0.5, & !  1./3. ] ![i-2,i+1] stencil !real(dp), dimension(4), parameter :: RDER4 = [ -1./3., -0.5, 1., & !  -1./6. ] ![i-1,i+2] stencil !========================= ! Enter primitive variables in flux array flx(Px,Py,Pz,den,vx,vy,vz) ! fcomp=curr_ndim+1 components flux_ind = 1 !=1 for pure upwind !=2 for LxF fluxin density equation i01 = ix1 if ( xl_bd ) i01 = ix1 + 2 i02 = ix2 if ( xr_bd ) i02 = ix2 - 2 j01 = jy1 if ( yl_bd ) j01 = jy1 + 2 j02 = jy2 if ( yr_bd ) j02 = jy2 - 2 k01 = kz1 if ( zl_bd ) k01 = kz1 + 2 k02 = kz2 if ( zr_bd ) k02 = kz2 - 2 aphx = dt_step * dx_inv aphy = dt_step * dy_inv aphz = dt_step * dz_inv !=========================== ! momenta-density fcomp_tot = fcomp + 1 do k = kz1 , kz2 do j = jy1 , jy2 do ic = 1 , fcomp_tot do i = i01 - 2 , i02 + 2 var ( i , ic ) = flx ( i , j , k , ic ) end do end do call weno3_nc ( fcomp_tot , i01 - 2 , i02 + 2 , xl_bd , xr_bd ) do ic = 1 , fcomp !var=momenta do i = i01 , i02 ef ( i , j , k , ic ) = ef ( i , j , k , ic ) - aphx * ww0 ( i , ic ) end do end do end do end do !==================== do k = kz1 , kz2 do i = ix1 , ix2 do ic = 1 , fcomp do j = j01 - 2 , j02 + 2 !Extended range[j1-2,n2p+2] in interior domains var ( j , ic ) = flx ( i , j , k , ic ) end do end do do j = j01 - 2 , j02 + 2 var ( j , fcomp + 1 ) = flx ( i , j , k , fcomp + 2 ) end do call weno3_nc ( fcomp + 1 , j01 - 2 , j02 + 2 , yl_bd , yr_bd ) !rec[flux][j01-1,j02+1] do ic = 1 , fcomp do j = j01 , j02 shy = aphy * loc_yg ( j - 2 , 3 , imody ) ef ( i , j , k , ic ) = ef ( i , j , k , ic ) - shy * ww0 ( j , ic ) end do end do end do end do if ( ndim < 3 ) return do j = jy1 , jy2 do i = ix1 , ix2 do ic = 1 , fcomp do k = k01 - 2 , k02 + 2 var ( k , ic ) = flx ( i , j , k , ic ) end do end do ic = fcomp + 1 do k = k01 - 2 , k02 + 2 var ( k , ic ) = flx ( i , j , k , fcomp + 3 ) end do call weno3_nc ( fcomp + 1 , k01 - 2 , k02 + 2 , zl_bd , zr_bd ) do ic = 1 , fcomp do k = k01 , k02 shz = aphz * loc_zg ( k - 2 , 3 , imodz ) ef ( i , j , k , ic ) = ef ( i , j , k , ic ) - shz * ww0 ( k , ic ) end do end do end do end do !================================= contains subroutine weno3_nc ( nc , i1 , np , lbd , rbd ) integer , intent ( in ) :: nc , i1 , np logical , intent ( in ) :: lbd , rbd !  enter data [i1,np] integer :: ii , iic !=======ENTER DATA [i1,np] !wl_{i+1/2}  uses stencil [i-1,i,i+1] in range [i=i1+1,np-1] !wr_{i+1/2}  uses stencil [i,i+1,i+2] in range [i=i1,np-2] !            common interior points [i1+1,np-2 !            Dw first derivative in range[i1+2,np-2] !            L-Boundary    Dw&#94;r[i1+1] uses the [i1:i1+3] stencil for v<0 !            R-Boundary    Dw&#94;L[np-1] uses the [np-3:np1] stencil !=========================================== iic = nc - 1 do ii = i1 , np var ( ii , nc + 1 ) = var ( ii , iic ) * var ( ii , nc ) !in den array var(nc+1) => den*v end do !================= reconstruct nc primitives (Px,Py,Pz,Den,V) do iic = 1 , nc do ii = i1 + 1 , np - 1 dw ( 1 ) = var ( ii , iic ) - var ( ii - 1 , iic ) !DW_{i-1/2} dw ( 2 ) = var ( ii + 1 , iic ) - var ( ii , iic ) !DW_{i+1/2} omgl ( 1 ) = 1. / ( dw ( 1 ) * dw ( 1 ) + EPS ) omgl ( 2 ) = 1. / ( dw ( 2 ) * dw ( 2 ) + EPS ) omgl (:) = omgl (:) * omgl (:) sl ( 1 ) = W03 ( 1 ) * omgl ( 1 ) sl ( 2 ) = W03 ( 2 ) * omgl ( 2 ) sr ( 1 ) = W03 ( 2 ) * omgl ( 1 ) sr ( 2 ) = W03 ( 1 ) * omgl ( 2 ) s0 = sl ( 1 ) + sl ( 2 ) wl ( ii , iic ) = var ( ii , iic ) + 0.5 * ( dw ( 1 ) * sl ( 1 ) + dw ( 2 ) * sl ( 2 )) / s0 s0 = sr ( 1 ) + sr ( 2 ) wr ( ii - 1 , iic ) = var ( ii , iic ) - 0.5 * ( dw ( 1 ) * sr ( 1 ) + dw ( 2 ) * sr ( 2 )) / s0 end do end do !=================================== !upwind boundary derivatives if ( lbd ) then do iic = 1 , nc - 2 ii = i1 ww0 ( ii , iic ) = 0.0 vv = var ( ii , nc ) if ( vv < 0.0 ) ww0 ( ii , iic ) = vv * ( var ( ii + 1 , iic ) - var ( ii , iic )) ii = i1 + 1 vv = var ( ii , nc ) ww0 ( ii , iic ) = vv * ( var ( ii , iic ) - var ( ii - 1 , iic )) if ( vv < 0.0 ) ww0 ( ii , iic ) = vv * dot_product ( RDER ( 1 : 3 ), var ( ii : ii + 2 , iic )) end do iic = nc - 1 ii = i1 ww0 ( ii , iic ) = 0.0 vv = var ( ii , nc ) if ( vv < 0.0 ) ww0 ( ii , iic ) = var ( ii + 1 , nc + 1 ) - var ( ii , nc + 1 ) ii = i1 + 1 vv = var ( ii , nc ) ww0 ( ii , iic ) = var ( ii , nc + 1 ) - var ( ii - 1 , nc + 1 ) if ( vv < 0.0 ) ww0 ( ii , iic ) = dot_product ( RDER ( 1 : 3 ), var ( ii : ii + 2 , nc + 1 )) end if if ( rbd ) then do iic = 1 , nc - 2 ii = np - 1 vv = var ( ii , nc ) ww0 ( ii , iic ) = vv * ( var ( ii + 1 , iic ) - var ( ii , iic )) if ( vv > 0.0 ) ww0 ( ii , iic ) = vv * dot_product ( LDER ( 1 : 3 ), var ( ii - 2 : ii , iic )) ii = np vv = var ( ii , nc ) ww0 ( ii , iic ) = 0.0 if ( vv > 0.0 ) ww0 ( ii , iic ) = vv * ( var ( ii , iic ) - var ( ii - 1 , iic )) end do iic = nc - 1 ii = np - 1 vv = var ( ii , nc ) ww0 ( ii , iic ) = var ( ii + 1 , nc + 1 ) - var ( ii , nc + 1 ) if ( vv > 0.0 ) ww0 ( ii , iic ) = dot_product ( LDER ( 1 : 3 ), var ( ii - 2 : ii , nc + 1 )) ii = np vv = var ( ii , nc ) ww0 ( ii , iic ) = 0.0 if ( vv > 0.0 ) ww0 ( ii , iic ) = var ( ii , nc + 1 ) - var ( ii - 1 , nc + 1 ) end if !=================================== !   UPWINDING at interior points !          Momenta do iic = 1 , nc - 2 do ii = i1 + 1 , np - 2 vv = wr ( ii , nc ) + wl ( ii , nc ) s0 = sign ( one_dp , vv ) !s0=1*sign(vv) var ( ii , iic ) = max ( 0. , s0 ) * wl ( ii , iic ) - min ( 0. , s0 ) * wr ( ii , iic ) end do do ii = i1 + 2 , np - 2 ww0 ( ii , iic ) = var ( ii , nc ) * ( var ( ii , iic ) - var ( ii - 1 , iic )) end do end do ! LxF flux for density variable !   F=nv=> 1/2(F_L+F_R)-|V_{max}|(den_R-den_L)] iic = nc - 1 do ii = i1 + 1 , np - 2 dw ( 1 ) = var ( ii - 1 , nc ) dw ( 2 ) = var ( ii , nc ) dw ( 3 ) = var ( ii + 1 , nc ) vv = maxval ( abs ( dw ( 1 : 3 ))) var ( ii , iic ) = wr ( ii , nc ) * wr ( ii , iic ) + wl ( ii , nc ) * wl ( ii , iic ) - & vv * ( wr ( ii , iic ) - wl ( ii , iic )) var ( ii , iic ) = 0.5 * var ( ii , iic ) end do do ii = i1 + 2 , np - 2 ww0 ( ii , iic ) = var ( ii , iic ) - var ( ii - 1 , iic ) end do end subroutine end subroutine !==================================== end module","tags":"","loc":"sourcefile/grid_fields.f90.html"},{"title":"init_grid_fields.f90 – ALaDyn","text":"This file depends on sourcefile~~init_grid_fields.f90~~EfferentGraph sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~init_grid_fields.f90~~AfferentGraph sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules init_grid_field Source Code init_grid_fields.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module init_grid_field use grid_field_param use pstruct_data use fstruct_data use phys_param , only : pi implicit none contains !===================== subroutine initial_beam_fields ( poten , efb , g2 , bet ) real ( dp ), intent ( inout ) :: poten (:, :, :, :) real ( dp ), intent ( out ) :: efb (:, :, :, :) real ( dp ), intent ( in ) :: g2 , bet integer :: i , j , k , ic , jj , kk real ( dp ) :: sdhy , sdhz ! Enter ! in poten(1) enters beam potential(i,j,k) => (Ex,Ey, Ez) ! in poten(2) enters Jx(i,j,k)=bet*rho => efb[4]=jx[i+1/2,j,k] !Computes !Ey=-Dy[poten] Ez=-Dz[poten]  Ex=-Dx[poten]/gam2 !Bz=-Dy[Ax]=bet*Ey     By=Dz[Ax]=-bet*Ez   Bx=0 !============================ !Interpolation to the Yee grid is needed for [By,Bz] fields !============================================================== ic = 1 if ( pe1y ) then j = jy2 do k = kz1 , kz2 do i = ix1 , ix2 poten ( i , j + 1 , k , ic ) = 3. * ( poten ( i , j , k , ic ) - poten ( i , j - 1 , k , ic )) + & poten ( i , j - 2 , k , ic ) end do end do end if if ( pe1x ) then do k = kz1 , kz2 do j = jy1 , jy2 poten ( ix2 + 1 , j , k , 1 ) = poten ( ix2 , j , k , 1 ) poten ( ix2 + 1 , j , k , 2 ) = 2. * poten ( ix2 , j , k , 2 ) - poten ( ix2 - 1 , j , k , 2 ) end do end do end if ! Interpolates jx=Jx[i+1/2,j,k] do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 efb ( i , j , k , 4 ) = 0.5 * ( poten ( i , j , k , 2 ) + poten ( i + 1 , j , k , 2 )) end do end do end do do k = kz1 , kz2 do j = jy1 , jy2 jj = j - 2 sdhy = loc_yg ( jj , 3 , imody ) * dy_inv do i = ix1 , ix2 + 1 efb ( i , j , k , 2 ) = - sdhy * ( poten ( i , j + 1 , k , 1 ) - poten ( i , j , k , 1 )) end do do i = ix1 , ix2 efb ( i , j , k , 1 ) = - dx_inv * ( poten ( i + 1 , j , k , 1 ) - poten ( i , j , k , 1 )) / g2 end do end do end do if ( ndim == 2 ) then !defines Bz[i+1/2,j+1/2,k] using interpolated Ey do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 efb ( i , j , k , 3 ) = 0.5 * bet * ( efb ( i , j , k , 2 ) + efb ( i + 1 , j , k , 2 )) end do end do end do !Bz[i+1/2,j+1/2,k] return end if !==============Here only 3D case if ( pe1z ) then k = kz2 do j = jy1 , jy2 do i = ix1 , ix2 poten ( i , j , k + 1 , 1 ) = 2. * poten ( i , j , k , 1 ) - poten ( i , j , k - 1 , 1 ) end do end do end if do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 efb ( i , j , k , 6 ) = 0.5 * bet * ( efb ( i , j , k , 2 ) + efb ( i + 1 , j , k , 2 )) end do end do end do do k = kz1 , kz2 kk = k - 2 sdhz = loc_zg ( kk , 3 , imodz ) * dz_inv do j = jy1 , jy2 do i = ix1 , ix2 efb ( i , j , k , 3 ) = - sdhz * ( poten ( i , j , k + 1 , 1 ) - poten ( i , j , k , 1 )) end do end do end do ![Ex,Ey,Ez, Bz]defined do k = kz1 , kz2 do j = jy1 , jy2 do i = ix1 , ix2 poten ( i , j , k , 2 ) = 0.5 * ( efb ( i , j , k , 3 ) + efb ( i + 1 , j , k , 3 )) efb ( i , j , k , 5 ) = - bet * poten ( i , j , k , 2 ) end do end do end do !  By[i+1/2,j+1/2,k=--bet*Ez !  EXIT pot(i,j,k,1) unmodified !====================================== end subroutine !=========================================== ! END SECTION FOR initial beam fields !================================== ! SECTION for initial fields in ENVELOPE MODEL !====================================== subroutine init_envelope_field ( ef , ee0 , t_loc , tf , wx , wy , xf0 , & om0 , pw , i1 , i2 , ycent , zcent ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: ee0 , t_loc , tf , wx , wy , xf0 , om0 integer , intent ( in ) :: pw , i1 , i2 integer :: j1 , j2 , k1 , k2 real ( dp ) :: xx , yy , zz , r2 , w2 real ( dp ) :: t , tm , zra , ycent , zcent real ( dp ) :: pih , phi , phi0 , phi1 , phx real ( dp ) :: ampl , ar , ai integer :: i , j , k , ii , jj , kk ! inviluppo temporale= cos&#94;2(pi*(t-x))/wx) ! eps=1./k0*wy k0=omega_0=omgl ! Ay(i,j,k) complex envelope in paraxial approximation !======================== t = t_loc - tf tm = t - dt_loc zra = 0.5 * om0 * wy * wy pih = 0.5 * acos ( - 1.0 ) if ( pw == 0 ) then !plane wave model xf0=xc (center) tf=0 j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) if ( ndim < 3 ) then k1 = 1 k2 = 1 else k1 = loc_zgrid ( imodz )% p_ind ( 1 ) k2 = loc_zgrid ( imodz )% p_ind ( 2 ) end if do k = k1 , k2 do j = j1 , j2 do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xx = xx - xf0 phi1 = pi * ( xx - t ) / wx if ( abs ( phi1 ) > pih ) phi1 = pih phi0 = pi * ( xx - tm ) / wx if ( abs ( phi0 ) > pih ) phi0 = pih phi = 0.0 ar = ee0 * cos ( phi ) ai = - ee0 * sin ( phi ) ampl = cos ( phi1 ) * cos ( phi1 ) !A0=A0*A0 ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ampl * ar !Re[Ay](t_loc) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ampl * ai !Im[Ay] ampl = cos ( phi0 ) * cos ( phi0 ) !A0=A0*A0 ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ampl * ar !Re[Ay](t_loc-Dt) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + ampl * ai !Im[Ay] end do end do end do return end if if ( ndim < 3 ) then j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) k = 1 do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yy = ( yy - ycent ) / wy r2 = yy * yy do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xx = xx - xf0 phi1 = pi * ( xx - t ) / wx if ( abs ( phi1 ) > pih ) phi1 = pih phi0 = pi * ( xx - tm ) / wx if ( abs ( phi0 ) > pih ) phi0 = pih xx = xx / zra w2 = 1. / ( 1. + xx * xx ) phx = atan ( xx ) phi = phx - xx * r2 * w2 ar = ee0 * cos ( phi ) * sqrt ( sqrt ( w2 )) * exp ( - w2 * r2 ) ai = - ee0 * sin ( phi ) * sqrt ( sqrt ( w2 )) * exp ( - w2 * r2 ) ampl = cos ( phi1 ) * cos ( phi1 ) !A0=A0*A0 ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ampl * ar !Re[Ay](t_loc) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ampl * ai !Im[Ay] ampl = cos ( phi0 ) * cos ( phi0 ) !A0=A0*A0 ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ampl * ar !Re[Ay](t_loc-Dt) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + ampl * ai !Im[Ay] end do end do return end if !=============== 3D cartesian j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) k1 = loc_zgrid ( imodz )% p_ind ( 1 ) k2 = loc_zgrid ( imodz )% p_ind ( 2 ) do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) zz = ( zz - zcent ) / wy do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yy = ( yy - ycent ) / wy r2 = ( yy * yy + zz * zz ) do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xx = xx - xf0 phi1 = pi * ( t - xx ) / wx if ( abs ( phi1 ) > pih ) phi1 = pih phi0 = pi * ( tm - xx ) / wx if ( abs ( phi0 ) > pih ) phi0 = pih xx = xx / zra w2 = 1. / ( 1. + xx * xx ) phx = atan ( xx ) phi = phx - xx * r2 * w2 ampl = cos ( phi1 ) * cos ( phi1 ) ar = ee0 * cos ( phi ) * sqrt ( w2 ) * exp ( - w2 * r2 ) ai = - ee0 * sin ( phi ) * sqrt ( w2 ) * exp ( - w2 * r2 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ampl * ar !Re[Ay](t_loc) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ampl * ai !Im[Ay] ampl = cos ( phi0 ) * cos ( phi0 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ampl * ar !Re[Ay](t_loc-Dt) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + ampl * ai !Im[Ay] end do end do end do end subroutine !======================== subroutine init_gprof_envelope_field ( ef , ee0 , t_loc , tf , wx , & wy , xf0 , om0 , pw , i1 , i2 , ycent , zcent ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: ee0 , t_loc , tf , wx , wy , xf0 , om0 integer , intent ( in ) :: i1 , i2 , pw integer :: j1 , j2 , k1 , k2 real ( dp ) :: xx , yy , zz , r2 , w2 real ( dp ) :: t , tm , zra , ycent , zcent real ( dp ) :: pih , phi , phi0 , phi1 , phx real ( dp ) :: ampl , ar , ai integer :: i , j , k , ii , jj , kk ! inviluppo temporale= ! eps=1./k0*wy k0=omega_0=omgl ! Ay(i,j,k) complex envelope in paraxial approximation ! xf0= xc+tf !======================== t = t_loc - tf tm = t - dt_loc zra = 0.5 * om0 * wy * wy pih = 0.5 * acos ( - 1.0 ) if ( pw == 0 ) then j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) if ( ndim < 3 ) then k1 = 1 k2 = 1 else k1 = loc_zgrid ( imodz )% p_ind ( 1 ) k2 = loc_zgrid ( imodz )% p_ind ( 2 ) end if do k = k1 , k2 do j = j1 , j2 do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xx = xx - xf0 phi1 = ( xx - t ) / wx !phi1=(x-xf+tf)/wx=(x-xc)/wx > longitudinal shape phi0 = ( xx - tm ) / wx phx = atan ( xx ) phi = phx ar = ee0 * cos ( phi ) ai = - ee0 * sin ( phi ) ampl = exp ( - phi1 * phi1 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ampl * ar !Re[Ay](t_loc) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ampl * ai !Im[Ay] ampl = exp ( - phi0 * phi0 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ampl * ar !Re[Ay](t_loc-Dt) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + ampl * ai !Im[Ay] end do end do end do return end if !========================== if ( ndim < 3 ) then j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) k = 1 do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yy = ( yy - ycent ) / wy r2 = yy * yy do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xx = xx - xf0 phi1 = ( xx - t ) / wx !phi1=(x-xf+tf)/wx=(x-xc)/wx > longitudinal shape phi0 = ( xx - tm ) / wx xx = xx / zra !xx=(x-xf)/Zr w2 = 1. / ( 1. + xx * xx ) phx = atan ( xx ) phi = phx - xx * r2 * w2 ar = ee0 * cos ( phi ) * sqrt ( sqrt ( w2 )) * exp ( - w2 * r2 ) ai = - ee0 * sin ( phi ) * sqrt ( sqrt ( w2 )) * exp ( - w2 * r2 ) ampl = exp ( - phi1 * phi1 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ampl * ar !Re[Ay](t_loc) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ampl * ai !Im[Ay] ampl = exp ( - phi0 * phi0 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ampl * ar !Re[Ay](t_loc-Dt) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + ampl * ai !Im[Ay] end do end do return end if !=============== 3D cartesian j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) k1 = loc_zgrid ( imodz )% p_ind ( 1 ) k2 = loc_zgrid ( imodz )% p_ind ( 2 ) do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) zz = ( zz - zcent ) / wy do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yy = ( yy - ycent ) / wy r2 = ( yy * yy + zz * zz ) do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xx = xx - xf0 phi1 = ( xx - t ) / wx phi0 = ( xx - tm ) / wx xx = xx / zra w2 = 1. / ( 1. + xx * xx ) phx = atan ( xx ) phi = phx - xx * r2 * w2 ar = ee0 * cos ( phi ) * sqrt ( w2 ) * exp ( - w2 * r2 ) ai = - ee0 * sin ( phi ) * sqrt ( w2 ) * exp ( - w2 * r2 ) ampl = exp ( - phi1 * phi1 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ampl * ar !Re[Ay](t_loc) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ampl * ai !Im[Ay] ampl = exp ( - phi0 * phi0 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ampl * ar !Re[Ay](t_loc-Dt) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + ampl * ai !Im[Ay] end do end do end do end subroutine !============== ! END INIT_ENV SECTION !================================== !================================= ! INITIAL (E,B) Laser FIELDS !============================== subroutine get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) real ( dp ), intent ( in ) :: coords ( 4 ), par_lp ( 7 ) real ( dp ), intent ( out ) :: fields ( 6 ) real ( dp ) :: phi0 , phi1 , phig00 , phig10 real ( dp ) :: x1 , y1 , t1 , r2 , w2 real ( dp ) :: ampl , ampl_1 , tshape , phx , wshape !========== enter !par_lp(1)=oml !par_lp(3)=wx !par_lp(4)=wy !par_lp(5)=zra !par_lp(6)=eps !par_lp(7)=sigma    =1/(oml*wx) !=============================== x1 = coords ( 1 ) !x-x_f y1 = coords ( 2 ) / par_lp ( 4 ) t1 = coords ( 4 ) !t-t_f        => (t1-x1)= t-(x-xc) !==================== r2 = y1 * y1 phi0 = par_lp ( 1 ) * ( t1 - x1 ) phi1 = ( t1 - x1 ) / par_lp ( 3 ) x1 = x1 / par_lp ( 5 ) w2 = 1. / ( 1. + x1 * x1 ) !     w2=(w0/w)&#94;2 phx = 0.5 * atan ( x1 ) phig00 = phi0 + phx - x1 * r2 * w2 !phi_g ,(phi_g)&#94;1=phi_g+phx phig10 = phig00 + phx tshape = exp ( - phi1 * phi1 ) wshape = sqrt ( sqrt ( w2 )) * exp ( - w2 * r2 ) ampl = tshape * sin ( phig00 ) fields ( 2 ) = wshape * ampl !Ey ampl_1 = tshape * 2. * par_lp ( 6 ) * w2 * exp ( - w2 * r2 ) fields ( 1 ) = y1 * ampl_1 * cos ( phig10 ) !Ex fields ( 4 ) = 0.0 fields ( 6 ) = fields ( 2 ) !Bz fields ( 3 ) = 0.0 fields ( 5 ) = 0.0 end subroutine !======================= subroutine get_2dlaser_fields_lp ( coords , par_lp , fields ) real ( dp ), intent ( in ) :: coords ( 4 ), par_lp ( 7 ) real ( dp ), intent ( out ) :: fields ( 6 ) real ( dp ) :: phi0 , phi1 , phig00 , phig10 real ( dp ) :: x1 , y1 , t1 , pih real ( dp ) :: w2 , ampl , ampl_1 real ( dp ) :: tshape , phx , r2 , wshape !========== enter !par_lp(1)=oml !par_lp(2)=xc !par_lp(3)=wx !par_lp(4)=wy !par_lp(5)=zra !par_lp(6)=eps !par_lp(7)=sigma !=============================== x1 = coords ( 1 ) y1 = coords ( 2 ) / par_lp ( 4 ) t1 = coords ( 4 ) pih = 0.5 * pi !==================== r2 = y1 * y1 phi0 = par_lp ( 1 ) * ( t1 - x1 ) phi1 = pi * ( t1 - x1 ) / par_lp ( 3 ) if ( abs ( phi1 ) > pih ) phi1 = pih x1 = x1 / par_lp ( 5 ) w2 = 1. / ( 1. + x1 * x1 ) !     w2=(w0/w)&#94;2 phx = 0.5 * atan ( x1 ) phig00 = phi0 + phx - x1 * r2 * w2 !phi_g ,(phi_g)&#94;1=phi_g+phx phig10 = phig00 + phx tshape = cos ( phi1 ) * cos ( phi1 ) wshape = sqrt ( sqrt ( w2 )) * exp ( - w2 * r2 ) ampl = tshape * sin ( phig00 ) fields ( 2 ) = wshape * ampl !Ey ampl_1 = tshape * 2. * par_lp ( 6 ) * w2 * exp ( - w2 * r2 ) fields ( 1 ) = y1 * ampl_1 * cos ( phig10 ) !Ex fields ( 4 ) = 0.0 fields ( 6 ) = fields ( 2 ) !Bz !===================== O(sigma) correction fields ( 3 ) = 0.0 fields ( 5 ) = 0.0 end subroutine !============================= subroutine get_laser_fields_lp ( coords , par_lp , fields ) real ( dp ), intent ( in ) :: coords ( 4 ), par_lp ( 7 ) real ( dp ), intent ( out ) :: fields ( 6 ) real ( dp ) :: phi0 , phi1 , phig00 , phig10 real ( dp ) :: x1 , y1 , z1 , t1 , pih real ( dp ) :: w2 , ampl , ampl_1 real ( dp ) :: tshape , phx , r2 , wshape !========== enter !par_lp(1)=oml !par_lp(2)=xc !par_lp(3)=wx !par_lp(4)=wy !par_lp(5)=zra !par_lp(6)=eps !par_lp(7)=sigma !=============================== x1 = coords ( 1 ) !x-xf y1 = coords ( 2 ) / par_lp ( 4 ) z1 = coords ( 3 ) / par_lp ( 4 ) t1 = coords ( 4 ) !t-t_f pih = 0.5 * pi !==================== r2 = y1 * y1 + z1 * z1 phi0 = par_lp ( 1 ) * ( t1 - x1 ) phi1 = pi * ( t1 - x1 ) / par_lp ( 3 ) if ( abs ( phi1 ) > pih ) phi1 = pih x1 = x1 / par_lp ( 5 ) w2 = 1. / ( 1. + x1 * x1 ) !     w2=(w0/w)&#94;2 phx = atan ( x1 ) phig00 = phi0 + phx - x1 * r2 * w2 !phi_g ,(phi_g)&#94;1=phi_g+phx phig10 = phig00 + phx tshape = cos ( phi1 ) * cos ( phi1 ) wshape = sqrt ( w2 ) * exp ( - w2 * r2 ) ampl = tshape * sin ( phig00 ) fields ( 2 ) = wshape * ampl !Ey ampl_1 = tshape * 2. * par_lp ( 6 ) * w2 * exp ( - w2 * r2 ) fields ( 1 ) = y1 * ampl_1 * cos ( phig10 ) !Ex fields ( 4 ) = z1 * ampl_1 * cos ( phig10 ) !Bx fields ( 6 ) = fields ( 2 ) !Bz fields ( 3 ) = 0.0 fields ( 5 ) = 0.0 end subroutine !================= subroutine get_laser_gprof_fields_lp ( coords , par_lp , fields ) real ( dp ), intent ( in ) :: coords ( 4 ), par_lp ( 7 ) real ( dp ), intent ( out ) :: fields ( 6 ) real ( dp ) :: phi0 , phi1 , phig00 , phig10 real ( dp ) :: x1 , y1 , z1 , t1 , pih real ( dp ) :: ampl , ampl_1 , w2 real ( dp ) :: phx , r2 , wshape , tshape !========== enter !par_lp(1)=oml !par_lp(2)=xc !par_lp(3)=wx !par_lp(4)=wy !par_lp(5)=zra !par_lp(6)=eps !par_lp(7)=sigma                  =1/(wx*oml) !=============================== !        t_profile is gaussian exp(-(t-x)*(t-x)/wx2) x1 = coords ( 1 ) !x-xf y1 = coords ( 2 ) / par_lp ( 4 ) z1 = coords ( 3 ) / par_lp ( 4 ) t1 = coords ( 4 ) !t-t_f pih = 0.5 * pi !==================== r2 = y1 * y1 + z1 * z1 phi0 = par_lp ( 1 ) * ( t1 - x1 ) !fast oscillations phi1 = ( t1 - x1 ) / par_lp ( 3 ) !t_envelope !----------- x1 = x1 / par_lp ( 5 ) w2 = 1. / ( 1. + x1 * x1 ) !     w2=(w0/w)&#94;2 phx = atan ( x1 ) phig00 = phi0 + phx - x1 * r2 * w2 !phi_g ,(phi_g)&#94;1=phi_g+phx phig10 = phig00 + phx tshape = exp ( - phi1 * phi1 ) wshape = sqrt ( w2 ) * exp ( - w2 * r2 ) ampl = tshape * sin ( phig00 ) fields ( 2 ) = wshape * ampl !Ey !============== ampl_1 = 2. * par_lp ( 6 ) * tshape * w2 * exp ( - w2 * r2 ) fields ( 1 ) = y1 * ampl_1 * cos ( phig10 ) !Ex fields ( 4 ) = z1 * ampl_1 * cos ( phig10 ) !Bx fields ( 6 ) = fields ( 2 ) !Bz fields ( 3 ) = 0.0 fields ( 5 ) = 0.0 end subroutine !==================== subroutine get_plane_wave_lp ( coords , par_pp , fields ) real ( dp ), intent ( in ) :: coords ( 4 ), par_pp ( 7 ) real ( dp ), intent ( out ) :: fields ( 6 ) real ( dp ) :: phi0 , phi1 , pih real ( dp ) :: x1 , t1 real ( dp ) :: ampl , ev0 !========== enter x1 = coords ( 1 ) t1 = coords ( 4 ) pih = 0.5 * pi !==================== !oml=par_pp(1)   par_pp(3)=wx phi0 = par_pp ( 1 ) * ( t1 - x1 ) phi1 = pi * ( t1 - x1 ) / par_pp ( 3 ) if ( abs ( phi1 ) > pih ) phi1 = pih ev0 = cos ( phi1 ) * cos ( phi1 ) ampl = ev0 * sin ( phi0 ) fields ( 2 ) = ampl !Ey fields ( 6 ) = fields ( 2 ) !Bz end subroutine !==================================== subroutine get_plane_wave_cp ( coords , par_pp , fields ) real ( dp ), intent ( in ) :: coords ( 4 ), par_pp ( 7 ) real ( dp ), intent ( out ) :: fields ( 6 ) real ( dp ) :: phi0 , phi1 , pih real ( dp ) :: x1 , t1 real ( dp ) :: ampl , ampl_1 , ev0 !========== enter x1 = coords ( 1 ) t1 = coords ( 4 ) pih = 0.5 * pi !==================== phi0 = par_pp ( 1 ) * ( t1 - x1 ) phi1 = par_pp ( 2 ) * ( t1 - x1 ) / par_pp ( 3 ) if ( abs ( phi1 ) > pih ) phi1 = pih ev0 = cos ( phi1 ) * cos ( phi1 ) ampl = ev0 * sin ( phi0 ) ampl_1 = ev0 * sin ( phi0 - pih ) fields ( 2 ) = ampl !Ey fields ( 3 ) = - ampl_1 !Ez fields ( 5 ) = - fields ( 3 ) !By fields ( 6 ) = fields ( 2 ) !Bz end subroutine !====================== subroutine get_laser_fields_cp ( coords , par_cp , fields ) real ( dp ), intent ( in ) :: coords ( 4 ), par_cp ( 7 ) real ( dp ), intent ( out ) :: fields ( 6 ) real ( dp ) :: phi0 , phi1 , phig00 , phig10 , csphig01 , snphig01 real ( dp ) :: x1 , y1 , z1 , t1 real ( dp ) :: w2 , ar , rho , ss0 , cs0 real ( dp ) :: ampl , ampl_1 , pih real ( dp ) :: ev0 , ev1 , phx , psi , r2 , wshape !========== enter !par_cp(1)=om0=k0 !par_cp(2)=xc !par_cp(3)=wx !par_cp(4)=wy !par_cp(5)=zra !par_cp(6)=eps !par_cp(7)=sigma pih = 0.5 * pi x1 = coords ( 1 ) y1 = coords ( 2 ) z1 = coords ( 3 ) t1 = coords ( 4 ) y1 = y1 / par_cp ( 4 ) z1 = z1 / par_cp ( 4 ) r2 = y1 * y1 + z1 * z1 phi0 = par_cp ( 1 ) * ( t1 - x1 ) phi1 = pi * ( t1 - x1 ) / par_cp ( 3 ) if ( abs ( phi1 ) > pih ) phi1 = pih x1 = x1 / par_cp ( 5 ) w2 = 1. / ( 1. + x1 * x1 ) !     w2=(w0/w)&#94;2 phx = atan ( x1 ) phig00 = phi0 + phx - x1 * r2 * w2 !phi_g ,(phi_g)&#94;1=phi_g+phx phig10 = phig00 + phx psi = phig00 + 2. * phx ar = 1. - r2 rho = sqrt ( ar * ar + x1 * x1 ) !the module of (1-r&#94;2)+x&#94;2 ss0 = 0.0 cs0 = 1.0 if ( rho > 0.0 ) then ss0 = x1 / rho cs0 = ar / rho end if csphig01 = cos ( psi ) * cs0 + sin ( psi ) * ss0 snphig01 = cos ( psi - pih ) * cs0 + sin ( psi - pih ) * ss0 ev0 = cos ( phi1 ) * cos ( phi1 ) ev1 = cos ( phi1 ) * sin ( phi1 ) wshape = sqrt ( w2 ) * exp ( - w2 * r2 ) ampl = ev0 * sin ( phig00 ) ampl_1 = ev1 * par_cp ( 7 ) * x1 * w2 * rho ampl_1 = ampl_1 * csphig01 fields ( 2 ) = wshape * ( ampl + ampl_1 ) !Ey(x,yh) ampl = ev0 * sin ( phig00 - pih ) ampl_1 = ev1 * par_cp ( 7 ) * x1 * w2 * rho ampl_1 = ampl_1 * snphig01 fields ( 3 ) = - wshape * ( ampl - ampl_1 ) ampl_1 = ev0 * 2. * par_cp ( 6 ) * w2 * exp ( - w2 * r2 ) fields ( 1 ) = y1 * ampl_1 * cos ( phig10 ) - z1 * ampl_1 * cos ( phig10 - pih ) fields ( 4 ) = z1 * ampl_1 * cos ( phig10 ) + y1 * ampl_1 * cos ( phig10 - pih ) !Bz=Ey !By=-Ez fields ( 5 ) = - fields ( 3 ) fields ( 6 ) = fields ( 2 ) end subroutine !============================== subroutine inflow_lp_fields ( ef , ee0 , t_loc , tf , wx , wy , xf0 , om0 , lp , & i , j1 , j2 , k1 , k2 ) !========================== real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: ee0 , t_loc , tf , wx , wy , xf0 , om0 integer , intent ( in ) :: lp , i , j1 , j2 , k1 , k2 real ( dp ) :: xxh , xx , yy , yyh , zz , zzh , sigma , eps real ( dp ) :: xp , yp real ( dp ) :: xc , zra real ( dp ) :: ex , ey , ez , bx , by , bz integer :: j , k , jj , kk real ( dp ) :: coords ( 4 ), fields ( 6 ), par_lp ( 7 ) ! inviluppo temporale= cos&#94;2(pi*(t-x))/wx) ! eps=1./k0*wy k0=omega_0=omgl sigma = 2. * pi / ( om0 * wx ) !sigma=lambda/wx eps = 1. / ( om0 * wy ) zra = 0.5 * om0 * wy * wy xx = loc_xg ( 1 , 1 , 0 ) xxh = loc_xg ( 1 , 2 , 0 ) xc = xf0 - tf coords ( 4 ) = t_loc - tf par_lp ( 1 ) = om0 par_lp ( 2 ) = xc par_lp ( 3 ) = wx par_lp ( 4 ) = wy par_lp ( 5 ) = zra par_lp ( 6 ) = eps par_lp ( 7 ) = sigma !Linear polarization (P-mode) !Ex   half-integer on x !Bx   half-integer on y and z !Ey   half-integer on y !Bz   half-integer on y and x select case ( lp ) case ( 0 ) !Plane 2D wave if ( ndim < 3 ) then !Holds also the 1D case k = 1 do j = j1 , j2 !===ora Ex(xxh,yy)========= ef ( i , j , k , 1 ) = 0.0 !==== Ey(xx,yyh)! xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey !===ora Bz(xxh,yyh)========= xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = bz end do return end if !====3D ======================== do k = k1 , k2 do j = j1 , j2 !==== Ex(xxh,yy,zz)========= !==== Ez(xx,yy,zzh) ========= ef ( i , j , k , 1 ) = 0.0 ef ( i , j , k , 3 ) = 0.0 !==== Ey(xx,yyh,zz) ========= xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey ef ( i , j , k , 4 ) = 0.0 ef ( i , j , k , 5 ) = 0.0 !==== Bz(xxh,yyh,zz)========= xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 6 ) ef ( i , j , k , 5 ) = 0.0 ef ( i , j , k , 6 ) = bz end do end do !=========== Gaussian field case ( 1 ) if ( ndim < 2 ) then k = 1 j = 1 coords ( 2 : 3 ) = 0.0 !===ora Ex(xxh,yy)========= xp = xxh coords ( 1 ) = xp - xf0 !==== Ex(xxh,yy)! if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ex = ee0 * fields ( 1 ) ef ( i , j , k , 1 ) = ex bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = bz !==== Ey(xx,yyh)! xp = xx coords ( 1 ) = xp - xf0 if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey return end if if ( ndim < 3 ) then k = 1 coords ( 3 ) = 0.0 do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) !===ora Ex(xxh,yy)========= xp = xxh yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp !==== Ex(xxh,yy)! if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ex = ee0 * fields ( 1 ) ef ( i , j , k , 1 ) = ex !==== Ey(xx,yyh)! xp = xx yp = yyh coords ( 1 ) = xp - xf0 coords ( 2 ) = yp if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey !===ora Bz(xxh,yyh)========= xp = xxh yp = yyh coords ( 1 ) = xp - xf0 coords ( 2 ) = yp if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = bz end do return end if !====3D ======================== do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) zzh = loc_zg ( kk , 2 , imodz ) do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) xp = xxh yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_lp ( coords , par_lp , fields ) ex = ee0 * fields ( 1 ) ef ( i , j , k , 1 ) = ex !==== Ey(xx,yyh,zz) ========= xp = xx yp = yyh coords ( 1 ) = xp - xf0 coords ( 2 ) = yp call get_laser_fields_lp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey !==== Ez(xx,yy,zzh) ========= xp = xx yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) ez = ee0 * fields ( 3 ) ef ( i , j , k , 3 ) = ez !==== Bx(xx,yyh,zzh)========= xp = xx yp = yyh coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) bx = ee0 * fields ( 4 ) ef ( i , j , k , 4 ) = bx !==== By(xxh,yy,zzh) ========= xp = xxh yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) by = ee0 * fields ( 5 ) ef ( i , j , k , 5 ) = by !==== Bz(xxh,yyh,zz)========= yp = yyh coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 6 ) ef ( i , j , k , 6 ) = bz end do end do !====== S POLARIZATION ============================================== case ( 2 ) if ( ndim < 3 ) then k = 1 coords ( 3 ) = 0 do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) !===ora Ez(xx,yy)========= xp = xx yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp call get_laser_fields_lp ( coords , par_lp , fields ) ez = ee0 * fields ( 2 ) !  Ez(s-pol)=Ey(p-pol) ef ( i , j , k , 3 ) = ez !==== Bx(xx,yyh)========= yp = yyh coords ( 2 ) = yp call get_laser_fields_lp ( coords , par_lp , fields ) bx = ee0 * fields ( 1 ) !  Bx(s-pol)= Ex(p-pol) ef ( i , j , k , 4 ) = bx by = - ee0 * fields ( 2 ) !  By(s-pol)=-Bz(p-pol) ef ( i , j , k , 5 ) = by end do return end if !====3D ======================== do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) zzh = loc_zg ( kk , 2 , imodz ) do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) !==== Ex(xxh,yy,zz)========= xp = xxh yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_lp ( coords , par_lp , fields ) ex = ee0 * fields ( 4 ) !  Ex(s-pol)= Bx(p-pol) ey = - ee0 * fields ( 3 ) !  Ey(s-pol)=-Ez(p-pol) ef ( i , j , k , 1 ) = ex !==== Ey(xx,yyh,zz) ========= yp = yyh coords ( 2 ) = yp call get_laser_fields_lp ( coords , par_lp , fields ) ey = - ee0 * fields ( 3 ) !  Ey(s-pol)=-Ez(p-pol) ef ( i , j , k , 2 ) = ey !==== Ez(xx,yy,zzh) ========= yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) ez = ee0 * fields ( 2 ) !  Ez(s-pol)= Ey(p-pol) ef ( i , j , k , 3 ) = ez !==== Bx(xx,yyh,zzh)========= yp = yyh coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) bx = ee0 * fields ( 1 ) !  Bx(s-pol)= Ex(p-pol) ef ( i , j , k , 4 ) = bx !==== By(xxh,yy,zzh) ========= xp = xxh yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) by = - ee0 * fields ( 6 ) !  By(s-pol)=-Bz(p-pol) ef ( i , j , k , 5 ) = by !==== Bz(xxh,yyh,zz)========= yp = yyh coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 5 ) !  Bz(s-pol)= By(p-pol) ef ( i , j , k , 6 ) = bz end do end do end select end subroutine !=================================== subroutine init_lp_inc0_fields ( ef , ee0 , t_loc , tf , wx , wy , xf0 , om0 , & lp , i1 , i2 , ycent , zcent ) !========================== real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: ee0 , t_loc , tf , wx , wy , xf0 , om0 integer , intent ( in ) :: lp , i1 , i2 real ( dp ) :: xxh , xx , yy , yyh , zz , zzh , sigma , eps real ( dp ) :: xp , xc , yc , zc , zra , ycent , zcent real ( dp ) :: ex , ey , ez , bx , by , bz integer :: i , j , k , ii , jj , kk integer :: j1 , j2 , k1 , k2 real ( dp ) :: coords ( 4 ), fields ( 6 ), par_lp ( 7 ) ! inviluppo temporale= cos&#94;2(pi*(t-x))/wx) ! inviluppo temporale -gprof = exp-(t-x)&#94;2/w2x) ! eps=1./k0*wy k0=omega_0=omgl ! NORMAL INCIDENCE sigma = 1. / ( om0 * wx ) eps = 1. / ( om0 * wy ) zra = 0.5 * om0 * wy * wy xc = xf0 - tf yc = ycent ! yc centroid y coordinate zc = zcent ! zc centroid z coordinate par_lp ( 1 ) = om0 par_lp ( 2 ) = xc par_lp ( 3 ) = wx par_lp ( 4 ) = wy par_lp ( 5 ) = zra par_lp ( 6 ) = eps par_lp ( 7 ) = sigma coords ( 4 ) = t_loc - tf !Linear polarization (P-mode) !Ex half-integer on x !Bx half-integer on y and z !Ey half-integer on y !Bz half-integer on y and x j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) k1 = loc_zgrid ( imodz )% p_ind ( 1 ) k2 = loc_zgrid ( imodz )% p_ind ( 2 ) select case ( lp ) case ( 0 ) !Plane 2D wave if ( ndim < 3 ) then !Holds also the 1D case k = 1 do j = j1 , j2 do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !===ora Ex(xxh,yy)========= ef ( i , j , k , 1 ) = 0.0 !==== Ey(xx,yyh)! xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey !===ora Bz(xxh,yyh)========= xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + bz end do end do return end if !====3D ======================== do k = k1 , k2 do j = j1 , j2 do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !==== Ex(xxh,yy,zz)========= !==== Ez(xx,yy,zzh) ========= ef ( i , j , k , 1 ) = 0.0 ef ( i , j , k , 3 ) = 0.0 !==== Ey(xx,yyh,zz) ========= coords ( 1 ) = xx - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey ef ( i , j , k , 4 ) = 0.0 ef ( i , j , k , 5 ) = 0.0 !==== Bz(xxh,yyh,zz)========= coords ( 1 ) = xxh - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 6 ) ef ( i , j , k , 6 ) = ef ( i , j , k , 6 ) + bz end do end do end do !=============  Gaussian radial shape  longitudinal Gaussian or cos&#94;2 profile case ( 1 ) if ( ndim < 2 ) then k = 1 j = 1 coords ( 2 : 3 ) = 0.0 do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !===ora Ex(xxh,yy)========= coords ( 1 ) = xxh - xf0 !==== Ex(xxh,yy)! if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ex = ee0 * fields ( 1 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ex !==== Ey(xx,yyh)! coords ( 1 ) = xx - xf0 if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey !===ora Bz(xxh,yyh)========= coords ( 1 ) = xxh - xf0 if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + bz end do return end if if ( ndim < 3 ) then k = 1 coords ( 3 ) = 0.0 do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !===ora Ex(xxh,yy)========= coords ( 1 ) = xxh - xf0 coords ( 2 ) = yy - yc !==== Ex(xxh,yy)! if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ex = ee0 * fields ( 1 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ex !==== Ey(xx,yyh)! coords ( 1 ) = xx - xf0 coords ( 2 ) = yyh - yc if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey !===ora Bz(xxh,yyh)========= coords ( 1 ) = xxh - xf0 coords ( 2 ) = yyh - yc if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + bz end do end do return end if !====3D ======================== do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) zzh = loc_zg ( kk , 2 , imodz ) do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !==== Ex(xxh,yy,zz)========= coords ( 1 ) = xxh - xf0 coords ( 2 ) = yy - yc coords ( 3 ) = zz - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if ex = ee0 * fields ( 1 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ex !==== Ey(xx,yyh,zz) ========= coords ( 1 ) = xx - xf0 coords ( 2 ) = yyh - yc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey !==== Ez(xx,yy,zzh) ========= coords ( 1 ) = xx - xf0 coords ( 2 ) = yy - yc coords ( 3 ) = zzh - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if ez = ee0 * fields ( 3 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ez !==== Bx(xx,yyh,zzh)========= coords ( 1 ) = xx - xf0 coords ( 2 ) = yyh - yc coords ( 3 ) = zzh - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if bx = ee0 * fields ( 4 ) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + bx !==== By(xxh,yy,zzh) ========= coords ( 1 ) = xxh - xf0 coords ( 2 ) = yy - yc coords ( 3 ) = zzh - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if by = ee0 * fields ( 5 ) ef ( i , j , k , 5 ) = ef ( i , j , k , 5 ) + by !==== Bz(xxh,yyh,zz)========= coords ( 1 ) = xxh - xf0 coords ( 2 ) = yyh - yc coords ( 3 ) = zz - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if bz = ee0 * fields ( 6 ) ef ( i , j , k , 6 ) = ef ( i , j , k , 6 ) + bz end do end do end do !====== S POLARIZATION ============================================== case ( 2 ) if ( ndim < 3 ) then k = 1 coords ( 3 ) = 0 do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !===ora Ez(xx,yy)========= coords ( 1 ) = xx - xf0 coords ( 2 ) = yy - yc if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if ez = ee0 * fields ( 2 ) !  Ez(s-pol)=Ey(p-pol) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ez !==== Bx(xx,yyh)========= coords ( 1 ) = xx - xf0 coords ( 2 ) = yyh - yc if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if bx = ee0 * fields ( 1 ) !  Bx(s-pol)= Ex(p-pol) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + bx !==== By(xx,yyh) ======= coords ( 1 ) = xx - xf0 coords ( 2 ) = yyh - yc if ( g_prof ) then call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) else call get_2dlaser_fields_lp ( coords , par_lp , fields ) end if by = - ee0 * fields ( 2 ) !  By(s-pol)=-Bz(p-pol) ef ( i , j , k , 5 ) = ef ( i , j , k , 5 ) + by end do end do return end if !====3D ======================== do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) zzh = loc_zg ( kk , 2 , imodz ) do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !==== Ex(xxh,yy,zz)========= coords ( 1 ) = xxh - xf0 coords ( 2 ) = yy - yc coords ( 3 ) = zz - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if ex = ee0 * fields ( 4 ) !  Ex(s-pol)= Bx(p-pol) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ex !==== Ey(xx,yyh,zz) ========= coords ( 1 ) = xx - xf0 coords ( 2 ) = yyh - yc coords ( 3 ) = zz - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if ey = - ee0 * fields ( 3 ) !  Ey(s-pol)=-Ez(p-pol) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey !==== Ez(xx,yy,zzh) ========= coords ( 1 ) = xx - xf0 coords ( 2 ) = yy - yc coords ( 3 ) = zzh - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if ez = ee0 * fields ( 2 ) !  Ez(s-pol)= Ey(p-pol) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ez !==== Bx(xx,yyh,zzh)========= coords ( 1 ) = xx - xf0 coords ( 2 ) = yyh - yc coords ( 3 ) = zzh - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if bx = ee0 * fields ( 1 ) !  Bx(s-pol)= Ex(p-pol) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + bx !==== By(xxh,yy,zzh) ========= coords ( 1 ) = xxh - xf0 coords ( 2 ) = yy - yc coords ( 3 ) = zzh - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if by = ee0 * fields ( 6 ) !  By(s-pol)=-Bz(p-pol) ef ( i , j , k , 5 ) = ef ( i , j , k , 5 ) + by !==== Bz(xxh,yyh,zz)========= coords ( 1 ) = xxh - xf0 coords ( 2 ) = yyh - yc coords ( 3 ) = zz - zc if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if bz = ee0 * fields ( 5 ) !  Bz(s-pol)= By(p-pol) ef ( i , j , k , 6 ) = bz end do end do end do end select end subroutine !===================================== subroutine init_lp_fields ( ef , ee0 , t_loc , tf , wx , wy , xf0 , om0 , angle , & lp_shx , lp , i1 , i2 , ycent , zcent ) !========================== real ( dp ), intent ( inout ) :: ef (:, :, :, :) real ( dp ), intent ( in ) :: ee0 , t_loc , tf , wx , wy , xf0 , angle , lp_shx , & om0 integer , intent ( in ) :: lp , i1 , i2 real ( dp ) :: xxh , xx , yy , yyh , zz , zzh , sigma , eps real ( dp ) :: xp , xc , yp , yc , zc , ycent , zcent real ( dp ) :: zra , sf , cf real ( dp ) :: ex , ey , ez , bx , by , bz integer :: i , j , k , ii , jj , kk integer :: j1 , j2 , k1 , k2 real ( dp ) :: coords ( 4 ), fields ( 6 ), par_lp ( 7 ) ! inviluppo temporale= cos&#94;2(pi*(t-x))/wx) ! inviluppo temporale -gprof = exp-(t-x)&#94;2/w2x) ! eps=1./k0*wy k0=omega_0=omgl sf = 0.0 cf = 1. if ( angle > 0.0 ) then sf = sin ( pi * angle / 18 0. ) cf = cos ( pi * angle / 18 0. ) end if sigma = 1. / ( om0 * wx ) eps = 1. / ( om0 * wy ) zra = 0.5 * om0 * wy * wy xc = xf0 - tf + lp_shx yc = ycent zc = zcent ! yc centroid y coordinate par_lp ( 1 ) = om0 par_lp ( 2 ) = xc par_lp ( 3 ) = wx par_lp ( 4 ) = wy par_lp ( 5 ) = zra par_lp ( 6 ) = eps par_lp ( 7 ) = sigma coords ( 4 ) = t_loc - tf ! for normal incidence ! rotates the laser pulse around the (xc,yc) point ! the (xp,yp) coordinates of the rotated pulse ! xp=xc+(x-xc)*cos+y*sin yp=y*cos-(x-xc)*sin !================================ !Linear polarization (P-mode) !Ex half-integer on x !Bx half-integer on y and z !Ey half-integer on y !Bz half-integer on y and x j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) k1 = loc_zgrid ( imodz )% p_ind ( 1 ) k2 = loc_zgrid ( imodz )% p_ind ( 2 ) select case ( lp ) case ( 0 ) !Plane 2D wave if ( ndim < 3 ) then !Holds also the 1D case k = 1 do j = j1 , j2 do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !===ora Ex(xxh,yy)========= ef ( i , j , k , 1 ) = 0.0 !==== Ey(xx,yyh)! xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey !===ora Bz(xxh,yyh)========= xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + bz end do end do return end if !====3D ======================== do k = k1 , k2 do j = j1 , j2 do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !==== Ex(xxh,yy,zz)========= !==== Ez(xx,yy,zzh) ========= ef ( i , j , k , 1 ) = 0.0 ef ( i , j , k , 3 ) = 0.0 !==== Ey(xx,yyh,zz) ========= xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey * cf ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ey * sf ef ( i , j , k , 4 ) = 0.0 ef ( i , j , k , 5 ) = 0.0 !==== Bz(xxh,yyh,zz)========= xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 6 ) ef ( i , j , k , 5 ) = ef ( i , j , k , 5 ) - bz * sf ef ( i , j , k , 6 ) = ef ( i , j , k , 6 ) + bz * cf end do end do end do !========== Gaussian field case ( 1 ) if ( ndim < 2 ) then k = 1 j = 1 coords ( 2 : 3 ) = 0.0 do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !===ora Ex(xxh,yy)========= xp = xxh coords ( 1 ) = xp - xf0 !==== Ex(xxh,yy)! !call get_laser_fields_lp(coords,par_lp,fields) call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) ex = ee0 * fields ( 1 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ex !==== Ey(xx,yyh)! xp = xx coords ( 1 ) = xp - xf0 call get_laser_fields_lp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey !===ora Bz(xxh,yyh)========= xp = xc + ( xxh - xc ) coords ( 1 ) = xp - xf0 !call get_laser_fields_lp(coords,par_lp,fields) call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + bz end do return end if if ( ndim < 3 ) then k = 1 coords ( 3 ) = 0.0 do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) yy = yy - yc yyh = yyh - yc do i = i1 , i2 ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !===ora Ex(xxh,yy)========= xp = xc + ( xxh - xc ) * cf + yy * sf yp = yy * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp !==== Ex(xxh,yy)! call get_2dlaser_fields_lp ( coords , par_lp , fields ) !call get_2Dlaser_gprof_fields_lp(coords,par_lp,fields) ex = ee0 * fields ( 1 ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ex * cf - ey * sf !==== Ey(xx,yyh)! xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp call get_2dlaser_fields_lp ( coords , par_lp , fields ) !call get_2Dlaser_gprof_fields_lp(coords,par_lp,fields) ex = ee0 * fields ( 1 ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey * cf + ex * sf !===ora Bz(xxh,yyh)========= xp = xc + ( xxh - xc ) * cf + yyh * sf yp = yyh * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp call get_2dlaser_fields_lp ( coords , par_lp , fields ) !call get_2Dlaser_gprof_fields_lp(coords,par_lp,fields) bz = ee0 * fields ( 6 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + bz end do end do return end if !====3D ======================== do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) zzh = loc_zg ( kk , 2 , imodz ) zz = zz - zc zzh = zzh - zc do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) yy = yy - yc yyh = yyh - yc do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !==== Ex(xxh,yy,zz)========= xp = xc + ( xxh - xc ) * cf + yy * sf yp = yy * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if ex = ee0 * fields ( 1 ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 1 ) = ex * cf - ey * sf !==== Ey(xx,yyh,zz) ========= xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp ex = ee0 * fields ( 1 ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey * cf + ex * sf !==== Ez(xx,yy,zzh) ========= xp = xc + ( xx - xc ) * cf + yy * sf yp = yy * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if ez = ee0 * fields ( 3 ) ef ( i , j , k , 3 ) = ez !==== Bx(xx,yyh,zzh)========= xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if bx = ee0 * fields ( 4 ) by = ee0 * fields ( 5 ) ef ( i , j , k , 4 ) = bx * cf - by * sf !==== By(xxh,yy,zzh) ========= xp = xc + ( xxh - xc ) * cf + yy * sf yp = yy * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if bx = ee0 * fields ( 4 ) by = ee0 * fields ( 5 ) ef ( i , j , k , 5 ) = by * cf + bx * sf !==== Bz(xxh,yyh,zz)========= xp = xc + ( xxh - xc ) * cf + yyh * sf yp = yyh * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz if ( g_prof ) then call get_laser_gprof_fields_lp ( coords , par_lp , fields ) else call get_laser_fields_lp ( coords , par_lp , fields ) end if bz = ee0 * fields ( 6 ) ef ( i , j , k , 6 ) = bz end do end do end do !====== S POLARIZATION ============================================== case ( 2 ) if ( ndim < 3 ) then k = 1 coords ( 3 ) = 0 do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) yy = yy - yc yyh = yyh - yc do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !===ora Ez(xx,yy)========= xp = xc + ( xx - xc ) * cf + yy * sf yp = yy * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp !call get_2Dlaser_fields_lp(coords,par_lp,fields) call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) ez = ee0 * fields ( 2 ) !  Ez(s-pol)=Ey(p-pol) ef ( i , j , k , 3 ) = ez !==== Bx(xx,yyh)========= xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp !call get_2Dlaser_fields_lp(coords,par_lp,fields) call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) bx = ee0 * fields ( 1 ) !  Bx(s-pol)= Ex(p-pol) by = - ee0 * fields ( 6 ) !  By(s-pol)=-Bz(p-pol) ef ( i , j , k , 4 ) = bx * cf - by * sf !==== By(xx,yyh) ======= xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp !call get_2Dlaser_fields_lp(coords,par_lp,fields) call get_2dlaser_gprof_fields_lp ( coords , par_lp , fields ) bx = ee0 * fields ( 1 ) !  Bx(s-pol)= Ex(p-pol by = - ee0 * fields ( 2 ) !  By(s-pol)=-Bz(p-pol) ef ( i , j , k , 5 ) = by * cf + bx * sf end do end do return end if !====3D ======================== do k = k1 , k2 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) zzh = loc_zg ( kk , 2 , imodz ) zz = zz - zc zzh = zzh - zc do j = j1 , j2 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) yy = yy - yc yyh = yyh - yc do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !==== Ex(xxh,yy,zz)========= xp = xc + ( xxh - xc ) * cf + yy * sf yp = yy * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_lp ( coords , par_lp , fields ) ex = ee0 * fields ( 4 ) !  Ex(s-pol)= Bx(p-pol) ey = - ee0 * fields ( 3 ) !  Ey(s-pol)=-Ez(p-pol) ef ( i , j , k , 1 ) = ex * cf - ey * sf !==== Ey(xx,yyh,zz) ========= xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_lp ( coords , par_lp , fields ) ex = ee0 * fields ( 4 ) !  Ex(s-pol)= Bx(p-pol) ey = - ee0 * fields ( 3 ) !  Ey(s-pol)=-Ez(p-pol) ef ( i , j , k , 2 ) = ey * cf + ex * sf !==== Ez(xx,yy,zzh) ========= xp = xc + ( xx - xc ) * cf + yy * sf yp = yy * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) ez = ee0 * fields ( 2 ) !  Ez(s-pol)= Ey(p-pol) ef ( i , j , k , 3 ) = ez !==== Bx(xx,yyh,zzh)========= xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) bx = ee0 * fields ( 1 ) !  Bx(s-pol)= Ex(p-pol) by = - ee0 * fields ( 6 ) !  By(s-pol)=-Bz(p-pol) ef ( i , j , k , 4 ) = bx * cf - by * sf !==== By(xxh,yy,zzh) ========= xp = xc + ( xxh - xc ) * cf + yy * sf yp = yy * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_lp ( coords , par_lp , fields ) bx = ee0 * fields ( 1 ) !  Bx(s-pol)= Ex(p-pol) by = ee0 * fields ( 6 ) !  By(s-pol)=-Bz(p-pol) ef ( i , j , k , 5 ) = by * cf + bx * sf !==== Bz(xxh,yyh,zz)========= xp = xc + ( xxh - xc ) * cf + yyh * sf yp = yyh * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_lp ( coords , par_lp , fields ) bz = ee0 * fields ( 5 ) !  Bz(s-pol)= By(p-pol) ef ( i , j , k , 6 ) = bz end do end do end do end select end subroutine !=============================== subroutine inflow_cp_fields ( ef , ee0 , t_loc , tf , wx , wy , xf0 , cp , i , j1 , & j2 , k1 , k2 ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) integer , intent ( in ) :: cp , i , j1 , j2 , k1 , k2 real ( dp ), intent ( in ) :: ee0 , t_loc , tf , wx , wy , xf0 real ( dp ) :: xxh , xx , yy , yyh , zz , zzh , xp , yp real ( dp ) :: xc , eps , sigma , zra real ( dp ) :: ey , bz , ex , bx , ez , by real ( dp ) :: coords ( 4 ), fields ( 6 ), par_lp ( 7 ) integer :: j , k , jj , kk !============ ! inviluppo temporale= cos&#94;2(pi*(t-x))/wx) ! eps=1./k0*wy k0=omega_0=omgl sigma = pi / ( oml * wx ) !sigma=lambda/wx eps = 1. / ( oml * wy ) zra = 0.5 * oml * wy * wy xc = xf0 - tf coords ( 4 ) = t_loc - tf par_lp ( 1 ) = oml par_lp ( 2 ) = xc par_lp ( 3 ) = wx par_lp ( 4 ) = wy par_lp ( 5 ) = zra par_lp ( 6 ) = eps par_lp ( 7 ) = sigma xx = loc_xg ( 1 , 1 , 0 ) xxh = loc_xg ( 1 , 2 , 0 ) !============================== !Circular polarization !Ey half-integer on y !Bz half-integer on y and x !Ez half-integer on z !By half-integer on z and x !Ex half-integer on x !Bx half-integer on y and z !============================= if ( cp == 0 ) then !CP plane wave if ( ndim < 3 ) then !Holds also the 1D case k = 1 do j = j1 , j2 !=== Ex(xxh,yy)========= ef ( i , j , k , 1 ) = 0.0 !==== Ey(xx,yyh), Ez(xx,yy), By(xxh,yy), Bz(xxh,yyh)! xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_cp ( coords , par_lp , fields ) ef ( i , j , k , 2 ) = ee0 * fields ( 2 ) ef ( i , j , k , 3 ) = ee0 * fields ( 3 ) !===ora Bz(xxh,yyh)========= xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_cp ( coords , par_lp , fields ) ef ( i , j , k , 5 ) = ee0 * fields ( 5 ) ef ( i , j , k , 6 ) = ee0 * fields ( 6 ) end do return end if !====3D ======================== do k = k1 , k2 do j = j1 , j2 !==== Ex(xxh,yy,zz)========= !==== Ez(xx,yy,zzh) ========= ef ( i , j , k , 1 ) = 0.0 ef ( i , j , k , 4 ) = 0.0 xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_cp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey ez = ee0 * fields ( 3 ) ef ( i , j , k , 3 ) = ez xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_cp ( coords , par_lp , fields ) ef ( i , j , k , 5 ) = ee0 * fields ( 5 ) ef ( i , j , k , 6 ) = ee0 * fields ( 6 ) end do end do return end if !============================= CP with gaussian envelope kk = 1 do k = k1 , k2 zz = loc_zg ( kk , 1 , imodz ) zzh = loc_zg ( kk , 2 , imodz ) if ( ndim < 3 ) then zz = 0.0 zzh = 0.0 end if jj = 1 do j = j1 , j2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) !================== xp = xxh yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_cp ( coords , par_lp , fields ) !(xh,y,z) ex = ee0 * fields ( 1 ) ef ( i , j , k , 1 ) = ex xp = xx yp = yyh coords ( 1 ) = xp - xf0 coords ( 2 ) = yp call get_laser_fields_cp ( coords , par_lp , fields ) !(x,yh,z) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey yp = yy coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_cp ( coords , par_lp , fields ) !(x,y,zh) ez = ee0 * fields ( 3 ) ef ( i , j , k , 3 ) = ez yp = yyh coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_cp ( coords , par_lp , fields ) !(x,yh,zh) bx = ee0 * fields ( 4 ) ef ( i , j , k , 4 ) = bx xp = xxh yp = yy coords ( 1 ) = xp - xf0 coords ( 2 ) = yp call get_laser_fields_cp ( coords , par_lp , fields ) !(xh,y,zh) by = ee0 * fields ( 5 ) ef ( i , j , k , 5 ) = by yp = yyh coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_cp ( coords , par_lp , fields ) !(xh,yh,z) bz = ee0 * fields ( 6 ) ef ( i , j , k , 6 ) = bz jj = jj + 1 end do kk = kk + 1 end do end subroutine !================================= subroutine init_cp_fields ( ef , ee0 , t_loc , tf , wx , wy , xf0 , angle , & lp_shx , cp , i1 , i2 ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) integer , intent ( in ) :: cp , i1 , i2 real ( dp ), intent ( in ) :: ee0 , t_loc , tf , wx , wy , xf0 , angle , lp_shx real ( dp ) :: xxh , xx , yy , yyh , zz , zzh , xp , yp real ( dp ) :: eps , sigma , sf , cf , zra , xc real ( dp ) :: ey , bz , ex , bx , ez , by real ( dp ) :: coords ( 4 ), fields ( 6 ), par_lp ( 7 ) integer :: j1 , j2 , k1 , k2 , i , j , k , ii , jj , kk !============ ! inviluppo temporale= cos&#94;2(pi*(t-x))/wx) ! eps=1./k0*wy k0=omega_0=omgl sf = sin ( pi * angle / 18 0. ) cf = cos ( pi * angle / 18 0. ) sigma = pi / ( oml * wx ) !sigma=lambda/wx eps = 1. / ( oml * wy ) zra = 0.5 * oml * wy * wy xc = xf0 - tf + lp_shx coords ( 4 ) = t_loc - tf par_lp ( 1 ) = oml par_lp ( 2 ) = xc par_lp ( 3 ) = wx par_lp ( 4 ) = wy par_lp ( 5 ) = zra par_lp ( 6 ) = eps par_lp ( 7 ) = sigma !============================== j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) k1 = loc_zgrid ( imodz )% p_ind ( 1 ) k2 = loc_zgrid ( imodz )% p_ind ( 2 ) !Circular polarization !Ey half-integer on y !Bz half-integer on y and x !Ez half-integer on z !By half-integer on z and x !Ex half-integer on x !Bx half-integer on y and z !============================= if ( cp == 0 ) then !CP plane wave if ( ndim < 3 ) then !Holds also the 1D case k = 1 do j = j1 , j2 do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !=== Ex(xxh,yy)========= ef ( i , j , k , 1 ) = 0.0 !==== Ey(xx,yyh), Ez(xx,yy), By(xxh,yy), Bz(xxh,yyh)! xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_cp ( coords , par_lp , fields ) ef ( i , j , k , 2 ) = ee0 * fields ( 2 ) ef ( i , j , k , 3 ) = ee0 * fields ( 3 ) !===ora Bz(xxh,yyh)========= xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_cp ( coords , par_lp , fields ) ef ( i , j , k , 5 ) = ee0 * fields ( 5 ) ef ( i , j , k , 6 ) = ee0 * fields ( 6 ) end do end do return end if !====3D ======================== do k = k1 , k2 do j = j1 , j2 do i = i1 , i2 !xp=x*cos+y*sin  yp=y*cos-x*sin ii = i - 2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !==== Ex(xxh,yy,zz)========= !==== Ez(xx,yy,zzh) ========= ef ( i , j , k , 1 ) = 0.0 ef ( i , j , k , 4 ) = 0.0 xp = xx coords ( 1 ) = xp - xf0 call get_plane_wave_cp ( coords , par_lp , fields ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ey ez = ee0 * fields ( 3 ) ef ( i , j , k , 3 ) = ez xp = xxh coords ( 1 ) = xp - xf0 call get_plane_wave_cp ( coords , par_lp , fields ) ef ( i , j , k , 5 ) = ee0 * fields ( 5 ) ef ( i , j , k , 6 ) = ee0 * fields ( 6 ) end do end do end do return end if !============================= CP with gaussian envelope kk = 1 do k = k1 , k2 zz = loc_zg ( kk , 1 , imodz ) zzh = loc_zg ( kk , 2 , imodz ) if ( ndim < 3 ) then zz = 0.0 zzh = 0.0 end if jj = 1 do j = j1 , j2 yy = loc_yg ( jj , 1 , imody ) yyh = loc_yg ( jj , 2 , imody ) ii = 1 do i = i1 , i2 xx = loc_xg ( ii , 1 , imodx ) xxh = loc_xg ( ii , 2 , imodx ) !================== xp = xc + ( xxh - xc ) * cf + yy * sf yp = yy * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_cp ( coords , par_lp , fields ) !(xh,y,z) ex = ee0 * fields ( 1 ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 1 ) = ef ( i , j , k , 1 ) + ex * cf - ey * sf xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp call get_laser_fields_cp ( coords , par_lp , fields ) !(x,yh,z) ex = ee0 * fields ( 1 ) ey = ee0 * fields ( 2 ) ef ( i , j , k , 2 ) = ef ( i , j , k , 2 ) + ey * cf + ex * sf xp = xc + ( xx - xc ) * cf + yy * sf yp = yy * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_cp ( coords , par_lp , fields ) !(x,y,zh) ez = ee0 * fields ( 3 ) ef ( i , j , k , 3 ) = ef ( i , j , k , 3 ) + ez xp = xc + ( xx - xc ) * cf + yyh * sf yp = yyh * cf - ( xx - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zzh call get_laser_fields_cp ( coords , par_lp , fields ) !(x,yh,zh) bx = ee0 * fields ( 4 ) by = ee0 * fields ( 5 ) ef ( i , j , k , 4 ) = ef ( i , j , k , 4 ) + bx * cf - by * sf xp = xc + ( xxh - xc ) * cf + yy * sf yp = yy * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp call get_laser_fields_cp ( coords , par_lp , fields ) !(xh,y,zh) bx = ee0 * fields ( 4 ) by = ee0 * fields ( 5 ) ef ( i , j , k , 5 ) = ef ( i , j , k , 5 ) + by * cf + bx * sf xp = xc + ( xxh - xc ) * cf + yyh * sf yp = yyh * cf - ( xxh - xc ) * sf coords ( 1 ) = xp - xf0 coords ( 2 ) = yp coords ( 3 ) = zz call get_laser_fields_cp ( coords , par_lp , fields ) !(xh,yh,z) bz = ee0 * fields ( 6 ) ef ( i , j , k , 6 ) = ef ( i , j , k , 6 ) + bz ii = ii + 1 end do jj = jj + 1 end do kk = kk + 1 end do end subroutine !=========================================================== !  END SECTION FOR Laser field init !============================================================== !   FLUID density-momenta !=========================================================== subroutine init_fluid_density_momenta ( dmodel , part_in ) integer , intent ( in ) :: dmodel real ( dp ), intent ( in ) :: part_in integer :: i , i0 , j , k , ic , nxl ( 6 ), ntot , i0_targ , i1_targ integer :: n1 , ix , i1 , i2 , j1 , j2 , k1 , k2 integer :: j01 , j02 , k01 , k02 , jj , kk real ( dp ) :: uu , tot_x , l_inv , np1_loc , peak_fluid_density , u2 , u3 , & ramp_prefactor real ( dp ) :: yy , zz , r2 !================================== n1 = loc_xgrid ( imodx )% ng i1 = loc_xgrid ( imodx )% p_ind ( 1 ) i2 = loc_xgrid ( imodx )% p_ind ( 2 ) j1 = loc_ygrid ( imody )% p_ind ( 1 ) j2 = loc_ygrid ( imody )% p_ind ( 2 ) k1 = loc_zgrid ( imodz )% p_ind ( 1 ) k2 = loc_zgrid ( imodz )% p_ind ( 2 ) tot_x = zero_dp ntot = 0 do i = 1 , 6 nxl ( i ) = nint ( dx_inv * lpx ( i )) lpx ( i ) = nxl ( i ) * dx tot_x = tot_x + lpx ( i ) ntot = ntot + nxl ( i ) end do if ( part_in > 0. ) then targ_in = part_in i0_targ = nint ( dx_inv * targ_in ) targ_end = targ_in + tot_x nxf = i0_targ + ntot else targ_in = 0.0 i0_targ = 0 targ_end = tot_x + part_in ! targ_end < tot_x nxf = ntot end if !============================= allocate ( fluid_x_profile ( nxf )) !allocate(fluid_yz_profile(j2,k2)) already allocated in comon file !==================== peak_fluid_density = ( one_dp - ratio_mpfluid ) * n_plasma * n0_ref fluid_x_profile (:) = zero_dp fluid_yz_profile (:, :) = one_dp np1_loc = 0.005 ramp_prefactor = one_dp if ( np1 > 0.0 ) np1_loc = np1 l_inv = log ( 1. / np1_loc ) !============== j01 = j1 k01 = k1 j02 = j2 k02 = k2 if ( pe0y ) j01 = sh_targ + 1 if ( pe1y ) j02 = j2 - sh_targ if ( ndim > 2 ) then if ( pe0z ) k01 = sh_targ + 1 if ( pe1z ) k02 = k2 - sh_targ end if do k = k01 , k02 do j = j01 , j02 fluid_yz_profile ( j , k ) = 1.0 end do end do !if(pe0)write(6,'(a15,e11.4)')& !'Uniform fluid density on the (y-z) target coordinates ' if ( channel ) then if ( ndim < 3 ) then k = k01 zz = 0.0 do j = j01 , j02 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) r2 = ( yy * yy + zz * zz ) / ( w0_y * w0_y ) fluid_yz_profile ( j , k ) = 1.0 + chann_fact * r2 end do else do k = k01 , k02 kk = k - 2 zz = loc_zg ( kk , 1 , imodz ) do j = j01 , j02 jj = j - 2 yy = loc_yg ( jj , 1 , imody ) r2 = ( yy * yy + zz * zz ) / ( w0_y * w0_y ) fluid_yz_profile ( j , k ) = 1.0 + chann_fact * r2 end do end do end if !if(pe0)write(6,'(a15,e11.4)')'channel factor=',chann_fact end if i0 = i0_targ select case ( dmodel ) !initial plateau, cubic ramp (exponential still available but commented), central plateau and exit ramp case ( 1 ) if ( nxl ( 1 ) > 0 ) then ramp_prefactor = one_dp - np1 do i = 1 , nxl ( 1 ) i0 = i0 + 1 fluid_x_profile ( i0 ) = peak_fluid_density * np1 end do end if if ( nxl ( 2 ) > 0 ) then !sigma=nxl(2)/3 do i = 1 , nxl ( 2 ) i0 = i0 + 1 !uu=-(float(i)-float(nxl(2)))/float(nxl(2)) uu = ( real ( i ) - 0.5 ) / real ( nxl ( 2 )) u2 = uu * uu u3 = u2 * uu !fluid_x_profile(i0)=peak_fluid_density*exp(-4.5*uu*uu) fluid_x_profile ( i0 ) = peak_fluid_density * ( - 2. * ramp_prefactor * u3 + 3. & * ramp_prefactor * u2 + one_dp - ramp_prefactor ) end do end if do i = 1 , nxl ( 3 ) i0 = i0 + 1 fluid_x_profile ( i0 ) = peak_fluid_density end do if ( nxl ( 4 ) > 0 ) then do i = 1 , nxl ( 4 ) i0 = i0 + 1 uu = peak_fluid_density * real ( i ) / nxl ( 4 ) fluid_x_profile ( i0 ) = peak_fluid_density - uu * ( 1. - np2 ) end do end if if ( nxl ( 5 ) > 0 ) then do i = 1 , nxl ( 5 ) i0 = i0 + 1 fluid_x_profile ( i0 ) = peak_fluid_density * np2 end do end if case ( 2 ) if ( nxl ( 1 ) > 0 ) then !a ramp 0==>np1 do i = 1 , nxl ( 1 ) i0 = i0 + 1 uu = ( real ( i ) - real ( nxl ( 1 ))) / real ( nxl ( 1 )) fluid_x_profile ( i0 ) = np1 * peak_fluid_density * exp ( - 4.5 * uu * uu ) end do end if if ( nxl ( 2 ) > 0 ) then ! np1 plateau do i = 1 , nxl ( 2 ) i0 = i0 + 1 fluid_x_profile ( i0 ) = np1 * peak_fluid_density end do end if if ( nxl ( 3 ) > 0 ) then ! a down ramp np1=> np2 do i = 1 , nxl ( 3 ) i0 = i0 + 1 uu = peak_fluid_density * real ( i ) / nxl ( 3 ) fluid_x_profile ( i0 ) = np1 * peak_fluid_density - uu * ( np1 - np2 ) end do end if if ( nxl ( 4 ) > 0 ) then !a np2 plateau do i = 1 , nxl ( 4 ) i0 = i0 + 1 fluid_x_profile ( i0 ) = np2 * peak_fluid_density end do end if if ( nxl ( 5 ) > 0 ) then do i = 1 , nxl ( 5 ) i0 = i0 + 1 uu = peak_fluid_density * real ( i ) / nxl ( 5 ) fluid_x_profile ( i0 ) = peak_fluid_density * np2 * ( 1. - uu ) end do end if case ( 3 ) if ( pe0 ) then write ( 6 , * ) & 'dmodel_id =3 not activated for one-species fluid scheme' end if return !initial plateau, cos&#94;2 bump, central plateau and exit ramp. !See model_id=4 for pic case case ( 4 ) !================ cos&#94;2 upramp with peak n0 ================= if ( nxl ( 1 ) > 0 ) then !a cos&#94;2() ramp do i = 1 , nxl ( 1 ) i0 = i0 + 1 uu = ( real ( i ) - 0.5 ) / real ( nxl ( 1 )) - one_dp fluid_x_profile ( i0 ) = peak_fluid_density * cos ( 0.5 * pi * ( uu )) * & cos ( 0.5 * pi * ( uu )) end do end if !================ uniform layer n0 ================= if ( nxl ( 2 ) > 0 ) then do i = 1 , nxl ( 2 ) i0 = i0 + 1 fluid_x_profile ( i0 ) = peak_fluid_density end do end if !================ cos&#94;2 downramp to the plateau np1/n0 ================= if ( nxl ( 3 ) > 0 ) then do i = 1 , nxl ( 3 ) i0 = i0 + 1 uu = ( real ( i , dp ) - 0.5 ) / real ( nxl ( 3 )) - one_dp fluid_x_profile ( i0 ) = peak_fluid_density * ( np1 + ( one_dp - np1 ) * sin ( 0.5 & * pi * ( uu )) * sin ( 0.5 * pi * ( uu ))) end do end if !================ Central layer of density np1/n0 ================= if ( nxl ( 4 ) > 0 ) then do i = 1 , nxl ( 4 ) i0 = i0 + 1 fluid_x_profile ( i0 ) = peak_fluid_density * np1 end do end if !================ cos&#94;2 downramp to second plateau np2/n0 ================= if ( nxl ( 5 ) > 0 ) then do i = 1 , nxl ( 5 ) i0 = i0 + 1 uu = ( real ( i , dp ) - 0.5 ) / real ( nxl ( 5 )) fluid_x_profile ( i0 ) = peak_fluid_density * ( np2 + ( np1 - np2 ) * cos ( 0.5 * pi & * ( uu )) * cos ( 0.5 * pi * ( uu ))) end do end if !================ Second plateau of density np2/n0 ================= if ( nxl ( 6 ) > 0 ) then do i = 1 , nxl ( 6 ) i0 = i0 + 1 fluid_x_profile ( i0 ) = peak_fluid_density * np2 end do end if !========================================= end select if ( part_in < 0.0 ) then i1_targ = nint ( dx_inv * abs ( part_in )) i0 = 0 do i = 1 , ntot - i1_targ i0 = i0 + 1 fluid_x_profile ( i0 ) = fluid_x_profile ( i + i1_targ ) end do end if !------------------------------- ! target profile of length nxf (tot_x) ! now put target on the computationale grid ! ic = size ( up , 4 ) !the particle number density do k = k1 , k2 do j = j1 , j2 do ix = i1 , i2 i = ix - 2 + imodx * n1 up ( ix , j , k , ic ) = fluid_x_profile ( i ) * fluid_yz_profile ( j , k ) up0 ( ix , j , k , ic ) = up ( ix , j , k , ic ) end do end do end do !  Momenta set to zero in the allocation procedure !======================== end subroutine !======================== subroutine set_poloidal_ex_fields ( ef1 , i1 , i2 , j1 , j2 , k1 , k2 , & bpoloidal , rpoloidal ) real ( dp ), intent ( inout ) :: ef1 (:, :, :, :) integer , intent ( in ) :: i1 , i2 , j1 , j2 , k1 , k2 real ( dp ), intent ( in ) :: bpoloidal , rpoloidal real ( dp ) :: xx , yy , zz integer :: i , j , k do k = k1 , k2 do j = j1 , j2 do i = i1 , i2 zz = loc_zg ( k - 2 , 1 , imodz ) yy = loc_yg ( j - 2 , 1 , imody ) xx = loc_xg ( i - 2 , 1 , imodx ) ef1 ( i , j , k , 1 ) = 0.0 !B_x(i,j+1/2,k+1/2) ef1 ( i , j , k , 2 ) = - bpoloidal * zz / rpoloidal !B_y(i+1/2,j,k+1/2) ef1 ( i , j , k , 3 ) = bpoloidal * yy / rpoloidal !B_z(i+1/2,j+1/2,k) end do end do end do end subroutine subroutine set_solenoid_fields ( ef1 , i1 , i2 , j1 , j2 , k1 , k2 , x0 , l_sol , & bs ) real ( dp ), intent ( inout ) :: ef1 (:, :, :, :) integer , intent ( in ) :: i1 , i2 , j1 , j2 , k1 , k2 real ( dp ), intent ( in ) :: x0 , l_sol ( 3 , 2 ), bs ( 2 ) real ( dp ) :: l , d , b0 , ff integer :: i , j , k , ii , jj , kk real ( dp ) :: f1 , f2 , fd1 , fd2 , xx , yy , zz ! Enter parameters B0= B size  l_sol geometrical sizes, x0 initial point ! in ef1(3) the (Bx,By,Bz) components of two solenoinds !------------------------------------ ! First element b0 = bs ( 1 ) d = x0 + l_sol ( 1 , 1 ) l = l_sol ( 2 , 1 ) ff = l_sol ( 3 , 1 ) do k = k1 , k2 kk = k - 2 zz = b0 * loc_zg ( kk , 1 , imodz ) do j = j1 , j2 jj = j - 2 yy = b0 * loc_yg ( jj , 1 , imody ) do i = i1 , i2 ii = i - 2 xx = ( loc_xg ( ii , 1 , imodx ) - d ) / ff f1 = 1. / ( 1. + exp ( - xx )) f2 = 1. / ( 1. + exp ( l / ff - xx )) ef1 ( i , j , k , 1 ) = b0 * ( f1 - f2 ) !B_x(i,j+1/2,k+1/2) xx = ( loc_xg ( ii , 2 , imodx ) - d ) / ff f1 = 1. / ( 1. + exp ( - xx )) f2 = 1. / ( 1. + exp ( l / ff - xx )) fd1 = exp ( - xx ) * f1 * f1 / ff fd2 = exp ( l / ff - xx ) * f2 * f2 / ff ef1 ( i , j , k , 2 ) = - yy * ( fd1 - fd2 ) !B_y(i+1/2,j,k+1/2) ef1 ( i , j , k , 3 ) = - zz * ( fd1 - fd2 ) !B_z(i+1/2,j+1/2,k) end do end do end do b0 = bs ( 2 ) d = d + l + l_sol ( 1 , 2 ) l = l_sol ( 2 , 2 ) ff = l_sol ( 3 , 2 ) do k = k1 , k2 kk = k - 2 zz = b0 * loc_zg ( kk , 1 , imodz ) do j = j1 , j2 jj = j - 2 yy = b0 * loc_yg ( jj , 1 , imody ) do i = i1 , i2 ii = i - 2 xx = ( loc_xg ( ii , 1 , imodx ) - d ) / ff f1 = 1. / ( 1. + exp ( - xx )) f2 = 1. / ( 1. + exp ( l / ff - xx )) ef1 ( i , j , k , 1 ) = ef1 ( i , j , k , 1 ) + b0 * ( f1 - f2 ) !B_x(i,j+1/2,k+1/2) xx = ( loc_xg ( ii , 1 , imodx ) - d ) / ff f1 = 1. / ( 1. + exp ( - xx )) f2 = 1. / ( 1. + exp ( l / ff - xx )) fd1 = exp ( - xx ) * f1 * f1 / ff fd2 = exp ( l / ff - xx ) * f2 * f2 / ff ef1 ( i , j , k , 2 ) = ef1 ( i , j , k , 2 ) - yy * ( fd1 - fd2 ) !B_y(i+1/2,j,k+1/2) ef1 ( i , j , k , 3 ) = ef1 ( i , j , k , 3 ) - zz * ( fd1 - fd2 ) !B_z(i+1/2,j+1/2,k) end do end do end do end subroutine !=============================== end module","tags":"","loc":"sourcefile/init_grid_fields.f90.html"},{"title":"prl_fft.f90 – ALaDyn","text":"This file depends on sourcefile~~prl_fft.f90~~EfferentGraph sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~modern_fft_lib.f90 modern_fft_lib.F90 sourcefile~prl_fft.f90->sourcefile~modern_fft_lib.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~modern_fft_lib.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~prl_fft.f90~~AfferentGraph sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules prl_fft Source Code prl_fft.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module prl_fft use parallel use modern_fft_lib implicit none real ( dp ), allocatable :: fp1 (:, :, :), fp2 (:, :, :), faux1 (:), & faux2 (:) integer , allocatable :: loc_yft_ord (:), loc_zft_ord (:) contains subroutine mpi_ftw_alloc ( n1 , n2 , n2_loc , n3 , n3_loc ) integer , intent ( in ) :: n1 , n2 , n2_loc , n3 , n3_loc integer :: n1_xloc , n2_xloc , lenw !======================= ! loc_grid allready define n1_xloc = n1 / npe_yloc n2_xloc = n1 / npe_zloc lenw = n1_xloc * n2_loc * n3_loc allocate ( faux1 ( lenw ), faux2 ( lenw )) allocate ( fp1 ( n1_xloc , n2 , n3_loc )) allocate ( fp2 ( n2_xloc , n2_loc , n3 )) end subroutine !========================== subroutine mpi_yzft_ord ( ny_ft , nz_ft ) integer , intent ( in ) :: ny_ft , nz_ft integer :: ip , nh allocate ( loc_yft_ord ( 0 : npe_yloc - 1 )) allocate ( loc_zft_ord ( 0 : npe_zloc - 1 )) nh = npe_yloc / 2 - 1 if ( npe_yloc > 4 ) then do ip = 0 , nh ![ x  |   |   |   ] loc_yft_ord ( ip ) = 1 end do do ip = nh + 1 , nh + 3 loc_yft_ord ( ip ) = loc_yft_ord ( ip - 1 ) + ny_ft end do ![   | x  |   |   ]   ![   |   | x  |   ] ![   |   |   | x  ] do ip = nh + 4 , npe_yloc - 1 loc_yft_ord ( ip ) = loc_yft_ord ( nh + 3 ) end do endif loc_zft_ord ( 0 : npe_zloc - 1 ) = 1 if ( npe_zloc > 4 ) then do ip = 0 , npe_zloc / 2 - 1 ![ x  |   |   |   ] loc_zft_ord ( ip ) = 1 end do do ip = npe_zloc / 2 , npe_zloc / 2 + 2 loc_zft_ord ( ip ) = loc_zft_ord ( ip - 1 ) + nz_ft end do ![   | x  |   |   ]   ![   |   | x  |   ] ![   |   |   | x  ] do ip = npe_zloc / 2 + 3 , npe_zloc - 1 loc_zft_ord ( ip ) = loc_zft_ord ( npe_zloc / 2 + 2 ) end do endif end subroutine subroutine mpi_ftw_dalloc if ( allocated ( faux1 )) deallocate ( faux1 ) if ( allocated ( faux2 )) deallocate ( faux2 ) if ( allocated ( fp1 )) deallocate ( fp1 ) if ( allocated ( fp2 )) deallocate ( fp2 ) end subroutine !=================== subroutine ft_overset_grid ( w_s , w_r , nft1 , nft2 , nft3 ) real ( dp ), intent ( inout ) :: w_s (:, :, :) real ( dp ), intent ( out ) :: w_r (:, :, :) integer , intent ( in ) :: nft1 , nft2 , nft3 integer :: lenw , dd , nhy , nhz integer :: j1 , j2 , k1 , k2 , jl , jr , kl , kr integer :: ybd , zbd , kkr , jjr integer :: tag , ip , per , pes !=========== gather on w_r data along y-coordinate using 3 neighbors ! imody(+1,+2,+3)-> imody for imody < npe_yloc/2-1 ! imody(-1,+1,+2)-> imody for imody= npe_yloc/2-1 ! imody(-2,-1,+1)-> imody for imody= npe_yloc/2 ! imody(-3,-2,-1)-> imody for imody> npe_yloc/2+1 !====================================================== lenw = nft1 * nft2 * nft3 dd = 1 nhy = npe_yloc / 2 - 1 nhz = npe_zloc / 2 - 1 jl = min ( imody , 3 ) jr = min ( nhy + 3 - imody , 3 ) ybd = min ( 3 , npe_yloc - 1 - imody ) k1 = loc_zft_ord ( imodz ) k2 = k1 + nft3 - 1 j1 = loc_yft_ord ( imody ) j2 = j1 + nft2 - 1 w_r ( 1 : nft1 , j1 : j2 , k1 : k2 ) = w_s ( 1 : nft1 , 1 : nft2 , 1 : nft3 ) !==================== !imody=[1,nh+3] sends to ipe=imody-1,imody-2,imody-3  => ipe=[0,nh] ! !=================== !sends to next(ip)  recieves from prev(ip) if ( imody < nhy + 4 ) then if ( imody > 0 ) then do ip = 1 , jl tag = 200 + ip pes = yp_prev ( ip ) call mpi_send ( w_s ( 1 , 1 , 1 ), lenw , mpi_sd , pes , tag , comm_col ( dd ), error ) end do endif j1 = loc_yft_ord ( imody ) do ip = 1 , jr per = yp_next ( ip ) tag = 200 + ip call mpi_recv ( fp1 ( 1 , 1 , 1 ), lenw , & mpi_sd , per , tag , comm_col ( dd ), status , error ) j1 = j1 + nft2 j2 = j1 + nft2 - 1 w_r ( 1 : nft1 , j1 : j2 , k1 : k2 ) = fp1 ( 1 : nft1 , 1 : nft2 , 1 : nft3 ) end do endif !sends imody=nh to (nh+1,nh+2,nh+3) up to !imody=npe_yloc-3 to npe_yloc-2,npe_yloc-1) ybd=2 !imody=npe_yloc-2 to npe_yloc-1)            ybd=1 if ( imody > ( nhy - 1 )) then j1 = loc_yft_ord ( imody ) jjr = imody - nhy jjr = min ( jjr , 3 ) do ip = 1 , ybd tag = 200 - ip pes = yp_next ( ip ) call mpi_send ( w_s ( 1 , 1 , 1 ), lenw , mpi_sd , pes , tag , comm_col ( dd ), error ) end do j1 = loc_yft_ord ( imody ) do ip = 1 , jjr tag = 200 - ip per = yp_prev ( ip ) call mpi_recv ( fp1 ( 1 , 1 , 1 ), lenw , & mpi_sd , per , tag , comm_col ( dd ), status , error ) j1 = j1 - nft2 j2 = j1 + nft2 - 1 w_r ( 1 : nft1 , j1 : j2 , k1 : k2 ) = fp1 ( 1 : nft1 , 1 : nft2 , 1 : nft3 ) end do endif !================== end prly==================== !============= if ( prlz ) then zbd = min ( 3 , npe_zloc - 1 - imodz ) kl = min ( imodz , 3 ) kr = min ( nhz + 3 - imodz , 3 ) dd = 2 j1 = loc_yft_ord ( imody ) j2 = j1 + nft2 - 1 !================= imodz sends to  imodz-1,-2,-3 if ( imodz < nhz + 4 ) then if ( imodz > 0 ) then do ip = 1 , kl tag = 100 + ip pes = zp_prev ( ip ) call mpi_send ( w_s ( 1 , 1 , 1 ), lenw , mpi_sd , pes , tag , comm_col ( dd ), error ) end do endif k1 = loc_zft_ord ( imodz ) do ip = 1 , kr tag = 100 + ip per = zp_next ( ip ) call mpi_recv ( fp1 ( 1 , 1 , 1 ), lenw , & mpi_sd , per , tag , comm_col ( dd ), status , error ) k1 = k1 + nft3 k2 = k1 + nft3 - 1 w_r ( 1 : nft1 , j1 : j2 , k1 : k2 ) = fp1 ( 1 : nft1 , 1 : nft2 , 1 : nft3 ) end do endif !sends nhz => (nhz+1,nhz+2,nhz+3)      => npe_zloc-2 > npe_zloc-1 (zbd=1) if ( imodz > ( nhz - 1 )) then kkr = imodz - nhz kkr = min ( kkr , 3 ) do ip = 1 , zbd tag = 100 - ip pes = zp_next ( ip ) call mpi_send ( w_s ( 1 , 1 , 1 ), lenw , mpi_sd , pes , tag , comm_col ( dd ), error ) end do k1 = loc_zft_ord ( imodz ) do ip = 1 , kkr per = zp_prev ( ip ) tag = 100 - ip call mpi_recv ( fp1 ( 1 , 1 , 1 ), lenw , & mpi_sd , per , tag , comm_col ( dd ), status , error ) k1 = k1 - nft3 k2 = k1 + nft3 - 1 w_r ( 1 : nft1 , j1 : j2 , k1 : k2 ) = fp1 ( 1 : nft1 , 1 : nft2 , 1 : nft3 ) end do endif endif end subroutine subroutine swap_yx_3data ( waux , wdata , n1_loc , n2 , n3 ) integer , intent ( in ) :: n1_loc , n2 , n3 real ( dp ), intent ( in ) :: waux (:, :, :) real ( dp ), intent ( out ) :: wdata (:, :, :) integer :: pes , per , ip integer :: i1 , j1 , lenws , lenwr , tag , n2_xloc , iy , ix , iz integer :: kk !----------------- !From waux(1:n1,1:n2_xloc) to wdata(1:n1_loc,1:n2) n2_xloc = n2 / npe_xloc do iz = 1 , n3 do iy = 1 , n2_xloc j1 = iy + n2_xloc * imodx do ix = 1 , n1_loc i1 = ix + n1_loc * imodx wdata ( ix , j1 , iz ) = waux ( i1 , iy , iz ) end do end do end do if ( npe_yloc == 1 ) return lenws = n1_loc * n2_xloc * n3 lenwr = lenws if ( size ( faux1 ) < lenwr ) then deallocate ( faux1 , faux2 ) allocate ( faux1 ( lenws )) allocate ( faux2 ( lenwr )) end if do ip = 1 , npe_xloc - 1 pes = xp_next ( ip ) i1 = n1_loc * pes per = xp_prev ( ip ) tag = 80 + ip kk = 0 do iz = 1 , n3 do iy = 1 , n2_xloc do ix = 1 , n1_loc kk = kk + 1 faux1 ( kk ) = waux ( ix + i1 , iy , iz ) end do end do end do call mpi_sendrecv ( faux1 ( 1 ), lenws , mpi_sd , pes , tag , faux2 ( 1 ), & lenwr , mpi_sd , per , tag , comm_col ( 3 ), status , error ) j1 = n2_xloc * per kk = 0 do iz = 1 , n3 do iy = 1 , n2_xloc do ix = 1 , n1_loc kk = kk + 1 wdata ( ix , iy + j1 , iz ) = faux2 ( kk ) end do end do end do end do end subroutine subroutine swap_xy_3data ( wp1 , wp2 , n1_loc , n2_loc , n3_loc ) integer , intent ( in ) :: n1_loc , n2_loc , n3_loc real ( dp ), intent ( in ) :: wp1 (:, :, :) real ( dp ), intent ( out ) :: wp2 (:, :, :) integer :: pes , per , ip integer :: i1 , j1 , lenws , lenwr , tag , iy , ix , iz integer :: kk !----------------- !From wp1(1:n1_loc,1:n2) to wp2(1:n1,1:n2_loc,ic) do iz = 1 , n3_loc do iy = 1 , n2_loc j1 = iy + n2_loc * imody do ix = 1 , n1_loc i1 = ix + n1_loc * imody wp2 ( i1 , iy , iz ) = wp1 ( ix , j1 , iz ) end do end do end do if ( npe_yloc == 1 ) return lenws = n1_loc * n2_loc * n3_loc lenwr = lenws if ( size ( faux1 ) < lenwr ) then deallocate ( faux1 , faux2 ) allocate ( faux1 ( lenws )) allocate ( faux2 ( lenwr )) end if do ip = 1 , npe_yloc - 1 pes = yp_next ( ip ) j1 = n2_loc * pes per = yp_prev ( ip ) tag = 80 + ip kk = 0 do iz = 1 , n3_loc do iy = 1 , n2_loc do ix = 1 , n1_loc kk = kk + 1 faux1 ( kk ) = wp1 ( ix , iy + j1 , iz ) end do end do end do call mpi_sendrecv ( faux1 ( 1 ), lenws , mpi_sd , pes , tag , faux2 ( 1 ), & lenwr , mpi_sd , per , tag , comm_col ( 1 ), status , error ) i1 = n1_loc * per kk = 0 do iz = 1 , n3_loc do iy = 1 , n2_loc do ix = 1 , n1_loc kk = kk + 1 wp2 ( ix + i1 , iy , iz ) = faux2 ( kk ) end do end do end do end do end subroutine subroutine swap_xz_3data ( wp1 , wp2 , n1_loc , n2_loc , n3_loc ) integer , intent ( in ) :: n1_loc , n2_loc , n3_loc real ( dp ), intent ( in ) :: wp1 (:, :, :) real ( dp ), intent ( out ) :: wp2 (:, :, :) integer :: pes , per , ip integer :: i1 , lenw , tag , iy , ix , iz , iz1 integer :: kk !----------------- !From wp1(1:n1_loc,1:n3) to wp2(1:n1,1:n3_loc) do iz = 1 , n3_loc iz1 = iz + n3_loc * imodz do iy = 1 , n2_loc do ix = 1 , n1_loc i1 = ix + n1_loc * imodz wp2 ( i1 , iy , iz ) = wp1 ( ix , iy , iz1 ) end do end do end do if ( npe_zloc == 1 ) return lenw = n1_loc * n2_loc * n3_loc if ( size ( faux1 ) < lenw ) then deallocate ( faux1 , faux2 ) allocate ( faux1 ( lenw )) allocate ( faux2 ( lenw )) end if do ip = 1 , npe_zloc - 1 pes = zp_next ( ip ) iz1 = n3_loc * pes per = zp_prev ( ip ) tag = 80 + ip kk = 0 do iz = 1 , n3_loc do iy = 1 , n2_loc do ix = 1 , n1_loc kk = kk + 1 faux1 ( kk ) = wp1 ( ix , iy , iz + iz1 ) end do end do end do call mpi_sendrecv ( faux1 ( 1 ), lenw , mpi_sd , pes , tag , faux2 ( 1 ), lenw , & mpi_sd , per , tag , comm_col ( 2 ), status , error ) i1 = n1_loc * per kk = 0 do iz = 1 , n3_loc do iy = 1 , n2_loc do ix = 1 , n1_loc kk = kk + 1 wp2 ( ix + i1 , iy , iz ) = faux2 ( kk ) end do end do end do end do end subroutine subroutine swap_yx_3data_inv ( wdata , waux , n1_loc , n2 , n3 ) integer , intent ( in ) :: n1_loc , n2 , n3 real ( dp ), intent ( in ) :: wdata (:, :, :) real ( dp ), intent ( out ) :: waux (:, :, :) integer :: pes , per , ip integer :: i1 , j1 , lenws , lenwr , tag , iy , ix , iz , n2_xloc integer :: kk !----------------- !enters wdata(n1_loc,n2,n3) !From wdata(1:n1_loc,1:n2) to waux(1:n1,1:n2_xloc) !n2_xloc=n2/npe_xloc n2_xloc = n2 / npe_xloc kk = 0 do iz = 1 , n3 do iy = 1 , n2_xloc j1 = iy + n2_xloc * imodx do ix = 1 , n1_loc i1 = ix + n1_loc * imodx kk = kk + 1 waux ( i1 , iy , iz ) = wdata ( ix , j1 , iz ) end do end do end do if ( npe_xloc == 1 ) return lenwr = n1_loc * n2_xloc * n3 lenws = lenwr if ( size ( faux1 ) < lenwr ) then deallocate ( faux1 , faux2 ) allocate ( faux1 ( lenws )) allocate ( faux2 ( lenwr )) end if do ip = 1 , npe_xloc - 1 pes = xp_next ( ip ) j1 = n2_xloc * pes per = xp_prev ( ip ) tag = 40 + ip kk = 0 do iz = 1 , n3 do iy = 1 , n2_xloc do ix = 1 , n1_loc kk = kk + 1 faux1 ( kk ) = wdata ( ix , iy + j1 , iz ) end do end do end do lenws = kk lenwr = lenws call mpi_sendrecv ( faux1 ( 1 ), lenws , mpi_sd , pes , tag , faux2 ( 1 ), & lenwr , mpi_sd , per , tag , comm_col ( 3 ), status , error ) i1 = n1_loc * per kk = 0 do iz = 1 , n3 do iy = 1 , n2_xloc do ix = 1 , n1_loc kk = kk + 1 waux ( ix + i1 , iy , iz ) = faux2 ( kk ) end do end do end do end do end subroutine subroutine swap_xy_3data_inv ( wp2 , wp1 , n1_loc , n2_loc , n3_loc ) integer , intent ( in ) :: n1_loc , n2_loc , n3_loc real ( dp ), intent ( in ) :: wp2 (:, :, :) real ( dp ), intent ( out ) :: wp1 (:, :, :) integer :: pes , per , ip integer :: i1 , j1 , lenws , lenwr , tag , iy , ix , iz integer :: kk !----------------- !From (1:n1,1:n2_loc) to (1:n1_loc,1:n2) kk = 0 do iz = 1 , n3_loc do iy = 1 , n2_loc j1 = iy + n2_loc * imody do ix = 1 , n1_loc i1 = ix + n1_loc * imody kk = kk + 1 wp1 ( ix , j1 , iz ) = wp2 ( i1 , iy , iz ) end do end do end do if ( npe_yloc == 1 ) return lenwr = n1_loc * n2_loc * n3_loc lenws = lenwr if ( size ( faux1 ) < lenwr ) then deallocate ( faux1 , faux2 ) allocate ( faux1 ( lenws )) allocate ( faux2 ( lenwr )) end if do ip = 1 , npe_yloc - 1 pes = yp_next ( ip ) i1 = n1_loc * pes per = yp_prev ( ip ) tag = 40 + ip kk = 0 do iz = 1 , n3_loc do iy = 1 , n2_loc do ix = 1 , n1_loc kk = kk + 1 faux1 ( kk ) = wp2 ( ix + i1 , iy , iz ) end do end do end do lenws = kk lenwr = lenws call mpi_sendrecv ( faux1 ( 1 ), lenws , mpi_sd , pes , tag , faux2 ( 1 ), & lenwr , mpi_sd , per , tag , comm_col ( 1 ), status , error ) j1 = n2_loc * per kk = 0 do iz = 1 , n3_loc do iy = 1 , n2_loc do ix = 1 , n1_loc kk = kk + 1 wp1 ( ix , iy + j1 , iz ) = faux2 ( kk ) end do end do end do end do end subroutine !===================== subroutine swap_xz_3data_inv ( wp2 , wp1 , n1_loc , n2_loc , n3_loc ) integer , intent ( in ) :: n1_loc , n2_loc , n3_loc real ( dp ), intent ( in ) :: wp2 (:, :, :) real ( dp ), intent ( out ) :: wp1 (:, :, :) integer :: pes , per , ip integer :: i1 , lenw , tag , iy , ix , iz , iz1 integer :: kk , k1 !----------------- !From (1:n1,1:n3_loc) to (1:n1_loc,1:n3) do iz = 1 , n3_loc k1 = iz + imodz * n3_loc do iy = 1 , n2_loc do ix = 1 , n1_loc i1 = ix + n1_loc * imodz wp1 ( ix , iy , k1 ) = wp2 ( i1 , iy , iz ) end do end do end do if ( npe_zloc == 1 ) return lenw = n1_loc * n2_loc * n3_loc if ( size ( faux1 ) < lenw ) then deallocate ( faux1 , faux2 ) allocate ( faux1 ( lenw )) allocate ( faux2 ( lenw )) end if do ip = 1 , npe_zloc - 1 pes = zp_next ( ip ) i1 = n1_loc * pes per = zp_prev ( ip ) tag = 40 + ip kk = 0 do iz = 1 , n3_loc do iy = 1 , n2_loc do ix = 1 , n1_loc kk = kk + 1 faux1 ( kk ) = wp2 ( ix + i1 , iy , iz ) end do end do end do call mpi_sendrecv ( faux1 ( 1 ), lenw , mpi_sd , pes , tag , faux2 ( 1 ), lenw , & mpi_sd , per , tag , comm_col ( 2 ), status , error ) k1 = n3_loc * per kk = 0 do iz = 1 , n3_loc iz1 = iz + k1 do iy = 1 , n2_loc do ix = 1 , n1_loc kk = kk + 1 wp1 ( ix , iy , iz1 ) = faux2 ( kk ) end do end do end do end do end subroutine !==================================== subroutine pftw2d_sc ( w , n1 , n2 , n2_loc , n3 , n3_loc , is , sym ) real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n2_loc , n3 , n3_loc , is , sym integer :: n1_loc !performs a 2D FFT sin/cosine`on the (y,z) coordinates for a 3D data (x,y,z) !sym=1 for a sine transform !sym=2 for a cosine transform select case ( is ) case ( - 1 ) ! if ( n2 <= 2 ) return if ( prly ) then n1_loc = n1 / npe_yloc call swap_xy_3data_inv ( w , fp1 , n1_loc , n2_loc , n3_loc ) call ftw1d_sc ( fp1 , n1_loc , n2 , n3_loc , is , 2 , sym ) call swap_xy_3data ( fp1 , w , n1_loc , n2_loc , n3_loc ) else call ftw1d_sc ( w , n1 , n2 , n3_loc , is , 2 , sym ) end if !===================== if ( n3 <= 2 ) return if ( npe_zloc > 1 ) then n1_loc = n1 / npe_zloc call swap_xz_3data_inv ( w , fp2 , n1_loc , n2_loc , n3_loc ) call ftw1d_sc ( fp2 , n1_loc , n2_loc , n3 , is , 3 , sym ) call swap_xz_3data ( fp2 , w , n1_loc , n2_loc , n3_loc ) else call ftw1d_sc ( w , n1 , n2_loc , n3 , is , 3 , sym ) end if !======== exit w(loc) case ( 1 ) ! enters w(loc) !======================== if ( n3 > 1 ) then if ( npe_zloc > 1 ) then n1_loc = n1 / npe_zloc call swap_xz_3data_inv ( w , fp2 , n1_loc , n2_loc , n3_loc ) call ftw1d_sc ( fp2 , n1_loc , n2_loc , n3 , is , 3 , sym ) call swap_xz_3data ( fp2 , w , n1_loc , n2_loc , n3_loc ) else call ftw1d_sc ( w , n1 , n2_loc , n3 , is , 3 , sym ) end if end if !================= if ( n2 > 1 ) then if ( prly ) then n1_loc = n1 / npe_yloc call swap_xy_3data_inv ( w , fp1 , n1_loc , n2_loc , n3_loc ) call ftw1d_sc ( fp1 , n1_loc , n2 , n3_loc , is , 2 , sym ) call swap_xy_3data ( fp1 , w , n1_loc , n2_loc , n3_loc ) else call ftw1d_sc ( w , n1 , n2 , n3_loc , is , 2 , sym ) end if end if end select !=================== !exit w(loc) end subroutine !======================== subroutine pftw3d_sc ( w , n1 , n2 , n2_loc , n3 , n3_loc , is , sym ) real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n2_loc , n3 , n3_loc , is , sym select case ( is ) case ( - 1 ) call ftw1d_sc ( w , n1 , n2_loc , n3_loc , is , 1 , sym ) call pftw2d_sc ( w , n1 , n2 , n2_loc , n3 , n3_loc , is , sym ) case ( 1 ) ! enters w(loc) call pftw2d_sc ( w , n1 , n2 , n2_loc , n3 , n3_loc , is , sym ) !======================== call ftw1d_sc ( w , n1 , n2_loc , n3_loc , is , 1 , sym ) end select !=================== !exit w(loc) end subroutine !============================ subroutine pftw2d ( w , n1 , n2 , n2_loc , n3 , n3_loc , is ) real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n2_loc , n3 , n3_loc , is integer :: n1_loc , dir select case ( is ) case ( - 1 ) if ( n2 <= 2 ) return dir = 2 if ( prly ) then n1_loc = n1 / npe_yloc call swap_xy_3data_inv ( w , fp1 , n1_loc , n2_loc , n3_loc ) call ftw1d ( fp1 , n1_loc , n2 , n3_loc , is , dir ) call swap_xy_3data ( fp1 , w , n1_loc , n2_loc , n3_loc ) else call ftw1d ( w , n1 , n2 , n3_loc , is , dir ) end if !===================== if ( n3 <= 2 ) return dir = 3 if ( npe_zloc > 1 ) then n1_loc = n1 / npe_zloc call swap_xz_3data_inv ( w , fp2 , n1_loc , n2_loc , n3_loc ) call ftw1d ( fp2 , n1_loc , n2_loc , n3 , is , dir ) call swap_xz_3data ( fp2 , w , n1_loc , n2_loc , n3_loc ) else call ftw1d ( w , n1 , n2_loc , n3 , is , dir ) end if !======== exit w(loc) case ( 1 ) ! enters w(loc) !======================== if ( n3 > 1 ) then dir = 3 if ( npe_zloc > 1 ) then n1_loc = n1 / npe_zloc call swap_xz_3data_inv ( w , fp2 , n1_loc , n2_loc , n3_loc ) call ftw1d ( fp2 , n1_loc , n2_loc , n3 , is , dir ) call swap_xz_3data ( fp2 , w , n1_loc , n2_loc , n3_loc ) else call ftw1d ( w , n1 , n2_loc , n3 , is , dir ) end if end if !================= if ( n2 > 1 ) then dir = 2 if ( prly ) then n1_loc = n1 / npe_yloc call swap_xy_3data_inv ( w , fp1 , n1_loc , n2_loc , n3_loc ) call ftw1d ( fp1 , n1_loc , n2 , n3_loc , is , dir ) call swap_xy_3data ( fp1 , w , n1_loc , n2_loc , n3_loc ) else call ftw1d ( w , n1 , n2 , n3_loc , is , dir ) end if end if end select !=================== !exit w(loc) end subroutine !==================================== subroutine pftw3d ( w , n1 , n2 , n2_loc , n3 , n3_loc , is ) real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n2_loc , n3 , n3_loc , is select case ( is ) case ( - 1 ) call ftw1d ( w , n1 , n2_loc , n3_loc , is , 1 ) call pftw2d ( w , n1 , n2 , n2_loc , n3 , n3_loc , is ) case ( 1 ) call pftw2d ( w , n1 , n2 , n2_loc , n3 , n3_loc , is ) call ftw1d ( w , n1 , n2_loc , n3_loc , is , 1 ) end select !=================== !exit w(loc) end subroutine end module","tags":"","loc":"sourcefile/prl_fft.f90.html"},{"title":"legacy_fft_lib.F90 – ALaDyn","text":"This file depends on sourcefile~~legacy_fft_lib.f90~~EfferentGraph sourcefile~legacy_fft_lib.f90 legacy_fft_lib.F90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~legacy_fft_lib.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules legacy_fft_lib Source Code legacy_fft_lib.F90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module legacy_fft_lib use precision_def use , intrinsic :: iso_c_binding implicit none include 'fftw3.f03' integer ( dp ) :: plan1 , iplan1 integer ( dp ) :: plan2 , iplan2 integer ( dp ) :: plan3 , iplan3 real ( dp ), allocatable :: cw (:, :), w1 (:), w1_st (:), w2 (:), w3 (:) real ( dp ), allocatable :: cfhx (:), sfhx (:) real ( dp ), allocatable :: cfhy (:), sfhy (:) real ( dp ), allocatable :: cfhz (:), sfhz (:) contains subroutine ftw_init ( n1 , n2 , n3 , ind_ft ) integer , intent ( in ) :: n1 , n2 , n3 , ind_ft integer :: i , nm real ( dp ) :: wk !!$PRAGMA C( DFFTW_PLAN_DFT_R2C_1D, DFFTW_PLAN_DFT_C2R_1D ) select case ( ind_ft ) case ( 0 ) nm = max ( n1 , n2 ) allocate ( w1 ( n1 + 2 ), w1_st ( nm + 1 ), cfhx ( n1 ), sfhx ( n1 )) wk = acos ( - 1.0 ) / real ( n1 , dp ) do i = 1 , n1 cfhx ( i ) = cos ( real ( i - 1 , dp ) * wk ) sfhx ( i ) = sin ( real ( i - 1 , dp ) * wk ) end do w1 = 0.0 call dfftw_plan_dft_r2c_1d ( plan1 , n1 , w1 , w1 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan1 , n1 , w1 , w1 , fftw_estimate ) allocate ( w2 ( n2 + 2 ), cfhy ( n2 ), sfhy ( n2 )) w2 = 0.0 call dfftw_plan_dft_r2c_1d ( plan2 , n2 , w2 , w2 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan2 , n2 , w2 , w2 , fftw_estimate ) wk = acos ( - 1.0 ) / real ( n2 , dp ) do i = 1 , n2 cfhy ( i ) = cos ( real ( i - 1 , dp ) * wk ) sfhy ( i ) = sin ( real ( i - 1 , dp ) * wk ) end do allocate ( w3 ( n3 + 2 ), cfhz ( n3 ), sfhz ( n3 )) w3 = 0.0 call dfftw_plan_dft_r2c_1d ( plan3 , n3 , w3 , w3 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan3 , n3 , w3 , w3 , fftw_estimate ) wk = acos ( - 1.0 ) / real ( n3 , dp ) do i = 1 , n3 cfhz ( i ) = cos ( real ( i - 1 , dp ) * wk ) sfhz ( i ) = sin ( real ( i - 1 , dp ) * wk ) end do case ( 1 ) allocate ( w1 ( n1 + 2 )) w1 = 0.0 call dfftw_plan_dft_r2c_1d ( plan1 , n1 , w1 , w1 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan1 , n1 , w1 , w1 , fftw_estimate ) allocate ( w2 ( n2 + 2 )) w2 = 0.0 call dfftw_plan_dft_r2c_1d ( plan2 , n2 , w2 , w2 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan2 , n2 , w2 , w2 , fftw_estimate ) allocate ( w3 ( n3 + 2 )) w3 = 0.0 call dfftw_plan_dft_r2c_1d ( plan3 , n3 , w3 , w3 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan3 , n3 , w3 , w3 , fftw_estimate ) case ( 2 ) !for sin/cos transforms allocate ( w1 ( 2 * n1 + 2 )) w1 = 0.0 call dfftw_plan_dft_r2c_1d ( plan1 , 2 * n1 , w1 , w1 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan1 , 2 * n1 , w1 , w1 , fftw_estimate ) if ( n2 > 1 ) then allocate ( w2 ( 2 * n2 + 2 )) w2 = 0.0 call dfftw_plan_dft_r2c_1d ( plan2 , 2 * n2 , w2 , w2 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan2 , 2 * n2 , w2 , w2 , fftw_estimate ) end if allocate ( w3 ( 2 * n3 + 2 )) w3 = 0.0 call dfftw_plan_dft_r2c_1d ( plan3 , 2 * n3 , w3 , w3 , fftw_estimate ) call dfftw_plan_dft_c2r_1d ( iplan3 , 2 * n3 , w3 , w3 , fftw_estimate ) end select end subroutine !---------------------- subroutine ftw_end if ( allocated ( w1 )) deallocate ( w1 ) if ( allocated ( w1_st )) deallocate ( w1_st ) if ( allocated ( w2 )) deallocate ( w2 ) if ( allocated ( w3 )) deallocate ( w3 ) if ( allocated ( cw )) deallocate ( cw ) end subroutine subroutine ftw1d_st ( w , n1 , n2 , n3 , is , dir ) real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n3 , is , dir integer :: ii , ix , iy , iz , i1 , i2 , n1_tr , n2_tr real ( dp ) :: sc , wrr , wir , wri , wii !!$PRAGMA C( DFFTW_EXECUTE ) !============================= !staggered (k_x,k_y,k_z) !=================== select case ( dir ) case ( 1 ) if ( is < 0 ) then sc = 1. / real ( n1 , dp ) do iz = 1 , n3 do iy = 1 , n2 do ix = 1 , n1 w1 ( ix ) = cfhx ( ix ) * w ( ix , iy , iz ) end do call dfftw_execute ( plan1 ) w1_st ( 1 : n1 ) = w1 ( 1 : n1 ) do ix = 1 , n1 w1 ( ix ) = sfhx ( ix ) * w ( ix , iy , iz ) end do call dfftw_execute ( plan1 ) do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w ( i1 , iy , iz ) = sc * ( w1_st ( i1 ) + w1 ( i2 )) w ( i2 , iy , iz ) = sc * ( w1_st ( i2 ) - w1 ( i1 )) end do end do end do else n1_tr = n1 / 2 + n1 / 4 do iz = 1 , n3 do iy = 1 , n2 w ( n1_tr + 1 : n1 , iy , iz ) = 0.0 w1 ( n1 + 1 : n1 + 2 ) = 0.0 w1 ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) call dfftw_execute ( iplan1 ) w1_st ( 1 : n1 ) = w1 ( 1 : n1 ) w1 ( 1 : n1 + 2 ) = 0.0 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w1 ( i1 ) = - w ( i2 , iy , iz ) w1 ( i2 ) = w ( i1 , iy , iz ) end do call dfftw_execute ( iplan1 ) do ix = 1 , n1 w ( ix , iy , iz ) = cfhx ( ix ) * w1_st ( ix ) + sfhx ( ix ) * w1 ( ix ) end do end do end do end if case ( 2 ) allocate ( cw ( n1 , n2 )) if ( is < 0 ) then sc = 1. / real ( n2 , dp ) do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do ii = i1 , i2 do iy = 1 , n2 w2 ( iy ) = cfhy ( iy ) * w ( ii , iy , iz ) end do call dfftw_execute ( plan2 ) do iy = 1 , n2 cw ( ii , iy ) = sc * w2 ( iy ) w2 ( iy ) = sfhy ( iy ) * w ( ii , iy , iz ) end do call dfftw_execute ( plan2 ) do iy = 1 , n2 / 2 cw ( ii , 2 * iy - 1 ) = cw ( ii , 2 * iy - 1 ) + sc * w2 ( 2 * iy ) cw ( ii , 2 * iy ) = cw ( ii , 2 * iy ) - sc * w2 ( 2 * iy - 1 ) end do end do end do !=========== reordering as 2D fft do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iy = 1 , n2 / 2 wrr = cw ( i1 , 2 * iy - 1 ) wri = cw ( i1 , 2 * iy ) wir = cw ( i2 , 2 * iy - 1 ) wii = cw ( i2 , 2 * iy ) w ( i1 , iy , iz ) = wrr - wii w ( i2 , iy , iz ) = wri + wir w ( i1 , n2 + 1 - iy , iz ) = wrr + wii w ( i2 , n2 + 1 - iy , iz ) = wir - wri end do end do end do else n2_tr = n2 / 2 + n2 / 4 do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iy = 1 , n2 / 2 cw ( i1 , 2 * iy - 1 ) = 0.5 * ( w ( i1 , iy , iz ) + w ( i1 , n2 + 1 - iy , iz )) !wrr cw ( i1 , 2 * iy ) = 0.5 * ( w ( i2 , iy , iz ) - w ( i2 , n2 + 1 - iy , iz )) !wri cw ( i2 , 2 * iy - 1 ) = 0.5 * ( w ( i2 , iy , iz ) + w ( i2 , n2 + 1 - iy , iz )) !wir cw ( i2 , 2 * iy ) = 0.5 * ( w ( i1 , n2 + 1 - iy , iz ) - w ( i1 , iy , iz )) !wii end do end do do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do ii = i1 , i2 cw ( ii , n2_tr + 1 : n2 ) = 0.0 w2 ( n2 + 1 : n2 + 2 ) = 0.0 do iy = 1 , n2 w2 ( iy ) = cw ( ii , iy ) end do call dfftw_execute ( iplan2 ) do iy = 1 , n2 w ( ii , iy , iz ) = cfhy ( iy ) * w2 ( iy ) end do w2 ( n2 + 1 : n2 + 2 ) = 0.0 do iy = 1 , n2 / 2 w2 ( 2 * iy - 1 ) = - cw ( ii , 2 * iy ) w2 ( 2 * iy ) = cw ( ii , 2 * iy - 1 ) end do call dfftw_execute ( iplan2 ) do iy = 1 , n2 w ( ii , iy , iz ) = w ( ii , iy , iz ) + sfhy ( iy ) * w2 ( iy ) end do end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) case ( 3 ) allocate ( cw ( n1 , n3 )) if ( is < 0 ) then sc = 1. / real ( n3 , dp ) do iy = 1 , n2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do ii = i1 , i2 do iz = 1 , n3 w3 ( iz ) = cfhz ( iz ) * w ( ii , iy , iz ) end do call dfftw_execute ( plan3 ) do iz = 1 , n3 cw ( ii , iz ) = sc * w3 ( iz ) w3 ( iz ) = sfhz ( iz ) * w ( ii , iy , iz ) end do call dfftw_execute ( plan3 ) do iz = 1 , n3 / 2 cw ( ii , 2 * iz - 1 ) = cw ( ii , 2 * iz - 1 ) + sc * w3 ( 2 * iz ) cw ( ii , 2 * iz ) = cw ( ii , 2 * iz ) - sc * w3 ( 2 * iz - 1 ) end do end do end do !=========== reordering as 2D fft do iz = 1 , n3 / 2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 wrr = cw ( i1 , 2 * iz - 1 ) wri = cw ( i1 , 2 * iz ) wir = cw ( i2 , 2 * iz - 1 ) wii = cw ( i2 , 2 * iz ) w ( i1 , iy , iz ) = wrr - wii w ( i2 , iy , iz ) = wri + wir w ( i1 , iy , n3 + 1 - iz ) = wrr + wii w ( i2 , iy , n3 + 1 - iz ) = wir - wri end do end do end do else n2_tr = n3 / 2 + n3 / 4 ! First reorders do iy = 1 , n2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iz = 1 , n3 / 2 cw ( i1 , 2 * iz - 1 ) = 0.5 * ( w ( i1 , iy , iz ) + w ( i1 , iy , n3 + 1 - iz )) !wrr cw ( i1 , 2 * iz ) = 0.5 * ( w ( i2 , iy , iz ) - w ( i2 , iy , n3 + 1 - iz )) !wri cw ( i2 , 2 * iz - 1 ) = 0.5 * ( w ( i2 , iy , iz ) + w ( i2 , iy , n3 + 1 - iz )) !wir cw ( i2 , 2 * iz ) = 0.5 * ( w ( i1 , iy , n3 + 1 - iz ) - w ( i1 , iy , iz )) !wii end do end do do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do ii = i1 , i2 cw ( ii , n2_tr + 1 : n3 ) = 0.0 w3 ( n3 + 1 : n3 + 2 ) = 0.0 do iz = 1 , n3 w3 ( iz ) = cw ( ii , iz ) end do call dfftw_execute ( iplan3 ) do iz = 1 , n3 w ( ii , iy , iz ) = cfhz ( iz ) * w3 ( iz ) end do w3 ( n3 + 1 : n3 + 2 ) = 0.0 do iz = 1 , n3 / 2 w3 ( 2 * iz - 1 ) = - cw ( ii , 2 * iz ) w3 ( 2 * iz ) = cw ( ii , 2 * iz - 1 ) end do call dfftw_execute ( iplan3 ) do iz = 1 , n3 w ( ii , iy , iz ) = w ( ii , iy , iz ) + sfhz ( iz ) * w3 ( iz ) end do end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) end select end subroutine !==================== subroutine ftw1d ( w , n1 , n2 , n3 , is , dir ) real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n3 , is , dir integer :: ix , iy , iz , i1 , i2 , n1_tr , n2_tr real ( dp ) :: sc , wrr , wir , wri , wii !!$PRAGMA C( DFFTW_EXECUTE ) select case ( dir ) case ( 1 ) if ( is < 0 ) then sc = 1. / real ( n1 , dp ) do iz = 1 , n3 do iy = 1 , n2 w1 ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) call dfftw_execute ( plan1 ) w ( 1 : n1 , iy , iz ) = sc * w1 ( 1 : n1 ) end do end do else n1_tr = n1 do iz = 1 , n3 do iy = 1 , n2 w1 ( n1 + 1 : n1 + 2 ) = 0.0 w1 ( 1 : n1_tr ) = w ( 1 : n1_tr , iy , iz ) call dfftw_execute ( iplan1 ) w ( 1 : n1 , iy , iz ) = w1 ( 1 : n1 ) end do end do end if case ( 2 ) allocate ( cw ( n1 , n2 )) if ( is < 0 ) then sc = 1. / real ( n2 , dp ) do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iy = 1 , n2 w2 ( iy ) = w ( i1 , iy , iz ) end do call dfftw_execute ( plan2 ) do iy = 1 , n2 cw ( i1 , iy ) = sc * w2 ( iy ) w2 ( iy ) = w ( i2 , iy , iz ) end do call dfftw_execute ( plan2 ) do iy = 1 , n2 cw ( i2 , iy ) = sc * w2 ( iy ) end do end do !=========== reordering as 2D fft do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w ( i1 : i2 , 1 : n2 , iz ) = 0. w ( i1 : i2 , 1 , iz ) = cw ( i1 : i2 , 1 ) do iy = 2 , n2 / 2 wrr = cw ( i1 , 2 * iy - 1 ) wri = cw ( i1 , 2 * iy ) wir = cw ( i2 , 2 * iy - 1 ) wii = cw ( i2 , 2 * iy ) w ( i1 , iy , iz ) = wrr - wii w ( i2 , iy , iz ) = wri + wir w ( i1 , n2 + 2 - iy , iz ) = wrr + wii w ( i2 , n2 + 2 - iy , iz ) = wir - wri end do end do end do else n2_tr = n2 / 2 do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iy = 1 , n2 cw ( i1 : i2 , iy ) = w ( i1 : i2 , iy , iz ) end do w2 ( 1 : n2 + 2 ) = 0.0 w2 ( 1 ) = cw ( i1 , 1 ) do iy = 2 , n2_tr w2 ( 2 * iy - 1 ) = 0.5 * ( cw ( i1 , iy ) + cw ( i1 , n2 + 2 - iy )) w2 ( 2 * iy ) = 0.5 * ( cw ( i2 , iy ) - cw ( i2 , n2 + 2 - iy )) end do call dfftw_execute ( iplan2 ) do iy = 1 , n2 w ( i1 , iy , iz ) = w2 ( iy ) end do w2 ( 1 : n2 + 2 ) = 0.0 w2 ( 1 ) = cw ( i2 , 1 ) do iy = 2 , n2_tr w2 ( 2 * iy - 1 ) = 0.5 * ( cw ( i2 , iy ) + cw ( i2 , n2 + 2 - iy )) w2 ( 2 * iy ) = 0.5 * ( cw ( i1 , n2 + 2 - iy ) - cw ( i1 , iy )) end do call dfftw_execute ( iplan2 ) do iy = 1 , n2 w ( i2 , iy , iz ) = w2 ( iy ) end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) case ( 3 ) allocate ( cw ( n1 , n3 )) if ( is < 0 ) then sc = 1. / real ( n3 , dp ) do iy = 1 , n2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iz = 1 , n3 w3 ( iz ) = w ( i1 , iy , iz ) end do call dfftw_execute ( plan3 ) do iz = 1 , n3 cw ( i1 , iz ) = sc * w3 ( iz ) w3 ( iz ) = w ( i2 , iy , iz ) end do call dfftw_execute ( plan3 ) do iz = 1 , n3 cw ( i2 , iz ) = sc * w3 ( iz ) end do end do !=========== reordering as 2D fft do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w ( i1 : i2 , iy , 1 ) = cw ( i1 : i2 , 1 ) end do do iz = 2 , n3 / 2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 wrr = cw ( i1 , 2 * iz - 1 ) wri = cw ( i1 , 2 * iz ) wir = cw ( i2 , 2 * iz - 1 ) wii = cw ( i2 , 2 * iz ) w ( i1 , iy , iz ) = wrr - wii w ( i2 , iy , iz ) = wri + wir w ( i1 , iy , n3 + 2 - iz ) = wrr + wii w ( i2 , iy , n3 + 2 - iz ) = wir - wri end do end do end do else n2_tr = n3 / 2 do iy = 1 , n2 do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 cw ( i1 : i2 , iz ) = w ( i1 : i2 , iy , iz ) end do end do do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w3 ( 1 : n3 + 2 ) = 0.0 w3 ( 1 ) = cw ( i1 , 1 ) do iz = 2 , n2_tr w3 ( 2 * iz - 1 ) = 0.5 * ( cw ( i1 , iz ) + cw ( i1 , n3 + 2 - iz )) !wrr w3 ( 2 * iz ) = 0.5 * ( cw ( i2 , iz ) - cw ( i2 , n3 + 2 - iz )) !wri end do call dfftw_execute ( iplan3 ) do iz = 1 , n3 w ( i1 , iy , iz ) = w3 ( iz ) end do w3 ( 1 : n3 + 2 ) = 0.0 w3 ( 1 ) = cw ( i2 , 1 ) do iz = 2 , n2_tr w3 ( 2 * iz - 1 ) = 0.5 * ( cw ( i2 , iz ) + cw ( i2 , n3 + 2 - iz )) !wir w3 ( 2 * iz ) = 0.5 * ( cw ( i1 , n3 + 2 - iz ) - cw ( i1 , iz )) !wii end do call dfftw_execute ( iplan3 ) do iz = 1 , n3 w ( i2 , iy , iz ) = w3 ( iz ) end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) end select end subroutine !================ subroutine ft_kern ( w , n1 , is ) real ( dp ), intent ( inout ) :: w (:) integer , intent ( in ) :: n1 , is integer :: ix , i2 real ( dp ) :: sc integer :: ndb !!$PRAGMA C( DFFTW_EXECUTE ) ndb = 2 * n1 sc = 1. if ( is < 0 ) then w1 ( 1 : n1 ) = w ( 1 : n1 ) w1 ( n1 + 1 ) = 0.0 do ix = n1 + 2 , ndb w1 ( ix ) = - w1 ( ndb + 2 - ix ) end do call dfftw_execute ( plan1 ) do ix = 1 , n1 i2 = 2 * ix w ( ix ) = sc * w1 ( i2 ) end do else w1 ( 1 : n1 ) = w ( 1 : n1 ) do ix = n1 + 2 , ndb w1 ( ix ) = w1 ( ndb + 2 - ix ) end do w1 ( n1 + 1 ) = 0.5 * ( w1 ( n1 ) + w1 ( n1 + 2 )) call dfftw_execute ( plan1 ) do ix = 1 , n1 i2 = 2 * ix - 1 w ( ix ) = sc * w1 ( i2 ) end do end if end subroutine !========================== subroutine ftw1d_sc ( w , n1 , n2 , n3 , is , dir , sym ) real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n3 , is , dir , sym integer :: ix , iy , iz , i2 , n1_tr , n2_tr real ( dp ) :: sc integer :: ndb !!$PRAGMA C( DFFTW_EXECUTE ) select case ( dir ) case ( 1 ) ndb = 2 * n1 if ( is < 0 ) then !grid to Fourier space sc = 1. / real ( ndb , dp ) if ( sym == 1 ) then !sin do iz = 1 , n3 do iy = 1 , n2 w1 ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) w1 ( n1 + 1 ) = 0.0 do ix = n1 + 2 , ndb w1 ( ix ) = - w1 ( ndb + 2 - ix ) end do call dfftw_execute ( plan1 ) do ix = 1 , n1 i2 = 2 * ix w ( ix , iy , iz ) = sc * w1 ( i2 ) end do end do end do else do iz = 1 , n3 !cos do iy = 1 , n2 w1 ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) do ix = n1 + 2 , ndb w1 ( ix ) = w1 ( ndb + 2 - ix ) end do w1 ( n1 + 1 ) = 0.5 * ( w1 ( n1 ) + w1 ( n1 + 2 )) call dfftw_execute ( plan1 ) do ix = 1 , n1 i2 = 2 * ix - 1 w ( ix , iy , iz ) = sc * w1 ( i2 ) end do end do end do end if else n1_tr = n1 if ( sym == 1 ) then do iz = 1 , n3 do iy = 1 , n2 w1 = 0.0 do ix = 1 , n1 i2 = 2 * ix w1 ( i2 ) = w ( ix , iy , iz ) end do call dfftw_execute ( iplan1 ) w ( 1 : n1 , iy , iz ) = w1 ( 1 : n1 ) end do end do else do iz = 1 , n3 do iy = 1 , n2 w1 = 0.0 do ix = 1 , n1 i2 = 2 * ix - 1 w1 ( i2 ) = w ( ix , iy , iz ) end do call dfftw_execute ( iplan1 ) w ( 1 : n1 , iy , iz ) = w1 ( 1 : n1 ) end do end do end if end if case ( 2 ) ndb = 2 * n2 allocate ( cw ( n1 , n2 )) if ( is < 0 ) then sc = 1. / real ( ndb , dp ) do iz = 1 , n3 do ix = 1 , n1 do iy = 1 , n2 w2 ( iy ) = w ( ix , iy , iz ) end do w2 ( n2 + 1 ) = 0.0 do iy = n2 + 2 , ndb w2 ( iy ) = - w2 ( ndb + 2 - iy ) end do call dfftw_execute ( plan2 ) do iy = 1 , n2 cw ( ix , iy ) = sc * w2 ( 2 * iy ) end do end do do iy = 1 , n2 do ix = 1 , n1 w ( ix , iy , iz ) = cw ( ix , iy ) end do end do end do else n2_tr = n2 do iz = 1 , n3 do ix = 1 , n1 w2 = 0.0 do iy = 1 , n2 w2 ( 2 * iy ) = w ( ix , iy , iz ) end do call dfftw_execute ( iplan2 ) do iy = 1 , n2 cw ( ix , iy ) = w2 ( iy ) end do end do w ( 1 : n1 , 1 : n2 , iz ) = cw ( 1 : n1 , 1 : n2 ) end do end if if ( allocated ( cw )) deallocate ( cw ) case ( 3 ) ndb = 2 * n3 allocate ( cw ( n1 , n3 )) if ( is < 0 ) then sc = 1. / real ( ndb , dp ) do iy = 1 , n2 do ix = 1 , n1 do iz = 1 , n3 w3 ( iz ) = w ( ix , iy , iz ) end do w3 ( n3 + 1 ) = 0.0 do iz = n3 + 2 , ndb w3 ( iz ) = - w3 ( ndb + 2 - iz ) end do call dfftw_execute ( plan3 ) do iz = 1 , n3 cw ( ix , iz ) = sc * w3 ( 2 * iz ) end do end do do iz = 1 , n3 do ix = 1 , n1 w ( ix , iy , iz ) = cw ( ix , iz ) end do end do end do else n2_tr = n3 do iy = 1 , n2 do ix = 1 , n1 w3 = 0.0 do iz = 1 , n3 w3 ( 2 * iz ) = w ( ix , iy , iz ) end do call dfftw_execute ( iplan3 ) do iz = 1 , n3 cw ( ix , iz ) = w3 ( iz ) end do end do do iz = 1 , n3 do ix = 1 , n1 w ( ix , iy , iz ) = cw ( ix , iz ) end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) end select end subroutine end module","tags":"","loc":"sourcefile/legacy_fft_lib.f90.html"},{"title":"modern_fft_lib.F90 – ALaDyn","text":"This file depends on sourcefile~~modern_fft_lib.f90~~EfferentGraph sourcefile~modern_fft_lib.f90 modern_fft_lib.F90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~modern_fft_lib.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~modern_fft_lib.f90~~AfferentGraph sourcefile~modern_fft_lib.f90 modern_fft_lib.F90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~prl_fft.f90->sourcefile~modern_fft_lib.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules modern_fft_lib Source Code modern_fft_lib.F90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module modern_fft_lib use precision_def use , intrinsic :: iso_c_binding implicit none include 'fftw3.f03' !=== Real arrays for the r2r transforms real ( C_DOUBLE ), pointer :: in1_1d (:) !! Array for the FFT along x real ( C_DOUBLE ), pointer :: in2_1d (:) !! Array for the FFT along y real ( C_DOUBLE ), pointer :: in3_1d (:) !! Array for the FFT along z type ( C_PTR ) :: data1_sc , data2_sc , data3_sc !! C Pointers assigned to the arrays !=== Plans that define the sine and cosine transform === type ( C_PTR ) :: plan1_s , plan1_c !! Plans of the sine and cosine FFT along x type ( C_PTR ) :: plan2_s , plan2_c !! Plans of the sine and cosine FFT along y type ( C_PTR ) :: plan3_s , plan3_c !! Plans of the sine and cosine FFT along z !=== Old plans kept for backward compatibility !=== (with the old_ftw1d_sc) type ( C_PTR ) :: plan1 , iplan1 type ( C_PTR ) :: plan2 , iplan2 type ( C_PTR ) :: plan3 , iplan3 !=== Old variables real ( C_DOUBLE ), pointer :: w1_re (:), w2_re (:), w3_re (:) complex ( C_DOUBLE_COMPLEX ), pointer :: w1_cplx (:), w2_cplx (:), w3_cplx (:) type ( C_PTR ) :: data1 , data2 , data3 real ( dp ), allocatable :: cw (:, :), w1_st (:) real ( dp ), allocatable :: cfhx (:), sfhx (:) real ( dp ), allocatable :: cfhy (:), sfhy (:) real ( dp ), allocatable :: cfhz (:), sfhz (:) contains pure function logical_dimension ( kind_flag , N ) result ( log_dim ) !! Returns the logical dimension given the FFT Kind. !! To be generalized for other applications than !! FFTW_RODFT00 and FFTW_REDFT00 integer ( C_INTPTR_T ), intent ( in ) :: kind_flag integer , intent ( in ) :: N integer :: log_dim select case ( kind_flag ) case ( FFTW_RODFT00 ) log_dim = 2 * ( N + 1 ) case ( FFTW_REDFT00 ) log_dim = 2 * ( N - 1 ) case default log_dim = 2 * N end select end function pure function determine_kind ( sym_index ) result ( kind ) !! Converts the integer flag `sym` into the proper FFT kind integer , intent ( in ) :: sym_index integer ( C_INTPTR_T ) :: kind select case ( sym_index ) case ( 1 ) kind = FFTW_RODFT00 case ( 2 ) kind = FFTW_REDFT00 end select end function subroutine ftw_init ( n1 , n2 , n3 , ind_ft ) !! Initialization of all the FFT variables and plans integer , intent ( in ) :: n1 , n2 , n3 , ind_ft integer :: i , nm real ( dp ) :: wk !!$PRAGMA C( DFFTW_PLAN_DFT_R2C_1D, DFFTW_PLAN_DFT_C2R_1D ) select case ( ind_ft ) case ( 0 ) nm = max ( n1 , n2 ) data1 = fftw_alloc_complex ( int ( n1 / 2 + 1 , C_SIZE_T )) call c_f_pointer ( data1 , w1_re , [ 2 * ( n1 / 2 + 1 )]) call c_f_pointer ( data1 , w1_cplx , [ n1 / 2 + 1 ]) allocate ( w1_st ( nm + 1 ), cfhx ( n1 ), sfhx ( n1 )) wk = acos ( - 1.0 ) / real ( n1 , dp ) do i = 1 , n1 cfhx ( i ) = cos ( real ( i - 1 , dp ) * wk ) sfhx ( i ) = sin ( real ( i - 1 , dp ) * wk ) end do w1_re (:) = 0.0 w1_cplx (:) = 0.0 plan1 = fftw_plan_dft_r2c_1d ( n1 , w1_re , w1_cplx , fftw_estimate ) iplan1 = fftw_plan_dft_c2r_1d ( n1 , w1_cplx , w1_re , fftw_estimate ) data2 = fftw_alloc_complex ( int ( n2 / 2 + 1 , C_SIZE_T )) call c_f_pointer ( data2 , w2_re , [ 2 * ( n2 / 2 + 1 )]) call c_f_pointer ( data2 , w2_cplx , [ n2 / 2 + 1 ]) allocate ( cfhy ( n2 ), sfhy ( n2 )) wk = acos ( - 1.0 ) / real ( n2 , dp ) do i = 1 , n2 cfhy ( i ) = cos ( real ( i - 1 , dp ) * wk ) sfhy ( i ) = sin ( real ( i - 1 , dp ) * wk ) end do w2_re (:) = 0.0 w2_cplx (:) = 0.0 plan2 = fftw_plan_dft_r2c_1d ( n2 , w2_re , w2_cplx , fftw_estimate ) iplan2 = fftw_plan_dft_c2r_1d ( n2 , w2_cplx , w2_re , fftw_estimate ) data3 = fftw_alloc_complex ( int ( n3 / 2 + 1 , C_SIZE_T )) call c_f_pointer ( data3 , w3_re , [ 2 * ( n3 / 2 + 1 )]) call c_f_pointer ( data3 , w3_cplx , [ n3 / 2 + 1 ]) allocate ( cfhz ( n3 ), sfhz ( n3 )) wk = acos ( - 1.0 ) / real ( n3 , dp ) do i = 1 , n3 cfhz ( i ) = cos ( real ( i - 1 , dp ) * wk ) sfhz ( i ) = sin ( real ( i - 1 , dp ) * wk ) end do w3_re (:) = 0.0 w3_cplx (:) = 0.0 plan3 = fftw_plan_dft_r2c_1d ( n3 , w3_re , w3_cplx , fftw_estimate ) iplan3 = fftw_plan_dft_c2r_1d ( n3 , w3_cplx , w3_re , fftw_estimate ) case ( 1 ) data1 = fftw_alloc_complex ( int ( n1 / 2 + 1 , C_SIZE_T )) call c_f_pointer ( data1 , w1_re , [ 2 * ( n1 / 2 + 1 )]) call c_f_pointer ( data1 , w1_cplx , [ n1 / 2 + 1 ]) w1_re (:) = 0.0 w1_cplx (:) = 0.0 plan1 = fftw_plan_dft_r2c_1d ( n1 , w1_re , w1_cplx , fftw_estimate ) iplan1 = fftw_plan_dft_c2r_1d ( n1 , w1_cplx , w1_re , fftw_estimate ) data2 = fftw_alloc_complex ( int ( n2 / 2 + 1 , C_SIZE_T )) call c_f_pointer ( data2 , w2_re , [ 2 * ( n2 / 2 + 1 )]) call c_f_pointer ( data2 , w2_cplx , [ n2 / 2 + 1 ]) w2_re (:) = 0.0 w2_cplx (:) = 0.0 plan2 = fftw_plan_dft_r2c_1d ( n2 , w2_re , w2_cplx , fftw_estimate ) iplan2 = fftw_plan_dft_c2r_1d ( n2 , w2_cplx , w2_re , fftw_estimate ) data3 = fftw_alloc_complex ( int ( n3 / 2 + 1 , C_SIZE_T )) call c_f_pointer ( data3 , w3_re , [ 2 * ( n3 / 2 + 1 )]) call c_f_pointer ( data3 , w3_cplx , [ n3 / 2 + 1 ]) w3_re (:) = 0.0 w3_cplx (:) = 0.0 plan3 = fftw_plan_dft_r2c_1d ( n3 , w3_re , w3_cplx , fftw_estimate ) iplan3 = fftw_plan_dft_c2r_1d ( n3 , w3_cplx , w3_re , fftw_estimate ) case ( 2 ) !for sin/cos transforms data1 = fftw_alloc_complex ( int ( n1 + 1 , C_SIZE_T )) call c_f_pointer ( data1 , w1_re , [ 2 * ( n1 + 1 )]) call c_f_pointer ( data1 , w1_cplx , [ n1 + 1 ]) w1_re (:) = 0.0 w1_cplx (:) = 0.0 plan1 = fftw_plan_dft_r2c_1d ( 2 * n1 , w1_re , w1_cplx , fftw_estimate ) iplan1 = fftw_plan_dft_c2r_1d ( 2 * n1 , w1_cplx , w1_re , fftw_estimate ) data2 = fftw_alloc_complex ( int ( n2 + 1 , C_SIZE_T )) call c_f_pointer ( data2 , w2_re , [ 2 * ( n2 + 1 )]) call c_f_pointer ( data2 , w2_cplx , [ n2 + 1 ]) w2_re (:) = 0.0 w2_cplx (:) = 0.0 plan2 = fftw_plan_dft_r2c_1d ( 2 * n2 , w2_re , w2_cplx , fftw_estimate ) iplan2 = fftw_plan_dft_c2r_1d ( 2 * n2 , w2_cplx , w2_re , fftw_estimate ) data3 = fftw_alloc_complex ( int ( n3 + 1 , C_SIZE_T )) call c_f_pointer ( data3 , w3_re , [ 2 * ( n3 + 1 )]) call c_f_pointer ( data3 , w3_cplx , [ n3 + 1 ]) w3_re (:) = 0.0 w3_cplx (:) = 0.0 plan3 = fftw_plan_dft_r2c_1d ( 2 * n3 , w3_re , w3_cplx , fftw_estimate ) iplan3 = fftw_plan_dft_c2r_1d ( 2 * n3 , w3_cplx , w3_re , fftw_estimate ) !===== New version based on r2r transforms ===== data1_sc = fftw_alloc_complex ( int ( n1 , C_SIZE_T )) call c_f_pointer ( data1_sc , in1_1d , [ n1 ]) in1_1d (:) = zero_dp plan1_s = fftw_plan_r2r_1d ( n1 , in1_1d , in1_1d , FFTW_RODFT00 , & FFTW_ESTIMATE ) plan1_c = fftw_plan_r2r_1d ( n1 , in1_1d , in1_1d , FFTW_REDFT00 , & FFTW_ESTIMATE ) data2_sc = fftw_alloc_complex ( int ( n2 , C_SIZE_T )) call c_f_pointer ( data2_sc , in2_1d , [ n2 ]) in2_1d (:) = zero_dp plan2_s = fftw_plan_r2r_1d ( n2 , in2_1d , in2_1d , FFTW_RODFT00 , & FFTW_ESTIMATE ) plan2_c = fftw_plan_r2r_1d ( n2 , in2_1d , in2_1d , FFTW_REDFT00 , & FFTW_ESTIMATE ) data3_sc = fftw_alloc_complex ( int ( n3 , C_SIZE_T )) call c_f_pointer ( data3_sc , in3_1d , [ n3 ]) in3_1d (:) = zero_dp plan3_s = fftw_plan_r2r_1d ( n3 , in3_1d , in3_1d , FFTW_RODFT00 , & FFTW_ESTIMATE ) plan3_c = fftw_plan_r2r_1d ( n3 , in3_1d , in3_1d , FFTW_RODFT00 , & FFTW_ESTIMATE ) end select end subroutine subroutine ftw_end !! Routines that ends all the FFTs. It destroys the existing plans !! and deallocates the arrays. if ( allocated ( w1_st )) deallocate ( w1_st ) if ( allocated ( cw )) deallocate ( cw ) call fftw_destroy_plan ( plan1 ) call fftw_destroy_plan ( plan2 ) call fftw_destroy_plan ( plan3 ) call fftw_destroy_plan ( iplan1 ) call fftw_destroy_plan ( iplan2 ) call fftw_destroy_plan ( iplan3 ) call fftw_destroy_plan ( plan1_s ) call fftw_destroy_plan ( plan2_s ) call fftw_destroy_plan ( plan3_s ) call fftw_destroy_plan ( plan1_c ) call fftw_destroy_plan ( plan2_c ) call fftw_destroy_plan ( plan3_c ) call fftw_free ( data1 ) call fftw_free ( data2 ) call fftw_free ( data3 ) call fftw_free ( data1_sc ) call fftw_free ( data2_sc ) call fftw_free ( data3_sc ) end subroutine subroutine ftw1d_st ( w , n1 , n2 , n3 , is , dir ) real ( dp ), intent ( inout ) :: w (:, :, :) !! WARNING: Not used in the code, need to be checked integer , intent ( in ) :: n1 , n2 , n3 , is , dir integer :: ii , ix , iy , iz , i1 , i2 , n1_tr , n2_tr real ( dp ) :: sc , wrr , wir , wri , wii !!$PRAGMA C( DFFTW_EXECUTE ) !============================= !staggered (k_x,k_y,k_z) !=================== select case ( dir ) case ( 1 ) if ( is < 0 ) then sc = 1. / real ( n1 , dp ) do iz = 1 , n3 do iy = 1 , n2 do ix = 1 , n1 w1_re ( ix ) = cfhx ( ix ) * w ( ix , iy , iz ) end do call fftw_execute_dft_r2c ( plan1 , w1_re , w1_cplx ) w1_st ( 1 : n1 ) = w1_cplx ( 1 : n1 ) do ix = 1 , n1 w1_re ( ix ) = sfhx ( ix ) * w ( ix , iy , iz ) end do call fftw_execute_dft_r2c ( plan1 , w1_re , w1_cplx ) do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w ( i1 , iy , iz ) = sc * ( w1_st ( i1 ) + w1_cplx ( i2 )) w ( i2 , iy , iz ) = sc * ( w1_st ( i2 ) - w1_cplx ( i1 )) end do end do end do else n1_tr = n1 / 2 + n1 / 4 do iz = 1 , n3 do iy = 1 , n2 w ( n1_tr + 1 : n1 , iy , iz ) = 0.0 w1_cplx ( n1 + 1 : n1 + 2 ) = 0.0 w1_cplx ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) call fftw_execute_dft_c2r ( iplan1 , w1_cplx , w1_re ) w1_st ( 1 : n1 ) = w1_re ( 1 : n1 ) w1_cplx ( 1 : n1 + 2 ) = 0.0 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w1_cplx ( i1 ) = - w ( i2 , iy , iz ) w1_cplx ( i2 ) = w ( i1 , iy , iz ) end do call fftw_execute_dft_c2r ( iplan1 , w1_cplx , w1_re ) do ix = 1 , n1 w ( ix , iy , iz ) = cfhx ( ix ) * w1_st ( ix ) + sfhx ( ix ) * w1_re ( ix ) end do end do end do end if case ( 2 ) allocate ( cw ( n1 , n2 )) if ( is < 0 ) then sc = 1. / real ( n2 , dp ) do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do ii = i1 , i2 do iy = 1 , n2 w2_re ( iy ) = cfhy ( iy ) * w ( ii , iy , iz ) end do call fftw_execute_dft_r2c ( plan2 , w2_re , w2_cplx ) do iy = 1 , n2 cw ( ii , iy ) = sc * w2_cplx ( iy ) w2_re ( iy ) = sfhy ( iy ) * w ( ii , iy , iz ) end do call fftw_execute_dft_r2c ( plan2 , w2_re , w2_cplx ) do iy = 1 , n2 / 2 cw ( ii , 2 * iy - 1 ) = cw ( ii , 2 * iy - 1 ) + sc * w2_cplx ( 2 * iy ) cw ( ii , 2 * iy ) = cw ( ii , 2 * iy ) - sc * w2_cplx ( 2 * iy - 1 ) end do end do end do !=========== reordering as 2D fft do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iy = 1 , n2 / 2 wrr = cw ( i1 , 2 * iy - 1 ) wri = cw ( i1 , 2 * iy ) wir = cw ( i2 , 2 * iy - 1 ) wii = cw ( i2 , 2 * iy ) w ( i1 , iy , iz ) = wrr - wii w ( i2 , iy , iz ) = wri + wir w ( i1 , n2 + 1 - iy , iz ) = wrr + wii w ( i2 , n2 + 1 - iy , iz ) = wir - wri end do end do end do else n2_tr = n2 / 2 + n2 / 4 do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iy = 1 , n2 / 2 cw ( i1 , 2 * iy - 1 ) = 0.5 * ( w ( i1 , iy , iz ) + w ( i1 , n2 + 1 - iy , iz )) !wrr cw ( i1 , 2 * iy ) = 0.5 * ( w ( i2 , iy , iz ) - w ( i2 , n2 + 1 - iy , iz )) !wri cw ( i2 , 2 * iy - 1 ) = 0.5 * ( w ( i2 , iy , iz ) + w ( i2 , n2 + 1 - iy , iz )) !wir cw ( i2 , 2 * iy ) = 0.5 * ( w ( i1 , n2 + 1 - iy , iz ) - w ( i1 , iy , iz )) !wii end do end do do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do ii = i1 , i2 cw ( ii , n2_tr + 1 : n2 ) = 0.0 w2_cplx ( n2 + 1 : n2 + 2 ) = 0.0 do iy = 1 , n2 w2_cplx ( iy ) = cw ( ii , iy ) end do call fftw_execute_dft_c2r ( iplan2 , w2_cplx , w2_re ) do iy = 1 , n2 w ( ii , iy , iz ) = cfhy ( iy ) * w2_re ( iy ) end do w2_cplx ( n2 + 1 : n2 + 2 ) = 0.0 do iy = 1 , n2 / 2 w2_cplx ( 2 * iy - 1 ) = - cw ( ii , 2 * iy ) w2_cplx ( 2 * iy ) = cw ( ii , 2 * iy - 1 ) end do call fftw_execute_dft_c2r ( iplan2 , w2_cplx , w2_re ) do iy = 1 , n2 w ( ii , iy , iz ) = w ( ii , iy , iz ) + sfhy ( iy ) * w2_re ( iy ) end do end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) case ( 3 ) allocate ( cw ( n1 , n3 )) if ( is < 0 ) then sc = 1. / real ( n3 , dp ) do iy = 1 , n2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do ii = i1 , i2 do iz = 1 , n3 w3_re ( iz ) = cfhz ( iz ) * w ( ii , iy , iz ) end do call fftw_execute_dft_r2c ( plan3 , w3_re , w3_cplx ) do iz = 1 , n3 cw ( ii , iz ) = sc * w3_cplx ( iz ) w3_re ( iz ) = sfhz ( iz ) * w ( ii , iy , iz ) end do call fftw_execute_dft_r2c ( plan3 , w3_re , w3_cplx ) do iz = 1 , n3 / 2 cw ( ii , 2 * iz - 1 ) = cw ( ii , 2 * iz - 1 ) + sc * w3_cplx ( 2 * iz ) cw ( ii , 2 * iz ) = cw ( ii , 2 * iz ) - sc * w3_cplx ( 2 * iz - 1 ) end do end do end do !=========== reordering as 2D fft do iz = 1 , n3 / 2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 wrr = cw ( i1 , 2 * iz - 1 ) wri = cw ( i1 , 2 * iz ) wir = cw ( i2 , 2 * iz - 1 ) wii = cw ( i2 , 2 * iz ) w ( i1 , iy , iz ) = wrr - wii w ( i2 , iy , iz ) = wri + wir w ( i1 , iy , n3 + 1 - iz ) = wrr + wii w ( i2 , iy , n3 + 1 - iz ) = wir - wri end do end do end do else n2_tr = n3 / 2 + n3 / 4 ! First reorders do iy = 1 , n2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iz = 1 , n3 / 2 cw ( i1 , 2 * iz - 1 ) = 0.5 * ( w ( i1 , iy , iz ) + w ( i1 , iy , n3 + 1 - iz )) !wrr cw ( i1 , 2 * iz ) = 0.5 * ( w ( i2 , iy , iz ) - w ( i2 , iy , n3 + 1 - iz )) !wri cw ( i2 , 2 * iz - 1 ) = 0.5 * ( w ( i2 , iy , iz ) + w ( i2 , iy , n3 + 1 - iz )) !wir cw ( i2 , 2 * iz ) = 0.5 * ( w ( i1 , iy , n3 + 1 - iz ) - w ( i1 , iy , iz )) !wii end do end do do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do ii = i1 , i2 cw ( ii , n2_tr + 1 : n3 ) = 0.0 w3_cplx ( n3 + 1 : n3 + 2 ) = 0.0 do iz = 1 , n3 w3_cplx ( iz ) = cw ( ii , iz ) end do call fftw_execute_dft_c2r ( iplan3 , w3_cplx , w3_re ) do iz = 1 , n3 w ( ii , iy , iz ) = cfhz ( iz ) * w3_re ( iz ) end do w3_cplx ( n3 + 1 : n3 + 2 ) = 0.0 do iz = 1 , n3 / 2 w3_cplx ( 2 * iz - 1 ) = - cw ( ii , 2 * iz ) w3_cplx ( 2 * iz ) = cw ( ii , 2 * iz - 1 ) end do call fftw_execute_dft_c2r ( iplan3 , w3_cplx , w3_re ) do iz = 1 , n3 w ( ii , iy , iz ) = w ( ii , iy , iz ) + sfhz ( iz ) * w3_re ( iz ) end do end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) end select end subroutine !==================== subroutine ftw1d ( w , n1 , n2 , n3 , is , dir ) !! WARNING: Still to be checked real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n3 , is , dir integer :: ix , iy , iz , n1_tr , n2_tr integer :: i1 , i2 , j1 , j2 real ( dp ) :: sc , wrr , wir , wri , wii !!$PRAGMA C( DFFTW_EXECUTE ) select case ( dir ) case ( 1 ) if ( is < 0 ) then sc = 1. / real ( n1 , dp ) do iz = 1 , n3 do iy = 1 , n2 w1_re ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) call fftw_execute_dft_r2c ( plan1 , w1_re , w1_cplx ) do ix = 1 , n1 / 2 i2 = 2 * ix i1 = 2 * ix - 1 w ( i1 , iy , iz ) = sc * real ( w1_cplx ( ix )) w ( i2 , iy , iz ) = sc * imag ( w1_cplx ( ix )) end do end do end do else n1_tr = n1 do iz = 1 , n3 do iy = 1 , n2 w1_re ( n1 + 1 : n1 + 2 ) = 0.0 do ix = 1 , n1_tr / 2 i2 = 2 * ix i1 = 2 * ix - 1 w1_cplx ( ix ) = cmplx ( w ( i1 , iy , iz ), w ( i2 , iy , iz )) end do call fftw_execute_dft_c2r ( iplan1 , w1_cplx , w1_re ) w ( 1 : n1 , iy , iz ) = w1_re ( 1 : n1 ) end do end do end if case ( 2 ) allocate ( cw ( n1 , n2 )) if ( is < 0 ) then sc = 1. / real ( n2 , dp ) do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w2_re ( 1 : n2 ) = w ( i1 , 1 : n2 , iz ) call fftw_execute_dft_r2c ( plan2 , w2_re , w2_cplx ) do iy = 1 , n2 / 2 j2 = 2 * iy j1 = 2 * iy - 1 cw ( i1 , j1 ) = sc * real ( w2_cplx ( iy )) cw ( i1 , j2 ) = sc * imag ( w2_cplx ( iy )) end do w2_re ( 1 : n2 ) = w ( i2 , 1 : n2 , iz ) call fftw_execute_dft_r2c ( plan2 , w2_re , w2_cplx ) do iy = 1 , n2 cw ( i2 , iy ) = sc * w2_cplx ( iy ) end do end do !=========== reordering as 2D fft do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w ( i1 : i2 , 1 : n2 , iz ) = 0. w ( i1 : i2 , 1 , iz ) = cw ( i1 : i2 , 1 ) do iy = 2 , n2 / 2 wrr = cw ( i1 , 2 * iy - 1 ) wri = cw ( i1 , 2 * iy ) wir = cw ( i2 , 2 * iy - 1 ) wii = cw ( i2 , 2 * iy ) w ( i1 , iy , iz ) = wrr - wii w ( i2 , iy , iz ) = wri + wir w ( i1 , n2 + 2 - iy , iz ) = wrr + wii w ( i2 , n2 + 2 - iy , iz ) = wir - wri end do end do end do else n2_tr = n2 / 2 do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iy = 1 , n2 cw ( i1 : i2 , iy ) = w ( i1 : i2 , iy , iz ) end do w2_re ( 1 : n2 + 2 ) = 0.0 w2_cplx ( 1 ) = cw ( i1 , 1 ) do iy = 2 , n2_tr w2_cplx ( 2 * iy - 1 ) = 0.5 * ( cw ( i1 , iy ) + cw ( i1 , n2 + 2 - iy )) w2_cplx ( 2 * iy ) = 0.5 * ( cw ( i2 , iy ) - cw ( i2 , n2 + 2 - iy )) end do call fftw_execute_dft_c2r ( iplan2 , w2_cplx , w2_re ) do iy = 1 , n2 w ( i1 , iy , iz ) = w2_re ( iy ) end do w2_re ( 1 : n2 + 2 ) = 0.0 w2_cplx ( 1 ) = cw ( i2 , 1 ) do iy = 2 , n2_tr w2_cplx ( 2 * iy - 1 ) = 0.5 * ( cw ( i2 , iy ) + cw ( i2 , n2 + 2 - iy )) w2_cplx ( 2 * iy ) = 0.5 * ( cw ( i1 , n2 + 2 - iy ) - cw ( i1 , iy )) end do call fftw_execute_dft_c2r ( iplan2 , w2_cplx , w2_re ) do iy = 1 , n2 w ( i2 , iy , iz ) = w2_re ( iy ) end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) case ( 3 ) allocate ( cw ( n1 , n3 )) if ( is < 0 ) then sc = 1. / real ( n3 , dp ) do iy = 1 , n2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 do iz = 1 , n3 w3_re ( iz ) = w ( i1 , iy , iz ) end do call fftw_execute_dft_r2c ( plan3 , w3_re , w3_cplx ) do iz = 1 , n3 cw ( i1 , iz ) = sc * w3_cplx ( iz ) w3_re ( iz ) = w ( i2 , iy , iz ) end do call fftw_execute_dft_r2c ( plan3 , w3_re , w3_cplx ) do iz = 1 , n3 cw ( i2 , iz ) = sc * w3_cplx ( iz ) end do end do !=========== reordering as 2D fft do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w ( i1 : i2 , iy , 1 ) = cw ( i1 : i2 , 1 ) end do do iz = 2 , n3 / 2 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 wrr = cw ( i1 , 2 * iz - 1 ) wri = cw ( i1 , 2 * iz ) wir = cw ( i2 , 2 * iz - 1 ) wii = cw ( i2 , 2 * iz ) w ( i1 , iy , iz ) = wrr - wii w ( i2 , iy , iz ) = wri + wir w ( i1 , iy , n3 + 2 - iz ) = wrr + wii w ( i2 , iy , n3 + 2 - iz ) = wir - wri end do end do end do else n2_tr = n3 / 2 do iy = 1 , n2 do iz = 1 , n3 do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 cw ( i1 : i2 , iz ) = w ( i1 : i2 , iy , iz ) end do end do do ix = 1 , n1 / 2 i2 = 2 * ix i1 = i2 - 1 w3_re ( 1 : n3 + 2 ) = 0.0 w3_cplx ( 1 ) = cw ( i1 , 1 ) do iz = 2 , n2_tr w3_cplx ( 2 * iz - 1 ) = 0.5 * ( cw ( i1 , iz ) + cw ( i1 , n3 + 2 - iz )) !wrr w3_cplx ( 2 * iz ) = 0.5 * ( cw ( i2 , iz ) - cw ( i2 , n3 + 2 - iz )) !wri end do call fftw_execute_dft_c2r ( iplan3 , w3_cplx , w3_re ) do iz = 1 , n3 w ( i1 , iy , iz ) = w3_re ( iz ) end do w3_re ( 1 : n3 + 2 ) = 0.0 w3_cplx ( 1 ) = cw ( i2 , 1 ) do iz = 2 , n2_tr w3_cplx ( 2 * iz - 1 ) = 0.5 * ( cw ( i2 , iz ) + cw ( i2 , n3 + 2 - iz )) !wir w3_cplx ( 2 * iz ) = 0.5 * ( cw ( i1 , n3 + 2 - iz ) - cw ( i1 , iz )) !wii end do call fftw_execute_dft_c2r ( iplan3 , w3_cplx , w3_re ) do iz = 1 , n3 w ( i2 , iy , iz ) = w3_re ( iz ) end do end do end do end if if ( allocated ( cw )) deallocate ( cw ) end select end subroutine !========================== subroutine ftw1d_sc ( w , n1 , n2 , n3 , is , dir , sym ) real ( dp ), intent ( inout ) :: w (:, :, :) integer , intent ( in ) :: n1 , n2 , n3 , is , dir , sym integer :: ix , iy , iz real ( dp ) :: sc integer :: ndb integer ( C_INTPTR_T ) :: kind !!$PRAGMA C( DFFTW_EXECUTE ) kind = determine_kind ( sym ) select case ( dir ) case ( 1 ) in1_1d (:) = zero_dp ndb = logical_dimension ( kind , n1 + 1 ) if ( is < 0 ) then !grid to Fourier space sc = 1. / real ( ndb , dp ) if ( kind == FFTW_RODFT00 ) then !sin do iz = 1 , n3 do iy = 1 , n2 in1_1d ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) call fftw_execute_r2r ( plan1_s , in1_1d , in1_1d ) w ( 1 : n1 , iy , iz ) = sc * in1_1d ( 1 : n1 ) end do end do else if ( kind == FFTW_REDFT00 ) then do iz = 1 , n3 !cos do iy = 1 , n2 in1_1d ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) call fftw_execute_r2r ( plan1_c , in1_1d , in1_1d ) w ( 1 : n1 , iy , iz ) = sc * in1_1d ( 1 : n1 ) end do end do end if else if ( kind == FFTW_RODFT00 ) then do iz = 1 , n3 do iy = 1 , n2 in1_1d (:) = zero_dp in1_1d ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) call fftw_execute_r2r ( plan1_s , in1_1d , in1_1d ) w ( 1 : n1 , iy , iz ) = in1_1d ( 1 : n1 ) end do end do else if ( kind == FFTW_REDFT00 ) then do iz = 1 , n3 do iy = 1 , n2 in1_1d (:) = zero_dp in1_1d ( 1 : n1 ) = w ( 1 : n1 , iy , iz ) call fftw_execute_r2r ( plan1_c , in1_1d , in1_1d ) w ( 1 : n1 , iy , iz ) = in1_1d ( 1 : n1 ) end do end do end if end if case ( 2 ) in2_1d (:) = zero_dp ndb = logical_dimension ( kind , n2 ) if ( is < 0 ) then sc = 1. / real ( ndb , dp ) do iz = 1 , n3 do ix = 1 , n1 in2_1d ( 1 : n2 ) = w ( ix , 1 : n2 , iz ) call fftw_execute_r2r ( plan2_s , in2_1d , in2_1d ) w ( ix , 1 : n2 , iz ) = sc * in2_1d ( 1 : n2 ) end do end do else do iz = 1 , n3 do ix = 1 , n1 in2_1d (:) = zero_dp in2_1d ( 1 : n2 ) = w ( ix , 1 : n2 , iz ) call fftw_execute_r2r ( plan2_s , in2_1d , in2_1d ) w ( ix , 1 : n2 , iz ) = in2_1d ( 1 : n2 ) end do end do end if case ( 3 ) in3_1d (:) = zero_dp ndb = logical_dimension ( kind , n3 ) if ( is < 0 ) then sc = 1. / real ( ndb , dp ) do iy = 1 , n2 do ix = 1 , n1 in3_1d (:) = zero_dp in3_1d ( 1 : n3 ) = w ( ix , iy , 1 : n3 ) call fftw_execute_r2r ( plan3_s , in3_1d , in3_1d ) w ( ix , iy , 1 : n3 ) = sc * in3_1d ( 1 : n3 ) end do end do else do iy = 1 , n2 do ix = 1 , n1 in3_1d ( 1 : n3 ) = w ( ix , iy , 1 : n3 ) call fftw_execute_r2r ( plan3_s , in3_1d , in3_1d ) w ( ix , iy , 1 : n3 ) = in3_1d ( 1 : n3 ) end do end do end if end select end subroutine end module","tags":"","loc":"sourcefile/modern_fft_lib.f90.html"},{"title":"grid_part_lib.f90 – ALaDyn","text":"This file depends on sourcefile~~grid_part_lib.f90~~EfferentGraph sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid_part_lib.f90~~AfferentGraph sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid_part_lib Source Code grid_part_lib.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module grid_part_lib use common_param use grid_param use stretched_grid implicit none real ( dp ), parameter :: half = 0.5 , thr = 0.75 , two_third = 2. / 3. , & one_sixth = 1. / 6. real ( sp ), parameter :: shx = 3. , shy = 3. , shz = 3. integer ( kind = 2 ) :: err_ind contains !    Templates of spl=1,2,3 order shape functions for grid-particle  connection !================================================== ! Computes subroutine set_int_pshape ( spl , xx , ax , ind ) integer , intent ( in ) :: spl real ( dp ), intent ( in ) :: xx real ( dp ), intent ( out ) :: ax ( 0 : 3 ) integer , intent ( out ) :: ind real ( dp ) :: sx , sx2 , sx3 !To integer grid points ax ( 0 : 3 ) = 0.0 select case ( spl ) case ( 1 ) ind = int ( xx ) ax ( 1 ) = xx - real ( ind , dp ) ax ( 0 ) = 1. - ax ( 1 ) case ( 2 ) ind = int ( xx + 0.5 ) sx = xx - real ( ind , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) case ( 3 ) ind = int ( xx ) sx = xx - real ( ind , dp ) sx2 = sx * sx sx3 = sx2 * sx ax ( 1 ) = two_third - sx2 + 0.5 * sx3 ax ( 2 ) = one_sixth + 0.5 * ( sx + sx2 - sx3 ) ax ( 3 ) = one_sixth * sx3 ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) - ax ( 3 ) end select end subroutine !======================== subroutine set_hint_pshape ( spl , xx , ax , ind ) integer , intent ( in ) :: spl real ( dp ), intent ( in ) :: xx integer , intent ( out ) :: ind real ( dp ), intent ( out ) :: ax ( 0 : 3 ) real ( dp ) :: sx , sx2 , sx3 !To half-integer grid points ax ( 0 : 3 ) = 0.0 select case ( spl ) case ( 1 ) sx = xx + 0.5 ind = int ( sx ) ax ( 1 ) = sx - real ( ind , dp ) ax ( 0 ) = 1. - ax ( 1 ) case ( 2 ) ind = int ( xx ) sx = xx - 0.5 - real ( ind , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) case ( 3 ) ind = int ( xx + 0.5 ) sx = xx - real ( ind , dp ) sx2 = sx * sx sx3 = sx2 * sx ax ( 1 ) = two_third - sx2 + 0.5 * sx3 ax ( 2 ) = one_sixth + 0.5 * ( sx + sx2 - sx3 ) ax ( 3 ) = one_sixth * sx3 ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) - ax ( 3 ) ! to (i-1/2,i+1/2,i+3/2,i+5/2) half-int end select end subroutine !======================= !=========================================== !     Computes particle density charge on grid integer points !============================================== !DIR$ ATTRIBUTES INLINE :: ql_interpolate,qq_interpolate !==================== subroutine qlh_2d_spline ( xp , ax , axh , ay , ayh , ix , ihx , iy , ihy ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 2 ), axh ( 0 : 1 ), ay ( 0 : 2 ), ayh ( 0 : 1 ) integer , intent ( inout ) :: ix , ihx , iy , ihy real ( dp ) :: xx , sx , sx2 !====================== xx = shx + xp ( 1 ) ix = int ( xx + 0.5 ) sx = xx - real ( ix , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) axh ( 1 ) = sx + 0.5 axh ( 0 ) = 1. - axh ( 1 ) xx = shy + xp ( 2 ) iy = int ( xx + 0.5 ) sx = xx - real ( iy , dp ) sx2 = sx * sx ay ( 1 ) = 0.75 - sx2 ay ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ay ( 0 ) = 1. - ay ( 1 ) - ay ( 2 ) ayh ( 1 ) = sx + 0.5 ayh ( 0 ) = 1. - ayh ( 1 ) ix = ix - 1 ihx = ix iy = iy - 1 ihy = iy end subroutine !==================== subroutine qqh_1d_spline ( xp , ax , axh , ix , ihx ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 2 ), axh ( 0 : 2 ) integer , intent ( inout ) :: ix , ihx real ( dp ) :: xx , sx , sx2 !====================== xx = shx + xp ( 1 ) ix = int ( xx + 0.5 ) sx = xx - real ( ix , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) ihx = int ( xx ) sx = xx - real ( ihx , dp ) sx2 = sx * sx axh ( 1 ) = 0.75 - sx2 axh ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) axh ( 0 ) = 1. - axh ( 1 ) - axh ( 2 ) ix = ix - 1 ihx = ihx - 1 end subroutine !======================= subroutine qqh_2d_spline ( xp , ax , axh , ay , ayh , ix , ihx , iy , ihy ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 2 ), axh ( 0 : 2 ), ay ( 0 : 2 ), ayh ( 0 : 2 ) integer , intent ( inout ) :: ix , ihx , iy , ihy real ( dp ) :: xx , sx , sx2 !====================== xx = shx + xp ( 1 ) ix = int ( xx + 0.5 ) sx = xx - real ( ix , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) ihx = int ( xx ) sx = xx - real ( ihx , dp ) - 0.5 sx2 = sx * sx axh ( 1 ) = 0.75 - sx2 axh ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) axh ( 0 ) = 1. - axh ( 1 ) - axh ( 2 ) xx = shy + xp ( 2 ) iy = int ( xx + 0.5 ) sx = xx - real ( iy , dp ) sx2 = sx * sx ay ( 1 ) = 0.75 - sx2 ay ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ay ( 0 ) = 1. - ay ( 1 ) - ay ( 2 ) ihy = int ( xx ) sx = xx - real ( ihy , dp ) - 0.5 sx2 = sx * sx ayh ( 1 ) = 0.75 - sx2 ayh ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ayh ( 0 ) = 1. - ayh ( 1 ) - ayh ( 2 ) ix = ix - 1 ihx = ihx - 1 iy = iy - 1 ihy = ihy - 1 end subroutine !======================================= subroutine qlh_3d_spline ( xp , ax , axh , ay , ayh , az , azh , ix , ihx , iy , & ihy , iz , ihz ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 2 ), axh ( 0 : 1 ), ay ( 0 : 2 ), ayh ( 0 : 1 ), & az ( 0 : 2 ), azh ( 0 : 1 ) integer , intent ( inout ) :: ix , ihx , iy , ihy , iz , ihz real ( dp ) :: xx , sx , sx2 !====================== xx = shx + xp ( 1 ) ix = int ( xx + 0.5 ) sx = xx - real ( ix , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) axh ( 1 ) = sx + 0.5 axh ( 0 ) = 1. - axh ( 1 ) xx = shy + xp ( 2 ) iy = int ( xx + 0.5 ) sx = xx - real ( iy , dp ) sx2 = sx * sx ay ( 1 ) = 0.75 - sx2 ay ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ay ( 0 ) = 1. - ay ( 1 ) - ay ( 2 ) ayh ( 1 ) = sx + 0.5 ayh ( 0 ) = 1. - ayh ( 1 ) xx = shz + xp ( 3 ) iz = int ( xx + 0.5 ) sx = xx - real ( iz , dp ) sx2 = sx * sx az ( 1 ) = 0.75 - sx2 az ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) az ( 0 ) = 1. - az ( 1 ) - az ( 2 ) azh ( 1 ) = sx + 0.5 azh ( 0 ) = 1. - azh ( 1 ) ix = ix - 1 ihx = ix iy = iy - 1 ihy = iy iz = iz - 1 ihz = iz end subroutine !================================= subroutine qqh_3d_spline ( xp , ax , axh , ay , ayh , az , azh , ix , ihx , iy , & ihy , iz , ihz ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 2 ), axh ( 0 : 2 ), ay ( 0 : 2 ), ayh ( 0 : 2 ), & az ( 0 : 2 ), azh ( 0 : 2 ) integer , intent ( inout ) :: ix , ihx , iy , ihy , iz , ihz real ( dp ) :: xx , sx , sx2 xx = shx + xp ( 1 ) ix = int ( xx + 0.5 ) sx = xx - real ( ix , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) ihx = int ( xx ) sx = xx - real ( ihx , dp ) - 0.5 sx2 = sx * sx axh ( 1 ) = 0.75 - sx2 axh ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) axh ( 0 ) = 1. - axh ( 1 ) - axh ( 2 ) xx = shy + xp ( 2 ) iy = int ( xx + 0.5 ) sx = xx - real ( iy , dp ) sx2 = sx * sx ay ( 1 ) = 0.75 - sx2 ay ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ay ( 0 ) = 1. - ay ( 1 ) - ay ( 2 ) ihy = int ( xx ) sx = xx - real ( ihy , dp ) - 0.5 sx2 = sx * sx ayh ( 1 ) = 0.75 - sx2 ayh ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ayh ( 0 ) = 1. - ayh ( 1 ) - ayh ( 2 ) xx = shz + xp ( 3 ) iz = int ( xx + 0.5 ) sx = xx - real ( iz , dp ) sx2 = sx * sx az ( 1 ) = 0.75 - sx2 az ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) az ( 0 ) = 1. - az ( 1 ) - az ( 2 ) ihz = int ( xx ) sx = xx - real ( ihz , dp ) - 0.5 sx2 = sx * sx azh ( 1 ) = 0.75 - sx2 azh ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) azh ( 0 ) = 1. - azh ( 1 ) - azh ( 2 ) ix = ix - 1 ihx = ihx - 1 iy = iy - 1 ihy = ihy - 1 iz = iz - 1 ihz = ihz - 1 end subroutine subroutine qden_1d_wgh ( xp , ax , ix ) real ( dp ), intent ( in ) :: xp (:) integer , intent ( inout ) :: ix real ( dp ), intent ( inout ) :: ax ( 0 : 2 ) real ( dp ) :: xx , sx , sx2 !====================== xx = shx + xp ( 1 ) ix = int ( xx + 0.5 ) sx = xx - real ( ix , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) end subroutine subroutine qden_2d_wgh ( xp , ax , ay , ix , iy ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 2 ), ay ( 0 : 2 ) integer , intent ( inout ) :: ix , iy real ( dp ) :: xx , sx , sx2 !====================== xx = shx + xp ( 1 ) ix = int ( xx + 0.5 ) sx = xx - real ( ix , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) xx = shy + xp ( 2 ) iy = int ( xx + 0.5 ) sx = xx - real ( iy , dp ) sx2 = sx * sx ay ( 1 ) = 0.75 - sx2 ay ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ay ( 0 ) = 1. - ay ( 1 ) - ay ( 2 ) end subroutine !====================== subroutine cden_2d_wgh ( xp , ax , ay , ix , iy ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 3 ), ay ( 0 : 3 ) integer , intent ( inout ) :: ix , iy real ( dp ) :: xx , sx , sx2 , sx3 !====================== !cubic spline to integer index xx = shy + xp ( 1 ) ix = int ( xx ) sx = xx - real ( ix , dp ) sx2 = sx * sx sx3 = sx2 * sx ax ( 1 ) = two_third - sx2 + 0.5 * sx3 ax ( 2 ) = one_sixth + 0.5 * ( sx + sx2 - sx3 ) ax ( 3 ) = one_sixth * sx3 ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) - ax ( 3 ) xx = shy + xp ( 2 ) iy = int ( xx ) sx = xx - real ( iy , dp ) sx2 = sx * sx sx3 = sx2 * sx ay ( 1 ) = two_third - sx2 + 0.5 * sx3 ay ( 2 ) = one_sixth + 0.5 * ( sx + sx2 - sx3 ) ay ( 3 ) = one_sixth * sx3 ay ( 0 ) = 1. - ay ( 1 ) - ay ( 2 ) - ay ( 3 ) end subroutine !========================== subroutine qden_3d_wgh ( xp , ax , ay , az , ix , iy , iz ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 2 ), ay ( 0 : 2 ), az ( 0 : 2 ) integer , intent ( inout ) :: ix , iy , iz real ( dp ) :: xx , sx , sx2 !====================== xx = shx + xp ( 1 ) ix = int ( xx + 0.5 ) sx = xx - real ( ix , dp ) sx2 = sx * sx ax ( 1 ) = 0.75 - sx2 ax ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) xx = shy + xp ( 2 ) iy = int ( xx + 0.5 ) sx = xx - real ( iy , dp ) sx2 = sx * sx ay ( 1 ) = 0.75 - sx2 ay ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) ay ( 0 ) = 1. - ay ( 1 ) - ay ( 2 ) xx = shz + xp ( 3 ) iz = int ( xx + 0.5 ) sx = xx - real ( iz , dp ) sx2 = sx * sx az ( 1 ) = 0.75 - sx2 az ( 2 ) = 0.5 * ( 0.25 + sx2 + sx ) az ( 0 ) = 1. - az ( 1 ) - az ( 2 ) end subroutine !--------------------- subroutine cden_3d_wgh ( xp , ax , ay , az , ix , iy , iz ) real ( dp ), intent ( in ) :: xp (:) real ( dp ), intent ( inout ) :: ax ( 0 : 3 ), ay ( 0 : 3 ), az ( 0 : 3 ) integer , intent ( inout ) :: ix , iy , iz real ( dp ) :: xx , sx , sx2 , sx3 !====================== !cubic spline to integer index xx = shx + xp ( 1 ) ix = int ( xx ) sx = xx - real ( ix , dp ) sx2 = sx * sx sx3 = sx2 * sx ax ( 1 ) = two_third - sx2 + 0.5 * sx3 ax ( 2 ) = one_sixth + 0.5 * ( sx + sx2 - sx3 ) ax ( 3 ) = one_sixth * sx3 ax ( 0 ) = 1. - ax ( 1 ) - ax ( 2 ) - ax ( 3 ) xx = shy + xp ( 2 ) iy = int ( xx ) sx = xx - real ( iy , dp ) sx2 = sx * sx sx3 = sx2 * sx ay ( 1 ) = two_third - sx2 + 0.5 * sx3 ay ( 2 ) = one_sixth + 0.5 * ( sx + sx2 - sx3 ) ay ( 3 ) = one_sixth * sx3 ay ( 0 ) = 1. - ay ( 1 ) - ay ( 2 ) - ay ( 3 ) xx = shz + xp ( 3 ) iz = int ( xx ) sx = xx - real ( iz , dp ) sx2 = sx * sx az ( 1 ) = two_third - sx2 + 0.5 * sx3 az ( 2 ) = one_sixth + 0.5 * ( sx + sx2 - sx3 ) az ( 3 ) = one_sixth * sx3 az ( 0 ) = 1. - az ( 1 ) - az ( 2 ) - az ( 3 ) end subroutine !==================================== !DIR$ ATTRIBUTES INLINE :: ql_interpolate subroutine set_local_2d_positions ( pt_loc , n1 , np ) real ( dp ), intent ( inout ) :: pt_loc (:, :) integer , intent ( in ) :: n1 , np integer :: n !========================= do n = 1 , np pt_loc ( n , 1 ) = dx_inv * ( pt_loc ( n , 1 ) - xmn ) end do if ( n1 == 0 ) return if ( n_str == 0 ) then do n = 1 , np pt_loc ( n , 2 ) = dy_inv * ( pt_loc ( n , 2 ) - ymn ) end do else call map2dy_part_sind ( np , 2 , pt_loc ) end if if ( n1 == 1 ) return do n = 1 , np pt_loc ( n , 3 ) = dx_inv * ( pt_loc ( n , 3 ) - xmn ) end do if ( n_str == 0 ) then do n = 1 , np pt_loc ( n , 4 ) = dy_inv * ( pt_loc ( n , 4 ) - ymn ) end do else call map2dy_part_sind ( np , 4 , pt_loc ) end if end subroutine !====================== subroutine set_local_3d_positions ( pt_loc , n1 , np ) real ( dp ), intent ( inout ) :: pt_loc (:, :) integer , intent ( in ) :: n1 , np integer :: n !========================= do n = 1 , np pt_loc ( n , 1 ) = dx_inv * ( pt_loc ( n , 1 ) - xmn ) end do if ( n_str == 0 ) then do n = 1 , np pt_loc ( n , 2 ) = dy_inv * ( pt_loc ( n , 2 ) - ymn ) pt_loc ( n , 3 ) = dz_inv * ( pt_loc ( n , 3 ) - zmn ) end do else call map3d_part_sind ( pt_loc , np , 2 , 3 ) end if if ( n1 == 1 ) return do n = 1 , np pt_loc ( n , 4 ) = dx_inv * ( pt_loc ( n , 4 ) - xmn ) end do if ( n_str == 0 ) then do n = 1 , np pt_loc ( n , 5 ) = dy_inv * ( pt_loc ( n , 5 ) - ymn ) pt_loc ( n , 6 ) = dz_inv * ( pt_loc ( n , 6 ) - zmn ) end do else call map3d_part_sind ( pt_loc , np , 5 , 6 ) end if end subroutine end module","tags":"","loc":"sourcefile/grid_part_lib.f90.html"},{"title":"grid_part_util.f90 – ALaDyn","text":"This file depends on sourcefile~~grid_part_util.f90~~EfferentGraph sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~grid_part_util.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~grid_part_util.f90->sourcefile~pstruct_data.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid_part_util.f90~~AfferentGraph sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid_part_util Source Code grid_part_util.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module grid_part_util use pstruct_data use fstruct_data use grid_part_lib implicit none contains !DIR$ ATTRIBUTES INLINE :: set_local_positions !================================ subroutine set_part_gamma ( pt_loc , np , nc ) real ( dp ), intent ( inout ) :: pt_loc (:, :) integer , intent ( in ) :: np , nc integer :: n real ( dp ) :: gam2 select case ( nc ) case ( 2 ) do n = 1 , np gam2 = pt_loc ( n , 3 ) * pt_loc ( n , 3 ) + pt_loc ( n , 4 ) * pt_loc ( n , 4 ) pt_loc ( n , 4 ) = sqrt ( 1. + gam2 ) end do case ( 3 ) do n = 1 , np gam2 = pt_loc ( n , 4 ) * pt_loc ( n , 4 ) + pt_loc ( n , 5 ) * pt_loc ( n , 5 ) + & pt_loc ( n , 6 ) * pt_loc ( n , 6 ) pt_loc ( n , 4 ) = sqrt ( 1. + gam2 ) end do end select !============exit gamma end subroutine !=================== subroutine set_part_velocities ( pt_loc , np , njc ) real ( dp ), intent ( inout ) :: pt_loc (:, :) integer , intent ( in ) :: np , njc integer :: n real ( dp ) :: gam2 , gam_inv select case ( njc ) case ( 2 ) do n = 1 , np gam2 = pt_loc ( n , 3 ) * pt_loc ( n , 3 ) + pt_loc ( n , 4 ) * pt_loc ( n , 4 ) gam_inv = 1. / sqrt ( 1. + gam2 ) pt_loc ( n , 3 ) = gam_inv * pt_loc ( n , 3 ) pt_loc ( n , 4 ) = gam_inv * pt_loc ( n , 4 ) end do case ( 3 ) do n = 1 , np gam2 = pt_loc ( n , 4 ) * pt_loc ( n , 4 ) + pt_loc ( n , 5 ) * pt_loc ( n , 5 ) + & pt_loc ( n , 6 ) * pt_loc ( n , 6 ) gam_inv = 1. / sqrt ( 1. + gam2 ) pt_loc ( n , 4 ) = gam_inv * pt_loc ( n , 4 ) pt_loc ( n , 5 ) = gam_inv * pt_loc ( n , 5 ) pt_loc ( n , 6 ) = gam_inv * pt_loc ( n , 6 ) end do end select end subroutine !========================== subroutine set_ho_grid_charge ( sp_loc , pt , den , np , ic ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) real ( dp ), intent ( inout ) :: den (:, :, :, :) integer , intent ( in ) :: np , ic real ( dp ) :: xp ( 3 ), dvol , ax0 ( 0 : 3 ), ay0 ( 0 : 3 ), az0 ( 0 : 3 ) integer :: i , j , k , i1 , j1 , k1 , i2 , j2 , k2 , n , ch , spl real ( sp ) :: wght !====================== ! Computes charge density on a grid using cubic spline on uniform grid !================================= ax0 ( 0 : 3 ) = zero_dp ay0 ( 0 : 3 ) = zero_dp az0 ( 0 : 3 ) = zero_dp spl = 3 select case ( ndim ) case ( 2 ) ch = 5 do n = 1 , np pt ( n , 1 ) = dx_inv * ( sp_loc % part ( n , 1 ) - xmn ) pt ( n , 2 ) = dy_inv * ( sp_loc % part ( n , 2 ) - ymn ) wgh_cmp = sp_loc % part ( n , 5 ) pt ( n , 4 ) = charge * wgh end do !========================== do n = 1 , np wght = real ( pt ( n , 4 ), sp ) xp ( 1 : 2 ) = pt ( n , 1 : 2 ) call cden_2d_wgh ( xp , ax0 , ay0 , i , j ) ax0 ( 0 : 3 ) = wght * ax0 ( 0 : 3 ) i = i - 1 j = j - 1 do j1 = 0 , 3 j2 = j + j1 do i1 = 0 , 3 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) den ( i2 , j2 , 1 , ic ) = den ( i2 , j2 , 1 , ic ) + dvol end do end do end do case ( 3 ) ch = 7 do n = 1 , np pt ( n , 1 ) = dx_inv * ( sp_loc % part ( n , 1 ) - xmn ) pt ( n , 2 ) = dy_inv * ( sp_loc % part ( n , 2 ) - ymn ) pt ( n , 3 ) = dz_inv * ( sp_loc % part ( n , 3 ) - zmn ) wgh_cmp = sp_loc % part ( n , 7 ) wght = charge * wgh pt ( n , 4 ) = wght end do do n = 1 , np xp ( 1 : 3 ) = pt ( n , 1 : 3 ) wght = real ( pt ( n , 4 ), sp ) call cden_3d_wgh ( xp , ax0 , ay0 , az0 , i , j , k ) ax0 ( 0 : 3 ) = wght * ax0 ( 0 : 3 ) i = i - 1 j = j - 1 k = k - 1 do k1 = 0 , spl k2 = k + k1 do j1 = 0 , spl j2 = j + j1 dvol = az0 ( k1 ) * ay0 ( j1 ) do i1 = 0 , spl i2 = i + i1 den ( i2 , j2 , k2 , ic ) = den ( i2 , j2 , k2 , ic ) + ax0 ( i1 ) * dvol end do end do end do end do ! charge density on den(i,j,k,ic) end select end subroutine !========================== subroutine set_charge_on_ftgrid ( sp_loc , pt , den , np , ic ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) real ( dp ), intent ( inout ) :: den (:, :, :, :) integer , intent ( in ) :: np , ic real ( dp ) :: xp ( 3 ), dvol , ax0 ( 0 : 2 ), ay0 ( 0 : 2 ), az0 ( 0 : 2 ) integer :: i , j , k , i1 , j1 , k1 , i2 , j2 , k2 , n , ch , spl real ( sp ) :: wght real ( dp ) :: x1_loc , y1_loc , z1_loc !====================== ! Computes charge density on the superposed uniform ftgrid !================================= ax0 ( 0 : 2 ) = zero_dp ay0 ( 0 : 2 ) = zero_dp az0 ( 0 : 2 ) = zero_dp spl = 2 x1_loc = xmn y1_loc = yft_min z1_loc = zft_min select case ( ndim ) case ( 2 ) ch = 5 do n = 1 , np pt ( n , 1 ) = dx_inv * ( sp_loc % part ( n , 1 ) - x1_loc ) pt ( n , 2 ) = dy_inv * ( sp_loc % part ( n , 2 ) - y1_loc ) wgh_cmp = sp_loc % part ( n , 5 ) pt ( n , 4 ) = charge * wgh end do !========================== do n = 1 , np wght = real ( pt ( n , 4 ), sp ) xp ( 1 : 2 ) = pt ( n , 1 : 2 ) call qden_2d_wgh ( xp , ax0 , ay0 , i , j ) ax0 ( 0 : 2 ) = wght * ax0 ( 0 : 2 ) i = i - 1 j = j - 1 do j1 = 0 , 2 j2 = j + j1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) den ( i2 , j2 , 1 , ic ) = den ( i2 , j2 , 1 , ic ) + dvol end do end do end do case ( 3 ) ch = 7 do n = 1 , np pt ( n , 1 ) = dx_inv * ( sp_loc % part ( n , 1 ) - x1_loc ) pt ( n , 2 ) = dy_inv * ( sp_loc % part ( n , 2 ) - y1_loc ) pt ( n , 3 ) = dz_inv * ( sp_loc % part ( n , 3 ) - z1_loc ) wgh_cmp = sp_loc % part ( n , 7 ) wght = charge * wgh pt ( n , 4 ) = wght end do do n = 1 , np xp ( 1 : 3 ) = pt ( n , 1 : 3 ) wght = real ( pt ( n , 4 ), sp ) call qden_3d_wgh ( xp , ax0 , ay0 , az0 , i , j , k ) ax0 ( 0 : 2 ) = wght * ax0 ( 0 : 2 ) i = i - 1 j = j - 1 k = k - 1 do k1 = 0 , spl k2 = k + k1 do j1 = 0 , spl j2 = j + j1 dvol = az0 ( k1 ) * ay0 ( j1 ) do i1 = 0 , spl i2 = i + i1 den ( i2 , j2 , k2 , ic ) = den ( i2 , j2 , k2 , ic ) + ax0 ( i1 ) * dvol end do end do end do end do ! charge density on den(ic) end select end subroutine !================================= subroutine set_grid_charge ( sp_loc , pt , den , np , ic ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) real ( dp ), intent ( inout ) :: den (:, :, :, :) integer , intent ( in ) :: np , ic real ( dp ) :: xp ( 3 ), dvol , ax0 ( 0 : 2 ), ay0 ( 0 : 2 ), az0 ( 0 : 2 ) integer :: i , j , k , i1 , j1 , k1 , i2 , j2 , k2 , n , ch , spl real ( sp ) :: wght !====================== ! Computes charge density of species ic on a grid !================================= ax0 ( 0 : 2 ) = zero_dp ay0 ( 0 : 2 ) = zero_dp az0 ( 0 : 2 ) = zero_dp spl = 2 select case ( ndim ) case ( 1 ) j2 = 1 do n = 1 , np pt ( n , 1 ) = sp_loc % part ( n , 1 ) end do call set_local_2d_positions ( pt , 0 , np ) do n = 1 , np xp ( 1 ) = pt ( n , 1 ) wgh_cmp = sp_loc % part ( n , 5 ) wght = charge * wgh call qden_1d_wgh ( xp , ax0 , i ) ax0 ( 0 : 2 ) = wght * ax0 ( 0 : 2 ) i = i - 1 do i1 = 0 , 2 i2 = i + i1 den ( i2 , j2 , 1 , ic ) = den ( i2 , j2 , 1 , ic ) + ax0 ( i1 ) end do end do case ( 2 ) ch = 5 do n = 1 , np pt ( n , 1 : 2 ) = sp_loc % part ( n , 1 : 2 ) wgh_cmp = sp_loc % part ( n , 5 ) pt ( n , 4 ) = charge * wgh end do call set_local_2d_positions ( pt , 1 , np ) !========================== do n = 1 , np wght = real ( pt ( n , 4 ), sp ) xp ( 1 : 2 ) = pt ( n , 1 : 2 ) call qden_2d_wgh ( xp , ax0 , ay0 , i , j ) ax0 ( 0 : 2 ) = wght * ax0 ( 0 : 2 ) i = i - 1 j = j - 1 do j1 = 0 , 2 j2 = j + j1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) den ( i2 , j2 , 1 , ic ) = den ( i2 , j2 , 1 , ic ) + dvol end do end do end do case ( 3 ) ch = 7 do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) pt ( n , 4 ) = sp_loc % part ( n , ch ) wgh_cmp = pt ( n , 4 ) wght = charge * wgh pt ( n , 4 ) = wght end do call set_local_3d_positions ( pt , 1 , np ) do n = 1 , np xp ( 1 : 3 ) = pt ( n , 1 : 3 ) wght = real ( pt ( n , 4 ), sp ) call qden_3d_wgh ( xp , ax0 , ay0 , az0 , i , j , k ) ax0 ( 0 : 2 ) = wght * ax0 ( 0 : 2 ) i = i - 1 j = j - 1 k = k - 1 do k1 = 0 , spl k2 = k + k1 do j1 = 0 , spl j2 = j + j1 dvol = az0 ( k1 ) * ay0 ( j1 ) do i1 = 0 , spl i2 = i + i1 den ( i2 , j2 , k2 , ic ) = den ( i2 , j2 , k2 , ic ) + ax0 ( i1 ) * dvol end do end do end do end do ! charge density on den(ic) end select end subroutine !========================== !========================== subroutine set_grid_env_den_energy ( sp_loc , pt , eden , np , icp ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) real ( dp ), intent ( inout ) :: eden (:, :, :, :) integer , intent ( in ) :: np , icp real ( dp ) :: dvol , gam2 , gam_p real ( dp ) :: ax0 ( 0 : 2 ), ay0 ( 0 : 2 ), az0 ( 0 : 2 ), xp ( 3 ), pp ( 3 ) integer :: i , j , k , i1 , j1 , k1 , i2 , j2 , k2 , n , ch , spl !====================== !   Computes eden(grid,1)= n/n_0 and eden(grid,2)=<gam-1}n>/n_0 !================================================ ax0 ( 0 : 2 ) = 0.0 ay0 ( 0 : 2 ) = 0.0 az0 ( 0 : 2 ) = 0.0 spl = 2 if ( np < 1 ) return select case ( ndim ) case ( 1 ) ch = 5 j2 = 1 do n = 1 , np pt ( n , 1 : ch ) = sp_loc % part ( n , 1 : ch ) end do call set_local_2d_positions ( pt , 0 , np ) do n = 1 , np xp ( 1 ) = pt ( n , 1 ) pp ( 1 : 2 ) = sp_loc % part ( n , 3 : 4 ) gam2 = pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) wgh_cmp = sp_loc % part ( n , ch ) call qden_1d_wgh ( xp , ax0 , i ) i = i - 1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) gam2 = gam2 + dvol * eden ( i2 , j2 , 1 , icp ) end do gam_p = sqrt ( 1. + gam2 ) ax0 ( 0 : 2 ) = wgh * ax0 ( 0 : 2 ) do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) eden ( i2 , j2 , 1 , 1 ) = eden ( i2 , j2 , 1 , 1 ) + dvol * charge eden ( i2 , j2 , 1 , 2 ) = eden ( i2 , j2 , 1 , 2 ) + ( gam_p - 1 ) * dvol end do end do case ( 2 ) ch = size ( sp_loc % part , 2 ) do n = 1 , np pt ( n , 1 : ch ) = sp_loc % part ( n , 1 : ch ) end do call set_local_2d_positions ( pt , 1 , np ) if ( curr_ndim == 2 ) then do n = 1 , np pp ( 1 : 2 ) = sp_loc % part ( n , 3 : 4 ) gam2 = pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) xp ( 1 : 2 ) = pt ( n , 1 : 2 ) wgh_cmp = pt ( n , ch ) call qden_2d_wgh ( xp , ax0 , ay0 , i , j ) i = i - 1 j = j - 1 do j1 = 0 , 2 j2 = j + j1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) gam2 = gam2 + dvol * eden ( i2 , j2 , 1 , icp ) end do end do gam_p = sqrt ( 1. + gam2 ) ax0 ( 0 : 2 ) = wgh * ax0 ( 0 : 2 ) !weights are inside do j1 = 0 , 2 j2 = j + j1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) eden ( i2 , j2 , 1 , 1 ) = eden ( i2 , j2 , 1 , 1 ) + dvol * charge eden ( i2 , j2 , 1 , 2 ) = eden ( i2 , j2 , 1 , 2 ) + ( gam_p - 1. ) * dvol end do end do end do end if if ( curr_ndim == 3 ) then do n = 1 , np pp ( 1 : 3 ) = sp_loc % part ( n , 4 : 6 ) gam2 = pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) + pp ( 3 ) * pp ( 3 ) xp ( 1 : 2 ) = pt ( n , 1 : 2 ) wgh_cmp = pt ( n , ch ) call qden_2d_wgh ( xp , ax0 , ay0 , i , j ) i = i - 1 j = j - 1 !============ adds iparticle assigned [A&#94;2/2]_p contribution do j1 = 0 , 2 j2 = j + j1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) gam2 = gam2 + dvol * eden ( i2 , j2 , 1 , icp ) end do end do gam_p = sqrt ( 1. + gam2 ) ax0 ( 0 : 2 ) = wgh * ax0 ( 0 : 2 ) do j1 = 0 , 2 j2 = j + j1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) eden ( i2 , j2 , 1 , 1 ) = eden ( i2 , j2 , 1 , 1 ) + dvol * charge eden ( i2 , j2 , 1 , 2 ) = eden ( i2 , j2 , 1 , 2 ) + ( gam_p - 1. ) * dvol end do end do end do end if case ( 3 ) ch = 7 do n = 1 , np pt ( n , 1 : ch ) = sp_loc % part ( n , 1 : ch ) end do call set_local_3d_positions ( pt , 1 , np ) do n = 1 , np pp ( 1 : 3 ) = sp_loc % part ( n , 4 : 6 ) gam2 = pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) + pp ( 3 ) * pp ( 3 ) xp ( 1 : 3 ) = pt ( n , 1 : 3 ) wgh_cmp = pt ( n , ch ) call qden_3d_wgh ( xp , ax0 , ay0 , az0 , i , j , k ) i = i - 1 j = j - 1 k = k - 1 do k1 = 0 , spl k2 = k + k1 do j1 = 0 , spl j2 = j + j1 dvol = az0 ( k1 ) * ay0 ( j1 ) do i1 = 0 , spl i2 = i + i1 gam2 = gam2 + ax0 ( i1 ) * dvol * eden ( i2 , j2 , k2 , icp ) end do end do end do gam_p = sqrt ( 1. + gam2 ) ax0 ( 0 : 2 ) = wgh * ax0 ( 0 : 2 ) do k1 = 0 , spl k2 = k + k1 do j1 = 0 , spl j2 = j + j1 dvol = az0 ( k1 ) * ay0 ( j1 ) do i1 = 0 , spl i2 = i + i1 eden ( i2 , j2 , k2 , 1 ) = eden ( i2 , j2 , k2 , 1 ) + ax0 ( i1 ) * dvol * charge eden ( i2 , j2 , k2 , 2 ) = eden ( i2 , j2 , k2 , 2 ) + & ( gam_p - 1. ) * ax0 ( i1 ) * dvol end do end do end do end do end select !=========================== end subroutine !================================================= subroutine set_grid_den_energy ( sp_loc , pt , eden , np ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) real ( dp ), intent ( inout ) :: eden (:, :, :, :) integer , intent ( in ) :: np real ( dp ) :: dvol , gam real ( dp ) :: ax0 ( 0 : 2 ), ay0 ( 0 : 2 ), az0 ( 0 : 2 ), xp ( 3 ), pp ( 3 ) integer :: i , j , k , i1 , j1 , k1 , i2 , j2 , k2 , n , ch , spl !====================== !   Computes eden(grid,1)= n/n_0 and eden(grid,2)=<gam-1}n>/n_0 !================================================ ax0 ( 0 : 2 ) = zero_dp ay0 ( 0 : 2 ) = zero_dp az0 ( 0 : 2 ) = zero_dp spl = 2 ch = size ( sp_loc % part , 2 ) if ( np < 1 ) return select case ( ndim ) case ( 1 ) j2 = 1 do n = 1 , np xp ( 1 ) = dx_inv * ( sp_loc % part ( n , 1 ) - xmn ) pp ( 1 : 2 ) = sp_loc % part ( n , 3 : 4 ) gam = sqrt ( pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) + 1. ) wgh_cmp = sp_loc % part ( n , ch ) call qden_1d_wgh ( xp , ax0 , i ) ax0 ( 0 : 2 ) = wgh * ax0 ( 0 : 2 ) i = i - 1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) eden ( i2 , j2 , 1 , 1 ) = eden ( i2 , j2 , 1 , 1 ) + dvol * charge eden ( i2 , j2 , 1 , 2 ) = eden ( i2 , j2 , 1 , 2 ) + ( gam - 1. ) * dvol end do end do case ( 2 ) do n = 1 , np pt ( n , 1 : ch ) = sp_loc % part ( n , 1 : ch ) end do call set_local_2d_positions ( pt , 1 , np ) call set_part_gamma ( pt , np , 2 ) do n = 1 , np xp ( 1 : 2 ) = pt ( n , 1 : 2 ) gam = pt ( n , 4 ) wgh_cmp = pt ( n , ch ) call qden_2d_wgh ( xp , ax0 , ay0 , i , j ) ax0 ( 0 : 2 ) = wgh * ax0 ( 0 : 2 ) i = i - 1 j = j - 1 do j1 = 0 , 2 j2 = j + j1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) eden ( i2 , j2 , 1 , 1 ) = eden ( i2 , j2 , 1 , 1 ) + dvol * charge eden ( i2 , j2 , 1 , 2 ) = eden ( i2 , j2 , 1 , 2 ) + ( gam - 1. ) * dvol end do end do end do case ( 3 ) ch = 7 do n = 1 , np pt ( n , 1 : ch ) = sp_loc % part ( n , 1 : ch ) end do call set_local_3d_positions ( pt , 1 , np ) call set_part_gamma ( pt , np , 3 ) do n = 1 , np xp ( 1 : 3 ) = pt ( n , 1 : 3 ) wgh_cmp = pt ( n , ch ) gam = pt ( n , 4 ) call qden_3d_wgh ( xp , ax0 , ay0 , az0 , i , j , k ) ax0 ( 0 : 2 ) = wgh * ax0 ( 0 : 2 ) i = i - 1 j = j - 1 k = k - 1 do k1 = 0 , spl k2 = k + k1 do j1 = 0 , spl j2 = j + j1 dvol = az0 ( k1 ) * ay0 ( j1 ) do i1 = 0 , spl i2 = i + i1 eden ( i2 , j2 , k2 , 1 ) = eden ( i2 , j2 , k2 , 1 ) + ax0 ( i1 ) * dvol * charge eden ( i2 , j2 , k2 , 2 ) = eden ( i2 , j2 , k2 , 2 ) + & ( gam - 1. ) * ax0 ( i1 ) * dvol end do end do end do end do end select !============================ end subroutine !============================================== subroutine set_grid_charge_and_jx ( sp_loc , pt , eden , np ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) real ( dp ), intent ( inout ) :: eden (:, :, :, :) integer , intent ( in ) :: np real ( dp ) :: dvol , gam real ( dp ) :: ax0 ( 0 : 2 ), ay0 ( 0 : 2 ), az0 ( 0 : 2 ), vx , xp ( 3 ) integer :: i , j , k , i1 , j1 , k1 , i2 , j2 , k2 , n , ch , spl real ( sp ) :: wght !====================== !   Computes charge density and Jx current density at t&#94;n current time !================================================ ax0 ( 0 : 2 ) = zero_dp ay0 ( 0 : 2 ) = zero_dp az0 ( 0 : 2 ) = zero_dp spl = 2 ch = size ( sp_loc % part , 2 ) if ( np < 1 ) return select case ( ndim ) case ( 2 ) do n = 1 , np pt ( n , 1 : ch ) = sp_loc % part ( n , 1 : ch ) end do call set_local_2d_positions ( pt , 1 , np ) do n = 1 , np xp ( 1 : 2 ) = pt ( n , 1 : 2 ) wgh_cmp = pt ( n , ch ) gam = sqrt ( 1. + pt ( n , 3 ) * pt ( n , 3 ) + pt ( n , 4 ) * pt ( n , 4 )) vx = pt ( n , 3 ) / gam wght = charge * wgh call qden_2d_wgh ( xp , ax0 , ay0 , i , j ) ax0 ( 0 : 2 ) = wght * ax0 ( 0 : 2 ) i = i - 1 j = j - 1 do j1 = 0 , 2 j2 = j + j1 do i1 = 0 , 2 i2 = i + i1 dvol = ax0 ( i1 ) * ay0 ( j1 ) eden ( i2 , j2 , 1 , 1 ) = eden ( i2 , j2 , 1 , 1 ) + dvol eden ( i2 , j2 , 1 , 2 ) = eden ( i2 , j2 , 1 , 2 ) + vx * dvol end do end do end do case ( 3 ) ch = 7 do n = 1 , np pt ( n , 1 : ch ) = sp_loc % part ( n , 1 : ch ) end do call set_local_3d_positions ( pt , 1 , np ) do n = 1 , np xp ( 1 : 3 ) = pt ( n , 1 : 3 ) wgh_cmp = pt ( n , ch ) gam = sqrt ( 1. + pt ( n , 4 ) * pt ( n , 4 ) + pt ( n , 5 ) * pt ( n , 5 ) + pt ( n , 6 ) * pt ( n , 6 )) vx = pt ( n , 4 ) / gam wght = charge * wgh call qden_3d_wgh ( xp , ax0 , ay0 , az0 , i , j , k ) ax0 ( 0 : 2 ) = wght * ax0 ( 0 : 2 ) i = i - 1 j = j - 1 k = k - 1 do k1 = 0 , spl k2 = k + k1 do j1 = 0 , spl j2 = j + j1 dvol = az0 ( k1 ) * ay0 ( j1 ) do i1 = 0 , spl i2 = i + i1 eden ( i2 , j2 , k2 , 1 ) = eden ( i2 , j2 , k2 , 1 ) + ax0 ( i1 ) * dvol eden ( i2 , j2 , k2 , 2 ) = eden ( i2 , j2 , k2 , 2 ) + vx * ax0 ( i1 ) * dvol end do end do end do end do end select end subroutine end module","tags":"","loc":"sourcefile/grid_part_util.f90.html"},{"title":"grid_part_connect.f90 – ALaDyn","text":"This file depends on sourcefile~~grid_part_connect.f90~~EfferentGraph sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~fstruct_data.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~grid_part_connect.f90->sourcefile~pstruct_data.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~grid_part_lib.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~grid_part_lib.f90->sourcefile~grid_param.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~stretched_grid.f90->sourcefile~common_param.f90 sourcefile~stretched_grid.f90->sourcefile~grid_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid_part_connect.f90~~AfferentGraph sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid_part_connect Source Code grid_part_connect.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module grid_part_connect use pstruct_data use fstruct_data use grid_part_lib implicit none !========= SECTION FOR FIELDS ASSIGNEMENT contains !========================================== subroutine set_part1d_acc ( ef , sp_loc , pt , np , ndf ) real ( dp ), intent ( in ) :: ef (:, :, :, :) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np , ndf real ( dp ) :: xp1 ( 3 ), ap ( 6 ) real ( dp ) :: axh ( 0 : 2 ), ax1 ( 0 : 2 ) integer :: i , ih , i1 , i2 , j2 , n !===================== !================================ select case ( ndf ) case ( 3 ) j2 = 1 do n = 1 , np ap ( 1 : 3 ) = zero_dp xp1 ( 1 ) = sp_loc % part ( n , 1 ) !the current particle positions call qqh_1d_spline ( xp1 , ax1 , axh , i , ih ) do i1 = 0 , 2 i2 = i1 + ih ap ( 1 ) = ap ( 1 ) + axh ( i1 ) * ef ( i2 , j2 , 1 , 1 ) !Ex(i+1/2) ap ( 3 ) = ap ( 3 ) + axh ( i1 ) * ef ( i2 , j2 , 1 , 3 ) !Bz(i+1/2) i2 = i + i1 ap ( 2 ) = ap ( 2 ) + ax1 ( i1 ) * ef ( i2 , j2 , 1 , 2 ) !Ey(i) end do pt ( n , 1 : 3 ) = ap ( 1 : 3 ) end do !======================== case ( 6 ) j2 = 1 do n = 1 , np ap ( 1 : 6 ) = zero_dp xp1 ( 1 ) = sp_loc % part ( n , 1 ) !the current particle positions call qqh_1d_spline ( xp1 , ax1 , axh , i , ih ) do i1 = 0 , 2 i2 = i1 + ih ap ( 1 ) = ap ( 1 ) + axh ( i1 ) * ef ( i2 , j2 , 1 , 1 ) !Ex ap ( 5 ) = ap ( 5 ) + axh ( i1 ) * ef ( i2 , j2 , 1 , 5 ) !By ap ( 6 ) = ap ( 6 ) + axh ( i1 ) * ef ( i2 , j2 , 1 , 6 ) !Bz end do do i1 = 0 , 2 i2 = i + i1 ap ( 2 ) = ap ( 2 ) + ax1 ( i1 ) * ef ( i2 , j2 , 1 , 2 ) !Ey ap ( 3 ) = ap ( 3 ) + ax1 ( i1 ) * ef ( i2 , j2 , 1 , 3 ) !Ez ap ( 4 ) = ap ( 4 ) + ax1 ( i1 ) * ef ( i2 , j2 , 1 , 4 ) !Bx end do pt ( n , 1 : 6 ) = ap ( 1 : 6 ) end do end select end subroutine !=========================== subroutine set_part2d_hcell_acc ( ef , sp_loc , pt , np , ndf ) real ( dp ), intent ( in ) :: ef (:, :, :, :) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np , ndf real ( dp ) :: dvol , dvol1 real ( dp ) :: xp1 ( 3 ), ap ( 6 ) real ( dp ) :: axh ( 0 : 1 ), ax1 ( 0 : 2 ) real ( dp ) :: ayh ( 0 : 1 ), ay1 ( 0 : 2 ) integer :: i , ih , j , jh , i1 , j1 , i2 , j2 , n !================================ ! Uses quadratic or linear shapes depending on staggering ! ndf is the number of field component xp1 = zero_dp do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) end do call set_local_2d_positions ( pt , 1 , np ) select case ( ndf ) !Field components case ( 3 ) do n = 1 , np ap ( 1 : 3 ) = zero_dp xp1 ( 1 : 2 ) = pt ( n , 1 : 2 ) call qlh_2d_spline ( xp1 , ax1 , axh , ay1 , ayh , i , ih , j , jh ) do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) do i1 = 0 , 1 i2 = i1 + ih dvol1 = axh ( i1 ) * dvol ap ( 1 ) = ap ( 1 ) + dvol1 * ef ( i2 , j2 , 1 , 1 ) !Ex(i+1/2,j) end do end do do j1 = 0 , 1 j2 = jh + j1 dvol = ayh ( j1 ) do i1 = 0 , 2 i2 = i + i1 dvol1 = ax1 ( i1 ) * dvol ap ( 2 ) = ap ( 2 ) + dvol1 * ef ( i2 , j2 , 1 , 2 ) !Ey(i,j+1/2) end do do i1 = 0 , 1 i2 = i1 + ih dvol1 = axh ( i1 ) * dvol ap ( 3 ) = ap ( 3 ) + dvol1 * ef ( i2 , j2 , 1 , 3 ) !Bz(i+1/2,j+1/2) end do end do pt ( n , 1 : 3 ) = ap ( 1 : 3 ) end do !============== case ( 6 ) !===================== do n = 1 , np ap ( 1 : 6 ) = zero_dp xp1 ( 1 : 2 ) = pt ( n , 1 : 2 ) call qlh_2d_spline ( xp1 , ax1 , axh , ay1 , ayh , i , ih , j , jh ) do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) do i1 = 0 , 1 i2 = i1 + ih dvol1 = axh ( i1 ) * dvol ap ( 1 ) = ap ( 1 ) + dvol1 * ef ( i2 , j2 , 1 , 1 ) !Ex(i+1/2,j) ap ( 5 ) = ap ( 5 ) + dvol1 * ef ( i2 , j2 , 1 , 5 ) !By(i+1/2,j) end do do i1 = 0 , 2 i2 = i1 + i dvol1 = ax1 ( i1 ) * dvol ap ( 3 ) = ap ( 3 ) + dvol1 * ef ( i2 , j2 , 1 , 3 ) !Ez(i,j,k+1/2) end do end do do j1 = 0 , 1 j2 = jh + j1 dvol = ayh ( j1 ) do i1 = 0 , 2 i2 = i + i1 dvol1 = ax1 ( i1 ) * dvol ap ( 2 ) = ap ( 2 ) + dvol1 * ef ( i2 , j2 , 1 , 2 ) !Ey(i,j+1/2) ap ( 4 ) = ap ( 4 ) + dvol1 * ef ( i2 , j2 , 1 , 4 ) !Bx(i,j+1/2) end do do i1 = 0 , 1 i2 = i1 + ih dvol1 = axh ( i1 ) * dvol ap ( 6 ) = ap ( 6 ) + dvol1 * ef ( i2 , j2 , 1 , 6 ) !Bz(i+1/2,j+1/2) end do end do pt ( n , 1 : 6 ) = ap ( 1 : 6 ) end do end select !===================== end subroutine !==================================== subroutine set_part3d_hcell_acc ( ef , sp_loc , pt , np ) real ( dp ), intent ( in ) :: ef (:, :, :, :) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np real ( dp ) :: dvol , ap ( 6 ), xp1 ( 3 ) real ( dp ) :: axh ( 0 : 1 ), ax1 ( 0 : 2 ) real ( dp ) :: ayh ( 0 : 1 ), ay1 ( 0 : 2 ) real ( dp ) :: azh ( 0 : 1 ), az1 ( 0 : 2 ) integer :: i , ih , j , jh , i1 , j1 , i2 , j2 , k , kh , k1 , k2 , n !=============================================== !Staggered shapes ! Linear shape at half-index ! Quadratic shape at integer index !==================================== !============================================================= do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) end do call set_local_3d_positions ( pt , 1 , np ) !========================== do n = 1 , np ap ( 1 : 6 ) = zero_dp xp1 ( 1 : 3 ) = pt ( n , 1 : 3 ) call qlh_3d_spline ( xp1 , ax1 , axh , ay1 , ayh , az1 , azh , i , ih , j , jh , & k , kh ) ! Ex(i+1/2,j,k) !============== !============== ! Ey(i,j+1/2,k) !============== !============== ! Bz(i+1/2,j+1/2,k) !============== do k1 = 0 , 2 k2 = k + k1 do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) * az1 ( k1 ) do i1 = 0 , 1 i2 = i1 + ih ap ( 1 ) = ap ( 1 ) + axh ( i1 ) * dvol * ef ( i2 , j2 , k2 , 1 ) end do end do do j1 = 0 , 1 j2 = jh + j1 dvol = ayh ( j1 ) * az1 ( k1 ) do i1 = 0 , 2 i2 = i + i1 ap ( 2 ) = ap ( 2 ) + ax1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 2 ) end do do i1 = 0 , 1 i2 = i1 + ih ap ( 6 ) = ap ( 6 ) + axh ( i1 ) * dvol * ef ( i2 , j2 , k2 , 6 ) end do end do end do !============== ! Bx(i,j+1/2,k+1/2) !============== !============== ! By(i+1/2,j,k+1/2) !============== !============== ! Ez(i,j,k+1/2) !============== do k1 = 0 , 1 k2 = kh + k1 do j1 = 0 , 1 j2 = jh + j1 dvol = ayh ( j1 ) * azh ( k1 ) do i1 = 0 , 2 i2 = i1 + i ap ( 4 ) = ap ( 4 ) + ax1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 4 ) end do end do do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) * azh ( k1 ) do i1 = 0 , 1 i2 = ih + i1 ap ( 5 ) = ap ( 5 ) + axh ( i1 ) * dvol * ef ( i2 , j2 , k2 , 5 ) end do do i1 = 0 , 2 i2 = i1 + i ap ( 3 ) = ap ( 3 ) + ax1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 3 ) end do end do end do pt ( n , 1 : 6 ) = ap ( 1 : 6 ) end do end subroutine !====================================== subroutine set_ion_efield ( ef , sp_loc , pt , np ) real ( dp ), intent ( in ) :: ef (:, :, :, :) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np real ( dp ) :: ef_sqr , dvol , ex , ey , ez real ( dp ) :: axh ( 0 : 2 ), ax1 ( 0 : 2 ) real ( dp ) :: ayh ( 0 : 2 ), ay1 ( 0 : 2 ) real ( dp ) :: azh ( 0 : 2 ), az1 ( 0 : 2 ) real ( dp ) :: xp1 ( 3 ) integer :: i , ih , j , jh , k , kh integer :: n , ip1 , jp1 , kp1 , ip2 , jp2 , kp2 !=============================================== ! qlh_spline()      Linear shape at half-index quadratic shape at integer index ! qqh_spline()      quadratic shape at half-index and at integer index !                 For field assignements !==================================== ! fields are at t&#94;n select case ( ndim ) case ( 2 ) kp2 = 1 do n = 1 , np pt ( n , 1 : 2 ) = sp_loc % part ( n , 1 : 2 ) end do call set_local_2d_positions ( pt , 1 , np ) !========================== do n = 1 , np ef_sqr = zero_dp xp1 ( 1 : 2 ) = pt ( n , 1 : 2 ) call qqh_2d_spline ( xp1 , ax1 , axh , ay1 , ayh , i , ih , j , jh ) ! Ex(i+1/2,j,k) !============== !============== ! Ey(i,j+1/2,k) !============== do jp1 = 0 , 2 jp2 = j + jp1 dvol = ay1 ( jp1 ) do ip1 = 0 , 2 ip2 = ih + ip1 ex = ef ( ip2 , jp2 , kp2 , 1 ) ef_sqr = ef_sqr + axh ( ip1 ) * dvol * ex * ex end do end do do jp1 = 0 , 2 jp2 = jh + jp1 dvol = ayh ( jp1 ) do ip1 = 0 , 2 ip2 = i + ip1 ey = ef ( ip2 , jp2 , kp2 , 2 ) ef_sqr = ef_sqr + ax1 ( ip1 ) * dvol * ey * ey end do end do !============== pt ( n , 5 ) = ef_sqr !Ex(p)&#94;2 + Ey(p)&#94;2 end do !======================================= case ( 3 ) do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) end do call set_local_3d_positions ( pt , 1 , np ) !========================== ! Here Quadratic shapes are used do n = 1 , np ef_sqr = zero_dp xp1 ( 1 : 3 ) = pt ( n , 1 : 3 ) call qqh_3d_spline ( xp1 , ax1 , axh , ay1 , ayh , az1 , azh , i , ih , j , jh , & k , kh ) ! Ex(i+1/2,j,k) !============== !============== ! Ey(i,j+1/2,k) !============== do kp1 = 0 , 2 kp2 = k + kp1 do jp1 = 0 , 2 jp2 = j + jp1 dvol = ay1 ( jp1 ) * az1 ( kp1 ) do ip1 = 0 , 2 ip2 = ip1 + ih ex = ef ( ip2 , jp2 , kp2 , 1 ) ef_sqr = ef_sqr + axh ( ip1 ) * dvol * ex * ex end do end do do jp1 = 0 , 2 jp2 = jh + jp1 dvol = ayh ( jp1 ) * az1 ( kp1 ) do ip1 = 0 , 2 ip2 = i + ip1 ey = ef ( ip2 , jp2 , kp2 , 2 ) ef_sqr = ef_sqr + ax1 ( ip1 ) * dvol * ey * ey end do end do end do !============== ! Ez(i,j,k+1/2) !============== do kp1 = 0 , 2 kp2 = kh + kp1 do jp1 = 0 , 2 jp2 = j + jp1 dvol = ay1 ( jp1 ) * azh ( kp1 ) do ip1 = 0 , 2 ip2 = ip1 + i ez = ef ( ip2 , jp2 , kp2 , 3 ) ef_sqr = ef_sqr + ax1 ( ip1 ) * dvol * ez * ez end do end do end do pt ( n , 7 ) = ef_sqr end do end select !================================ end subroutine !=================================== ! ENV field assignement section !=========================== subroutine set_env_acc ( ef , av , sp_loc , pt , np , dt_step ) real ( dp ), intent ( in ) :: ef (:, :, :, :), av (:, :, :, :) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np real ( dp ), intent ( in ) :: dt_step real ( dp ) :: dvol , dvol1 real ( dp ) :: xp1 ( 3 ), upart ( 3 ), ap ( 12 ) real ( dp ) :: aa1 , b1 , dgam , gam_inv , gam , gam2 , dth real ( dp ) :: axh1 ( 0 : 2 ), ax1 ( 0 : 2 ) real ( dp ) :: ayh1 ( 0 : 2 ), ay1 ( 0 : 2 ) real ( dp ) :: azh1 ( 0 : 2 ), az1 ( 0 : 2 ) integer :: i , ih , j , jh , i2 , j2 , k , kh , k2 , n integer ( kind = 2 ) :: i1 , j1 , k1 integer ( kind = 2 ), parameter :: stl = 2 !=============================================== !=============================================== ! Uses quadratic shape functions at integer and half-integer grid points !==================================== !=================================================== ! enter ef(1:6) wake fields ! enters av(1)=F=|a|&#94;2/2 envelope at integer grid nodes ! and av(2:4)=grad[F] at staggered points !  COMPUTES !(E,B), F, grad[F] assignements to particle positions ! => ap(1:6)  in 2D ! => ap(1:10) in 3D ! approximated gamma function: ! gam_new= gam +0.25*charge*Dt(gam*E+0.5*grad[F]).p&#94;{n-1/2}/gam&#94;2 ! EXIT ! (E+ 0.5grad[F]/gam_new) B/gam_new, F   and wgh/gam_new ! pt(1:5)  in 2D ! pt(1:7)  in 3D !======================================== dth = 0.5 * dt_step select case ( ndim ) !========================== case ( 2 ) ax1 ( 0 : 2 ) = zero_dp ay1 ( 0 : 2 ) = zero_dp axh1 ( 0 : 2 ) = zero_dp ayh1 ( 0 : 2 ) = zero_dp k2 = 1 do n = 1 , np pt ( n , 1 : 2 ) = sp_loc % part ( n , 1 : 2 ) end do call set_local_2d_positions ( pt , 1 , np ) do n = 1 , np ap ( 1 : 6 ) = 0.0 xp1 ( 1 : 2 ) = pt ( n , 1 : 2 ) !the current particle positions upart ( 1 : 2 ) = sp_loc % part ( n , 3 : 4 ) !the current particle  momenta wgh_cmp = sp_loc % part ( n , 5 ) !the current particle (weight,charge) call qqh_2d_spline ( xp1 , ax1 , axh1 , ay1 , ayh1 , i , ih , j , jh ) !========================== do j1 = 0 , stl j2 = j + j1 dvol = ay1 ( j1 ) do i1 = 0 , stl i2 = i + i1 ap ( 6 ) = ap ( 6 ) + ax1 ( i1 ) * dvol * av ( i2 , j2 , k2 , 1 ) !t&#94;n p-assigned F=a&#94;2/2 field end do do i1 = 0 , stl i2 = ih + i1 dvol1 = dvol * axh1 ( i1 ) ap ( 1 ) = ap ( 1 ) + dvol1 * ef ( i2 , j2 , k2 , 1 ) !Ex and Dx[F] (i+1/2,j,k)) ap ( 4 ) = ap ( 4 ) + dvol1 * av ( i2 , j2 , k2 , 2 ) !ap(4)=ap(4)+dvol1*dx_inv*(av(i2+1,j2,k2,1)-av(i2,j2,k2,1)) end do end do do j1 = 0 , stl j2 = jh + j1 dvol = ayh1 ( j1 ) do i1 = 0 , stl i2 = i + i1 dvol1 = dvol * ax1 ( i1 ) ap ( 2 ) = ap ( 2 ) + dvol1 * ef ( i2 , j2 , k2 , 2 ) !Ey and Dy[F] (i,j+1/2,k) ap ( 5 ) = ap ( 5 ) + dvol1 * av ( i2 , j2 , k2 , 3 ) !ap(5)=ap(5)+dvol1*dy_inv*(av(i2,j2+1,k2,1)-av(i2,j2,k2,1)) end do do i1 = 0 , stl i2 = ih + i1 ap ( 3 ) = ap ( 3 ) + axh1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 3 ) !Bz(i+1/2,j+1/2,k) end do end do !========================= gam2 = 1. + upart ( 1 ) * upart ( 1 ) + upart ( 2 ) * upart ( 2 ) + ap ( 6 ) !gamma&#94;{n-1/2} ap ( 1 : 3 ) = charge * ap ( 1 : 3 ) ap ( 4 : 5 ) = 0.5 * charge * charge * ap ( 4 : 5 ) !  ap(1:2)=q(Ex,Ey)   ap(3)=q*Bz,ap(4:5)=q*q*[Dx,Dy]F/2 aa1 = dth * dot_product ( ap ( 1 : 2 ), upart ( 1 : 2 )) !Dt*(qE_ip_i)/2 ==> a b1 = dth * dot_product ( ap ( 4 : 5 ), upart ( 1 : 2 )) !Dt*(qD_iFp_i)/4 ===> c gam = sqrt ( gam2 ) dgam = ( aa1 * gam - b1 ) / gam2 gam_inv = ( gam - dgam ) / gam2 ap ( 3 : 5 ) = ap ( 3 : 5 ) * gam_inv !ap(3)=q*B/gamp, ap(4:5)= q*Grad[F]/2*gamp pt ( n , 1 : 2 ) = ap ( 1 : 2 ) - ap ( 4 : 5 ) ! Lorentz force already multiplied by q pt ( n , 3 ) = ap ( 3 ) pt ( n , 5 ) = wgh * gam_inv !weight/gamp end do !============================= case ( 3 ) ax1 ( 0 : 2 ) = zero_dp ay1 ( 0 : 2 ) = zero_dp az1 ( 0 : 2 ) = zero_dp azh1 ( 0 : 2 ) = zero_dp axh1 ( 0 : 2 ) = zero_dp ayh1 ( 0 : 2 ) = zero_dp do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) end do call set_local_3d_positions ( pt , 1 , np ) do n = 1 , np ap = zero_dp xp1 ( 1 : 3 ) = pt ( n , 1 : 3 ) upart ( 1 : 3 ) = sp_loc % part ( n , 4 : 6 ) !the current particle  momenta wgh_cmp = sp_loc % part ( n , 7 ) !the current particle (weight,charge) call qqh_3d_spline ( xp1 , ax1 , axh1 , ay1 , ayh1 , az1 , azh1 , i , ih , j , & jh , k , kh ) !========================== do k1 = 0 , stl k2 = k + k1 do j1 = 0 , stl j2 = j + j1 dvol = ay1 ( j1 ) * az1 ( k1 ) do i1 = 0 , stl i2 = i1 + i ap ( 10 ) = ap ( 10 ) + ax1 ( i1 ) * dvol * av ( i2 , j2 , k2 , 1 ) !t&#94;n p-assigned Phi=a&#94;2/2 field end do do i1 = 0 , stl i2 = i1 + ih dvol1 = dvol * axh1 ( i1 ) ap ( 1 ) = ap ( 1 ) + dvol1 * ef ( i2 , j2 , k2 , 1 ) !Ex and Dx[F] (i+1/2,j,k)) ap ( 7 ) = ap ( 7 ) + dvol1 * av ( i2 , j2 , k2 , 2 ) end do end do do j1 = 0 , stl j2 = jh + j1 dvol = ayh1 ( j1 ) * az1 ( k1 ) do i1 = 0 , 2 i2 = i + i1 dvol1 = dvol * ax1 ( i1 ) ap ( 2 ) = ap ( 2 ) + dvol1 * ef ( i2 , j2 , k2 , 2 ) !Ey and Dy[F] (i,j+1/2,k) ap ( 8 ) = ap ( 8 ) + dvol1 * av ( i2 , j2 , k2 , 3 ) end do do i1 = 0 , stl i2 = i1 + ih ap ( 6 ) = ap ( 6 ) + axh1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 6 ) !Bz(i+1/2,j+1/2,k) end do end do end do !========================= do k1 = 0 , stl k2 = kh + k1 do j1 = 0 , stl j2 = jh + j1 dvol = ayh1 ( j1 ) * azh1 ( k1 ) do i1 = 0 , stl i2 = i1 + i ap ( 4 ) = ap ( 4 ) + ax1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 4 ) !Bx(i,j+1/2,k+1/2) end do end do do j1 = 0 , stl j2 = j + j1 dvol = ay1 ( j1 ) * azh1 ( k1 ) do i1 = 0 , stl i2 = ih + i1 ap ( 5 ) = ap ( 5 ) + axh1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 5 ) !By(i+1/2,j,k+1/2) end do do i1 = 0 , stl i2 = i1 + i dvol1 = dvol * ax1 ( i1 ) ap ( 3 ) = ap ( 3 ) + dvol1 * ef ( i2 , j2 , k2 , 3 ) !Ez and Dz[F] (i,j,k+1/2) ap ( 9 ) = ap ( 9 ) + dvol1 * av ( i2 , j2 , k2 , 4 ) end do end do end do !================================= gam2 = 1. + upart ( 1 ) * upart ( 1 ) + upart ( 2 ) * upart ( 2 ) + & upart ( 3 ) * upart ( 3 ) + ap ( 10 ) !gamma&#94;{n-1/2} ap ( 1 : 6 ) = charge * ap ( 1 : 6 ) ap ( 7 : 9 ) = 0.5 * charge * charge * ap ( 7 : 9 ) !  ap(1:3)=q(Ex,Ey,Ez)   ap(4:6)=q(Bx,By,Bz),ap(7:9)=q[Dx,Dy,Dz]F/2 aa1 = dth * dot_product ( ap ( 1 : 3 ), upart ( 1 : 3 )) b1 = dth * dot_product ( ap ( 7 : 9 ), upart ( 1 : 3 )) gam = sqrt ( gam2 ) dgam = ( aa1 * gam - b1 ) / gam2 gam_inv = ( gam - dgam ) / gam2 ap ( 4 : 9 ) = ap ( 4 : 9 ) * gam_inv !ap(4:6)=B/gamp, ap(7:9)= Grad[F]/2*gamp pt ( n , 1 : 3 ) = ap ( 1 : 3 ) - ap ( 7 : 9 ) pt ( n , 4 : 6 ) = ap ( 4 : 6 ) pt ( n , 7 ) = wgh * gam_inv !weight/gamp end do end select end subroutine !======================================= subroutine set_ion_env_field ( ef , sp_loc , pt , np , om0 ) real ( dp ), intent ( in ) :: ef (:, :, :, :) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np real ( dp ), intent ( in ) :: om0 real ( dp ) :: axh1 ( 0 : 2 ), ax1 ( 0 : 2 ) real ( dp ) :: ayh1 ( 0 : 2 ), ay1 ( 0 : 2 ) real ( dp ) :: azh1 ( 0 : 2 ), az1 ( 0 : 2 ) real ( dp ) :: dvol , ddx , ddy real ( dp ) :: xp1 ( 3 ), ap ( 6 ) integer :: i , ih , j , jh , i1 , j1 , i2 , j2 , k , kh , k1 , k2 , n !============================== ! Enter ef(1:2)<=  A=(A_R,A_I) ! Exit pt=|E|&#94;2= |E_y|&#94;2 + |E_x|&#94;2 assigned to each ion particle !=========================== !  Up to O(epsilon)&#94;2: ! |E_y|&#94;2= k_0&#94;2*|A|&#94;2+2*k_0*[A_R*Dx(A_I)-A_I*Dx(A_R)] +(Dx[A_R])&#94;2 +Dx[A_I}&#94;2) ! |E_x|&#94;2= (Dy[A_R])&#94;2 +Dy[A_I]&#94;2) !=============================================== !=============================================== ! Quadratic shape functions !==================================== ddx = dx_inv ddy = dy_inv !===== enter species positions at t&#94;{n+1} level======== ! fields are at t&#94;n select case ( ndim ) case ( 2 ) ax1 ( 0 : 2 ) = zero_dp ay1 ( 0 : 2 ) = zero_dp axh1 ( 0 : 2 ) = zero_dp ayh1 ( 0 : 2 ) = zero_dp k2 = 1 do n = 1 , np pt ( n , 1 : 2 ) = sp_loc % part ( n , 1 : 2 ) end do call set_local_2d_positions ( pt , 1 , np ) !========================== do n = 1 , np ap ( 1 : 6 ) = zero_dp xp1 ( 1 : 2 ) = pt ( n , 1 : 2 ) call qqh_2d_spline ( xp1 , ax1 , axh1 , ay1 , ayh1 , i , ih , j , jh ) do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) do i1 = 0 , 2 i2 = i1 + i ap ( 1 ) = ap ( 1 ) + ax1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 1 ) !A_R ap ( 2 ) = ap ( 2 ) + ax1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 2 ) !A_I end do do i1 = 0 , 2 i2 = i1 + ih ap ( 3 ) = ap ( 3 ) + axh1 ( i1 ) * dvol * ( ef ( i2 + 1 , j2 , k2 , 1 ) - ef ( i2 , j2 , k2 , 1 )) !DxA_R ap ( 4 ) = ap ( 4 ) + axh1 ( i1 ) * dvol * ( ef ( i2 + 1 , j2 , k2 , 2 ) - ef ( i2 , j2 , k2 , 2 )) !DxA_I end do end do do j1 = 0 , 2 j2 = jh + j1 dvol = ayh1 ( j1 ) do i1 = 0 , 2 i2 = i + i1 ap ( 5 ) = ap ( 5 ) + ax1 ( i1 ) * dvol * ( ef ( i2 , j2 + 1 , k2 , 1 ) - ef ( i2 , j2 , k2 , 1 )) !DyA_R ap ( 6 ) = ap ( 6 ) + ax1 ( i1 ) * dvol * ( ef ( i2 , j2 + 1 , k2 , 2 ) - ef ( i2 , j2 , k2 , 2 )) !DyA_I end do end do !================== pt ( n , 4 ) = sqrt ( ap ( 1 ) * ap ( 1 ) + ap ( 2 ) * ap ( 2 )) !The interpolated |A| potential ap ( 1 ) = om0 * ap ( 1 ) ap ( 2 ) = om0 * ap ( 2 ) ap ( 3 ) = ddx * ap ( 3 ) ap ( 4 ) = ddx * ap ( 4 ) ap ( 5 ) = ddy * ap ( 5 ) ap ( 6 ) = ddy * ap ( 6 ) pt ( n , 5 ) = ap ( 1 ) * ap ( 1 ) + ap ( 2 ) * ap ( 2 ) + ap ( 3 ) * ap ( 3 ) + ap ( 4 ) * ap ( 4 ) + & ap ( 5 ) * ap ( 5 ) + ap ( 6 ) * ap ( 6 ) pt ( n , 5 ) = pt ( n , 5 ) + 2. * ( ap ( 1 ) * ap ( 4 ) - ap ( 2 ) * ap ( 3 )) end do !========================== case ( 3 ) ax1 ( 0 : 2 ) = zero_dp ay1 ( 0 : 2 ) = zero_dp axh1 ( 0 : 2 ) = zero_dp ayh1 ( 0 : 2 ) = zero_dp az1 ( 0 : 2 ) = zero_dp azh1 ( 0 : 2 ) = zero_dp do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) end do call set_local_3d_positions ( pt , 1 , np ) do n = 1 , np ap ( 1 : 6 ) = zero_dp xp1 ( 1 : 3 ) = pt ( n , 1 : 3 ) call qqh_3d_spline ( xp1 , ax1 , axh1 , ay1 , ayh1 , az1 , azh1 , i , ih , j , & jh , k , kh ) !=============== Quadratic/linear assignements do k1 = 0 , 2 k2 = k + k1 do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) * az1 ( k1 ) do i1 = 0 , 2 i2 = i1 + i ap ( 1 ) = ap ( 1 ) + ax1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 1 ) !A_R ap ( 2 ) = ap ( 2 ) + ax1 ( i1 ) * dvol * ef ( i2 , j2 , k2 , 2 ) !A_I end do do i1 = 0 , 2 i2 = i1 + ih ap ( 3 ) = ap ( 3 ) + axh1 ( i1 ) * dvol * ( ef ( i2 + 1 , j2 , k2 , 1 ) - ef ( i2 , j2 , k2 , 1 )) !DxA_R ap ( 4 ) = ap ( 4 ) + axh1 ( i1 ) * dvol * ( ef ( i2 + 1 , j2 , k2 , 2 ) - ef ( i2 , j2 , k2 , 2 )) !DxA_I end do end do do j1 = 0 , 2 j2 = jh + j1 dvol = ayh1 ( j1 ) * az1 ( k1 ) do i1 = 0 , 2 i2 = i + i1 ap ( 5 ) = ap ( 5 ) + ax1 ( i1 ) * dvol * ( ef ( i2 , j2 + 1 , k2 , 1 ) - ef ( i2 , j2 , k2 , 1 )) !DyA_R ap ( 6 ) = ap ( 6 ) + ax1 ( i1 ) * dvol * ( ef ( i2 , j2 + 1 , k2 , 2 ) - ef ( i2 , j2 , k2 , 2 )) !DyA_I end do end do end do pt ( n , 6 ) = sqrt ( ap ( 1 ) * ap ( 1 ) + ap ( 2 ) * ap ( 2 )) !The interpolated |A| potential ap ( 1 ) = om0 * ap ( 1 ) ap ( 2 ) = om0 * ap ( 2 ) ap ( 3 ) = ddx * ap ( 3 ) ap ( 4 ) = ddx * ap ( 4 ) ap ( 5 ) = ddy * ap ( 5 ) ap ( 6 ) = ddy * ap ( 6 ) pt ( n , 7 ) = ap ( 1 ) * ap ( 1 ) + ap ( 2 ) * ap ( 2 ) + ap ( 3 ) * ap ( 3 ) + ap ( 4 ) * ap ( 4 ) + & ap ( 5 ) * ap ( 5 ) + ap ( 6 ) * ap ( 6 ) pt ( n , 7 ) = pt ( n , 7 ) + 2. * ( ap ( 1 ) * ap ( 4 ) - ap ( 2 ) * ap ( 3 )) end do end select !================================ end subroutine !================================ subroutine set_env_grad_interp ( av , sp_loc , pt , np , ndm ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( in ) :: av (:, :, :, :) real ( dp ), intent ( inout ) :: pt (:, :) integer , intent ( in ) :: np , ndm real ( dp ) :: axh1 ( 0 : 2 ), ax1 ( 0 : 2 ) real ( dp ) :: ayh1 ( 0 : 2 ), ay1 ( 0 : 2 ) real ( dp ) :: azh1 ( 0 : 2 ), az1 ( 0 : 2 ) real ( dp ) :: dvol , dvol1 , dxe , dye , dze real ( dp ) :: xp1 ( 3 ), ap ( 4 ) integer :: i , ih , j , jh , i1 , j1 , i2 , j2 , k , kh , k1 , k2 , n !=============================================== ! enters av(1)=|a|&#94;2/2 envelope at integer grid nodes ! and av(2:4)=[Grad |a|2/2] at staggered grid points ! exit in pt(1:4) grad[|a|&#94;2]/2 and |a|&#94;2/2 at the particle positions ! On output => Reverse ordering of field variables is used !========================= ! Particle positions assigned using quadratic splines !  F=|a|&#94;2/2 !  ap(1)= [D_x(F)](i+1/2,j,k) !  ap(2)= [D_y(F)](i,j+1/2,k) !  ap(3)= [D_z(F)](i,j,k+1/2) !  ap(4)= [Phi](i,j,k) !=========================================== select case ( ndim ) case ( 2 ) dxe = dx_inv dye = dy_inv k2 = 1 do n = 1 , np pt ( n , 1 : 2 ) = sp_loc % part ( n , 1 : 2 ) ! end do call set_local_2d_positions ( pt , 1 , np ) do n = 1 , np ap = 0.0 xp1 ( 1 : 2 ) = pt ( n , 1 : 2 ) call qqh_2d_spline ( xp1 , ax1 , axh1 , ay1 , ayh1 , i , ih , j , jh ) !========================== do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) do i1 = 0 , 2 i2 = i1 + ih dvol1 = dvol * axh1 ( i1 ) ap ( 1 ) = ap ( 1 ) + dvol1 * av ( i2 , j2 , k2 , 2 ) !Dx[Phi] i2 = i1 + i ap ( 3 ) = ap ( 3 ) + ax1 ( i1 ) * dvol * av ( i2 , j2 , k2 , 1 ) ![Phi] end do end do do j1 = 0 , 2 j2 = jh + j1 dvol = ayh1 ( j1 ) do i1 = 0 , 2 i2 = i + i1 dvol1 = dvol * ax1 ( i1 ) ap ( 2 ) = ap ( 2 ) + dvol1 * av ( i2 , j2 , k2 , 3 ) !Dy[Phi] end do end do !pt(n,1)=dxe*ap(1)    !assigned grad[A&#94;2/2] !pt(n,2)=dye*ap(2) pt ( n , 1 : 3 ) = ap ( 1 : 3 ) !assigned grad[Phi] and Phi end do !================================= case ( 3 ) dxe = dx_inv dye = dy_inv dze = dz_inv do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) end do call set_local_3d_positions ( pt , 1 , np ) do n = 1 , np ap = 0.0 xp1 ( 1 : 3 ) = pt ( n , 1 : 3 ) call qqh_3d_spline ( xp1 , ax1 , axh1 , ay1 , ayh1 , az1 , azh1 , i , ih , j , & jh , k , kh ) !========================== ap = 0.0 do k1 = 0 , 2 k2 = k + k1 do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) * az1 ( k1 ) do i1 = 0 , 2 i2 = i1 + ih dvol1 = dvol * axh1 ( i1 ) ap ( 1 ) = ap ( 1 ) + dvol1 * av ( i2 , j2 , k2 , 2 ) !Dx[F] i2 = i1 + i ap ( 4 ) = ap ( 4 ) + ax1 ( i1 ) * dvol * av ( i2 , j2 , k2 , 1 ) !Phi end do end do do j1 = 0 , 2 j2 = jh + j1 dvol = ayh1 ( j1 ) * az1 ( k1 ) do i1 = 0 , 2 i2 = i + i1 dvol1 = dvol * ax1 ( i1 ) ap ( 2 ) = ap ( 2 ) + dvol1 * av ( i2 , j2 , k2 , 3 ) !Dy[F] end do end do k2 = kh + k1 do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) * azh1 ( k1 ) do i1 = 0 , 2 i2 = i + i1 dvol1 = dvol * ax1 ( i1 ) ap ( 3 ) = ap ( 3 ) + dvol1 * av ( i2 , j2 , k2 , 4 ) !Dz[F] end do end do end do pt ( n , 1 : 4 ) = ap ( 1 : 4 ) !Exit grad[Phi] and Phi !================================= end do end select end subroutine !=========================== subroutine set_env_density ( efp , av , np , ic ) real ( dp ), intent ( inout ) :: efp (:, :) real ( dp ), intent ( inout ) :: av (:, :, :, :) integer , intent ( in ) :: np , ic real ( dp ) :: dvol , dvol1 , wghp real ( dp ) :: ax1 ( 0 : 2 ), ay1 ( 0 : 2 ), az1 ( 0 : 2 ), xp1 ( 3 ) integer :: i , j , i1 , j1 , i2 , j2 , k , k1 , k2 , n !=============================================== ! 2D enter efp(1:2) positions and efp(5) wgh/gamp at time level n ! 3D enter efp(1:3) positions and efp(7) wgh/gamp at time level n ! exit av(:,:,:,ic) the den source in envelope equation :  <n*wgh/gamp> > 0 ! exit efp(1:3) relative positions at time level n !========================= ax1 ( 0 : 2 ) = zero_dp ay1 ( 0 : 2 ) = zero_dp az1 ( 0 : 2 ) = zero_dp select case ( ndim ) case ( 2 ) k2 = 1 call set_local_2d_positions ( efp , 1 , np ) do n = 1 , np xp1 ( 1 : 2 ) = efp ( n , 1 : 2 ) wghp = efp ( n , 5 ) !the particle  wgh/gamp at current time call qden_2d_wgh ( xp1 , ax1 , ay1 , i , j ) i = i - 1 j = j - 1 !========================== do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) * wghp do i1 = 0 , 2 i2 = i1 + i dvol1 = dvol * ax1 ( i1 ) av ( i2 , j2 , k2 , ic ) = av ( i2 , j2 , k2 , ic ) + dvol1 end do end do end do !======================== case ( 3 ) call set_local_3d_positions ( efp , 1 , np ) do n = 1 , np xp1 ( 1 : 3 ) = efp ( n , 1 : 3 ) ! local x-y-z wghp = efp ( n , 7 ) !the particle  wgh/gamp at current time call qden_3d_wgh ( xp1 , ax1 , ay1 , az1 , i , j , k ) i = i - 1 j = j - 1 k = k - 1 do k1 = 0 , 2 k2 = k + k1 do j1 = 0 , 2 j2 = j + j1 dvol = ay1 ( j1 ) * az1 ( k1 ) * wghp do i1 = 0 , 2 i2 = i1 + i dvol1 = dvol * ax1 ( i1 ) av ( i2 , j2 , k2 , ic ) = av ( i2 , j2 , k2 , ic ) + dvol1 end do end do end do end do end select !In ebfp(1:3) exit relative (x,y,z) positions at current t&#94;n level !In av(ic)  exit particle density !================================ end subroutine !==================================================== !========= PARTICLE ASSIGNEMENT TO GRID FOR CURRENT DENSITY !============================= subroutine esirkepov_2d_curr ( sp_loc , pt , jcurr , np ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :), jcurr (:, :, :, :) integer , intent ( in ) :: np real ( dp ) :: dvol real ( dp ) :: ax0 ( 0 : 3 ), ay0 ( 0 : 3 ), xp1 ( 3 ), xp0 ( 3 ) real ( dp ) :: ax1 ( 0 : 3 ), ay1 ( 0 : 3 ), vp ( 3 ) real ( dp ) :: axh ( 0 : 4 ), axh0 ( 0 : 4 ), axh1 ( 0 : 4 ), ayh ( 0 : 4 ) real ( dp ) :: currx ( 0 : 4 ), curry ( 0 : 4 ) real ( sp ) :: wght integer :: i , j , ii0 , jj0 , i1 , j1 , i2 , j2 , n integer :: ih , jh , x0 , x1 , y0 , y1 !========================== !Iform=0 or 1 IMPLEMENTS the ESIRKEPOV SCHEME for LINEAR-QUADRATIC SHAPE ! ==============================Only new and old positions needed ax1 = zero_dp ay1 = zero_dp ax0 = zero_dp ay0 = zero_dp !====================== select case ( ndim ) case ( 2 ) if ( curr_ndim == 2 ) then !Two current components do n = 1 , np pt ( n , 1 : 2 ) = sp_loc % part ( n , 1 : 2 ) !x-y-new  t&#94;(n+1) wgh_cmp = sp_loc % part ( n , 5 ) wght = charge * wgh pt ( n , 5 ) = wght end do call set_local_2d_positions ( pt , 2 , np ) !======================== ii0 = 0 jj0 = 0 i = 0 j = 0 do n = 1 , np xp1 ( 1 : 2 ) = pt ( n , 1 : 2 ) !x-y  -new xp0 ( 1 : 2 ) = pt ( n , 3 : 4 ) !x-y  -old wght = real ( pt ( n , 5 ), sp ) !w*q !===================== call qden_2d_wgh ( xp0 , ax0 , ay0 , ii0 , jj0 ) call qden_2d_wgh ( xp1 , ax1 , ay1 , i , j ) axh ( 0 : 4 ) = zero_dp ih = i - ii0 + 1 do i1 = 0 , 2 axh ( ih + i1 ) = ax1 ( i1 ) end do currx ( 0 ) = - axh ( 0 ) do i1 = 1 , 3 currx ( i1 ) = currx ( i1 - 1 ) + ax0 ( i1 - 1 ) - axh ( i1 ) end do currx ( 4 ) = currx ( 3 ) - axh ( 4 ) do i1 = 1 , 3 axh ( i1 ) = axh ( i1 ) + ax0 ( i1 - 1 ) end do currx ( 0 : 4 ) = wght * currx ( 0 : 4 ) x0 = min ( ih , 1 ) x1 = max ( ih + 2 , 3 ) !------- jh = j - jj0 + 1 ayh ( 0 : 4 ) = zero_dp do i1 = 0 , 2 ayh ( jh + i1 ) = ay1 ( i1 ) end do curry ( 0 ) = - ayh ( 0 ) do i1 = 1 , 3 curry ( i1 ) = curry ( i1 - 1 ) + ay0 ( i1 - 1 ) - ayh ( i1 ) end do curry ( 4 ) = curry ( 3 ) - ayh ( 4 ) curry ( 0 : 4 ) = wght * curry ( 0 : 4 ) !======================================== do i1 = 1 , 3 ayh ( i1 ) = ayh ( i1 ) + ay0 ( i1 - 1 ) end do y0 = min ( jh , 1 ) y1 = max ( jh + 2 , 3 ) !================dt*J_x jj0 = jj0 - 1 j = j - 1 jh = jj0 - 1 i = i - 1 ii0 = ii0 - 1 ih = ii0 - 1 do j1 = y0 , y1 j2 = jh + j1 do i1 = x0 , x1 i2 = ih + i1 jcurr ( i2 , j2 , 1 , 1 ) = jcurr ( i2 , j2 , 1 , 1 ) + ayh ( j1 ) * currx ( i1 ) end do end do !================dt*J_y do j1 = y0 , y1 j2 = jh + j1 do i1 = x0 , x1 i2 = ih + i1 jcurr ( i2 , j2 , 1 , 2 ) = jcurr ( i2 , j2 , 1 , 2 ) + axh ( i1 ) * curry ( j1 ) end do end do end do end if if ( curr_ndim == 3 ) then !Three currents conditions in 2D grid do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) !x-y-z -new  t&#94;(n+1) wgh_cmp = sp_loc % part ( n , 7 ) wght = charge * wgh pt ( n , 7 ) = wght end do call set_local_2d_positions ( pt , 2 , np ) !============================== do n = 1 , np xp1 ( 1 : 3 ) = pt ( n , 1 : 3 ) !increments xyz-new xp0 ( 1 : 3 ) = pt ( n , 4 : 6 ) !increments xyz z-old wght = real ( pt ( n , 7 ), sp ) vp ( 3 ) = xp1 ( 3 ) - xp0 ( 3 ) !dt*v_z(n+1/2) vp ( 3 ) = wght * vp ( 3 ) / 3. !dt*q*w*vz/3 !===================== call qden_2d_wgh ( xp0 , ax0 , ay0 , ii0 , jj0 ) call qden_2d_wgh ( xp1 , ax1 , ay1 , i , j ) axh ( 0 : 4 ) = zero_dp ih = i - ii0 + 1 x0 = min ( ih , 1 ) x1 = max ( ih + 2 , 3 ) do i1 = 0 , 2 axh ( ih + i1 ) = ax1 ( i1 ) end do currx ( 0 ) = - axh ( 0 ) do i1 = 1 , 3 currx ( i1 ) = currx ( i1 - 1 ) + ax0 ( i1 - 1 ) - axh ( i1 ) end do currx ( 4 ) = currx ( 3 ) - axh ( 4 ) do i1 = 1 , 3 axh ( i1 ) = axh ( i1 ) + ax0 ( i1 - 1 ) end do currx ( 0 : 4 ) = wght * currx ( 0 : 4 ) axh0 ( 0 : 4 ) = 0.5 * axh ( 0 : 4 ) axh1 ( 0 : 4 ) = axh ( 0 : 4 ) do i1 = 1 , 3 axh0 ( i1 ) = axh0 ( i1 ) + ax0 ( i1 - 1 ) axh1 ( i1 ) = axh1 ( i1 ) + 0.5 * ax0 ( i1 - 1 ) axh ( i1 ) = axh ( i1 ) + ax0 ( i1 - 1 ) !Wx&#94;0+Wx&#94;1) end do !------- i = i - 1 ii0 = ii0 - 1 jh = j - jj0 + 1 y0 = min ( jh , 1 ) y1 = max ( jh + 2 , 3 ) ayh ( 0 : 4 ) = zero_dp do i1 = 0 , 2 ayh ( jh + i1 ) = ay1 ( i1 ) end do curry ( 0 ) = - ayh ( 0 ) do i1 = 1 , 3 curry ( i1 ) = curry ( i1 - 1 ) + ay0 ( i1 - 1 ) - ayh ( i1 ) end do curry ( 4 ) = curry ( 3 ) - ayh ( 4 ) curry ( 0 : 4 ) = wght * curry ( 0 : 4 ) do i1 = 1 , 3 ayh ( i1 ) = ayh ( i1 ) + ay0 ( i1 - 1 ) end do !----------- jj0 = jj0 - 1 j = j - 1 !================dt*J_x= currx*(Wy&#94;0+Wy&#94;1) to be multiplied by dx/2 ih = ii0 - 1 jh = jj0 - 1 do j1 = y0 , y1 j2 = jh + j1 do i1 = x0 , x1 i2 = ih + i1 jcurr ( i2 , j2 , 1 , 1 ) = jcurr ( i2 , j2 , 1 , 1 ) + ayh ( j1 ) * currx ( i1 ) end do end do !================dt*J_y= curry*(Wx&#94;0+Wx&#94;1) do j1 = y0 , y1 j2 = jh + j1 do i1 = x0 , x1 i2 = ih + i1 jcurr ( i2 , j2 , 1 , 2 ) = jcurr ( i2 , j2 , 1 , 2 ) + axh ( i1 ) * curry ( j1 ) end do end do !========== dt*J_z Vz*[Wy&#94;0(Wx&#94;0+0.5*Wx&#94;1)+Wy&#94;1*(Wx&#94;1+0.5*Wx&#94;0)] do j1 = 0 , 2 j2 = jj0 + j1 dvol = ay0 ( j1 ) * vp ( 3 ) do i1 = x0 , x1 i2 = i1 + ih jcurr ( i2 , j2 , 1 , 3 ) = jcurr ( i2 , j2 , 1 , 3 ) + axh0 ( i1 ) * dvol end do j2 = j + j1 dvol = ay1 ( j1 ) * vp ( 3 ) do i1 = x0 , x1 i2 = i1 + ih jcurr ( i2 , j2 , 1 , 3 ) = jcurr ( i2 , j2 , 1 , 3 ) + axh1 ( i1 ) * dvol end do end do end do end if end select !----------------------- end subroutine !========================================== !=============3D================= subroutine esirkepov_3d_curr ( sp_loc , pt , jcurr , np ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :), jcurr (:, :, :, :) integer , intent ( in ) :: np real ( dp ) :: dvol , dvolh real ( dp ) :: ax0 ( 0 : 2 ), ay0 ( 0 : 2 ), az0 ( 0 : 2 ), xp0 ( 1 : 3 ) real ( dp ) :: ax1 ( 0 : 2 ), ay1 ( 0 : 2 ), az1 ( 0 : 2 ), xp1 ( 1 : 3 ) real ( dp ) :: axh ( 0 : 4 ), ayh ( 0 : 4 ), azh ( 0 : 4 ) real ( dp ) :: axh0 ( 0 : 4 ), axh1 ( 0 : 4 ), ayh0 ( 0 : 4 ), ayh1 ( 0 : 4 ) real ( dp ) :: currx ( 0 : 4 ), curry ( 0 : 4 ), currz ( 0 : 4 ) real ( sp ) :: wght integer :: i , j , k , ii0 , jj0 , kk0 , i1 , j1 , k1 , i2 , j2 , k2 , n integer :: x0 , x1 , y0 , y1 , z0 , z1 , ih , jh , kh !======================= !Enter pt(4:6) old positions sp_loc(1:3) new positions ax1 ( 0 : 2 ) = zero_dp ay1 ( 0 : 2 ) = zero_dp az1 ( 0 : 2 ) = zero_dp az0 ( 0 : 2 ) = zero_dp ax0 ( 0 : 2 ) = zero_dp ay0 ( 0 : 2 ) = zero_dp axh ( 0 : 4 ) = zero_dp ayh ( 0 : 4 ) = zero_dp azh ( 0 : 4 ) = zero_dp currx ( 0 : 4 ) = zero_dp curry ( 0 : 4 ) = zero_dp currz ( 0 : 4 ) = zero_dp axh0 ( 0 : 4 ) = zero_dp ayh0 ( 0 : 4 ) = zero_dp axh1 ( 0 : 4 ) = zero_dp ayh1 ( 0 : 4 ) = zero_dp ! ==============================Only new and old positions needed do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) !x-y-z -new  t&#94;(n+1) wgh_cmp = sp_loc % part ( n , 7 ) wght = charge * wgh pt ( n , 7 ) = wght end do call set_local_3d_positions ( pt , 2 , np ) do n = 1 , np wght = real ( pt ( n , 7 ), sp ) xp1 ( 1 : 3 ) = pt ( n , 1 : 3 ) !increments of the new positions xp0 ( 1 : 3 ) = pt ( n , 4 : 6 ) !increments of old positions call qden_3d_wgh ( xp0 , ax0 , ay0 , az0 , ii0 , jj0 , kk0 ) call qden_3d_wgh ( xp1 , ax1 , ay1 , az1 , i , j , k ) axh ( 0 : 4 ) = zero_dp ih = i - ii0 + 1 !========== direct Jx-inversion do i1 = 0 , 2 axh ( ih + i1 ) = ax1 ( i1 ) end do currx ( 0 ) = - axh ( 0 ) do i1 = 1 , 3 currx ( i1 ) = currx ( i1 - 1 ) + ax0 ( i1 - 1 ) - axh ( i1 ) end do currx ( 4 ) = currx ( 3 ) - axh ( 4 ) currx ( 0 : 4 ) = wght * currx ( 0 : 4 ) !======================= axh0 ( 0 : 4 ) = 0.5 * axh ( 0 : 4 ) axh1 ( 0 : 4 ) = axh ( 0 : 4 ) do i1 = 1 , 3 axh0 ( i1 ) = axh0 ( i1 ) + ax0 ( i1 - 1 ) axh1 ( i1 ) = axh1 ( i1 ) + 0.5 * ax0 ( i1 - 1 ) end do x0 = min ( ih , 1 ) x1 = max ( ih + 2 , 3 ) !------- i = i - 1 ii0 = ii0 - 1 !========== direct Jy-inversion jh = j - jj0 + 1 !=[0,1,2] ayh ( 0 : 4 ) = zero_dp do i1 = 0 , 2 ayh ( jh + i1 ) = ay1 ( i1 ) end do curry ( 0 ) = - ayh ( 0 ) do i1 = 1 , 3 curry ( i1 ) = curry ( i1 - 1 ) + ay0 ( i1 - 1 ) - ayh ( i1 ) end do curry ( 4 ) = curry ( 3 ) - ayh ( 4 ) curry ( 0 : 4 ) = wght * curry ( 0 : 4 ) !===================================== !                                 Jx =>    Wz&#94;0(0.5*wy&#94;1+Wy&#94;0)=Wz&#94;0*ayh0 !                                          Wz&#94;1(wy&#94;1+0.5*Wy&#94;0)=Wz&#94;1*ayh1 !============================== ayh0 ( 0 : 4 ) = 0.5 * ayh ( 0 : 4 ) ayh1 ( 0 : 4 ) = ayh ( 0 : 4 ) do i1 = 1 , 3 ayh0 ( i1 ) = ayh0 ( i1 ) + ay0 ( i1 - 1 ) ayh1 ( i1 ) = ayh1 ( i1 ) + 0.5 * ay0 ( i1 - 1 ) end do y0 = min ( jh , 1 ) ![0,1] y1 = max ( jh + 2 , 3 ) ![3,4] !----------- jj0 = jj0 - 1 j = j - 1 ! Direct Jz inversion kh = k - kk0 + 1 azh ( 0 : 4 ) = zero_dp do i1 = 0 , 2 azh ( kh + i1 ) = az1 ( i1 ) end do currz ( 0 ) = - azh ( 0 ) do i1 = 1 , 3 currz ( i1 ) = currz ( i1 - 1 ) + az0 ( i1 - 1 ) - azh ( i1 ) end do currz ( 4 ) = currz ( 3 ) - azh ( 4 ) currz ( 0 : 4 ) = wght * currz ( 0 : 4 ) !---------- kk0 = kk0 - 1 k = k - 1 z0 = min ( kh , 1 ) z1 = max ( kh + 2 , 3 ) !================Jx=DT*drho_x to be inverted================== jh = jj0 - 1 !==================== ih = ii0 - 1 do k1 = 0 , 2 do j1 = y0 , y1 j2 = jh + j1 dvol = ayh0 ( j1 ) * az0 ( k1 ) dvolh = ayh1 ( j1 ) * az1 ( k1 ) do i1 = x0 , x1 i2 = ih + i1 jcurr ( i2 , j2 , kk0 + k1 , 1 ) = jcurr ( i2 , j2 , kk0 + k1 , 1 ) + & dvol * currx ( i1 ) jcurr ( i2 , j2 , k + k1 , 1 ) = jcurr ( i2 , j2 , k + k1 , 1 ) + dvolh * currx ( i1 ) end do end do end do !================Jy do k1 = 0 , 2 do j1 = y0 , y1 j2 = jh + j1 dvol = curry ( j1 ) * az0 ( k1 ) dvolh = curry ( j1 ) * az1 ( k1 ) do i1 = x0 , x1 i2 = ih + i1 jcurr ( i2 , j2 , kk0 + k1 , 2 ) = jcurr ( i2 , j2 , kk0 + k1 , 2 ) + axh0 ( i1 ) * dvol jcurr ( i2 , j2 , k + k1 , 2 ) = jcurr ( i2 , j2 , k + k1 , 2 ) + axh1 ( i1 ) * dvolh end do end do end do !================Jz kh = kk0 - 1 do k1 = z0 , z1 k2 = kh + k1 do j1 = 0 , 2 dvol = ay0 ( j1 ) * currz ( k1 ) dvolh = ay1 ( j1 ) * currz ( k1 ) do i1 = x0 , x1 i2 = ih + i1 jcurr ( i2 , jj0 + j1 , k2 , 3 ) = jcurr ( i2 , jj0 + j1 , k2 , 3 ) + axh0 ( i1 ) * dvol jcurr ( i2 , j + j1 , k2 , 3 ) = jcurr ( i2 , j + j1 , k2 , 3 ) + axh1 ( i1 ) * dvolh end do end do end do end do !============= Curr data on [1:n+4] extended range end subroutine !=============================== ! NO CHARGE PRESERVING CURRENT DENSITY !========================= subroutine ncdef_2d_curr ( sp_loc , pt , jcurr , np ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :), jcurr (:, :, :, :) integer , intent ( in ) :: np real ( dp ) :: axh0 ( 0 : 2 ), ayh0 ( 0 : 2 ) real ( dp ) :: axh1 ( 0 : 2 ), ayh1 ( 0 : 2 ) real ( dp ) :: ax0 ( 0 : 2 ), ay0 ( 0 : 2 ), xp0 ( 1 : 2 ) real ( dp ) :: ax1 ( 0 : 2 ), ay1 ( 0 : 2 ), xp1 ( 1 : 2 ) real ( dp ) :: vp ( 3 ), dvol ( 3 ) real ( sp ) :: wght integer :: i , j , ii0 , jj0 , i1 , j1 , i2 , j2 , n integer :: jh0 , jh , ih0 , ih !======================= !Enter pt(3:4) old x-y positions !===================================== do n = 1 , np pt ( n , 1 : 2 ) = sp_loc % part ( n , 1 : 2 ) !(x,y,z) new end do call set_local_2d_positions ( pt , 2 , np ) !========== pt(n,5) = dt/gam do n = 1 , np wgh_cmp = sp_loc % part ( n , 5 ) wght = charge * wgh !w*q for  q=e, ion_charge vp ( 1 : 2 ) = wght * pt ( n , 5 ) * sp_loc % part ( n , 3 : 4 ) !dt*q*wgh*P/gam at t&#94;{n+1/2} vp ( 1 : 2 ) = 0.5 * vp ( 1 : 2 ) !1/2 * V*q*wgh*dt xp1 ( 1 : 2 ) = pt ( n , 1 : 2 ) xp0 ( 1 : 2 ) = pt ( n , 3 : 4 ) call qlh_2d_spline ( xp0 , ax0 , axh0 , ay0 , ayh0 , ii0 , ih0 , jj0 , jh0 ) !==================== call qlh_2d_spline ( xp1 , ax1 , axh1 , ay1 , ayh1 , i , ih , j , jh ) !===============Jx ======== do j1 = 0 , 2 j2 = j + j1 dvol ( 1 ) = vp ( 1 ) * ay1 ( j1 ) do i1 = 0 , 1 i2 = ih + i1 jcurr ( i2 , j2 , 1 , 1 ) = jcurr ( i2 , j2 , 1 , 1 ) + dvol ( 1 ) * axh1 ( i1 ) end do j2 = jj0 + j1 dvol ( 1 ) = vp ( 1 ) * ay0 ( j1 ) do i1 = 0 , 1 i2 = ih0 + i1 jcurr ( i2 , j2 , 1 , 1 ) = jcurr ( i2 , j2 , 1 , 1 ) + dvol ( 1 ) * axh0 ( i1 ) end do end do !=========== Jy do j1 = 0 , 1 j2 = jh0 + j1 dvol ( 2 ) = vp ( 2 ) * ayh0 ( j1 ) do i1 = 0 , 2 i2 = ii0 + i1 jcurr ( i2 , j2 , 1 , 2 ) = jcurr ( i2 , j2 , 1 , 2 ) + dvol ( 2 ) * ax0 ( i1 ) end do j2 = jh + j1 dvol ( 2 ) = vp ( 2 ) * ayh1 ( j1 ) do i1 = 0 , 2 i2 = i + i1 jcurr ( i2 , j2 , 1 , 2 ) = jcurr ( i2 , j2 , 1 , 2 ) + dvol ( 2 ) * ax1 ( i1 ) end do end do end do end subroutine !======================== subroutine ncdef_3d_curr ( sp_loc , pt , jcurr , np ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: pt (:, :), jcurr (:, :, :, :) integer , intent ( in ) :: np real ( dp ) :: dvol ( 3 ), gam_inv real ( dp ) :: xp0 ( 3 ), xp1 ( 3 ) real ( dp ) :: ax0 ( 0 : 2 ), ay0 ( 0 : 2 ), az0 ( 0 : 2 ) real ( dp ) :: ax1 ( 0 : 2 ), ay1 ( 0 : 2 ), az1 ( 0 : 2 ) real ( dp ) :: axh0 ( 0 : 1 ), ayh0 ( 0 : 1 ), azh0 ( 0 : 1 ) real ( dp ) :: axh1 ( 0 : 1 ), ayh1 ( 0 : 1 ), azh1 ( 0 : 1 ) real ( dp ) :: vp ( 3 ) real ( sp ) :: wght integer :: i , j , k , ii0 , jj0 , kk0 , i1 , j1 , k1 , i2 , j2 , k2 , n integer :: ih , jh , kh , ih0 , jh0 , kh0 !======================= ! Current densities defined by alternating order (quadratic/linear) shapes ! Enter pt(4:6)=old positions sp_loc(1:3)=new positions !WARNING : to be used ONLY within the one cycle partcle integration scheme !========================================== ! Exit in jcurr(1:3) =[Drho,J_y,J_z]   !Drho= rho&#94;{new}-rho&#94;{old} ! Component J_x recovered by enforcing the continuity equation on a grid !============================================= do n = 1 , np pt ( n , 1 : 3 ) = sp_loc % part ( n , 1 : 3 ) !(x,y,z) new end do call set_local_3d_positions ( pt , 2 , np ) do n = 1 , np vp ( 1 : 3 ) = sp_loc % part ( n , 4 : 6 ) !Momenta at t&#94;{n+1/2} wgh_cmp = sp_loc % part ( n , 7 ) wght = real ( charge * wgh , sp ) !w*q for  q=charge gam_inv = wght * pt ( n , 7 ) !q*wgh*dt/gam vp ( 1 : 3 ) = 0.5 * gam_inv * vp ( 1 : 3 ) !wgh*q*dt*V factor 1/2 from density average xp1 ( 1 : 3 ) = pt ( n , 1 : 3 ) !new relative coordinates xp0 ( 1 : 3 ) = pt ( n , 4 : 6 ) !old relative coordinates call qlh_3d_spline ( xp0 , ax0 , axh0 , ay0 , ayh0 , az0 , azh0 , ii0 , ih0 , & jj0 , jh0 , kk0 , kh0 ) !==================== call qlh_3d_spline ( xp1 , ax1 , axh1 , ay1 , ayh1 , az1 , azh1 , i , ih , j , & jh , k , kh ) !======================   Jx do k1 = 0 , 2 k2 = k + k1 do j1 = 0 , 2 j2 = j + j1 dvol ( 1 ) = vp ( 1 ) * ay1 ( j1 ) * az1 ( k1 ) do i1 = 0 , 1 i2 = ih + i1 jcurr ( i2 , j2 , k2 , 1 ) = jcurr ( i2 , j2 , k2 , 1 ) + dvol ( 1 ) * axh1 ( i1 ) end do end do k2 = kk0 + k1 do j1 = 0 , 2 j2 = jj0 + j1 dvol ( 1 ) = vp ( 1 ) * ay0 ( j1 ) * az0 ( k1 ) do i1 = 0 , 1 i2 = ih0 + i1 jcurr ( i2 , j2 , k2 , 1 ) = jcurr ( i2 , j2 , k2 , 1 ) + dvol ( 1 ) * axh0 ( i1 ) end do end do end do !================Jy-Jz============= do k1 = 0 , 2 k2 = kk0 + k1 do j1 = 0 , 1 j2 = jh0 + j1 dvol ( 2 ) = vp ( 2 ) * ayh0 ( j1 ) * az0 ( k1 ) do i1 = 0 , 2 i2 = ii0 + i1 jcurr ( i2 , j2 , k2 , 2 ) = jcurr ( i2 , j2 , k2 , 2 ) + dvol ( 2 ) * ax0 ( i1 ) end do end do k2 = k + k1 do j1 = 0 , 1 j2 = jh + j1 dvol ( 2 ) = vp ( 2 ) * ayh1 ( j1 ) * az1 ( k1 ) do i1 = 0 , 2 i2 = i + i1 jcurr ( i2 , j2 , k2 , 2 ) = jcurr ( i2 , j2 , k2 , 2 ) + dvol ( 2 ) * ax1 ( i1 ) end do end do end do do k1 = 0 , 1 k2 = kh0 + k1 do j1 = 0 , 2 j2 = jj0 + j1 dvol ( 3 ) = vp ( 3 ) * ay0 ( j1 ) * azh0 ( k1 ) do i1 = 0 , 2 i2 = ii0 + i1 jcurr ( i2 , j2 , k2 , 3 ) = jcurr ( i2 , j2 , k2 , 3 ) + dvol ( 3 ) * ax0 ( i1 ) end do end do k2 = kh + k1 do j1 = 0 , 2 j2 = j + j1 dvol ( 3 ) = vp ( 3 ) * ay1 ( j1 ) * azh1 ( k1 ) do i1 = 0 , 2 i2 = i + i1 jcurr ( i2 , j2 , k2 , 3 ) = jcurr ( i2 , j2 , k2 , 3 ) + dvol ( 3 ) * ax1 ( i1 ) end do end do end do end do !============= Curr and density data on [0:n+3] extended range end subroutine !========================== end module","tags":"","loc":"sourcefile/grid_part_connect.f90.html"},{"title":"mpi_curr_interface.f90 – ALaDyn","text":"This file depends on sourcefile~~mpi_curr_interface.f90~~EfferentGraph sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~fstruct_data.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~mpi_curr_interface.f90->sourcefile~pstruct_data.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~mpi_curr_interface.f90->sourcefile~grid_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mpi_curr_interface.f90~~AfferentGraph sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mpi_curr_interface Source Code mpi_curr_interface.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! !=================================================== !     Local grid structure under mpi domain decomposition !============== ! grid [1:n]   np=n+2  extended domain [1:np+3] ! interior [3,np]   ghost [1:2], [np+1:np+3] ! !             overlapping grid points !==================================================================== !                                     1-----2---- 3---  4---- 5   |      pey+1 !                 1-----2----[3-------np-1--np]--np+1--np+2--np+3 |    pey !1-2--------------np-1--np---np+1                          |pey-1 !---------------------------------------------------------------------- !  On current pey mpi-task !  data [1,2] recieved form right are added to [np-1,np] data !  data [np+1:np+3] recieved from right are added to [3:5] data !=================================== module mpi_curr_interface use pstruct_data use fstruct_data use parallel use grid_param implicit none integer ( hp_int ), parameter , private :: rt = 1 , lt = - 1 contains !==================== subroutine fill_curr_yzxbdsdata ( curr , nc ) real ( dp ), intent ( inout ) :: curr (:, :, :, :) integer , intent ( in ) :: nc integer :: s1 , s2 , r1 , r2 , y1 , y2 , z1 , z2 , x1 , x2 integer :: ic , ix , j , iy , iz , kk , lenws , lenwr integer , parameter :: str = 3 , stl = 2 !================ PREDEFINED MAX ! enter currents on a five-point extended stencil !=========================== z1 = kz1 - stl z2 = kz2 + str y1 = jy1 - stl y2 = jy2 + str if ( ndim < 3 ) then z1 = kz1 z2 = kz2 end if if ( ndim < 2 ) then y1 = jy1 y2 = jy2 end if x1 = ix1 - stl x2 = ix2 + str lenwr = str * nc * ( x2 + 1 - x1 ) * max ( z2 + 1 - z1 , y2 + 1 - y1 ) if ( size ( aux1 ) < lenwr ) then deallocate ( aux1 , aux2 ) allocate ( aux1 ( lenwr )) allocate ( aux2 ( lenwr )) end if if ( prly ) then !===================== ! for stl=2 ! sends y=[j1-2;j1-1] stl data to left !receives from right and adds data on y=[nyc-1:nyc] sign=+1 !========================= s1 = jy1 - stl kk = 0 do ic = 1 , nc do iz = z1 , z2 do j = 0 , stl - 1 iy = s1 + j do ix = x1 , x2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 1 , rt ) r1 = jy2 - stl kk = 0 if ( pe1y ) then if ( iby < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if do ic = 1 , nc do iz = z1 , z2 do j = 1 , stl iy = j + r1 do ix = x1 , x2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do !======================================== ! sends y=[nyc+1:nyc+str] str=3 data to the right !receives from left and adds data on y=[j1:j1+str-1] sign=-1 s2 = jy2 kk = 0 do ic = 1 , nc do iz = z1 , z2 do j = 1 , str iy = j + s2 do ix = x1 , x2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 1 , lt ) !===================== r2 = jy1 kk = 0 if ( pe0y ) then if ( iby < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if do ic = 1 , nc do iz = z1 , z2 do j = 0 , str - 1 iy = j + r2 do ix = x1 , x2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do end if ! The reduced stencil of summed data y1 = jy1 y2 = jy2 !================ if ( prlz ) then !================ ! sends z=[k1-2;k1-1] stl data to left ! receives from right and adds data on y=[nzc-1:nzc] sign=+1 s1 = kz1 - stl kk = 0 do ic = 1 , nc do j = 0 , stl - 1 iz = s1 + j do iy = y1 , y2 do ix = x1 , x2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 2 , rt ) r1 = kz2 - stl if ( pe1z ) then if ( ibz < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = 1 , nc do j = 1 , stl iz = j + r1 do iy = y1 , y2 do ix = x1 , x2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do ! !================ ! sends z=[nzc+1:nzc+str] str=3 data to the right !receives from left and adds data on z=[k1:k1+str-1] sign=-1 s2 = kz2 kk = 0 do ic = 1 , nc do j = 1 , str iz = j + s2 do iy = y1 , y2 do ix = x1 , x2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 2 , lt ) !================ r2 = kz1 if ( pe0z ) then if ( ibz < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = 1 , nc do j = 0 , str - 1 iz = j + r2 do iy = y1 , y2 do ix = x1 , x2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do ! The reduced stencil of summed data z1 = kz1 z2 = kz2 end if !========================== prlx case if ( prlx ) then ! sends x=[i1-2;i1-1] stl data to left ! receives from right and adds data on x=[nxc-1:nxc] sign=+1 s1 = ix1 - stl kk = 0 do ic = 1 , nc do iz = z1 , z2 do iy = y1 , y2 do j = 0 , stl - 1 ix = s1 + j kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 3 , rt ) !===================== r1 = ix2 - stl kk = 0 if ( pex1 ) then if ( ibx < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if do ic = 1 , nc do iz = z1 , z2 do iy = y1 , y2 do j = 1 , stl ix = j + r1 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do ! sends x=[nxc+1:nxc+str] str=3 data to the right !receives from left and adds data on x=[i1:i1+str-1] sign=-1 s2 = ix2 kk = 0 do ic = 1 , nc do iz = z1 , z2 do iy = y1 , y2 do j = 1 , str ix = j + s2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 3 , lt ) !===================== r2 = ix1 kk = 0 if ( pex0 ) then if ( ibx < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if do ic = 1 , nc do iz = z1 , z2 do iy = y1 , y2 do j = 0 , str - 1 ix = j + r2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do return end if !===================== No MPI x-decomposition if ( ibx == 2 ) then ! data nxc-1:nxc sums to i1-2:i1-1 ! data i1:i1+2 sums to nxc+1:nxc+3 s1 = ix1 - stl - 1 r1 = ix2 - stl do ic = 1 , nc do iz = z1 , z2 do iy = y1 , y2 do j = 1 , stl curr ( r1 + j , iy , iz , ic ) = curr ( r1 + j , iy , iz , ic ) + & curr ( s1 + j , iy , iz , ic ) end do do j = 1 , str ix = ix1 - 1 + j curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + & curr ( r1 + j , iy , iz , ic ) end do end do end do end do end if !============================= end subroutine !=============================== subroutine fill_ftcurr_yzbdsdata ( curr , nc ) real ( dp ), intent ( inout ) :: curr (:, :, :, :) integer , intent ( in ) :: nc integer :: s1 , s2 , r1 , r2 , y1 , y2 , z1 , z2 , x1 , x2 integer :: ic , ix , j , iy , iz , kk , lenws , lenwr integer :: j1 , j2 , k1 , k2 integer , parameter :: str = 3 , stl = 2 !================ PREDEFINED MAX ! enter currents on a five-point extended stencil !=========================== k1 = loc_zftgrid ( imodz )% p_ind ( 1 ) k2 = loc_zftgrid ( imodz )% p_ind ( 2 ) j1 = loc_yftgrid ( imody )% p_ind ( 1 ) j2 = loc_yftgrid ( imody )% p_ind ( 2 ) z1 = k1 - stl z2 = k2 + str y1 = j1 - stl y2 = j2 + str if ( ndim < 3 ) then z1 = k1 z2 = k2 end if x1 = ix1 - stl x2 = ix2 + str lenwr = str * nc * ( x2 + 1 - x1 ) * max ( z2 + 1 - z1 , y2 + 1 - y1 ) if ( size ( aux1 ) < lenwr ) then deallocate ( aux1 , aux2 ) allocate ( aux1 ( lenwr )) allocate ( aux2 ( lenwr )) end if if ( prly ) then !===================== ! for stl=2 ! sends y=[j1-2;j1-1] stl data to left !receives from right and adds data on y=[nyc-1:nyc] sign=+1 !========================= s1 = j1 - stl kk = 0 do ic = 1 , nc do iz = z1 , z2 do j = 0 , stl - 1 iy = s1 + j do ix = x1 , x2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 1 , rt ) r1 = j2 - stl kk = 0 if ( pe1y ) then if ( iby < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if do ic = 1 , nc do iz = z1 , z2 do j = 1 , stl iy = j + r1 do ix = x1 , x2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do !======================================== ! sends y=[nyc+1:nyc+str] str=3 data to the right !receives from left and adds data on y=[j1:j1+str-1] sign=-1 s2 = j2 kk = 0 do ic = 1 , nc do iz = z1 , z2 do j = 1 , str iy = j + s2 do ix = x1 , x2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 1 , lt ) !===================== r2 = j1 kk = 0 if ( pe0y ) then if ( iby < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if do ic = 1 , nc do iz = z1 , z2 do j = 0 , str - 1 iy = j + r2 do ix = x1 , x2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do end if ! The reduced stencil of summed data y1 = j1 y2 = j2 !================ if ( prlz ) then !================ ! sends z=[k1-2;k1-1] stl data to left ! receives from right and adds data on y=[nzc-1:nzc] sign=+1 s1 = k1 - stl kk = 0 do ic = 1 , nc do j = 0 , stl - 1 iz = s1 + j do iy = y1 , y2 do ix = x1 , x2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 2 , rt ) r1 = k2 - stl if ( pe1z ) then if ( ibz < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = 1 , nc do j = 1 , stl iz = j + r1 do iy = y1 , y2 do ix = x1 , x2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do ! !================ ! sends z=[nzc+1:nzc+str] str=3 data to the right !receives from left and adds data on z=[k1:k1+str-1] sign=-1 s2 = k2 kk = 0 do ic = 1 , nc do j = 1 , str iz = j + s2 do iy = y1 , y2 do ix = x1 , x2 kk = kk + 1 aux1 ( kk ) = curr ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 2 , lt ) !================ r2 = k1 if ( pe0z ) then if ( ibz < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = 1 , nc do j = 0 , str - 1 iz = j + r2 do iy = y1 , y2 do ix = x1 , x2 kk = kk + 1 curr ( ix , iy , iz , ic ) = curr ( ix , iy , iz , ic ) + aux2 ( kk ) end do end do end do end do ! The reduced stencil of summed data z1 = k1 z2 = k2 end if end subroutine !===================================== subroutine jc_xyzbd ( curr , nc ) real ( dp ), intent ( inout ) :: curr (:, :, :, :) integer , intent ( in ) :: nc integer :: ix , iy , iz , i0 , j2 , k2 , ik integer :: i1 , n1 , j1 , n2 , k1 , n3 ! Enter current data on extended ranges: !========== Only for Periodic BDs period=n1-1 i1 = ix1 n1 = ix2 j1 = jy1 n2 = jy2 k1 = kz1 n3 = kz2 j2 = n2 k2 = n3 if ( ibx == 0 ) then do ik = 1 , nc curr ( i1 , j1 : j2 , k1 : k2 , ik ) = curr ( i1 , j1 : j2 , k1 : k2 , ik ) + & curr ( i1 - 1 , j1 : j2 , k1 : k2 , ik ) curr ( i1 - 1 , j1 : j2 , k1 : k2 , ik ) = 0.0 curr ( n1 , j1 : j2 , k1 : k2 , ik ) = curr ( n1 , j1 : j2 , k1 : k2 , ik ) + & curr ( n1 + 1 , j1 : j2 , k1 : k2 , ik ) + curr ( n1 + 2 , j1 : j2 , k1 : k2 , ik ) curr ( n1 + 1 : n1 + 2 , j1 : j2 , k1 : k2 , ik ) = 0.0 end do i0 = 1 end if if ( ndim < 2 ) return if ( pe0y ) then if ( iby == 0 ) then do ik = 1 , nc do iz = k1 , k2 do ix = i1 , n1 curr ( ix , j1 , iz , ik ) = curr ( ix , j1 , iz , ik ) + & curr ( ix , j1 - 1 , iz , ik ) + curr ( ix , j1 - 2 , iz , ik ) curr ( ix , j1 - 2 : j1 - 1 , iz , ik ) = 0.0 end do end do end do end if if ( iby == 1 ) then !Before norm  r*Jx(j)=rVxrho ==> rEx odd Jx(j-1)=-Jx(j+1) !             r*Jr=rVrrho ==> rEr even   Jr(j-1/2)=jr(j+1/2) do iz = k1 , k2 do ix = i1 , n1 curr ( ix , j1 + 1 , iz , 1 ) = curr ( ix , j1 + 1 , iz , 1 ) + & curr ( ix , j1 - 1 , iz , 1 ) curr ( ix , j1 , iz , 2 ) = curr ( ix , j1 , iz , 2 ) - curr ( ix , j1 - 1 , iz , 2 ) end do end do end if end if if ( pe1y ) then if ( iby == 0 ) then do ik = 1 , nc do iz = k1 , k2 do ix = i1 , n1 curr ( ix , n2 , iz , ik ) = curr ( ix , n2 , iz , ik ) + & curr ( ix , n2 + 1 , iz , ik ) + curr ( ix , n2 + 2 , iz , ik ) curr ( ix , n2 + 1 : n2 + 2 , iz , ik ) = 0.0 end do end do end do end if end if if ( ndim < 3 ) return if ( ibz == 0 ) then if ( pe0z ) then do ik = 1 , nc do iy = j1 , j2 do ix = i1 , n1 curr ( ix , iy , k1 , ik ) = curr ( ix , iy , k1 , ik ) + & curr ( ix , iy , k1 - 1 , ik ) curr ( ix , iy , k1 - 1 , ik ) = 0.0 end do end do end do end if if ( pe1z ) then if ( ibz == 0 ) then do ik = 1 , nc do iy = j1 , j2 do ix = i1 , n1 curr ( ix , iy , n3 , ik ) = curr ( ix , iy , n3 , ik ) + & curr ( ix , iy , n3 + 1 , ik ) + curr ( ix , iy , n3 + 2 , ik ) curr ( ix , iy , n3 + 1 : n3 + 2 , ik ) = 0.0 end do end do end do end if end if end if end subroutine !========================= ! subroutine den_zyxbd ( rho , ik ) real ( dp ), intent ( inout ) :: rho (:, :, :, :) integer , intent ( in ) :: ik integer :: i1 , i2 , j1 , j2 , k1 , k2 integer :: ix , iy ! Enter current data on extended ranges: !Enter data on the computational box [i1:n1p][j1:nyp][k1:nzp] i1 = ix1 i2 = ix2 j1 = jy1 j2 = jy2 k1 = kz1 k2 = kz2 if ( ndim > 2 ) then if ( ibz == 0 ) then if ( pe0z ) then do iy = j1 , j2 do ix = i1 , i2 rho ( ix , iy , k1 + 1 , ik ) = rho ( ix , iy , k1 + 1 , ik ) + & rho ( ix , iy , k1 - 1 , ik ) rho ( ix , iy , k1 , ik ) = rho ( ix , iy , k1 + 1 , ik ) end do end do end if if ( pe1z ) then if ( ibz < 2 ) then do iy = j1 , j2 do ix = i1 , i2 rho ( ix , iy , k2 - 1 , ik ) = rho ( ix , iy , k2 - 1 , ik ) + & rho ( ix , iy , k2 + 1 , ik ) rho ( ix , iy , k2 , ik ) = rho ( ix , iy , k2 - 1 , ik ) end do end do end if end if end if end if !================ if ( ndim > 1 ) then if ( pe0y ) then if ( iby == 0 ) then rho ( i1 : i2 , j1 + 1 , k1 : k2 , ik ) = rho ( i1 : i2 , j1 + 1 , k1 : k2 , ik ) + & rho ( i1 : i2 , j1 - 1 , k1 : k2 , ik ) rho ( i1 : i2 , j1 , k1 : k2 , ik ) = rho ( i1 : i2 , j1 + 1 , k1 : k2 , ik ) end if if ( iby == 1 ) then rho ( i1 : i2 , j1 + 1 , k1 : k2 , ik ) = rho ( i1 : i2 , j1 + 1 , k1 : k2 , ik ) + & rho ( i1 : i2 , j1 - 1 , k1 : k2 , ik ) rho ( i1 : i2 , j1 - 1 , k1 : k2 , ik ) = 0.0 end if end if if ( pe1y ) then if ( iby < 2 ) then rho ( i1 : i2 , j2 - 1 , k1 : k2 , ik ) = rho ( i1 : i2 , j2 - 1 , k1 : k2 , ik ) + & rho ( i1 : i2 , j2 + 1 , k1 : k2 , ik ) rho ( i1 : i2 , j2 , k1 : k2 , ik ) = rho ( i1 : i2 , j2 - 1 , k1 : k2 , ik ) end if end if end if !============== field data on [y_loc] if ( ibx < 2 ) then if ( pex0 ) then rho ( i1 + 1 , j1 : j2 , k1 : k2 , ik ) = rho ( i1 + 1 , j1 : j2 , k1 : k2 , ik ) + & rho ( i1 - 1 , j1 : j2 , k1 : k2 , ik ) rho ( i1 , j1 : j2 , k1 : k2 , ik ) = rho ( i1 + 1 , j1 : j2 , k1 : k2 , ik ) end if if ( pex1 ) then rho ( i2 - 1 , j1 : j2 , k1 : k2 , ik ) = rho ( i2 - 1 , j1 : j2 , k1 : k2 , ik ) + & rho ( i2 + 1 , j1 : j2 , k1 : k2 , ik ) rho ( i2 , j1 : j2 , k1 : k2 , ik ) = rho ( i2 - 1 , j1 : j2 , k1 : k2 , ik ) end if end if end subroutine end module","tags":"","loc":"sourcefile/mpi_curr_interface.f90.html"},{"title":"parallel.F90 – ALaDyn","text":"This file depends on sourcefile~~parallel.f90~~EfferentGraph sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~parallel.f90~~AfferentGraph sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~parallel.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~parallel.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules parallel Source Code parallel.F90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module parallel use mpi_var use common_param use util , only : init_random_seed #if !defined (_CRESCO) #define ENABLE_MPI_LONG_INT #endif #if defined (FORCE_OLD_MPI) implicit none include 'mpif.h' #else use mpi implicit none #endif integer , parameter :: offset_kind = mpi_offset_kind , & whence = mpi_seek_set integer :: mpi_err real ( dp ), allocatable :: fp0x (:, :, :, :), fp1x (:, :, :, :) integer :: status ( mpi_status_size ), error , mpi_sd contains !================== subroutine check_decomposition if ( npe_yz > 0 ) then nprocy = npe_yz if ( nz > 1 ) then nprocz = npe_yz else nprocz = 1 end if nprocx = mpi_size / nprocy / nprocz end if if ( nprocx < 0 . or . nprocy < 0 . or . nprocz < 0 . or . & nprocx * nprocy * nprocz /= mpi_size ) then if ( mpi_rank == 0 ) then write ( 6 , * ) 'Invalid MPI decomposition' write ( 6 , * ) 'mpi_size =' , mpi_size write ( 6 , * ) 'nprocx =' , nprocx , 'nprocy =' , nprocy , 'nprocz =' , & nprocz stop 674 end if end if end subroutine subroutine start_parallel ( ncmp , p_ind , b_ind ) integer , intent ( in ) :: ncmp , p_ind , b_ind integer :: ipe , pen , pkind , bkind call mpi_init ( error ) call mpi_comm_size ( mpi_comm_world , mpi_size , error ) call mpi_comm_rank ( mpi_comm_world , mpi_rank , error ) call check_decomposition !=================================== npe_xloc = nprocx npe_yloc = nprocy npe_zloc = nprocz npe = mpi_size pe_min = 0 pe_max = npe - 1 mype = mpi_rank pe0 = ( mype == 0 ) pe1 = ( mype == pe_max ) prl = ( npe > 1 ) prlx = ( npe_xloc > 1 ) prly = ( npe_yloc > 1 ) prlz = ( npe_zloc > 1 ) comm = mpi_comm_world mpi_sd = mpi_double_precision call mpi_type_contiguous ( ncmp + 1 , mpi_sd , partype , error ) call mpi_type_commit ( partype , error ) !================ ndims = 3 dims ( 1 ) = npe_yloc dims ( 2 ) = npe_zloc dims ( 3 ) = npe_xloc !================ imodzx = mype / npe_yloc imody = mod ( mype , npe_yloc ) imodz = mod ( imodzx , npe_zloc ) imodx = imodzx / npe_zloc imodyx = imody + npe_yloc * npe_zloc * imodx imodyz = imody + npe_yloc * imodz !====================== !================= !================= MPI cartesiantopology with (imody,imodz,imodx) coordinates ! mype=imody+npe_yloc*imodzx ! imodzx=imodz+npe_zloc*imodx !---------------------------- ! mype=imodyx+npe_yloc*imodz ! imodyx=imody+npe_yloc*npe_zloc*imodx !=================== ! mype=imodyz+npe_yloc*npe_zloc*imodx col_or ( 1 ) = dims ( 1 ) * ( imodz + dims ( 2 ) * imodx ) ! imodyz=imody+npe_yloc*imodz col_or ( 2 ) = imody + dims ( 1 ) * dims ( 2 ) * imodx !========================== col_or ( 3 ) = imody + dims ( 1 ) * imodz !====================== call mpi_comm_split ( comm , col_or ( 1 ), imody , comm_col ( 1 ), error ) call mpi_comm_rank ( comm_col ( 1 ), coor ( 1 ), error ) call mpi_comm_split ( comm , col_or ( 2 ), imodz , comm_col ( 2 ), error ) call mpi_comm_rank ( comm_col ( 2 ), coor ( 2 ), error ) call mpi_comm_split ( comm , col_or ( 3 ), imodx , comm_col ( 3 ), error ) call mpi_comm_rank ( comm_col ( 3 ), coor ( 3 ), error ) !imodzx=>> all pes in the (imodz,imodx) plane for given imody !imodyx=> all pes in the (imody,imodx) plane for given imodz !all pes in the (imody,imodz) plane for given imodx !============ for diagnostic pe0y = imody == 0 pe1y = imody == npe_yloc - 1 pe0z = imodz == 0 pe1z = imodz == npe_zloc - 1 pex0 = imodx == 0 pex1 = imodx == npe_xloc - 1 !=========================== pe_min_y = 0 pe_max_y = npe_yloc - 1 pe_min_z = 0 pe_max_z = npe_zloc - 1 pe_min_x = 0 pe_max_x = npe_xloc - 1 !=========================== xl_bd = . false . xr_bd = . false . yl_bd = . false . yr_bd = . false . zl_bd = . false . zr_bd = . false . if ( pex0 ) xl_bd = . true . if ( pex1 ) xr_bd = . true . if ( pe0y ) yl_bd = . true . if ( pe1y ) yr_bd = . true . if ( pe0z ) zl_bd = . true . if ( pe1z ) zr_bd = . true . pe0x = pex0 pe1x = pex1 ! Logical idensification of mpi boundary coordinates pkind = max ( 1 , p_ind ) bkind = max ( 1 , b_ind ) !==================== allocate ( loc_npart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , 1 : pkind )) loc_npart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , 1 : pkind ) = 0 !======================================== allocate ( loc_ne_ionz ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 )) loc_ne_ionz ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 ) = 0 allocate ( loc_tpart ( npe )) loc_tpart ( 1 : npe ) = 0 allocate ( loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , 1 : bkind )) loc_nbpart ( 0 : npe_yloc - 1 , 0 : npe_zloc - 1 , 0 : npe_xloc - 1 , 1 : bkind ) = 0 allocate ( yp_next ( npe_yloc ), yp_prev ( npe_yloc )) allocate ( zp_next ( npe_zloc ), zp_prev ( npe_zloc )) allocate ( xp_next ( npe_xloc ), xp_prev ( npe_xloc )) yp_next ( 1 ) = imody yp_prev ( 1 ) = imody if ( npe_yloc > 1 ) then do ipe = 1 , npe_yloc - 1 pen = imody + ipe yp_next ( ipe ) = mod ( pen , npe_yloc ) !============================ pen = imody - ipe if ( pen < 0 ) pen = pen + npe_yloc yp_prev ( ipe ) = pen end do end if zp_next ( 1 ) = imodz zp_prev ( 1 ) = imodz if ( npe_zloc > 1 ) then do ipe = 1 , npe_zloc - 1 pen = imodz + ipe zp_next ( ipe ) = mod ( pen , npe_zloc ) pen = imodz - ipe if ( pen < 0 ) pen = pen + npe_zloc zp_prev ( ipe ) = pen end do end if xp_next ( 1 ) = imodx xp_prev ( 1 ) = imodx if ( prlx ) then do ipe = 1 , npe_xloc - 1 pen = imodx + ipe xp_next ( ipe ) = mod ( pen , npe_xloc ) !============= output arrays pen = imodx - ipe if ( pen < 0 ) pen = pen + npe_xloc xp_prev ( ipe ) = pen end do end if !========================================== ! INITIALIZE THE RANDOM SEED FOR EVERY MYPE !========================================== call init_random_seed ( mype ) !call processor_grid_diag end subroutine subroutine mpi_write_dp ( buf , bufsize , disp , nchar , fout ) real ( dp ), intent ( in ) :: buf (:) integer , intent ( in ) :: bufsize , nchar integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout !=========================== integer :: ierr , thefile !======================== call mpi_file_open ( comm , fout , mpi_mode_wronly + mpi_mode_create , & mpi_info_null , thefile , ierr ) call mpi_file_write_at ( thefile , disp , buf , bufsize , mpi_sd , & mpi_status_ignore , ierr ) call mpi_file_close ( thefile , ierr ) end subroutine !======== each process acces thefile and writes at disp(byte) coordinate subroutine mpi_write_row_dp ( buf , bufsize , disp , nchar , fout ) real ( dp ), intent ( in ) :: buf (:) integer , intent ( in ) :: bufsize , nchar integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout integer :: ierr , thefile !======================================= call mpi_file_open ( comm_col ( 2 ), fout , mpi_mode_wronly + mpi_mode_create & , mpi_info_null , thefile , ierr ) !call mpi_file_set_view(thefile, disp, mpi_sd, & call mpi_file_write_at ( thefile , disp , buf , bufsize , mpi_sd , & mpi_status_ignore , ierr ) ! mpi_sd, 'native', & call mpi_file_close ( thefile , ierr ) end subroutine !mpi_info_null, ierr) subroutine mpi_write_col_dp ( buf , bufsize , disp , nchar , fout ) real ( dp ), intent ( in ) :: buf (:) integer , intent ( in ) :: bufsize , nchar integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout integer :: ierr , thefile !=================== call mpi_file_open ( comm_col ( 1 ), fout , mpi_mode_wronly + mpi_mode_create & , mpi_info_null , thefile , ierr ) !call mpi_file_set_view(thefile, disp, mpi_sd, & call mpi_file_write_at ( thefile , disp , buf , bufsize , & mpi_double_precision , mpi_status_ignore , ierr ) ! mpi_sd, 'native', & call mpi_file_close ( thefile , ierr ) ! mpi_info_null, ierr) end subroutine subroutine mpi_read_col_dp ( buf , bufsize , disp , nchar , fout ) real ( dp ), intent ( inout ) :: buf (:) integer , intent ( in ) :: bufsize , nchar integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout integer :: ierr , thefile !======================== call mpi_file_open ( comm_col ( 1 ), fout , mpi_mode_rdonly , mpi_info_null , & thefile , ierr ) !call mpi_file_set_view(thefile, disp, mpi_sd, & call mpi_file_read_at ( thefile , disp , buf , bufsize , mpi_sd , & mpi_status_ignore , ierr ) !mpi_sd, 'native', & call mpi_file_close ( thefile , ierr ) !mpi_info_null, ierr) end subroutine subroutine mpi_read_dp ( buf , bufsize , disp , nchar , fout ) real ( dp ), intent ( inout ) :: buf (:) integer , intent ( in ) :: bufsize , nchar integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout integer :: ierr , thefile !======================================= call mpi_file_open ( comm , fout , mpi_mode_rdonly , mpi_info_null , & thefile , ierr ) call mpi_file_read_at ( thefile , disp , buf , bufsize , mpi_sd , & mpi_status_ignore , ierr ) !call mpi_file_set_view(thefile, disp, mpi_sd, & call mpi_file_close ( thefile , ierr ) ! mpi_sd, 'native', mpi_info_null, ierr) end subroutine !call mpi_file_seek(thefile,disp,whence,ierr) subroutine mpi_write_part ( buf , bufsize , loc_np , disp , nchar , fout ) real ( sp ), intent ( in ) :: buf (:) integer , intent ( in ) :: bufsize , loc_np , nchar integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout integer :: ierr , thefile !=============================== call mpi_file_open ( comm , fout , mpi_mode_wronly + mpi_mode_create , & mpi_info_null , thefile , ierr ) call mpi_file_set_view ( thefile , disp , mpi_real , mpi_real , 'native' , & mpi_info_null , ierr ) call mpi_file_write ( thefile , loc_np , 1 , mpi_integer , & mpi_status_ignore , ierr ) call mpi_file_write ( thefile , buf , bufsize , mpi_real , & mpi_status_ignore , ierr ) call mpi_file_close ( thefile , ierr ) !mpi_file_set_view is broken on Windows 10 with Intel MPI 5 (don't have money to upgrade MPI-Lib and check) end subroutine !please disable any binary output in Windows/IFORT if it doesn't work for you subroutine mpi_write_part_col ( buf , bufsize , disp , nchar , fout ) real ( sp ), intent ( in ) :: buf (:) integer , intent ( in ) :: bufsize , nchar integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout !======================== integer :: ierr , thefile !======================== call mpi_file_open ( comm_col ( 1 ), fout , mpi_mode_wronly + mpi_mode_create & , mpi_info_null , thefile , ierr ) call mpi_file_set_view ( thefile , disp , mpi_real , mpi_real , 'native' , & mpi_info_null , ierr ) call mpi_file_write ( thefile , buf , bufsize , mpi_real , & mpi_status_ignore , ierr ) !mpi_file_set_view is broken on Windows 10 with Intel MPI 5 (don't have money to upgrade MPI-Lib and check) call mpi_file_close ( thefile , ierr ) !please disable any binary output in Windows/IFORT if it doesn't work for you end subroutine subroutine mpi_write_field ( buf , bufsize , header , header_size , disp , & nchar , fout ) real ( sp ), intent ( in ) :: buf (:) integer , intent ( in ) :: bufsize , nchar , header_size , header (:) integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout integer :: ierr , thefile !======================== call mpi_file_open ( comm , fout , mpi_mode_wronly + mpi_mode_create , & mpi_info_null , thefile , ierr ) call mpi_file_set_view ( thefile , disp , mpi_real , mpi_real , 'native' , & mpi_info_null , ierr ) call mpi_file_write ( thefile , header , header_size , mpi_integer , & mpi_status_ignore , ierr ) !mpi_file_set_view is broken on Windows 10 with Intel MPI 5 (don't have money to upgrade MPI-Lib and check) call mpi_file_write ( thefile , buf , bufsize , mpi_real , & mpi_status_ignore , ierr ) !please disable any binary output in Windows/IFORT if it doesn't work for you call mpi_file_close ( thefile , ierr ) end subroutine subroutine mpi_write_field_col ( buf , bufsize , header , header_size , & disp , nchar , fout ) !======================== real ( sp ), intent ( in ) :: buf (:) integer , intent ( in ) :: bufsize , nchar , header_size , header (:) integer ( offset_kind ), intent ( in ) :: disp character ( nchar ), intent ( in ) :: fout !different from mpi_write_field because of the different communicator in integer :: ierr , thefile !mpi_file_open call mpi_file_open ( comm_col ( 1 ), fout , mpi_mode_wronly + mpi_mode_create & , mpi_info_null , thefile , ierr ) call mpi_file_set_view ( thefile , disp , mpi_real , mpi_real , 'native' , & mpi_info_null , ierr ) call mpi_file_write ( thefile , header , header_size , mpi_integer , & mpi_status_ignore , ierr ) !mpi_file_set_view is broken on Windows 10 with Intel MPI 5 (don't have money to upgrade MPI-Lib and check) call mpi_file_write ( thefile , buf , bufsize , mpi_real , & mpi_status_ignore , ierr ) !please disable any binary output in Windows/IFORT if it doesn't work for you call mpi_file_close ( thefile , ierr ) end subroutine subroutine End_parallel call MPI_FINALIZE ( error ) end subroutine subroutine exchange_idata ( sr , idat , lenw , ipe , tag ) integer , intent ( in ) :: lenw , ipe , tag integer , intent ( inout ) :: idat (:) logical , intent ( in ) :: sr if ( sr ) then !======================= call mpi_send ( idat ( 1 ), lenw , mpi_integer , ipe , tag , comm , error ) !===================================== else call mpi_recv ( idat ( 1 ), lenw , mpi_integer , ipe , tag , comm , status , & error ) end if end subroutine subroutine exchange_2d_idata ( sr , idat , n1 , n2 , ipe , tag ) logical , intent ( in ) :: sr integer , intent ( inout ) :: idat (:, :) integer , intent ( in ) :: n1 , n2 , ipe , tag integer :: lenw lenw = n1 * n2 if ( sr ) then call mpi_send ( idat ( 1 , 1 ), lenw , mpi_integer , ipe , tag , comm , error ) else call mpi_recv ( idat ( 1 , 1 ), lenw , mpi_integer , ipe , tag , comm , status , & error ) end if end subroutine subroutine exchange_3d_sp_data ( sr , dat0 , n1 , n2 , n3 , ipe , tag ) integer , intent ( in ) :: n1 , n2 , n3 , ipe , tag real ( sp ), intent ( inout ) :: dat0 (:, :, :) logical , intent ( in ) :: sr integer :: lenw lenw = n1 * n2 * n3 if ( sr ) then call mpi_send ( dat0 ( 1 , 1 , 1 ), lenw , mpi_real , ipe , tag , comm , error ) !==================== else call mpi_recv ( dat0 ( 1 , 1 , 1 ), lenw , mpi_real , ipe , tag , comm , status , & error ) end if end subroutine subroutine exchange_1d_grdata ( sr , dat0 , lenw , ipe , tag ) logical , intent ( in ) :: sr real ( dp ), intent ( inout ) :: dat0 (:) integer , intent ( in ) :: lenw , ipe , tag if ( sr ) then call mpi_send ( dat0 ( 1 ), lenw , mpi_sd , ipe , tag , comm , error ) else !==================== call mpi_recv ( dat0 ( 1 ), lenw , mpi_sd , ipe , tag , comm , status , error ) end if end subroutine subroutine exchange_2d_grdata ( sr , dat0 , n1 , n2 , ipe , tag ) logical , intent ( in ) :: sr real ( dp ), intent ( inout ) :: dat0 (:, :) integer , intent ( in ) :: n1 , n2 , ipe , tag integer :: lenw lenw = n1 * n2 if ( sr ) then call mpi_send ( dat0 ( 1 , 1 ), lenw , mpi_sd , ipe , tag , comm , error ) else call mpi_recv ( dat0 ( 1 , 1 ), lenw , mpi_sd , ipe , tag , comm , status , & error ) end if end subroutine !==================== subroutine exchange_3d_grdata ( sr , dat0 , lenw , dir , ipe ) integer , intent ( in ) :: lenw , dir , ipe real ( dp ), intent ( inout ) :: dat0 (:, :, :) logical , intent ( in ) :: sr integer :: tag tag = 10 + ipe if ( sr ) then call mpi_send ( dat0 ( 1 , 1 , 1 ), lenw , mpi_sd , ipe , tag , comm_col ( dir ), & error ) !========================= else call mpi_recv ( dat0 ( 1 , 1 , 1 ), lenw , mpi_sd , ipe , tag , comm_col ( dir ), & status , error ) end if end subroutine subroutine exchange_grdata ( sr , dat0 , lenw , dir , ipe ) integer , intent ( in ) :: lenw , dir , ipe real ( dp ), intent ( inout ) :: dat0 (:, :, :, :) logical , intent ( in ) :: sr integer :: tag tag = 10 + ipe if ( sr ) then call mpi_send ( dat0 ( 1 , 1 , 1 , 1 ), lenw , mpi_sd , ipe , tag , comm_col ( dir ), & error ) !========================= else call mpi_recv ( dat0 ( 1 , 1 , 1 , 1 ), lenw , mpi_sd , ipe , tag , comm_col ( dir ), & status , error ) end if end subroutine subroutine realvec_distribute ( rs , rv , nproc ) integer , intent ( in ) :: nproc real ( dp ), intent ( in ) :: rs real ( dp ) :: rv (:), rc integer :: ipe if (. not . pe0 ) then call mpi_send ( rs , 1 , mpi_real , pe_min , 20 + mype , comm , error ) else rv ( 1 ) = rs do ipe = 1 , nproc - 1 call mpi_recv ( rc , 1 , mpi_real , ipe , 20 + ipe , comm , status , error ) rv ( ipe + 1 ) = rc end do end if end subroutine subroutine intvec_distribute ( ns , nc , nproc ) integer , intent ( in ) :: ns , nproc integer , intent ( inout ) :: nc (:) integer :: ipe , nr if (. not . pe0 ) then call mpi_send ( ns , 1 , mpi_integer , pe_min , mype , comm , error ) else nc ( 1 ) = ns do ipe = 1 , nproc - 1 call mpi_recv ( nr , 1 , mpi_integer , ipe , ipe , comm , status , error ) nc ( ipe + 1 ) = nr end do end if call MPI_BCAST ( nc , nproc , mpi_integer , pe_min , comm , error ) end subroutine subroutine sr_idata ( ns , nr , dir , side ) integer , intent ( in ) :: ns , dir , side integer , intent ( out ) :: nr integer :: pes , per , tag nr = 0 tag = 100 + dir select case ( dir ) case ( 1 ) if ( side > 0 ) then pes = yp_prev ( side ) per = yp_next ( side ) !============= else pes = yp_next ( - side ) per = yp_prev ( - side ) !sends to left ns data end if case ( 2 ) if ( side > 0 ) then pes = zp_prev ( side ) per = zp_next ( side ) else pes = zp_next ( - side ) per = zp_prev ( - side ) end if case ( 3 ) if ( side > 0 ) then pes = xp_prev ( side ) per = xp_next ( side ) else pes = xp_next ( - side ) per = xp_prev ( - side ) end if end select call mpi_sendrecv ( ns , 1 , mpi_integer , pes , tag , nr , 1 , mpi_integer , & per , tag , comm_col ( dir ), status , error ) !receives from right nr daata end subroutine !sends to right ns data subroutine sr_pdata ( sdata , rdata , ns , nr , dir , side ) real ( dp ), intent ( in ) :: sdata (:) real ( dp ), intent ( out ) :: rdata (:) integer , intent ( in ) :: ns , nr , dir , side integer :: tag , pes , per !receives form left nr data tag = 1000 + dir select case ( dir ) case ( 1 ) if ( side > 0 ) then pes = yp_prev ( side ) per = yp_next ( side ) else pes = yp_next ( - side ) per = yp_prev ( - side ) end if case ( 2 ) if ( side > 0 ) then pes = zp_prev ( side ) per = zp_next ( side ) else pes = zp_next ( - side ) per = zp_prev ( - side ) end if case ( 3 ) if ( side > 0 ) then pes = xp_prev ( side ) per = xp_next ( side ) else pes = xp_next ( - side ) per = xp_prev ( - side ) end if end select if ( ns * nr > 0 ) then call mpi_sendrecv ( sdata ( 1 ), ns , mpi_sd , pes , tag , rdata ( 1 ), nr , & mpi_sd , per , tag , comm_col ( dir ), status , error ) else if ( ns > 0 ) call mpi_send ( sdata ( 1 ), ns , mpi_sd , pes , tag , & comm_col ( dir ), error ) if ( nr > 0 ) call mpi_recv ( rdata ( 1 ), nr , mpi_sd , per , tag , & comm_col ( dir ), status , error ) end if end subroutine subroutine sr_vidata ( sidat , ridat , n2 , n3 , dir , side ) integer , intent ( in ) :: n2 , n3 , dir , side integer , intent ( in ) :: sidat ( n2 , n3 ) integer , intent ( out ) :: ridat ( n2 , n3 ) integer :: tag , pes , per , nq !================== tag = 10 + dir nq = n2 * n3 select case ( dir ) case ( 1 ) if ( side > 0 ) then pes = yp_prev ( side ) per = yp_next ( side ) else pes = yp_next ( - side ) per = yp_prev ( - side ) end if case ( 2 ) if ( side > 0 ) then pes = zp_prev ( side ) per = zp_next ( side ) else pes = zp_next ( - side ) per = zp_prev ( - side ) end if case ( 3 ) if ( side > 0 ) then pes = xp_prev ( side ) per = xp_next ( side ) else pes = xp_next ( - side ) per = xp_prev ( - side ) end if end select call mpi_sendrecv ( sidat ( 1 , 1 ), nq , mpi_integer , pes , tag , ridat ( 1 , 1 ), & nq , mpi_integer , per , tag , comm_col ( dir ), status , error ) !==================== end subroutine subroutine exchange_pdata ( sr , pdata , lenw , ipe , tag ) integer , intent ( in ) :: lenw , ipe , tag logical , intent ( in ) :: sr real ( sp ), intent ( inout ) :: pdata (:) if ( sr ) then call mpi_send ( pdata ( 1 ), lenw , mpi_real , pe_min , tag , comm , error ) else call mpi_recv ( pdata ( 1 ), lenw , mpi_real , ipe , tag , comm , status , & error ) end if end subroutine subroutine exchange_rdata ( buff , sr , lenw , ipe , dir , tag ) real ( dp ), intent ( inout ) :: buff (:) logical , intent ( in ) :: sr integer , intent ( in ) :: lenw , ipe , dir , tag if ( sr ) then call mpi_send ( buff ( 1 ), lenw , mpi_sd , ipe , tag , comm_col ( dir ), error ) else call mpi_recv ( buff ( 1 ), lenw , mpi_sd , ipe , tag , comm_col ( dir ), & status , error ) end if end subroutine subroutine exchange_rdata_int ( buff , sr , lenw , ipe , dir , tag ) integer , intent ( inout ) :: buff (:) logical , intent ( in ) :: sr integer , intent ( in ) :: lenw , ipe , dir , tag if ( sr ) then call mpi_send ( buff ( 1 ), lenw , mpi_integer , ipe , tag , comm_col ( dir ), error ) else call mpi_recv ( buff ( 1 ), lenw , mpi_integer , ipe , tag , comm_col ( dir ), & status , error ) end if end subroutine !======================= subroutine vint_2d_bcast ( mydat , n1 , n2 ) integer , intent ( in ) :: n1 , n2 integer , intent ( inout ), dimension (:, :) :: mydat integer :: nt nt = n1 * n2 call MPI_BCAST ( mydat ( 1 , 1 ), nt , mpi_integer , pe_min , comm , error ) end subroutine subroutine vint_bcast ( mydat , nt ) integer , intent ( in ) :: nt integer , intent ( inout ) :: mydat ( nt ) call MPI_BCAST ( mydat , nt , mpi_integer , pe_min , comm , error ) end subroutine subroutine int_bcast ( mydat ) integer , intent ( in ) :: mydat call MPI_BCAST ( mydat , 1 , mpi_integer , pe_min , comm , error ) end subroutine subroutine all_gather_dpreal ( rv_send , rv_recv , dir , nt ) real ( dp ), intent ( inout ) :: rv_send (:), rv_recv (:) integer , intent ( in ) :: dir , nt call mpi_allgather ( rv_send , nt , mpi_sd , rv_recv , nt , mpi_sd , & comm_col ( dir ), error ) end subroutine subroutine allreduce_dpreal ( ib , rv_loc , rv , nt ) integer , intent ( in ) :: ib , nt real ( dp ), intent ( in ) :: rv_loc (:) real ( dp ), intent ( out ) :: rv (:) if ( prl ) then select case ( ib ) case ( - 1 ) !min call mpi_allreduce ( rv_loc , rv , nt , mpi_sd , mpi_min , comm , error ) case ( 0 ) !sum call mpi_allreduce ( rv_loc , rv , nt , mpi_sd , mpi_sum , comm , error ) case ( 1 ) !max call mpi_allreduce ( rv_loc , rv , nt , mpi_sd , mpi_max , comm , error ) end select else rv = rv_loc end if end subroutine #ifdef ENABLE_MPI_LONG_INT ! WARNING: unsupported on some architecture!! subroutine allreduce_big_int ( n0 , n1 ) integer ( dp ), intent ( in ) :: n0 integer ( dp ), intent ( out ) :: n1 if ( prl ) then call mpi_allreduce ( n0 , n1 , 1 , mpi_long_int , mpi_sum , comm , error ) end if !=========================== end subroutine #endif subroutine allreduce_sint ( ib , dt0 , dt_tot ) integer , intent ( in ) :: ib integer , intent ( in ) :: dt0 integer , intent ( out ) :: dt_tot if ( prl ) then select case ( ib ) case ( - 1 ) !--------------------------------------------- call MPI_REDUCE ( dt0 , dt_tot , 1 , mpi_integer , mpi_min , pe_min , comm , & error ) case ( 0 ) call MPI_REDUCE ( dt0 , dt_tot , 1 , mpi_integer , mpi_sum , pe_min , comm , & error ) case ( 1 ) call MPI_REDUCE ( dt0 , dt_tot , 1 , mpi_integer , mpi_max , pe_min , comm , & error ) end select call MPI_BCAST ( dt_tot , 1 , mpi_integer , pe_min , comm , error ) else dt_tot = dt0 end if end subroutine subroutine allreduce_vint ( ib , dt0 , dt_tot , nt ) integer , intent ( in ) :: ib , nt integer , intent ( in ) :: dt0 ( nt ) integer , intent ( out ) :: dt_tot ( nt ) if ( prl ) then select case ( ib ) case ( - 1 ) !max call MPI_REDUCE ( dt0 , dt_tot , nt , mpi_integer , mpi_min , pe_min , comm , & error ) case ( 0 ) !============================== call MPI_REDUCE ( dt0 , dt_tot , nt , mpi_integer , mpi_sum , pe_min , comm , & error ) case ( 1 ) call MPI_REDUCE ( dt0 , dt_tot , nt , mpi_integer , mpi_max , pe_min , comm , & error ) end select call MPI_BCAST ( dt_tot , nt , mpi_integer , pe_min , comm , error ) else dt_tot = dt0 end if end subroutine subroutine bcast_grdata ( dat0 , n1 , n2 , n3 , nc ) integer , intent ( in ) :: n1 , n2 , n3 , nc real ( dp ), intent ( inout ) :: dat0 (:, :, :, :) integer :: lenw lenw = n1 * n2 * n3 * nc call MPI_BCAST ( dat0 ( 1 , 1 , 1 , 1 ), lenw , mpi_sd , pe_min , comm , error ) end subroutine subroutine bcast_realv_sum ( ib , dt_prl , dt_tot , nt ) logical , intent ( in ) :: ib integer , intent ( in ) :: nt real ( dp ), intent ( in ) :: dt_prl ( nt ) real ( dp ), intent ( out ) :: dt_tot ( nt ) if ( prl ) then call MPI_REDUCE ( dt_prl , dt_tot , nt , mpi_sd , mpi_sum , pe_min , comm , & error ) if ( ib ) call MPI_BCAST ( dt_tot , nt , mpi_sd , pe_min , comm , error ) else dt_tot = dt_prl end if end subroutine subroutine bcast_int_sum ( dt_prl , dt_tot ) integer , intent ( in ) :: dt_prl integer , intent ( out ) :: dt_tot if ( prl ) then call MPI_REDUCE ( dt_prl , dt_tot , 1 , mpi_integer , mpi_sum , pe_min , comm , & error ) call MPI_BCAST ( dt , 1 , mpi_integer , pe_min , comm , error ) else dt = dt_prl end if end subroutine subroutine real_bcast ( dt_tot , ndt ) integer , intent ( in ) :: ndt real ( dp ) :: dt_tot ( ndt ) call MPI_BCAST ( dt_tot , ndt , mpi_sd , pe_min , comm , error ) end subroutine subroutine local_to_global_grdata ( buff1 , buff2 , lenws , ip , dir ) real ( dp ), intent ( in ) :: buff1 (:) real ( dp ), intent ( out ) :: buff2 (:) integer , intent ( in ) :: lenws , ip , dir integer pes , per , tag tag = 250 + ip select case ( dir ) case ( 1 ) per = yp_prev ( ip ) pes = yp_next ( ip ) case ( 2 ) per = zp_prev ( ip ) pes = zp_next ( ip ) case ( 3 ) per = xp_prev ( ip ) pes = xp_next ( ip ) end select call mpi_sendrecv ( buff1 ( 1 ), lenws , mpi_sd , pes , tag , buff2 ( 1 ), lenws , & mpi_sd , per , tag , comm_col ( dir ), status , error ) end subroutine subroutine exchange_bd_3d_data ( buff1 , lenws , buff2 , lenwr , dir , side ) real ( dp ), intent ( in ) :: buff1 (:, :, :) real ( dp ), intent ( out ) :: buff2 (:, :, :) integer , intent ( in ) :: lenws , lenwr , dir integer ( hp_int ), intent ( in ) :: side integer pes , per , tag !=============================== ! side > recievies next sends left tag = 610 select case ( dir ) case ( 1 ) if ( side > 0 ) then pes = yp_prev ( side ) per = yp_next ( side ) else pes = yp_next ( - side ) per = yp_prev ( - side ) end if case ( 2 ) if ( side > 0 ) then pes = zp_prev ( side ) per = zp_next ( side ) else pes = zp_next ( - side ) per = zp_prev ( - side ) end if case ( 3 ) if ( side > 0 ) then pes = xp_prev ( side ) per = xp_next ( side ) else pes = xp_next ( - side ) per = xp_prev ( - side ) end if end select call mpi_sendrecv ( buff1 ( 1 , 1 , 1 ), lenws , mpi_sd , pes , tag , buff2 ( 1 , 1 , 1 ), lenwr , & mpi_sd , per , tag , comm_col ( dir ), status , error ) end subroutine subroutine exchange_bdx_data ( buff1 , buff2 , lenws , lenwr , dir , side ) real ( dp ), intent ( in ) :: buff1 (:) real ( dp ), intent ( out ) :: buff2 (:) integer , intent ( in ) :: lenws , lenwr , dir integer ( hp_int ), intent ( in ) :: side integer pes , per , tag !=============================== tag = 610 select case ( dir ) case ( 1 ) if ( side > 0 ) then pes = yp_prev ( side ) per = yp_next ( side ) else pes = yp_next ( - side ) per = yp_prev ( - side ) end if case ( 2 ) if ( side > 0 ) then pes = zp_prev ( side ) per = zp_next ( side ) else pes = zp_next ( - side ) per = zp_prev ( - side ) end if case ( 3 ) if ( side > 0 ) then pes = xp_prev ( side ) per = xp_next ( side ) else pes = xp_next ( - side ) per = xp_prev ( - side ) end if end select call mpi_sendrecv ( buff1 ( 1 ), lenws , mpi_sd , pes , tag , buff2 ( 1 ), lenwr , & mpi_sd , per , tag , comm_col ( dir ), status , error ) end subroutine subroutine processor_grid_diag !============================ integer :: i character ( 10 ) :: fname = '          ' integer , parameter :: lun = 10 if ( mype < 10 ) then write ( fname , '(a9,i1)' ) 'proc_map0' , mype else write ( fname , '(a8,i2)' ) 'proc_map' , mype end if open ( lun , file = fname // '.dat' , form = 'formatted' ) write ( lun , * ) '== local carteisan ranks' write ( lun , * ) imody , imodz , imodx write ( lun , * ) coor ( 1 : 3 ) i = 1 write ( lun , * ) '====== y-neighbors=========' write ( lun , * ) yp_next ( i ), yp_prev ( i ) write ( lun , * ) '====== z-neighbors=========' write ( lun , * ) zp_next ( i ), zp_prev ( i ) write ( lun , * ) '====== x-neighbors=========' write ( lun , * ) xp_next ( i ), xp_prev ( i ) write ( lun , * ) '======== comm_col===========' write ( lun , * ) comm_col ( 1 : 3 ) close ( lun ) end subroutine !================== side <0 receives from left   side >0 receives from right end module","tags":"","loc":"sourcefile/parallel.f90.html"},{"title":"mpi_var.f90 – ALaDyn","text":"This file depends on sourcefile~~mpi_var.f90~~EfferentGraph sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mpi_var.f90~~AfferentGraph sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~ionize.f90->sourcefile~mpi_var.f90 sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~set_grid_param.f90->sourcefile~mpi_var.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~system_utilities.f90 system_utilities.f90 sourcefile~system_utilities.f90->sourcefile~mpi_var.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~init_part_distrib.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~read_input.f90 read_input.f90 sourcefile~read_input.f90->sourcefile~mpi_var.f90 sourcefile~stretched_grid.f90 stretched_grid.f90 sourcefile~stretched_grid.f90->sourcefile~mpi_var.f90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~mpi_curr_interface.f90 mpi_curr_interface.f90 sourcefile~mpi_curr_interface.f90->sourcefile~parallel.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~init_grid_fields.f90 sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~window.f90 window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~diag_part_and_fields.f90->sourcefile~parallel.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~ionize.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~prl_fft.f90 prl_fft.f90 sourcefile~prl_fft.f90->sourcefile~parallel.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_part_lib.f90 grid_part_lib.f90 sourcefile~grid_part_lib.f90->sourcefile~stretched_grid.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~pic_out.f90 pic_out.f90 sourcefile~pic_out.f90->sourcefile~parallel.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~start_all.f90->sourcefile~set_grid_param.f90 sourcefile~start_all.f90->sourcefile~system_utilities.f90 sourcefile~start_all.f90->sourcefile~read_input.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~curr_and_fields_util.f90->sourcefile~init_grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_fields.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~grid_part_connect.f90 grid_part_connect.f90 sourcefile~curr_and_fields_util.f90->sourcefile~grid_part_connect.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_curr_interface.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~psolve.f90 psolve.f90 sourcefile~pic_out_util.f90->sourcefile~psolve.f90 sourcefile~grid_part_util.f90 grid_part_util.f90 sourcefile~pic_out_util.f90->sourcefile~grid_part_util.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_curr_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~init_grid_fields.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~psolve.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~grid_part_util.f90 sourcefile~fluid_density_momenta.f90->sourcefile~grid_fields.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~grid_part_connect.f90->sourcefile~grid_part_lib.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~pic_out.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~psolve.f90->sourcefile~prl_fft.f90 sourcefile~psolve.f90->sourcefile~grid_fields.f90 sourcefile~grid_part_util.f90->sourcefile~grid_part_lib.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mpi_var Source Code mpi_var.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module mpi_var use precision_def implicit none integer , allocatable :: loc_npart (:, :, :, :), loc_nbpart (:, :, :, :) integer , allocatable :: loc_ne_ionz (:, :, :), loc_tpart (:) integer , allocatable :: yp_next (:), yp_prev (:) integer , allocatable :: zp_next (:), zp_prev (:) integer , allocatable :: xp_next (:), xp_prev (:) integer :: np_max , pe_npmax , np_min , pe_npmin integer :: mype , imodx , imody , imodz , npe , npe_yloc , npe_zloc , & npe_xloc integer :: npe_yz , mpi_size , mpi_rank integer :: partype integer :: imodzx , imodyz , imodyx integer :: pe_min , pe_max integer :: pe_min_y , pe_max_y , pe_min_z , pe_max_z , pe_min_x , pe_max_x integer :: ndims , dims ( 3 ) logical :: pe0y , pe0z , pe1y , pe1z , pe0 , pe1 , prl , prlx , prly , prlz logical :: xl_bd , yl_bd , zl_bd , xr_bd , yr_bd , zr_bd logical :: pe0x , pe1x , pex0 , pex1 integer :: comm , coor ( 3 ), comm_col ( 3 ), col_or ( 3 ) end module","tags":"","loc":"sourcefile/mpi_var.f90.html"},{"title":"mpi_field_interface.f90 – ALaDyn","text":"This file depends on sourcefile~~mpi_field_interface.f90~~EfferentGraph sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~fstruct_data.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~mpi_field_interface.f90->sourcefile~pstruct_data.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~mpi_field_interface.f90->sourcefile~grid_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_field_interface.f90->sourcefile~parallel.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mpi_field_interface.f90~~AfferentGraph sourcefile~mpi_field_interface.f90 mpi_field_interface.f90 sourcefile~curr_and_fields_util.f90 curr_and_fields_util.f90 sourcefile~curr_and_fields_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~pic_out_util.f90 pic_out_util.f90 sourcefile~pic_out_util.f90->sourcefile~mpi_field_interface.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~mpi_field_interface.f90 sourcefile~init_beam_part_distrib.f90 init_beam_part_distrib.f90 sourcefile~init_beam_part_distrib.f90->sourcefile~mpi_field_interface.f90 sourcefile~fluid_density_momenta.f90 fluid_density_momenta.f90 sourcefile~fluid_density_momenta.f90->sourcefile~mpi_field_interface.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_out_util.f90 sourcefile~aladyn.f90->sourcefile~init_beam_part_distrib.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 sourcefile~env_evolve_in_time.f90->sourcefile~curr_and_fields_util.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~fluid_density_momenta.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mpi_field_interface Source Code mpi_field_interface.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! !=================================================== !     Local grid structure under mpi domain decomposition !============== ! grid [1:n]   np=n+2  extended domain [1:np+2] ! interior [3,np]   ghost [1:2], [np+1:np+2] ! ! !             overlapping grid points !==================================================================== !                                     1-----2---- 3--- 4   |      pey+1 !                 1-----2----[3-------np-1--np]--np+1--np+2|    pey !1-2--------------np-1--np---np+1                          |pey-1 !====================  Fill  extended grid data  ====================================== !      Right(pey+1)     [3:4] ==>      pey [np+1:np+2]  right ghost data !      Left(pey-1)      [np+1:np+2]==> pey [1:2]        left  ghost data !=================================== module mpi_field_interface use pstruct_data use fstruct_data use parallel use grid_param implicit none integer , parameter , private :: x_parity ( 6 ) = [ - 1 , 1 , 1 , - 1 , 1 , 1 ] integer , parameter , private :: y_parity ( 6 ) = [ 1 , - 1 , 1 , 1 , - 1 , 1 ] integer , parameter , private :: z_parity ( 6 ) = [ 1 , 1 , - 1 , 1 , 1 , - 1 ] integer ( hp_int ), parameter :: lft = - 1 , rgt = 1 contains !=========================== subroutine field_xyzbd ( ef , nc ) real ( dp ), intent ( inout ) :: ef (:, :, :, :) integer , intent ( in ) :: nc integer :: ik , iy , ix , iz , str , stl integer :: i1 , i2 , j1 , j2 , k1 , k2 !========================== ! enter fields(1:n1,j01-1:j02+1,k01-1:k02+1,nc) ! Only for NON-PERIODIC boundaries str = 1 stl = 1 j1 = jy1 j2 = jy2 k1 = kz1 k2 = kz2 i1 = ix1 i2 = ix2 if ( pex0 ) then if ( ibx < 2 ) then do ik = 1 , nc do iz = k1 , k2 do iy = j1 , j2 ef ( ix1 - 1 , iy , iz , ik ) = 2. * ef ( ix1 , iy , iz , ik ) - & ef ( ix1 + 1 , iy , iz , ik ) end do end do end do end if i1 = i1 - 1 end if if ( pex1 ) then if ( ibx == 0 ) then do ik = 1 , nc do iz = k1 , k2 do iy = j1 , j2 ef ( ix2 + 1 , iy , iz , ik ) = 2. * ef ( ix2 , iy , iz , ik ) - & ef ( ix2 - 1 , iy , iz , ik ) end do end do end do end if if ( ibx == 1 ) then do ik = 1 , nc do iz = k1 , k2 do iy = j1 , j2 ef ( ix2 + 1 , iy , iz , ik ) = x_parity ( ik ) * ef ( ix2 , iy , iz , ik ) end do end do end do end if i2 = i2 + 1 end if if ( ndim < 2 ) return if ( yl_bd ) then if ( iby == 0 ) then do ik = 1 , nc do iz = k1 , k2 do ix = i1 , i2 ef ( ix , jy1 - 1 , iz , ik ) = 2. * ef ( ix , jy1 , iz , ik ) - & ef ( ix , jy1 + 1 , iz , ik ) end do end do end do end if if ( iby == 1 ) then do ik = 1 , nc do iz = k1 , k2 do ix = i1 , i2 ef ( ix , jy1 - 1 , iz , ik ) = y_parity ( ik ) * ef ( ix , jy1 + 1 , iz , ik ) end do end do end do end if j1 = j1 - 1 end if if ( yr_bd ) then if ( iby == 0 ) then do ik = 1 , nc do iz = k1 , k2 do ix = i1 , i2 ef ( ix , jy2 + 1 , iz , ik ) = 2. * ef ( ix , jy2 , iz , ik ) - & ef ( ix , jy2 - 1 , iz , ik ) end do end do end do end if if ( iby == 1 ) then do ik = 1 , nc do iz = k1 , k2 do ix = i1 , i2 ef ( ix , jy2 + 1 , iz , ik ) = y_parity ( ik ) * ef ( ix , jy2 - 1 , iz , ik ) end do end do end do end if j2 = j2 + 1 end if if ( ndim < 3 ) return if ( zl_bd ) then if ( ibz == 0 ) then do ik = 1 , nc do iy = j1 , j2 do ix = i1 , i2 ef ( ix , iy , kz1 - 1 , ik ) = 2 * ef ( ix , iy , kz1 , ik ) - & ef ( ix , iy , kz1 + 1 , ik ) end do end do end do end if if ( ibz == 1 ) then do ik = 1 , nc do iy = j1 , j2 do ix = i1 , i2 ef ( ix , iy , kz1 - 1 , ik ) = z_parity ( ik ) * ef ( ix , iy , kz1 + 1 , ik ) end do end do end do end if k1 = k1 - 1 end if if ( zr_bd ) then if ( ibz == 0 ) then do ik = 1 , nc do iy = j1 , j2 do ix = i1 , i2 ef ( ix , iy , kz2 + 1 , ik ) = 2 * ef ( ix , iy , kz2 , ik ) - & ef ( ix , iy , kz2 - 1 , ik ) end do end do end do end if if ( ibz == 1 ) then do ik = 1 , nc do iy = j1 , j2 do ix = i1 , i2 ef ( ix , iy , kz1 + 1 , ik ) = z_parity ( ik ) * ef ( ix , iy , kz1 - 1 , ik ) end do end do end do end if k2 = k2 + 1 end if end subroutine !======================================== subroutine fluid_left_xshift ( fld , den_x , den_yz , i1 , i2 , ic1 , ic2 , & xsh ) integer , intent ( in ) :: i1 , i2 , ic1 , ic2 , xsh real ( dp ), intent ( inout ) :: fld (:, :, :, :) real ( dp ), intent ( in ) :: den_x (:), den_yz (:, :) integer :: n1 , ic , ii , ix , j , iy , iz , kk , lenws integer :: j1 , j2 , k1 , k2 if ( xsh == 0 ) return j1 = jy1 j2 = jy2 k1 = kz1 k2 = kz2 n1 = loc_xgrid ( imodx )% ng lenws = ( ic2 + 1 - ic1 ) * ( k2 + 1 - k1 ) * ( j2 + 1 - j1 ) * xsh if ( prlx ) then !Sends to x-left side xsh data (i1:i1+xsh-1) !Recvs from x-right data(i2+1:i2+xsh)       i2=n1p-xsh kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 0 , xsh - 1 ix = i1 + j kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk call exchange_bdx_data ( aux1 , aux2 , lenws , lenws , 3 , rgt ) end if ! ! shifts (i1+xsx:i2+xsh=n1p)=>(i1:i2) do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do ix = i1 , i2 fld ( ix , iy , iz , ic ) = fld ( ix + xsh , iy , iz , ic ) end do end do end do end do if ( xl_bd ) then do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 fld ( i1 - 1 , iy , iz , ic ) = fld ( i1 + xsh - 1 , iy , iz , ic ) fld ( i1 , iy , iz , ic ) = 0.5 * fld ( i1 , iy , iz , ic ) + & 0.25 * ( fld ( i1 + 1 , iy , iz , ic ) + fld ( i1 - 1 , iy , iz , ic )) end do end do end do endif if ( pex1 ) then do ic = ic1 , ic2 - 1 do iz = k1 , k2 do iy = j1 , j2 do ix = i2 + 1 , i2 + xsh fld ( ix , iy , iz , ic ) = zero_dp end do end do end do end do endif ! now replaces (i2+1:i2+xsh=n1p) if ( prlx ) then if ( pex1 ) aux2 ( 1 : lenws ) = 0.0 kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 1 , xsh ix = i2 + j kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do end if if ( pex1 ) then ic = ic2 do iz = k1 , k2 do iy = j1 , j2 do ix = i2 + 1 , i2 + xsh ii = ix + imodx * n1 fld ( ix , iy , iz , ic ) = den_x ( ii ) * den_yz ( iy , iz ) end do end do end do endif end subroutine !================================== subroutine fields_left_xshift ( fld , i1 , i2 , ic1 , ic2 , xsh ) integer , intent ( in ) :: i1 , i2 , ic1 , ic2 , xsh real ( dp ) :: fld (:, :, :, :) integer :: ic , ix , j , iy , iz , kk , lenws integer :: j1 , j2 , k1 , k2 if ( xsh == 0 ) return j1 = jy1 j2 = jy2 k1 = kz1 k2 = kz2 lenws = ( ic2 + 1 - ic1 ) * ( k2 + 1 - k1 ) * ( j2 + 1 - j1 ) * xsh if ( prlx ) then !Sends to x-left side xsh data (i1:i1+xsh-1) !Recvs from x-right data(i2+1:i2+xsh)       i2=n1p-sh kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 0 , xsh - 1 ix = i1 + j kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk call exchange_bdx_data ( aux1 , aux2 , lenws , lenws , 3 , rgt ) end if ! ! shifts (i1+xsh:i2+xsh=n1p)=>(i1:i2) do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do ix = i1 , i2 fld ( ix , iy , iz , ic ) = fld ( ix + xsh , iy , iz , ic ) end do fld ( i2 + 1 : i2 + xsh , iy , iz , ic ) = 0.0 end do end do end do ! now replaces (i2+1:i2+xsh=n1p) if ( prlx ) then if ( pex1 ) aux2 ( 1 : lenws ) = 0.0 kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 1 , xsh ix = i2 + j kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do end if end subroutine !================================= subroutine fill_ebfield_yzxbdsdata ( fld , ic1 , ic2 , str , stl ) real ( dp ) :: fld (:, :, :, :) integer , intent ( in ) :: ic1 , ic2 , str , stl integer :: ic , ix , j , iy , iz , kk , iy1 , iy2 , iz1 , iz2 , lenws , lenwr integer :: i1 , i2 , j1 , j2 , k1 , k2 i1 = ix1 i2 = ix2 j1 = jy1 j2 = jy2 k1 = kz1 k2 = kz2 iy1 = j1 iy2 = j2 iz1 = k1 iz2 = k2 ! WARNING str <3 , stl>2 allowed !======================= ! Extends data to the y-left ! sends to the right iy=[j2:j2-str+1] !recvs from the left iy=[j1-1:j1-str] sign=-1 !============================================ if ( prly ) then if ( str > 0 ) then kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do j = 0 , str - 1 iy = j2 - j do ix = i1 , i2 kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 1 , lft ) if ( yl_bd ) then if ( iby < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do j = 1 , str iy = j1 - j do ix = i1 , i2 kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do iy1 = j1 - str end if !========================= if ( stl > 0 ) then !======================= ! Extends data to the y-right, stl>2 allowed !Sends to the left stl data[j1:j1+stl-1] !Recvs from right [j2+1:j2+stl] f_data sign=+1 kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do j = 0 , stl - 1 iy = j1 + j do ix = i1 , i2 kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws !======================= next indx=1 cart dim=1 sign=+1 call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 1 , rgt ) if ( yr_bd ) then if ( iby < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do j = 1 , stl iy = j + j2 do ix = i1 , i2 kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do iy2 = j2 + stl end if end if !======================== if ( prlz ) then !======================= ! Extends data to the z-left ! sends to the right iz=[k2:k2-str+1] !recvs from the left iz=[k1-1:k1-str] sign=-1 !============================================ if ( str > 0 ) then kk = 0 do ic = ic1 , ic2 do j = 0 , str - 1 iz = k2 - j do iy = iy1 , iy2 do ix = i1 , i2 kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 2 , lft ) if ( zl_bd ) then if ( ibz < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = ic1 , ic2 do j = 1 , str iz = k1 - j do iy = iy1 , iy2 do ix = i1 , i2 kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do iz1 = k1 - str end if if ( stl > 0 ) then ! Extends data to the z-right !Sends to the left stl data[k1:k1+stl-1] !Recvs from right [k2+1:k2+stl] f_data sign=+1 kk = 0 do ic = ic1 , ic2 do j = 0 , stl - 1 iz = k1 + j do iy = iy1 , iy2 do ix = i1 , i2 kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 2 , rgt ) if ( zr_bd ) then if ( ibz < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = ic1 , ic2 do j = 1 , stl iz = k2 + j do iy = iy1 , iy2 do ix = i1 , i2 kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do iz2 = k2 + stl end if end if !=============================== if (. not . prlx ) then if ( ibx == 2 ) then if ( str > 0 ) then do ic = ic1 , ic2 do iz = iz1 , iz2 do iy = iy1 , iy2 do j = 1 , str fld ( i1 - j , iy , iz , ic ) = fld ( i2 + 1 - j , iy , iz , ic ) end do end do end do end do end if if ( stl > 0 ) then do ic = ic1 , ic2 do iz = iz1 , iz2 do iy = iy1 , iy2 do j = 1 , stl fld ( i2 + j , iy , iz , ic ) = fld ( i1 - 1 + j , iy , iz , ic ) end do end do end do end do end if end if return end if !==================================== ! Extends data to the x-left ! sends to the right ix=[i2:i2-str+1] !recvs from the left ix=[i1-1:i1-str] sign=-1 !============================================ if ( str > 0 ) then kk = 0 do ic = ic1 , ic2 do iz = iz1 , iz2 do iy = iy1 , iy2 do j = 0 , str - 1 ix = i2 - j kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 3 , lft ) if ( xl_bd ) then if ( ibx < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = ic1 , ic2 do iz = iz1 , iz2 do iy = iy1 , iy2 do j = 1 , str ix = i1 - j kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do end if !======================= if ( stl > 0 ) then !======================= ! Extends data to the x-right !Sends to the left stl data[i1:i1+stl-1] !Recvs from right [i2+1:i2+stl] f_data sign=+1 kk = 0 do ic = ic1 , ic2 do iz = iz1 , iz2 do iy = iy1 , iy2 do j = 0 , stl - 1 ix = i1 + j kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 3 , rgt ) if ( pex1 ) then if ( ibx < 2 ) then aux2 ( 1 : lenwr ) = 0.0 end if end if kk = 0 do ic = ic1 , ic2 do iz = iz1 , iz2 do iy = iy1 , iy2 do j = 1 , stl ix = j + i2 kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do end if ! end data transfer !=========================== end subroutine !=============================== subroutine fill_ebfield_xbdsdata ( fld , ic1 , ic2 , str , stl ) real ( dp ) :: fld (:, :, :, :) integer , intent ( in ) :: ic1 , ic2 , str , stl integer :: ic , ix , j , iy , iz , kk , lenws , lenwr integer :: i1 , i2 , j1 , j2 , k1 , k2 !============================ i1 = ix1 i2 = ix2 j1 = jy1 j2 = jy2 k1 = kz1 k2 = kz2 if (. not . prlx ) then if ( ibx == 2 ) then if ( str > 0 ) then do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 1 , str fld ( i1 - j , iy , iz , ic ) = fld ( i2 + 1 - j , iy , iz , ic ) end do end do end do end do end if if ( stl > 0 ) then do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 1 , stl fld ( i2 + j , iy , iz , ic ) = fld ( i1 - 1 + j , iy , iz , ic ) end do end do end do end do end if end if return end if !==================================== if ( str > 0 ) then !Sends to x-right str data(i2+1-str) !Recvs from the x-left str data(i1-str) sign=-1 kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 0 , str - 1 ix = i2 - j kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 3 , lft ) if ( pex0 ) then if ( ibx < 2 ) aux2 ( 1 : lenws ) = 0.0 end if kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 1 , str ix = i1 - j kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do end if if ( stl > 0 ) then !Sends to left data(ii1:i1+stl-1) !Recvs from the right str data(i2:i2+stl) kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 0 , stl - 1 ix = i1 + j kk = kk + 1 aux1 ( kk ) = fld ( ix , iy , iz , ic ) end do end do end do end do lenws = kk lenwr = lenws call exchange_bdx_data ( aux1 , aux2 , lenws , lenwr , 3 , rgt ) if ( pex1 ) then if ( ibx < 2 ) aux2 ( 1 : lenws ) = 0.0 end if kk = 0 do ic = ic1 , ic2 do iz = k1 , k2 do iy = j1 , j2 do j = 1 , stl ix = i2 + j kk = kk + 1 fld ( ix , iy , iz , ic ) = aux2 ( kk ) end do end do end do end do end if ! end data transfer !=========================== end subroutine !===================== end module","tags":"","loc":"sourcefile/mpi_field_interface.f90.html"},{"title":"mpi_part_interface.f90 – ALaDyn","text":"This file depends on sourcefile~~mpi_part_interface.f90~~EfferentGraph sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~mpi_part_interface.f90->sourcefile~code_util.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~mpi_part_interface.f90->sourcefile~parallel.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~mpi_part_interface.f90->sourcefile~grid_param.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~mpi_part_interface.f90->sourcefile~array_alloc.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mpi_part_interface.f90~~AfferentGraph sourcefile~mpi_part_interface.f90 mpi_part_interface.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90->sourcefile~mpi_part_interface.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mpi_part_interface Source Code mpi_part_interface.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module mpi_part_interface use array_alloc use grid_param use code_util use parallel implicit none real ( dp ) :: loc_pstore ( 7 ) real ( dp ), allocatable :: sp_aux (:, :), sp1_aux (:, :) contains !================= subroutine traffic_size_eval ( sp_loc , xl , xr , pel , per , ibd , ind , & npold , nsr , npnew ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( in ) :: xl , xr logical , intent ( in ) :: pel , per integer , intent ( in ) :: ibd , ind , npold integer , intent ( inout ) :: nsr ( 4 ) integer , intent ( inout ) :: npnew integer :: p , q integer :: nl_send , nl_recv , nr_send , nr_recv , cdir cdir = ind - 1 if ( ind == 1 ) cdir = 3 p = 0 q = 0 nr_recv = 0 nl_recv = 0 if ( npold > 0 ) then p = COUNT ( sp_loc % part ( 1 : npold , ind ) > xr ) q = COUNT ( sp_loc % part ( 1 : npold , ind ) < xl ) end if nr_send = p nl_send = q call sr_idata ( nr_send , nl_recv , cdir , left ) !sends to right nr_send receives from left nl_recv call sr_idata ( nl_send , nr_recv , cdir , right ) !sends to left nl_send  receives from right nr_recv if ( ibd < 2 ) then !NOT PERIODIC BD if ( pel ) nl_recv = 0 if ( per ) then nr_recv = 0 if ( ibd == 1 ) nr_send = 0 end if end if npnew = npold + nl_recv + nr_recv - nl_send - nr_send !================================ !if(pel)nl_send=0 !if(per)nr_send=0 nsr ( 1 ) = nl_send nsr ( 2 ) = nr_send nsr ( 3 ) = nl_recv nsr ( 4 ) = nr_recv !================================ end subroutine !====================================== subroutine part_prl_wexchange ( sp_loc , xl , xr , xlmin , xrmax , & pel , per , ibd , dir , ndv , old_np , n_sr , npt ) type ( species ), intent ( inout ) :: sp_loc real ( dp ), intent ( in ) :: xl , xr , xlmin , xrmax logical , intent ( in ) :: pel , per integer , intent ( in ) :: ibd , dir , ndv , old_np , n_sr ( 4 ) integer , intent ( out ) :: npt type ( index_array ) :: left_pind , right_pind integer :: k , kk , n , p , q , ns , nr , cdir integer :: nl_send , nr_send , nl_recv , nr_recv , vxdir logical :: mask ( old_np ) !================ dir are cartesian coordinate index (x,y,z) !================ cdir are mpi-cartesian index (y,z,x) nl_send = n_sr ( 1 ) nr_send = n_sr ( 2 ) nl_recv = n_sr ( 3 ) nr_recv = n_sr ( 4 ) cdir = dir - 1 if ( dir == 1 ) cdir = 3 !for x-direction vxdir = dir + ndim !================== checks memory p = ndv * max ( nl_send , nr_send ) if ( p > 0 ) then if ( size ( aux1 ) < p ) then deallocate ( aux1 ) allocate ( aux1 ( p )) aux1 (:) = zero_dp end if end if q = ndv * max ( nl_recv , nr_recv ) if ( q > 0 ) then if ( size ( aux2 ) < q ) then deallocate ( aux2 ) allocate ( aux2 ( q )) aux2 (:) = zero_dp end if end if !==================== copy remaining part => ebfp right_pind = index_array ( old_np ) left_pind = index_array ( old_np ) p = 0 q = 0 npt = 0 if ( ibd == 1 . and . dir == 1 ) then !reflecting on the right if ( per ) then associate ( xp => sp_loc % part ( 1 : old_np , dir )) where ( xp > xr ) xp = xr - ( xp - xr ) sp_loc % part ( 1 : old_np , vxdir ) = - sp_loc % part ( 1 : old_np , vxdir ) end where end associate end if end if !================== copy in sp_aux particles not to be exchanged associate ( xp => sp_loc % part ( 1 : old_np , dir )) call right_pind % find_index ( xp > xr ) call left_pind % find_index ( xp < xl ) mask (:) = ( xp >= xl . and . xp <= xr ) npt = COUNT ( mask (:)) end associate do n = 1 , ndv sp_aux ( 1 : npt , n ) = PACK ( sp_loc % part ( 1 : old_np , n ), mask (:)) end do !======================= ns = ndv * nr_send nr = ndv * nl_recv if ( ibd < 2 ) then !NON PERIODIC CASE if ( per ) ns = 0 if ( pel ) nr = 0 end if if ( ns > 0 ) then kk = 0 if ( per ) then !sends to the right only for Periodic boundary do k = 1 , nr_send n = right_pind % indices ( k ) loc_pstore ( 1 : ndv ) = sp_loc % part ( n , 1 : ndv ) loc_pstore ( dir ) = loc_pstore ( dir ) + xlmin - xr do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do !=============== NON PERIODIC CASE else !To be checked case ibd == 1 do k = 1 , nr_send n = right_pind % indices ( k ) loc_pstore ( 1 : ndv ) = sp_loc % part ( n , 1 : ndv ) do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do end if end if if ( max ( ns , nr ) > 0 ) call sr_pdata ( aux1 , aux2 , ns , nr , cdir , left ) ! sends ns data to the right if ( nr > 0 ) then !receives nr data from left kk = 0 p = npt do n = 1 , nl_recv p = p + 1 do q = 1 , ndv kk = kk + 1 sp_aux ( p , q ) = aux2 ( kk ) end do end do npt = p end if !=================== ns = ndv * nl_send nr = ndv * nr_recv if ( ibd == 0 ) then if ( pel ) ns = 0 if ( per ) nr = 0 end if if ( ns > 0 ) then kk = 0 if ( pel ) then !only for periodic case do k = 1 , nl_send n = left_pind % indices ( k ) loc_pstore ( 1 : ndv ) = sp_loc % part ( n , 1 : ndv ) loc_pstore ( dir ) = loc_pstore ( dir ) + xrmax - xl do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do else !============ NON PERIODIC EXCHANGE do k = 1 , nl_send n = left_pind % indices ( k ) loc_pstore ( 1 : ndv ) = sp_loc % part ( n , 1 : ndv ) do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do end if end if !END ns >0 if ( max ( ns , nr ) > 0 ) call sr_pdata ( aux1 , aux2 , ns , nr , cdir , right ) ! sends ns data to the left recieves nr data from right if ( nr > 0 ) then p = npt kk = 0 do n = 1 , nr_recv p = p + 1 do q = 1 , ndv kk = kk + 1 sp_aux ( p , q ) = aux2 ( kk ) end do end do npt = p end if !  EXIT old+new data in sp_aux(:,:) end subroutine !============================================== subroutine part_prl_exchange ( sp_loc , vstore , xl , xr , xlmin , xrmax , & pel , per , ibd , dir , ndv , old_np , n_sr , npt ) type ( species ), intent ( inout ) :: sp_loc real ( dp ), intent ( in ) :: vstore (:, :) real ( dp ), intent ( in ) :: xl , xr , xlmin , xrmax logical , intent ( in ) :: pel , per integer , intent ( in ) :: ibd , dir , ndv , old_np , n_sr ( 4 ) integer , intent ( out ) :: npt type ( index_array ) :: left_pind , right_pind integer :: k , kk , n , p , q , ns , nr , cdir integer :: nl_send , nr_send , nl_recv , nr_recv , vxdir logical :: mask ( old_np ) !================ dir are cartesian coordinate index (x,y,z) !================ cdir are mpi-cartesian index (y,z,x) nl_send = n_sr ( 1 ) nr_send = n_sr ( 2 ) nl_recv = n_sr ( 3 ) nr_recv = n_sr ( 4 ) cdir = dir - 1 if ( dir == 1 ) cdir = 3 !for x-direction vxdir = dir + ndim !================== checks memory p = 2 * ndv * max ( nl_send , nr_send ) if ( p > 0 ) then if ( size ( aux1 ) < p ) then deallocate ( aux1 ) allocate ( aux1 ( p )) aux1 (:) = zero_dp end if end if q = 2 * ndv * max ( nl_recv , nr_recv ) if ( q > 0 ) then if ( size ( aux2 ) < q ) then deallocate ( aux2 ) allocate ( aux2 ( q )) aux2 (:) = zero_dp end if end if !==================== copy remaining part => ebfp right_pind = index_array ( old_np ) left_pind = index_array ( old_np ) p = 0 q = 0 npt = 0 if ( ibd == 1 . and . dir == 1 ) then !reflecting on the right if ( per ) then associate ( xp => sp_loc % part ( 1 : old_np , dir )) where ( xp > xr ) xp = xr - ( xp - xr ) sp_loc % part ( 1 : old_np , vxdir ) = - sp_loc % part ( 1 : old_np , vxdir ) end where end associate end if end if !================== copy in sp_aux particles not to be exchanged associate ( xp => sp_loc % part ( 1 : old_np , dir )) call right_pind % find_index ( xp > xr ) call left_pind % find_index ( xp < xl ) mask (:) = ( xp >= xl . and . xp <= xr ) npt = COUNT ( mask (:)) end associate do n = 1 , ndv sp_aux ( 1 : npt , n ) = PACK ( sp_loc % part ( 1 : old_np , n ), mask (:)) sp1_aux ( 1 : npt , n ) = PACK ( vstore ( 1 : old_np , n ), mask (:)) end do !======================= ns = 2 * ndv * nr_send nr = 2 * ndv * nl_recv if ( ibd < 2 ) then !NON PERIODIC CASE if ( per ) ns = 0 if ( pel ) nr = 0 end if if ( ns > 0 ) then kk = 0 if ( per ) then !sends to the right only for Periodic boundary do k = 1 , nr_send n = right_pind % indices ( k ) loc_pstore ( 1 : ndv ) = sp_loc % part ( n , 1 : ndv ) loc_pstore ( dir ) = loc_pstore ( dir ) + xlmin - xr do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do !adds vstore data do k = 1 , nr_send n = right_pind % indices ( k ) loc_pstore ( 1 : ndv ) = vstore ( n , 1 : ndv ) loc_pstore ( dir ) = loc_pstore ( dir ) + xlmin - xr do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do !=============== NON PERIODIC CASE else !To be checked case ibd == 1 do k = 1 , nr_send n = right_pind % indices ( k ) loc_pstore ( 1 : ndv ) = sp_loc % part ( n , 1 : ndv ) do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do !adds vstore data do k = 1 , nr_send n = right_pind % indices ( k ) loc_pstore ( 1 : ndv ) = vstore ( n , 1 : ndv ) do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do end if end if if ( max ( ns , nr ) > 0 ) call sr_pdata ( aux1 , aux2 , ns , nr , cdir , left ) ! sends ns data to the right if ( nr > 0 ) then !receives nr data from left kk = 0 p = npt do n = 1 , nl_recv p = p + 1 do q = 1 , ndv kk = kk + 1 sp_aux ( p , q ) = aux2 ( kk ) end do end do !   adds... p = npt do n = 1 , nl_recv p = p + 1 do q = 1 , ndv kk = kk + 1 sp1_aux ( p , q ) = aux2 ( kk ) end do end do npt = p end if !=================== ns = 2 * ndv * nl_send nr = 2 * ndv * nr_recv if ( ibd == 0 ) then if ( pel ) ns = 0 if ( per ) nr = 0 end if if ( ns > 0 ) then kk = 0 if ( pel ) then !only for periodic case do k = 1 , nl_send n = left_pind % indices ( k ) loc_pstore ( 1 : ndv ) = sp_loc % part ( n , 1 : ndv ) loc_pstore ( dir ) = loc_pstore ( dir ) + xrmax - xl do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do ! adds.... do k = 1 , nl_send n = left_pind % indices ( k ) loc_pstore ( 1 : ndv ) = vstore ( n , 1 : ndv ) loc_pstore ( dir ) = loc_pstore ( dir ) + xrmax - xl do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do else !============ NON PERIODIC EXCHANGE do k = 1 , nl_send n = left_pind % indices ( k ) loc_pstore ( 1 : ndv ) = sp_loc % part ( n , 1 : ndv ) do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do do k = 1 , nl_send n = left_pind % indices ( k ) loc_pstore ( 1 : ndv ) = vstore ( n , 1 : ndv ) do q = 1 , ndv kk = kk + 1 aux1 ( kk ) = loc_pstore ( q ) end do end do end if end if !END ns >0 if ( max ( ns , nr ) > 0 ) call sr_pdata ( aux1 , aux2 , ns , nr , cdir , right ) ! sends ns data to the left recieves nr data from right if ( nr > 0 ) then p = npt kk = 0 do n = 1 , nr_recv p = p + 1 do q = 1 , ndv kk = kk + 1 sp_aux ( p , q ) = aux2 ( kk ) end do end do p = npt do n = 1 , nr_recv p = p + 1 do q = 1 , ndv kk = kk + 1 sp1_aux ( p , q ) = aux2 ( kk ) end do end do npt = p end if !  EXIT old+new data in sp_aux(:,:) and sp1_aux(:,:) end subroutine !================ !============================= subroutine reset_all_part_dist ( loc_sp , pstore , xl , xr , ib , np , ndv , & cin , np_new , mwin ) type ( species ), intent ( inout ) :: loc_sp real ( dp ), intent ( inout ) :: pstore (:, :) real ( dp ), intent ( in ) :: xl , xr logical , intent ( in ) :: mwin integer , intent ( in ) :: ib , np , ndv , cin integer , intent ( out ) :: np_new real ( dp ) :: xp , dxp integer :: n , p , pout !=========================== np_new = np p = 0 pout = 0 if ( ib == 2 ) then dxp = xr - xl do p = 1 , np xp = loc_sp % part ( p , cin ) if ( xp < xl ) loc_sp % part ( p , cin ) = xp + dxp xp = loc_sp % part ( p , cin ) if ( xp > xr ) loc_sp % part ( p , cin ) = xp - dxp end do return end if do n = 1 , np xp = loc_sp % part ( n , cin ) if ( xp <= xl ) p = p + 1 if ( xp > xr ) p = p + 1 end do pout = p if ( pout > 0 ) then if ( mwin ) then call v_realloc ( sp_aux , np - pout , ndv ) p = 0 do n = 1 , np xp = loc_sp % part ( n , cin ) if ( xp > xl . and . xp <= xr ) then p = p + 1 sp_aux ( p , 1 : ndv ) = loc_sp % part ( n , 1 : ndv ) end if end do else call v_realloc ( sp_aux , np - pout , ndv ) call v_realloc ( sp1_aux , np - pout , ndv ) p = 0 do n = 1 , np xp = loc_sp % part ( n , cin ) if ( xp > xl . and . xp <= xr ) then p = p + 1 sp_aux ( p , 1 : ndv ) = loc_sp % part ( n , 1 : ndv ) sp1_aux ( p , 1 : ndv ) = pstore ( n , 1 : ndv ) end if end do endif np_new = p end if end subroutine !============== subroutine cell_part_dist ( moving_wind ) logical , intent ( in ) :: moving_wind integer :: ic , nspx , n , np , np_new , np_new_allocate , ndv , & np_rs , np_out integer :: n_sr ( 4 ) real ( dp ) :: ymm , ymx , lbd_min , rbd_max real ( dp ) :: zmm , zmx real ( dp ) :: xmm , xmx ndv = nd2 + 1 !=================================== ! In traffic_size_eval() Counts numbers of left-right exchanges !nsr(1)=nl_send !nsr(2)=nr_send !nsr(3)=nl_recv !nsr(4)=nr_recv ! ==> new particle number np_new= nl_recv-nl_send+ nr_recv-nr_send !      In part_prl_exchange()    exchanges particle data by mpi_send_recv !===================================== !In moving window box (xmm,xmx) are right shifted !all species leaving the computational box at the left !x-boundary are removed !========================================== !=========== mowing window section if ( moving_wind ) then nspx = nsp xmm = loc_xgrid ( imodx )% gmin xmx = loc_xgrid ( imodx )% gmax lbd_min = loc_xgrid ( 0 )% gmin rbd_max = loc_xgrid ( npe_xloc - 1 )% gmax if ( prlx ) then do ic = 1 , nspx np = loc_npart ( imody , imodz , imodx , ic ) np_new = np n_sr = 0 call traffic_size_eval ( spec ( ic ), xmm , xmx , pex0 , pex1 , ibx , 1 , np , & n_sr , np_new ) ! Allocate the aux array with lenght np + n_recieve ! because it needs to receive before to send np_new_allocate = np_new + SUM ( n_sr ( 1 : 2 )) np_rs = maxval ( n_sr ( 1 : 4 )) if ( np_rs > 0 ) then call v_realloc ( sp_aux , np_new_allocate , ndv ) call part_prl_wexchange ( spec ( ic ), xmm , xmx , lbd_min , rbd_max , & pex0 , pex1 , ibx , 1 , ndv , np , n_sr , np_out ) if ( np_out /= np_new ) then write ( 6 , * ) 'error in x-part w-count' , mype , np_out , np_new ier = 99 end if call p_realloc ( spec ( ic ), np_new , ndv ) call v_realloc ( ebfp , np_new , ndv ) spec ( ic )% part ( 1 : np_new , 1 : ndv ) = sp_aux ( 1 : np_new , 1 : ndv ) loc_npart ( imody , imodz , imodx , ic ) = np_new end if end do else do ic = 1 , nspx np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then call reset_all_part_dist ( spec ( ic ), ebfp , xmm , xmx , ibx , np , ndv , & 1 , np_new , moving_wind ) if ( np_new < np ) then loc_npart ( imody , imodz , imodx , ic ) = np_new do n = 1 , np_new spec ( ic )% part ( n , 1 : ndv ) = sp_aux ( n , 1 : ndv ) end do end if end if end do end if if ( allocated ( sp_aux )) deallocate ( sp_aux ) return endif !=========== not mowing window section nspx = nsp_run xmm = loc_xgrid ( imodx )% gmin xmx = loc_xgrid ( imodx )% gmax lbd_min = loc_xgrid ( 0 )% gmin rbd_max = loc_xgrid ( npe_xloc - 1 )% gmax if ( prlx ) then do ic = 1 , nspx np = loc_npart ( imody , imodz , imodx , ic ) np_new = np n_sr = 0 call traffic_size_eval ( spec ( ic ), xmm , xmx , pex0 , pex1 , ibx , 1 , np , & n_sr , np_new ) ! Allocate the aux array with lenght np + n_recieve ! because it needs to recieve before to send np_new_allocate = np_new + SUM ( n_sr ( 1 : 2 )) np_rs = maxval ( n_sr ( 1 : 4 )) if ( np_rs > 0 ) then call v_realloc ( sp_aux , np_new_allocate , ndv ) call v_realloc ( sp1_aux , np_new_allocate , ndv ) call part_prl_exchange ( spec ( ic ), ebfp , xmm , xmx , lbd_min , rbd_max , & pex0 , pex1 , ibx , 1 , ndv , np , n_sr , np_out ) if ( np_out /= np_new ) then write ( 6 , * ) 'error in x-part count' , mype , np_out , np_new ier = 99 end if call p_realloc ( spec ( ic ), np_new , ndv ) call v_realloc ( ebfp , np_new , ndv ) spec ( ic )% part ( 1 : np_new , 1 : ndv ) = sp_aux ( 1 : np_new , 1 : ndv ) ebfp ( 1 : np_new , 1 : ndv ) = sp1_aux ( 1 : np_new , 1 : ndv ) loc_npart ( imody , imodz , imodx , ic ) = np_new end if end do else do ic = 1 , nspx np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then call reset_all_part_dist ( spec ( ic ), ebfp , xmm , xmx , ibx , np , ndv , & 1 , np_new , moving_wind ) if ( np_new < np ) then loc_npart ( imody , imodz , imodx , ic ) = np_new do n = 1 , np_new spec ( ic )% part ( n , 1 : ndv ) = sp_aux ( n , 1 : ndv ) ebfp ( n , 1 : ndv ) = sp1_aux ( n , 1 : ndv ) end do end if end if end do end if if ( allocated ( sp_aux )) deallocate ( sp_aux ) if ( allocated ( sp1_aux )) deallocate ( sp1_aux ) !========================== ymm = loc_ygrid ( imody )% gmin ymx = loc_ygrid ( imody )% gmax lbd_min = loc_ygrid ( 0 )% gmin rbd_max = loc_ygrid ( npe_yloc - 1 )% gmax if ( prly ) then do ic = 1 , nsp_run n_sr = 0 np = loc_npart ( imody , imodz , imodx , ic ) np_new = np call traffic_size_eval ( spec ( ic ), ymm , ymx , pe0y , pe1y , iby , 2 , np , & n_sr , np_new ) np_new_allocate = np_new + SUM ( n_sr ( 1 : 2 )) np_rs = maxval ( n_sr ( 1 : 4 )) if ( np_rs > 0 ) then call v_realloc ( sp_aux , np_new_allocate , ndv ) call v_realloc ( sp1_aux , np_new_allocate , ndv ) call part_prl_exchange ( spec ( ic ), ebfp , ymm , ymx , lbd_min , & rbd_max , pe0y , pe1y , iby , 2 , ndv , np , n_sr , np_out ) if ( np_out /= np_new ) then write ( 6 , * ) 'error in y-part count' , mype , np_out , np_new ier = 99 end if call p_realloc ( spec ( ic ), np_new , ndv ) call v_realloc ( ebfp , np_new , ndv ) do n = 1 , np_new spec ( ic )% part ( n , 1 : ndv ) = sp_aux ( n , 1 : ndv ) ebfp ( n , 1 : ndv ) = sp1_aux ( n , 1 : ndv ) end do loc_npart ( imody , imodz , imodx , ic ) = np_new end if end do else do ic = 1 , nsp_run np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then call reset_all_part_dist ( spec ( ic ), ebfp , ymm , ymx , iby , np , ndv , & 2 , np_new , moving_wind ) if ( np_new < np ) then loc_npart ( imody , imodz , imodx , ic ) = np_new do n = 1 , np_new spec ( ic )% part ( n , 1 : ndv ) = sp_aux ( n , 1 : ndv ) ebfp ( n , 1 : ndv ) = sp1_aux ( n , 1 : ndv ) end do end if end if end do end if if ( allocated ( sp_aux )) deallocate ( sp_aux ) if ( allocated ( sp1_aux )) deallocate ( sp1_aux ) if ( ndim > 2 ) then zmm = loc_zgrid ( imodz )% gmin zmx = loc_zgrid ( imodz )% gmax lbd_min = loc_zgrid ( 0 )% gmin rbd_max = loc_zgrid ( npe_zloc - 1 )% gmax if ( prlz ) then do ic = 1 , nsp_run np = loc_npart ( imody , imodz , imodx , ic ) np_new = np n_sr = 0 call traffic_size_eval ( spec ( ic ), zmm , zmx , pe0z , pe1z , ibz , 3 , & np , n_sr , np_new ) np_new_allocate = np_new + SUM ( n_sr ( 1 : 2 )) np_rs = maxval ( n_sr ( 1 : 4 )) if ( np_rs > 0 ) then !===================== call v_realloc ( sp_aux , np_new_allocate , ndv ) call v_realloc ( sp1_aux , np_new_allocate , ndv ) !================ call part_prl_exchange ( spec ( ic ), ebfp , zmm , zmx , lbd_min , & rbd_max , pe0z , pe1z , ibz , 3 , ndv , np , n_sr , np_out ) if ( np_out /= np_new ) then write ( 6 , * ) 'error in z-part count' , mype , np_out , np_new ier = 99 end if call p_realloc ( spec ( ic ), np_new , ndv ) call v_realloc ( ebfp , np_new , ndv ) do n = 1 , np_new spec ( ic )% part ( n , 1 : ndv ) = sp_aux ( n , 1 : ndv ) ebfp ( n , 1 : ndv ) = sp1_aux ( n , 1 : ndv ) end do loc_npart ( imody , imodz , imodx , ic ) = np_new end if end do else do ic = 1 , nsp_run np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then call reset_all_part_dist ( spec ( ic ), ebfp , zmm , zmx , ibz , np , ndv , & 3 , np_new , moving_wind ) if ( np_new < np ) then loc_npart ( imody , imodz , imodx , ic ) = np_new do n = 1 , np_new spec ( ic )% part ( n , 1 : ndv ) = sp_aux ( n , 1 : ndv ) ebfp ( n , 1 : ndv ) = sp1_aux ( n , 1 : ndv ) end do end if end if end do end if if ( allocated ( sp_aux )) deallocate ( sp_aux ) if ( allocated ( sp1_aux )) deallocate ( sp1_aux ) end if !===================== end subroutine !========================= end module","tags":"","loc":"sourcefile/mpi_part_interface.f90.html"},{"title":"run_data_info.f90 – ALaDyn","text":"This file depends on sourcefile~~run_data_info.f90~~EfferentGraph sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~run_data_info.f90->sourcefile~ionz_data.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~run_data_info.f90->sourcefile~phys_param.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~run_data_info.f90->sourcefile~control_bunch_input.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~run_data_info.f90->sourcefile~common_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~fstruct_data.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~run_data_info.f90->sourcefile~code_util.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~run_data_info.f90~~AfferentGraph sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~window.f90 window.f90 sourcefile~window.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~run_data_info.f90 sourcefile~aladyn.f90->sourcefile~start_all.f90 sourcefile~pic_evolve_in_time.f90 pic_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~pic_evolve_in_time.f90 sourcefile~env_evolve_in_time.f90 env_evolve_in_time.f90 sourcefile~aladyn.f90->sourcefile~env_evolve_in_time.f90 sourcefile~pic_evolve_in_time.f90->sourcefile~window.f90 sourcefile~env_evolve_in_time.f90->sourcefile~window.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules run_data_info Source Code run_data_info.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module run_data_info use pstruct_data use fstruct_data use code_util use common_param use grid_param use ionz_data use parallel use control_bunch_input , only : reduced_charge , bunch_charge , epsy , & epsz , sxb , syb , gam , rhob , jb_norm use phys_param , only : electron_charge_norm implicit none contains subroutine timing if ( mod ( iter , write_every ) == 0 ) then mem_psize_max = 0.0 if ( prl ) then call Part_numbers call Max_pmemory_check () end if if ( pe0 ) then call tot_num_part write ( 6 , '(a10,i6,a10,e11.4,a10,e11.4)' ) 'iter = ' , iter , ' t = ' , & tnow , ' dt = ' , dt_loc call CPU_TIME ( unix_time_now ) write ( 6 , '(a16,f12.3,a10,i15)' ) ' Time elapsed = ' , & unix_time_now - unix_time_begin , ', nptot = ' , nptot_global if ( prl ) then if ( part ) then write ( 6 , '(a21,i10,a1,i10)' ) ' part min/max distr. ' , np_min , & ' ' , np_max write ( 6 , '(a18,2i8)' ) ' where pmin/pmax  ' , pe_npmin , pe_npmax endif write ( 6 , '(a24,e12.5)' ) ' max part memory in MB= ' , & mem_psize_max write ( 6 , '(a20,e12.5)' ) ' Max part  address= ' , mem_max_addr end if write ( 6 , '(a13,2E11.4)' ) ' xmin/xmax   ' , xmin , xmax write ( 6 , * ) '========================' end if !end Pe0 write end if !end mod(write_every) if ( tnow < tmax ) then tnow = tnow + dt_loc iter = iter + 1 end if end subroutine !--------------------------- subroutine error_message if ( pe0 ) then if ( ier > 0 ) write ( 6 , * ) 'error occurred: ' if ( ier == 20 ) write ( 6 , * ) 'error: negative density: ' , ier if ( ier == 1 ) write ( 6 , * ) 'error: fields values too big: ' , ier end if end subroutine !====================================== subroutine Part_numbers integer :: ip , iz , ix , pp , ic , np_new , nploc ( npe ) do ic = 1 , nsp nploc (:) = 0 np_new = loc_npart ( imody , imodz , imodx , ic ) call intvec_distribute ( np_new , nploc , npe ) pp = 0 !loc_npart() distribution on each MPI task do ix = 0 , npe_xloc - 1 do iz = 0 , npe_zloc - 1 do ip = 0 , npe_yloc - 1 pp = pp + 1 loc_npart ( ip , iz , ix , ic ) = nploc ( pp ) end do end do end do end do np_max = maxval ( nploc ( 1 : npe )) np_min = minval ( nploc ( 1 : npe )) if (. not . part ) then if ( np_max > 0 ) part = . true . endif do ip = 0 , npe - 1 if ( nploc ( ip + 1 ) == np_min ) pe_npmin = ip if ( nploc ( ip + 1 ) == np_max ) pe_npmax = ip end do end subroutine subroutine tot_num_part integer ( dp ) :: nptot_local integer :: iterator_x , iterator_y , iterator_z integer :: iterator_species nptot_global = 0 !! WARNING: allreduce_big_int is unsupported on many architectures: MPI_SUM not available for MPI_LONG_INT datatype !do iterator_species=1,nsp_run ! nptot_local = loc_npart(imody, imodz, imodx, nsp_run) !end do !call allreduce_big_int(nptot_local, nptot_global) if ( pe0 ) then do iterator_y = 0 , npe_yloc - 1 do iterator_z = 0 , npe_zloc - 1 do iterator_x = 0 , npe_xloc - 1 do iterator_species = 1 , nsp_run !nsp_run is the real number of species running! nptot_local = int ( loc_npart ( iterator_y , iterator_z , iterator_x , & iterator_species ), dp_int ) nptot_global = nptot_global + nptot_local end do end do end do end do end if end subroutine !--------------------------- subroutine initial_run_info ( nw ) integer , intent ( in ) :: nw integer :: i character ( len = 21 ) :: output_data_in integer ( hp_int ) :: chsize real ( sp ) :: wgsize write ( output_data_in , '(a15,i2.2,a4)' ) 'init_data_info_' , id_new , & '.dat' write ( 6 , * ) '***********************************************' write ( 6 , * ) 'Start: new = ' , nw if ( nw == 0 ) then write ( 6 , '(a18,3i8)' ) '  total grid size ' , nx , ny , nz write ( 6 , '(a18,3i8)' ) '  local grid size ' , nx_loc , ny_loc , nz_loc write ( 6 , '(a27,i3)' ) '  Cartesian grid dimension ' , ndim end if if ( nw == 1 ) then write ( 6 , '(a13,e11.4)' ) ' restart time' , tstart write ( 6 , * ) ' diag ienout' , ienout end if !write(6,*)' kind of dp and int data',kind(tstart),kind(nx) !====================================== open ( 60 , file = output_data_in ) write ( 60 , * ) ' data bsize' write ( 60 , * ) huge ( chsize ), huge ( wgsize ) !============================================ if ( nw == 0 ) then write ( 60 , * ) '********** INITIAL DATA INFO************* ' else write ( 60 , * ) '*********  RESTART DATA INFO*************' end if write ( 60 , '(a12,f6.2)' ) '  Start time=' , tstart write ( 60 , '(a20,i4,a4)' ) '  ALaDyn running on ' , npe , ' cpu' write ( 60 , '(a30,3i4)' ) '  (x-y-z) MPI decomposition : ' , npe_xloc , & npe_yloc , npe_zloc write ( 60 , '(a26,i4)' ) '  Data output initial id= ' , id_new write ( 60 , * ) '*************IMPLEMENTATION TOOLS********************' write ( 60 , * ) '  Field collocation on the Yee-module staggered grid' write ( 60 , * ) '  B-spline shapes of alternating first-second order ' if ( lpf_ord > 0 ) then if ( lpf_ord == 2 ) write ( 60 , * ) & '  One-step leap-frog time integration ' if ( der_ord == 2 ) write ( 60 , * ) & '  Explicit second order space derivative ' if ( der_ord == 3 ) write ( 60 , * ) & '  Optmal Explicit second order space derivative' if ( der_ord == 4 ) write ( 60 , * ) & '  Fourth-order Maxwell solver only for (E,B) fields' if ( lpf_ord > 2 ) then write ( 60 , * ) '  RK multi-step fourth order time scheme ' write ( 60 , * ) '  Explicit fourth order Space Derivative' end if end if if ( charge_cons ) then if ( iform < 2 ) then write ( 60 , * ) '  Continuity equation enforced by Esirkepov scheme' else write ( 60 , * ) ' Continuity equation enforced on x-grid & &using non-conservative schemes' end if end if write ( 60 , * ) '***************GRID**********************' write ( 60 , '(a18,3i8)' ) '  total grid size ' , nx , ny , nz write ( 60 , '(a18,3i8)' ) '  local grid size ' , nx_loc , ny_loc , nz_loc write ( 60 , '(a27,i3)' ) '  Cartesian grid dimension ' , ndim if ( curr_ndim == 2 ) then write ( 60 , * ) ' Current components: [Jx,Jy] ' write ( 60 , * ) ' Field components: [Ex,Ey,Bz] ' else write ( 60 , * ) ' Current components: [Jx,Jy,Jz] ' write ( 60 , * ) ' Field components: [Ex,Ey,Ez,Bx,By,Bz] ' end if write ( 60 , * ) '   Box sizes' write ( 60 , * ) '     xmin,      xmax     ' write ( 60 , '(a1,2e11.4)' ) ' ' , xmin , xmax if ( ndim > 1 ) then write ( 60 , * ) '    ymin       ymax     ' write ( 60 , '(a1,2e11.4)' ) ' ' , ymin , ymax if ( ndim > 2 ) then write ( 60 , * ) '    zmin       zmax     ' write ( 60 , '(a1,2e11.4)' ) ' ' , zmin , zmax end if end if write ( 60 , * ) '   Cell sizes' if ( ndim < 3 ) then write ( 60 , '(a6,e11.4,a6,e11.4)' ) '  Dx =' , dx , '  Dy =' , dy else write ( 60 , '(a6,e11.4,a6,e11.4,a6,e11.4)' ) '  Dx =' , dx , '  Dy =' , & dy , '  Dz =' , dz end if if ( stretch ) then write ( 60 , * ) & ' Grid is stretched on the transverse coordinates: y=tan(a*xi)' write ( 60 , '(a28,f8.2,a8,f8.2)' ) '  Y grid is uniform from y =' , & str_ygrid % smin , ' to y = ' , str_ygrid % smax write ( 60 , '(a34, i4)' ) '  Number of stretched cells n_y = ' , ny_stretch write ( 60 , '(a28,f8.2,a8,f8.2)' ) '  Z grid is uniform from z =' , & str_zgrid % smin , ' to z = ' , str_zgrid % smax write ( 60 , '(a34, i4)' ) '  Number of stretched cells n_z = ' , nz_stretch end if write ( 60 , * ) '***************PHYSICAL MODEL**********************' if ( model_id < 4 ) then write ( 60 , * ) '  Laser field injected ' if ( model_id == 1 ) write ( 60 , * ) '  P-polarization on y-axis' if ( model_id == 2 ) write ( 60 , * ) '  S-polarization on z-axis' if ( model_id == 3 ) write ( 60 , * ) & '  Circular polarization on y-z plane' write ( 60 , * ) & '***************** Laser pulse structure***************' if ( model_id == 0 ) then write ( 60 , * ) '  A plane wave model' else write ( 60 , * ) & '  Gaussian profile exp(-[r/w0_y]&#94;2) on radial coordinate' end if if ( g_prof ) then write ( 60 , * ) '  Gaussian profile exp(-[(x-t)/w0_x]&#94;2) & &on longitudinal (x-t) coordinate' else write ( 60 , * ) & '  Cos&#94;2[Pi(x-t)/w0_x] profile on longitudinal (x-t) coordinate' end if else select case ( model_id ) case ( 4 ) write ( 60 , * ) '  LP(P-pol) laser field injected using & &ENVELOPE integration model' case ( 5 ) write ( 60 , * ) '  Electron bunch injected' end select end if write ( 60 , * ) & '***********FIELD BOUNDARY CONDITIONS*************************' if ( ibx == 0 ) write ( 60 , * ) ' Open boundaries on x axis' if ( ibx == 1 ) write ( 60 , * ) ' Reflecting boundary on right x ' if ( ibx == 2 ) write ( 60 , * ) ' Periodic boundaries on x axis' if ( ibx > 2 ) write ( 60 , * ) ' Invalid x-boundary flag' if ( ndim > 1 ) then if ( iby == 0 ) write ( 60 , * ) ' Open boundaries on y axis' if ( iby == 1 ) write ( 60 , * ) ' Reflecting boundaries on y axis' if ( iby == 2 ) write ( 60 , * ) ' Periodic boundaries on y axis' if ( iby > 2 ) write ( 60 , * ) ' Invalid y-boundary flag' end if if ( ndim > 2 ) then if ( ibz == 0 ) write ( 60 , * ) ' Open boundaries on z axis' if ( ibz == 1 ) write ( 60 , * ) ' Reflecting boundaries on z axis' if ( ibz == 2 ) write ( 60 , * ) ' Periodic boundaries on z axis' if ( ibz > 2 ) write ( 60 , * ) ' Invalid z-boundary flag' end if if ( w_speed > 0.0 ) then write ( 60 , '(a23,f5.2)' ) '  Moving window speed= ' , w_speed end if if ( w_speed < 0.0 ) then write ( 60 , '(a35,f5.2)' ) '  Comoving x-coordinate system V_b=' , & vbeam end if if ( model_id < 5 ) then write ( 60 , * ) '******LASER PHYSICAL PARAMETERS *****************' write ( 60 , * ) '     Main pulse parameters ' write ( 60 , * ) ' Transverse scales' write ( 60 , '(a8,f6.2,a18,f6.2)' ) '  w0_y= ' , w0_y , & '   focal spot =   ' , lp_rad write ( 60 , * ) ' Longitudinal scales' write ( 60 , '(a8,f6.2,a18,f6.2)' ) '  w0_x= ' , w0_x , & '   tau_fwhm(fs) = ' , tau_fwhm write ( 60 , '(a13,f5.2,a13,f5.2)' ) '  wavelength=' , lam0 , & '   frequency=' , oml write ( 60 , '(a17,e13.3,a17,f6.2)' ) '  Initial focus =' , xf , & '   Pulse center= ' , xc_lp write ( 60 , '(a29,e11.4)' ) '  Diffraction length Z_Rayl= ' , zr write ( 60 , '(a25,f5.2)' ) '  Strength parameter a0= ' , a0 write ( 60 , '(a33,f5.2,a6)' ) '  Max transverse field at focus= ' , & e0 * a0 * oml , '(TV/m)' write ( 60 , '(a13,e13.3,a10)' ) '  Intensity= ' , lp_intensity , & '(e18W/cm2)' write ( 60 , '(a9,e13.3,a4)' ) '  Power = ' , lp_pow , '(TW)' write ( 60 , '(a10,e13.3,a3)' ) '  Energy= ' , lp_energy , '(J)' write ( 60 , '(a30,i4)' ) '  Number of main laser pulses= ' , nb_laser if (. not . enable_ionization ( 1 )) write ( 60 , * ) & ' WARNING: Ionization disabled for the main pulse' if ( nb_laser > 1 ) then do i = 2 , nb_laser write ( 60 , '(a23,i2,a5,i2,a10,f5.2)' ) '  Distance between the ' , & i - 1 , ' and ' , i , ' centers= ' , lp_delay ( i - 1 ) end do end if write ( 60 , * ) '-----------------------------------' if ( Two_color ) then write ( 60 , * ) '     Injected pulse parameters ' write ( 60 , '(a20,f5.2)' ) '  Offset distance = ' , lp_offset write ( 60 , * ) ' Transverse scales' write ( 60 , '(a8,f5.2,a18,f5.2)' ) '  w1_y= ' , w1_y , & '   focal spot =   ' , lp1_rad write ( 60 , * ) ' Longitudinal scales' write ( 60 , '(a8,f5.2,a18,f5.2)' ) '  w0_x= ' , w1_x , & '   tau_fwhm(fs) = ' , tau1_fwhm write ( 60 , '(a13,f5.2,a13,f5.2)' ) '  wavelength=' , lam1 , & '   frequency=' , om1 write ( 60 , '(a17,f6.2,a17,f6.2)' ) '  Initial focus =' , xf1 , & '   Pulse center= ' , xc1_lp write ( 60 , '(a29,e11.4)' ) '  Diffraction length Z_Rayl= ' , zr1 write ( 60 , '(a25,f5.2)' ) '  Strength parameter a0= ' , a1 write ( 60 , '(a33,f5.2,a6)' ) '  Max transverse field at focus= ' , & e0 * a1 * om1 , '(TV/m)' if (. not . enable_ionization ( 2 )) write ( 60 , * ) & ' WARNING: Ionization disabled for the injection pulse' end if end if if ( hybrid ) then write ( 60 , * ) '************** FLUID DATA *****************' write ( 60 , * ) 'Fluid density-momenta components' , nfcomp end if write ( 60 , * ) '**************PARTICLE DATA *****************' write ( 60 , '(a18,i4)' ) '  Species number =' , nsp write ( 60 , '(a32,i4)' ) '  Id number of running species: ' , nsp_run write ( 60 , * ) '=============================' write ( 60 , * ) ' Species name:' , species_name ( 0 ) write ( 60 , '(a29,i4)' ) '  Macropart number per cell =' , & mp_per_cell ( 1 ) write ( 60 , '(a34,e11.4)' ) '  Reference macroparticle weight =' , & j0_norm write ( 60 , * ) ' Initial electron thermal speed V_T/c' write ( 60 , '(a2,1E12.4)' ) '  ' , t0_pl ( 1 ) write ( 60 , * ) '=============================' if ( nsp > 1 ) then do i = 2 , nsp write ( 60 , * ) ' Ion species name:' , species_name ( atomic_number ( i - 1 ) & ) write ( 60 , '(a23,i4)' ) '  Ion number per cell =' , mp_per_cell ( i ) write ( 60 , '(a34,e11.4)' ) '  Reference macroparticle weight= ' , & wgh_ion write ( 60 , * ) ' Initial charge, atomic number , mass number' write ( 60 , '(a4,i8,a4,i8,a6,e11.4)' ) '    ' , ion_min ( i - 1 ), '    ' , & atomic_number ( i - 1 ), '      ' , mass_number ( i - 1 ) write ( 60 , * ) ' Initial ion thermal speed V_T/c' write ( 60 , '(a2,1E12.4)' ) '  ' , t0_pl ( i ) end do end if write ( 60 , * ) '-----------------------------------' if ( ionization ) then write ( 60 , * ) ' Field ionization model:' if ( ionz_model == 1 ) write ( 60 , * ) ' W_DC ADK  ' if ( ionz_model == 2 ) write ( 60 , * ) ' W_AC= <W_DC>  ADK ' if ( ionz_model == 4 ) write ( 60 , * ) ' W_AC ADK +BSI ' if ( beam ) write ( 60 , '(a24,e11.4,a6)' ) '  Reference max E_field ' , & eb_max , '(TV/m)' if ( lp_active ) write ( 60 , '(a24,e11.4,a6)' ) & '  Reference max E_field ' , lp_max , '(TV/m)' do i = 1 , nsp_ionz - 1 write ( 60 , * ) ' Ionization active on ion species:' , & species_name ( atomic_number ( i )) end do if ( symmetrization_pulse . and . ( curr_ndim > 2 )) then write ( 60 , * ) ' A symmetrization pulse is implied when ionizing' write ( 60 , * ) & ' The sym. formula is sin(2*pi*u)*\\Delta*a_1*a_symm_rat' if ( a_symm_rat > zero_dp ) then write ( 60 , '(a32,e11.4)' ) ' Symmetrization amplitude a_symm_rat' , & a_symm_rat else write ( 60 , '(a32,e11.4)' ) ' Symmetrization amplitude a_symm_rat' , & sqrt ( 2. ) end if end if end if write ( 60 , * ) '**********TARGET PLASMA PARAMETERS***********' if ( part . or . hybrid ) then write ( 60 , '(a26,e11.4,a10)' ) '  Electron number density ' , n0_ref , & '[10&#94;18/cc]' write ( 60 , '(a21,e11.4)' ) '  Plasma wavelength= ' , lambda_p write ( 60 , '(a20,e11.4)' ) ' Chanelling fact  = ' , chann_fact if ( model_id < 5 ) then write ( 60 , '(a20,f5.2,a10)' ) '  Critical density= ' , ncrit , & '[10&#94;21/cc]' write ( 60 , '(a18,e11.4,a4)' ) '  Critical power= ' , p_c , '(TW)' end if write ( 60 , * ) '     Target sizes ' write ( 60 , * ) '  xmin_t        xmax_t' write ( 60 , '(a2,2e11.4)' ) '  ' , targ_in , targ_end write ( 60 , * ) ' ymin_t       ymax_t     ' write ( 60 , '(a2,2e11.4)' ) '  ' , ymin_t , ymax_t if ( ndim > 2 ) then write ( 60 , * ) ' zmin_t       zmax_t     ' write ( 60 , '(a2,2e11.4)' ) '  ' , zmin_t , zmax_t end if write ( 60 , * ) '********** TARGET CONFIGURATION***********' if ( wake ) then select case ( dmodel_id ) case ( 1 ) write ( 60 , * ) & ' Multispecies five-layer x-profile with one central plateau ' case ( 2 ) write ( 60 , * ) ' Multispecie five-layer x-profile with & &one central lpx(3) downrump' write ( 6 , * ) '        connecting two lpx(2) lpx(4) plateau ' case ( 3 ) write ( 60 , * ) & ' Five-layer x-profile with two lpx(2) lpx(4) plateau and' write ( 60 , * ) ' a ionizing dopant added in lpx(3) layer' end select end if if ( solid_target ) then select case ( dmodel_id ) case ( 3 ) write ( 60 , * ) ' Target preplasma-enabled ' if ( lpx ( 1 ) > 0.0 ) write ( 60 , '(a17,e11.4)' ) '  Preplasma size ' , & lpx ( 1 ) if ( lpx ( 2 ) > 0.0 ) write ( 60 , '(a12,e11.4)' ) '  Ramp size ' , lpx ( 2 ) if ( lpx ( 3 ) > 0.0 ) write ( 60 , '(a21,e11.4)' ) '  Central layer size ' , & lpx ( 3 ) if ( lpx ( 5 ) > 0.0 ) write ( 60 , '(a33,e11.4)' ) & '  Post-layer H contaminants size ' , lpx ( 5 ) case ( 4 ) write ( 60 , * ) ' Target H-foam-enabled ' if ( lpx ( 1 ) > 0.0 ) write ( 60 , '(a12,e11.4)' ) '  Foam size ' , lpx ( 1 ) if ( lpx ( 2 ) > 0.0 ) write ( 60 , '(a12,e11.4)' ) '  Ramp size ' , lpx ( 2 ) if ( lpx ( 5 ) > 0.0 ) write ( 60 , '(a33,e11.4)' ) & '  Post-layer H contaminants size ' , lpx ( 5 ) case ( 5 ) write ( 60 , * ) & ' Three species [El,Z1,Z3] target +[El,Z2] contaminants ' write ( 60 , * ) 'x-layer sizes' write ( 60 , '(3e11.4)' ) lpx ( 1 ), lpx ( 3 ), lpx ( 5 ) write ( 60 , * ) 'Layer density' write ( 60 , '(3e11.4)' ) n1_over_n , n_over_nc , n2_over_n case ( 6 ) write ( 60 , * ) ' Three species [El,Z]nanowires+ bulk ' write ( 60 , * ) 'wire size,interwire distance filling fact' if ( ndim < 3 ) then write ( 60 , '(3e11.4)' ) lpy ( 1 ), lpy ( 2 ), ( lpy ( 1 ) / ( lpy ( 1 ) + lpy ( 2 ))) else write ( 60 , '(3e11.4)' ) lpy ( 1 ), lpy ( 2 ), ( lpy ( 1 ) / ( lpy ( 1 ) + lpy ( 2 ))) ** & 2 end if write ( 60 , * ) 'Boundaries' , ibx , iby case ( 7 ) write ( 60 , * ) ' One layer [El,Z] nano-tubes' write ( 60 , * ) ' 2R_ext    2dr   ' write ( 60 , '(2e11.4)' ) lpy ( 1 ), lpy ( 2 ) write ( 60 , * ) 'Boundaries' , ibx , iby end select end if write ( 60 , * ) 'Fully kinetic PIC schemes' if ( model_id > 4 ) then write ( 60 , * ) '******Beam+plasma data *****************' write ( 60 , * ) ' nbfield components' , nbfield if ( ibeam > 0 ) then write ( 60 , * ) & ' Bunch fields described by two arrays: ebf_bunch,ebf1_bunch' end if write ( 60 , * ) ' Beam parameters: ' write ( 60 , * ) ' unit length is 1mu, unit density is n0=10&#94;18/cc' write ( 60 , * ) '  Lambda , Omega_p,  n_over_n0 ' write ( 60 , '(3e11.4)' ) lambda_p , omega_p , n_over_nc write ( 60 , * ) & '  gamma ,  sigma_x ,     sigma_y,   eps_y       eps_z ' do i = 1 , nsb write ( 60 , '(5e11.4)' ) gam ( i ), sxb ( i ), syb ( i ), epsy ( i ), epsz ( i ) end do write ( 60 , * ) '  nb_over_np  b_charge   Qcharge ' do i = 1 , nsb write ( 60 , '(3e11.4)' ) rhob ( i ), bunch_charge ( i ), reduced_charge ( i ) end do else write ( 60 , * ) ' unit length is 1mm, unit density is nc' write ( 60 , * ) '  Lambda , Omega_p    n_over_nc  ' write ( 60 , '(3e11.4)' ) lambda_p , omega_p , n_over_nc write ( 60 , * ) & '  gamma   bet0        Lx       sigma_y,   eps_y       eps_z ' i = 1 write ( 60 , '(6e11.4)' ) gam ( i ), bet0 , sxb ( i ), syb ( i ), epsy ( i ), & epsz ( i ) write ( 60 , * ) ' jb_norm     nb_o_np    b_charge_den  ' write ( 60 , '(3e11.4)' ) jb_norm ( i ), rhob ( i ), b_charge end if write ( 60 , * ) ' target in  target_end' write ( 60 , '(2e11.4)' ) targ_in , targ_end write ( 60 , * ) ' ymin_t       ymax_t     ' write ( 60 , '(2e11.4)' ) ymin_t , ymax_t write ( 60 , * ) ' Electron number per cell ' write ( 60 , '(i4)' ) nref write ( 60 , * ) ' Particle density normalization  ' write ( 60 , '(e11.4)' ) j0_norm end if write ( 60 , * ) '*******  END INITIAL DATA INFO***********' close ( 60 ) write ( 6 , * ) '********** TARGET *********************' write ( 6 , * ) ' target in  target_end' write ( 6 , '(2e11.4)' ) targ_in , targ_end write ( 6 , * ) ' ymin_t       ymax_t     ' write ( 6 , '(2e11.4)' ) ymin_t , ymax_t write ( 6 , * ) ' Electron number per cell ' write ( 6 , '(i4)' ) nref write ( 6 , * ) ' Particle density normalization  ' write ( 6 , '(e11.4)' ) j0_norm write ( 6 , * ) '********** ALLOCATED MEMORY (MB) *********************' write ( 6 , '(a28,e12.5)' ) ' Pe0 allocated grid memory= ' , & 1.e-06 * real ( mem_size , dp ) * kind ( electron_charge_norm ) write ( 6 , '(a28,e12.5)' ) ' Pe0 allocated part memory= ' , & 1.e-06 * real ( mem_psize , dp ) * kind ( electron_charge_norm ) if ( prl ) then write ( 6 , '(a24,e12.5)' ) ' Max part memory (MB) = ' , mem_psize_max !write(6,'(a20,e12.5)')' Max part  address= ',mem_max_addr end if write ( 6 , * ) ' Particle min/max distr. ' write ( 6 , '(i10,a1,i10)' ) np_min , ' ' , np_max write ( 6 , '(a18,2i8)' ) ' where pmin/pmax  ' , pe_npmin , pe_npmax write ( 6 , * ) '******************************************************' end subroutine !================================ subroutine ioniz_data ( ef_max , z0 , an , zlev , zmod ) real ( dp ), intent ( in ) :: ef_max integer , intent ( in ) :: z0 (:), an (:), zlev , zmod integer :: i , ic , k , zm_loc , lev_max if ( zlev == 1 ) open ( 10 , file = 'diag_one_level_ionz.dat' ) if ( zlev == 2 ) open ( 10 , file = 'diag_two_level_ionz.dat' ) write ( 10 , * ) 'nsp_ionz-1,zlev,zmod,N_ge ' write ( 10 , '(4i8)' ) nsp_ionz - 1 , zlev , zmod , n_ge write ( 10 , * ) '  Max Ef       dt      Omega_au  ' write ( 10 , '(3E11.4)' ) ef_max , dt_fs , omega_a if ( Two_color ) then write ( 10 , * ) & ' a0        lam0,      om0,      a1,      lam1,         om1' write ( 10 , '(6E11.4)' ) a0 , lam0 , oml , a1 , lam1 , om1 else write ( 10 , * ) ' a0        lam0,      om0' write ( 10 , '(6E11.4)' ) a0 , lam0 , oml end if do ic = 1 , nsp_ionz - 1 write ( 10 , * ) ' z0,     zmax' write ( 10 , '(2i6)' ) z0 ( ic ), an ( ic ) write ( 10 , * ) ' E_c       E_b           V_norm(a.u.)  ' lev_max = an ( ic ) do i = 1 , lev_max write ( 10 , '(3E12.4)' ) e_c ( i , ic ), e_b ( i , ic ), v_norm ( i , ic ) end do zm_loc = lev_max - z0 ( ic ) write ( 10 , * ) 'ionization rate :Wi(Ef,1:zmax-z0,ic) in fs&#94;{-1}' do i = 1 , zm_loc write ( 10 , * ) i write ( 10 , '(6e12.4)' ) wi ( 1 : n_ge , i , ic ) end do !=========================== cumulative distribution wsp if ( zlev == 1 ) then write ( 10 , * ) 'ionization one level probability  wsp(Ne_g,z0:zmax)' do i = 0 , zm_loc - 1 write ( 10 , * ) i write ( 10 , '(6e12.4)' ) w_one_lev ( 1 : n_ge , i + z0 ( ic ), ic ) end do else !for multi-level ionization write ( 10 , * ) & 'ionization multi level probability  wsp(Ne_g,z0:zmax,z0+i:zmax)' do i = 0 , zm_loc - 1 write ( 10 , * ) i do k = 0 , zm_loc - i write ( 10 , * ) k write ( 10 , '(6e12.4)' ) wsp ( 1 : n_ge , k , i + z0 ( ic ), ic ) end do end do end if end do close ( 10 ) end subroutine !==================================== subroutine Final_run_info if ( pe0 ) then write ( 6 , '(a14,i6,a5,e11.4,a11,e11.4)' ) ' final iter = ' , iter , & ' t = ' , tnow , ' last dt = ' , dt_loc !call tot_num_part call CPU_TIME ( unix_time_now ) write ( 6 , '(a22,f12.3,a10,i15)' ) ' Total time elapsed = ' , & unix_time_now - unix_time_begin write ( 6 , * ) ' END OF RUN' end if end subroutine !--------------------------- subroutine submem ( rmem ) real ( dp ), intent ( out ) :: rmem integer ( kind = 8 ) :: addr real ( dp ), allocatable :: am (:) allocate ( am ( 100 )) call memaddr ( am , addr ) deallocate ( am ) rmem = addr end subroutine !--------------------------- subroutine Max_pmemory_check () integer :: ndv1 , ndv2 integer :: ic real ( dp ) :: mem_loc ( 1 ), max_mem ( 1 ) !real(dp) :: adr mem_loc = 0. max_mem = 0. do ic = 1 , nsp if ( allocated ( spec ( ic )% part )) then ndv1 = size ( spec ( ic )% part , 1 ) ndv2 = size ( spec ( ic )% part , 2 ) mem_loc ( 1 ) = mem_loc ( 1 ) + real ( ndv1 * ndv2 , dp ) end if end do if ( allocated ( ebfp )) then ndv1 = size ( ebfp , 1 ) ndv2 = size ( ebfp , 2 ) mem_loc ( 1 ) = mem_loc ( 1 ) + real ( ndv1 * ndv2 , dp ) end if if ( beam ) then do ic = 1 , nsb if ( allocated ( bunch ( ic )% part )) then ndv1 = size ( spec ( ic )% part , 1 ) ndv2 = size ( spec ( ic )% part , 2 ) mem_loc ( 1 ) = mem_loc ( 1 ) + real ( ndv1 * ndv2 , dp ) end if end do if ( allocated ( ebfb )) then ndv1 = size ( ebfb , 1 ) ndv2 = size ( ebfb , 2 ) mem_loc ( 1 ) = mem_loc ( 1 ) + real ( ndv1 * ndv2 , dp ) end if end if if ( allocated ( ebfp0 )) then ndv1 = size ( ebfp0 , 1 ) ndv2 = size ( ebfp0 , 2 ) mem_loc ( 1 ) = mem_loc ( 1 ) + real ( ndv1 * ndv2 , dp ) end if if ( allocated ( ebfp1 )) then ndv1 = size ( ebfp1 , 1 ) ndv2 = size ( ebfp1 , 2 ) mem_loc ( 1 ) = mem_loc ( 1 ) + real ( ndv1 * ndv2 , dp ) end if call allreduce_dpreal ( maxv , mem_loc , max_mem , 1 ) mem_psize_max = kind ( electron_charge_norm ) * 1.e-06 * max_mem ( 1 ) !call submem(adr) !mem_loc(1)=adr !call allreduce_dpreal(MAXV,mem_loc,max_mem,1) !mem_max_addr=1.e-06*max_mem(1) end subroutine !--------------------------- end module","tags":"","loc":"sourcefile/run_data_info.f90.html"},{"title":"diag_part_and_fields.f90 – ALaDyn","text":"This file depends on sourcefile~~diag_part_and_fields.f90~~EfferentGraph sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~diag_part_and_fields.f90->sourcefile~phys_param.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~diag_part_and_fields.f90->sourcefile~control_bunch_input.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~diag_part_and_fields.f90->sourcefile~pstruct_data.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~diag_part_and_fields.f90->sourcefile~parallel.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~diag_part_and_fields.f90->sourcefile~fstruct_data.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~diag_part_and_fields.f90->sourcefile~code_util.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~diag_part_and_fields.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~diag_part_and_fields.f90~~AfferentGraph sourcefile~diag_part_and_fields.f90 diag_part_and_fields.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~diag_part_and_fields.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules diag_part_and_fields Source Code diag_part_and_fields.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module diag_part_and_fields use pstruct_data use fstruct_data use code_util use phys_param use parallel use grid_param use control_bunch_input , only : reduced_charge , bunch_charge , epsy , & epsz , sxb , syb , gam , dg implicit none real ( dp ) :: tloc ( 10000 ), tsp ( 1 : 1001 ), eavg ( 10 , 1001 ), & eavg1 ( 10 , 1001 ), pavg ( 15 , 1001 , 4 ), favg ( 30 , 1001 ) integer , parameter :: ne = 100 real ( dp ) :: nde0 ( ne ), nde1 ( ne ), nde2 ( ne ) real ( dp ) :: nde ( ne , 500 , 4 ), eksp_max ( 500 , 4 ), nde_sm ( ne , 500 , 4 ), & nde_sp ( ne , 500 , 4 ) integer :: ionz_number ( 500 ), hgam_number ( 500 ), bunch_number ( 500 , 5 ) real ( dp ) :: ionz_bavg ( 500 , 18 ), bunch_bavg ( 500 , 18 , 5 ), tbunch ( 1000 ), & tionz ( 500 ), hgam_charge ( 500 ), ionz_charge ( 500 ), bcharge ( 500 , 5 ) real ( dp ) :: hgam_bavg ( 500 , 18 ), tgam ( 500 ) contains subroutine track_part_pdata_out ( tk ) character ( 12 ), parameter :: tpart_name = 'El_track_out' character ( 14 ) :: fname character ( 23 ) :: fname_out integer , intent ( in ) :: tk real ( dp ), allocatable :: pdata (:) integer :: ik , p , q , ip , ip_max , it , tot_tpart integer :: lenp , ndv integer ( offset_kind ) :: disp character ( 4 ) :: foldername !integer,parameter :: file_version = 4 write ( foldername , '(i4.4)' ) iout ndv = nd2 + 1 if ( mype > 0 ) then ip = 0 else ip = loc_tpart ( 1 ) end if !call intvec_distribute(ip,loc_tpart,npe) !tot_tpart=0 !nptot_global_reduced=sum(ip_loc(1:npe)) !do ik=1,npe tot_tpart = loc_tpart ( 1 ) !end do ip_max = ip !if(pe0)ip_max=maxval(loc_tpart(1:npe)) lenp = ndv * ip * tk write ( fname , '(a12,i2.2)' ) tpart_name , iout !serve sempre fname_out = foldername // '/' // fname // '.bin' disp = 0 if ( pe0 ) then allocate ( pdata ( lenp )) ik = 0 do it = 1 , tk do p = 1 , ip do q = 1 , ndv ik = ik + 1 pdata ( ik ) = pdata_tracking ( q , p , it ) end do end do end do write ( 6 , * ) 'tpart size' , ik , lenp open ( 10 , file = foldername // '/' // fname // '.dat' , form = 'formatted' ) write ( 10 , * ) ' Real parameters' write ( 10 , * ) 'time ' write ( 10 , '(e11.4)' ) tnow write ( 10 , * ) 'time step size ' write ( 10 , '(e11.4)' ) dt write ( 10 , * ) ' Integer parameters' write ( 10 , * ) 'tot_nproc ' write ( 10 , '(i6)' ) npe write ( 10 , * ) 'phase dim ' write ( 10 , '(i6)' ) ndv write ( 10 , * ) 'space dim ' write ( 10 , '(i6)' ) ndim write ( 10 , * ) 'time nstep ' write ( 10 , '(i6)' ) tk write ( 10 , * ) 'nstep inc  ' write ( 10 , '(i6)' ) tkjump write ( 10 , * ) 'tot tkpart ' write ( 10 , '(3i8)' ) ip , tot_tpart , track_tot_part close ( 10 ) write ( 6 , * ) 'Particles param written on file: ' // foldername // & '/' // fname // '.dat' !====================== open ( 20 , file = foldername // '/' // fname // '.bin' , form = 'unformatted' ) write ( 20 ) pdata ( 1 : lenp ) !(coordinates,pindex,time)=>(coordinates,time,pind) close ( 20 ) write ( 6 , * ) 'Particles data written on file: ' // foldername // & '/' // fname // '.bin' end if end subroutine !============================================== subroutine energy_spect ( np , ekem , gfield ) integer , intent ( in ) :: np real ( dp ), intent ( in ) :: ekem real ( dp ), intent ( in ) :: gfield (:, :) integer :: p , ix real ( dp ) :: xx , de , wght ! activated only for np>0 de = ekem / real ( ne , dp ) if ( ekem < 1.e-06 ) return do p = 1 , np xx = gfield ( p , 1 ) / de !0.5*mc&#94;2*(gamma-1) energy in MeV wght = gfield ( p , 2 ) !weight >0 to be multiplied by np_per_cell ix = nint ( xx ) ix = min ( ix + 1 , ne ) nde0 ( ix ) = nde0 ( ix ) + wght end do end subroutine subroutine select_energy_spect ( np , ekem , xl , xr , gfield ) integer , intent ( in ) :: np real ( dp ), intent ( in ) :: ekem , xl , xr real ( dp ), intent ( in ) :: gfield (:, :) integer :: p , ix real ( dp ) :: xx , de , wght ! activated only for np>0 de = ekem / real ( ne , dp ) if ( ekem < 1.e-06 ) return do p = 1 , np xx = gfield ( p , 1 ) / de !0.5*mc&#94;2*(gamma-1) energy in MeV wght = gfield ( p , 2 ) !weight >0 ix = nint ( xx ) ix = min ( ix + 1 , ne ) if ( gfield ( p , 4 ) < xl ) then nde0 ( ix ) = nde0 ( ix ) + wght end if if ( gfield ( p , 4 ) > xr ) then nde1 ( ix ) = nde1 ( ix ) + wght end if end do end subroutine !-------------------------- subroutine energy_momenta ( sp_loc , gfield , np , ek , ekmax ) type ( species ), intent ( in ) :: sp_loc real ( dp ), intent ( inout ) :: gfield (:, :) integer , intent ( in ) :: np real ( dp ), intent ( out ) :: ek (:), ekmax integer :: ip , ik real ( dp ) :: xp ( 3 ), vp ( 3 ), gamm , gam1 ek = 0.0 ekmax = 0.0 if ( curr_ndim < 3 ) then do ip = 1 , np vp ( 1 : 2 ) = sp_loc % part ( ip , 3 : 4 ) gamm = sqrt ( 1. + vp ( 1 ) * vp ( 1 ) + vp ( 2 ) * vp ( 2 )) gfield ( ip , 1 ) = pmass * ( gamm - 1. ) wgh_cmp = sp_loc % part ( ip , 5 ) gfield ( ip , 2 ) = wgh gfield ( ip , 3 ) = vp ( 1 ) gfield ( ip , 4 ) = sp_loc % part ( ip , 1 ) gam1 = gamm - 1. do ik = 1 , curr_ndim ek ( ik ) = ek ( ik ) + wgh * vp ( ik ) end do ek ( 6 ) = ek ( 6 ) + real ( charge * wgh , dp ) ek ( 7 ) = ek ( 7 ) + real ( wgh * gam1 , dp ) ekmax = max ( ekmax , gam1 ) end do else do ip = 1 , np xp ( 1 : 3 ) = sp_loc % part ( ip , 1 : 3 ) vp ( 1 : 3 ) = sp_loc % part ( ip , 4 : 6 ) gamm = sqrt ( 1. + vp ( 1 ) * vp ( 1 ) + vp ( 2 ) * vp ( 2 ) + vp ( 3 ) * vp ( 3 )) gfield ( ip , 1 ) = pmass * ( gamm - 1. ) wgh_cmp = sp_loc % part ( ip , 7 ) gfield ( ip , 2 ) = wgh gfield ( ip , 3 ) = vp ( 1 ) gfield ( ip , 4 ) = sp_loc % part ( ip , 1 ) gam1 = gamm - 1. do ik = 1 , curr_ndim ek ( ik ) = ek ( ik ) + vp ( ik ) !momenta end do ek ( 4 ) = ek ( 4 ) + wgh * ( xp ( 2 ) * vp ( 3 ) - xp ( 3 ) * vp ( 2 )) ek ( 6 ) = ek ( 6 ) + real ( charge * wgh , dp ) ek ( 7 ) = ek ( 7 ) + real ( wgh * gam1 , dp ) ekmax = max ( ekmax , gam1 ) end do end if end subroutine !-------------------------- subroutine laser_struct_data ( nst ) integer , intent ( in ) :: nst integer :: i1 , j1 , k1 , i2 , ic , nb_tot integer :: ik , ix , iy , iz real ( dp ) :: xm , a2 , ekt ( 10 ), xcm ( 10 ), eks ( 10 ), xcms ( 10 ) j1 = jy1 k1 = kz1 i1 = ix1 i2 = nxp xm = loc_xgrid ( imodx )% gmin ekt = 0.0 xcm = 0.0 ! !data on driver laser field ! CComputes the COM x- coordinates of nb_laser Ey fields (=> group velocity) !=================== ik = 3 if ( ndim < 3 ) ik = 2 nb_tot = nb_laser if ( Two_color ) nb_tot = nb_laser + 1 eavg ( 1 : nb_tot , nst ) = 0.0 !================ field component selection do ic = 1 , nb_laser if ( lp_in ( ic ) > xm ) then do iz = k1 , nzp do iy = j1 , nyp do ix = i1 , i2 if ( x ( ix ) >= lp_in ( ic ) . and . x ( ix ) <= lp_end ( ic )) then a2 = ebf ( ix , iy , iz , ik ) * ebf ( ix , iy , iz , ik ) xcm ( ic ) = xcm ( ic ) + x ( ix ) * a2 ekt ( ic ) = ekt ( ic ) + a2 end if end do end do end do end if end do if ( Two_color ) then if ( lp_ionz_in > xm ) then ic = nb_laser + 1 do iz = k1 , nzp do iy = j1 , nyp do ix = i1 , i2 if ( x ( ix ) >= lp_ionz_in . and . x ( ix ) <= lp_ionz_end ) then a2 = ebf ( ix , iy , iz , ik ) * ebf ( ix , iy , iz , ik ) xcm ( ic ) = xcm ( ic ) + x ( ix ) * a2 ekt ( ic ) = ekt ( ic ) + a2 end if end do end do end do end if end if eks ( 1 : nb_tot ) = ekt ( 1 : nb_tot ) xcms ( 1 : nb_tot ) = xcm ( 1 : nb_tot ) call allreduce_dpreal ( sumv , ekt , eks , nb_tot ) call allreduce_dpreal ( sumv , xcm , xcms , nb_tot ) do ic = 1 , nb_tot if ( eks ( ic ) > 0.0 ) eavg ( ic , nst ) = xcms ( ic ) / eks ( ic ) !Sum(xE&#94;2)/sum(E&#94;2) end do !================= end subroutine subroutine envelope_struct_data ( nst ) integer , intent ( in ) :: nst integer :: i1 , j1 , k1 , i2 , kk integer :: ik , ix , iy , iz , i01 , i02 , i0_lp , j , k real ( dp ) :: ekt ( 7 ), ekm ( 7 ) real ( dp ) :: dvol , dgvol , rr , yy , zz real ( dp ) :: dar , dai , a2 , aph1 , aph2 real ( dp ), parameter :: field_energy = 1.156e-06 dgvol = dx * dy * dz if ( ndim == 2 ) dgvol = dx * dy * dy j1 = jy1 k1 = kz1 i1 = ix1 i2 = nxp ekt = 0.0 ! env(1)=Re[A], env(2)=Im[A] A in adimensional form aph1 = 0.5 * dx_inv aph2 = 0.0 i01 = i1 + 1 i02 = i2 - 1 if ( der_ord == 4 ) then aph1 = 4. * dx_inv / 3. aph2 = - dx_inv / 6. i01 = i01 + 1 i02 = i02 - 1 end if kk = 0 do iz = k1 , nzp do iy = j1 , nyp do ix = i01 , i02 ik = ix - 2 dar = aph1 * ( env ( ix + 1 , iy , iz , 1 ) - env ( ix - 1 , iy , iz , 1 )) + & aph2 * ( env ( ix + 2 , iy , iz , 1 ) - env ( ix - 2 , iy , iz , 1 )) dai = aph1 * ( env ( ix + 1 , iy , iz , 2 ) - env ( ix - 1 , iy , iz , 2 )) + & aph2 * ( env ( ix + 2 , iy , iz , 2 ) - env ( ix - 2 , iy , iz , 2 )) a2 = env ( ix , iy , iz , 1 ) * env ( ix , iy , iz , 1 ) + & env ( ix , iy , iz , 2 ) * env ( ix , iy , iz , 2 ) ekt ( 1 ) = ekt ( 1 ) + x ( ik ) * a2 ! Centroid ekt ( 2 ) = ekt ( 2 ) + a2 ! !A|&#94;2 ekt ( 6 ) = dai * env ( ix , iy , iz , 1 ) - dar * env ( ix , iy , iz , 2 ) ekt ( 3 ) = ekt ( 3 ) + oml * oml * a2 + 2. * oml * ekt ( 6 ) + dar * dar + dai * dai !|Z|&#94;2=(Ey&#94;2+Bz&#94;2)/2= field energy ekt ( 4 ) = ekt ( 4 ) + oml * a2 + ekt ( 6 ) ! Action ekt ( 7 ) = max ( ekt ( 7 ), sqrt ( a2 )) ! Max |A| kk = kk + 1 end do end do end do dvol = 1. / real ( kk , dp ) call allreduce_dpreal ( sumv , ekt , ekm , 4 ) if ( ekm ( 2 ) > 0.0 ) then ekm ( 1 ) = ekm ( 1 ) / ekm ( 2 ) !Centroid end if eavg ( 2 , nst ) = ekm ( 1 ) !Centroid eavg ( 4 , nst ) = field_energy * dgvol * ekm ( 3 ) !Energy eavg ( 5 , nst ) = dvol * ekm ( 4 ) !Action !=============== i0_lp = i1 + nint ( dx_inv * ekm ( 1 )) ekt ( 1 : 2 ) = 0.0 do iz = k1 , nzp zz = 0.0 if ( k1 > 2 ) then k = iz - 2 zz = loc_zg ( k , 2 , imodz ) end if do iy = j1 , nyp j = iy - 2 yy = loc_yg ( j , 2 , imody ) rr = sqrt ( zz * zz + yy * yy ) do ix = i01 , i02 a2 = env ( ix , iy , iz , 1 ) * env ( ix , iy , iz , 1 ) + & env ( ix , iy , iz , 2 ) * env ( ix , iy , iz , 2 ) ekt ( 1 ) = ekt ( 1 ) + rr * a2 end do end do end do call allreduce_dpreal ( sumv , ekt , ekm , 1 ) if ( ekm ( 2 ) > 0.0 ) then ekm ( 1 ) = ekm ( 1 ) / ekm ( 2 ) ! env radius end if eavg ( 3 , nst ) = ekm ( 1 ) !radius !=============== ekt ( 1 ) = ekt ( 7 ) if ( ekt ( 1 ) > giant_field ) then write ( 6 , * ) ' WARNING: Env field too big ' , ekt ( 1 ) write ( 6 , '(a23,3i4)' ) ' At the mpi_task=' , imodx , imody , imodz end if ekm ( 1 ) = ekt ( 1 ) if ( prl ) call allreduce_dpreal ( maxv , ekt , ekm , 1 ) eavg ( 1 , nst ) = ekm ( 1 ) if ( Two_color ) then kk = 0 ekt = 0.0 do iz = k1 , nzp do iy = j1 , nyp do ix = i1 , i2 ik = ix - 2 dar = aph1 * ( env1 ( ix + 1 , iy , iz , 1 ) - env1 ( ix - 1 , iy , iz , 1 )) + & aph2 * ( env1 ( ix + 2 , iy , iz , 1 ) - env1 ( ix - 2 , iy , iz , 1 )) dai = aph1 * ( env1 ( ix + 1 , iy , iz , 2 ) - env1 ( ix - 1 , iy , iz , 2 )) + & aph2 * ( env1 ( ix + 2 , iy , iz , 2 ) - env1 ( ix - 2 , iy , iz , 2 )) a2 = env1 ( ix , iy , iz , 1 ) * env1 ( ix , iy , iz , 1 ) + & env1 ( ix , iy , iz , 2 ) * env1 ( ix , iy , iz , 2 ) ekt ( 1 ) = ekt ( 1 ) + x ( ik ) * a2 ! Centroid ekt ( 2 ) = ekt ( 2 ) + a2 ! !A|&#94;2 ekt ( 6 ) = dai * env1 ( ix , iy , iz , 1 ) - dar * env1 ( ix , iy , iz , 2 ) ekt ( 3 ) = ekt ( 3 ) + om1 * om1 * a2 + 2. * om1 * ekt ( 6 ) + dar * dar + dai * dai !|Z|&#94;2=(Ey&#94;2+Bz&#94;2)/2= field energy ekt ( 4 ) = ekt ( 4 ) + om1 * a2 + ekt ( 6 ) ! Action ekt ( 7 ) = max ( ekt ( 7 ), sqrt ( a2 )) ! Max |A| kk = kk + 1 end do end do end do dvol = 1. / real ( kk , dp ) call allreduce_dpreal ( sumv , ekt , ekm , 4 ) if ( ekm ( 2 ) > 0.0 ) then ekm ( 1 ) = ekm ( 1 ) / ekm ( 2 ) !Centroid end if eavg1 ( 2 , nst ) = ekm ( 1 ) eavg1 ( 4 , nst ) = field_energy * dgvol * ekm ( 3 ) !Energy eavg1 ( 5 , nst ) = dvol * ekm ( 4 ) !Action !=============== i0_lp = i1 + nint ( dx_inv * ekm ( 1 )) ekt ( 1 : 2 ) = 0.0 do iz = k1 , nzp zz = 0.0 if ( k1 > 2 ) then k = iz - 2 zz = loc_zg ( k , 2 , imodz ) end if do iy = j1 , nyp j = iy - 2 yy = loc_yg ( j , 2 , imody ) rr = sqrt ( zz * zz + yy * yy ) do ix = i01 , i02 a2 = env1 ( ix , iy , iz , 1 ) * env1 ( ix , iy , iz , 1 ) + & env1 ( ix , iy , iz , 2 ) * env1 ( ix , iy , iz , 2 ) ekt ( 1 ) = ekt ( 1 ) + rr * a2 end do end do end do call allreduce_dpreal ( sumv , ekt , ekm , 1 ) if ( ekm ( 2 ) > 0.0 ) then ekm ( 1 ) = ekm ( 1 ) / ekm ( 2 ) ! env radius end if eavg ( 3 , nst ) = ekm ( 1 ) !radius !=============== ekt ( 1 ) = ekt ( 7 ) if ( ekt ( 1 ) > giant_field ) then write ( 6 , * ) ' WARNING: Env1 field too big ' , ekt ( 1 ) write ( 6 , '(a23,3i4)' ) ' At the mpi_task=' , imodx , imody , imodz end if ekm ( 1 ) = ekt ( 1 ) if ( prl ) call allreduce_dpreal ( maxv , ekt , ekm , 1 ) eavg1 ( 1 , nst ) = ekm ( 1 ) end if end subroutine !=========================== subroutine fields_on_target ( nst ) integer , intent ( in ) :: nst integer :: i1 , j1 , k1 , i2 , ii integer :: ik , ix , iy , iz real ( dp ) :: ekt ( 7 ), ekm ( 7 ) real ( dp ) :: dgvol real ( dp ), parameter :: field_energy = 1.156e-06 dgvol = dx * dy * dz if ( ndim == 2 ) dgvol = dx * dy * dy j1 = jy1 k1 = kz1 i1 = ix1 i2 = nxp ekt = 0.0 do ix = i1 , i2 ii = ix - 2 if ( x ( ii ) >= targ_in ) then do ik = 1 , nfield do iz = k1 , nzp do iy = j1 , nyp ekt ( ik ) = ekt ( ik ) + ebf ( ix , iy , iz , ik ) * ebf ( ix , iy , iz , ik ) end do end do end do end if end do ekt ( 1 : nfield ) = dgvol * ekt ( 1 : nfield ) call allreduce_dpreal ( sumv , ekt , ekm , nfield ) eavg ( 1 : nfield , nst ) = field_energy * ekm ( 1 : nfield ) !======================= end subroutine subroutine Envar ( nst ) integer , intent ( in ) :: nst integer :: np , ik , ix , iy , iz , ic , i1 , i2 , ndv integer :: j1 , k1 , ii , jj , kk , j , k , l real ( dp ) :: ek_max ( 1 ), ekt ( 7 ), ekm ( 7 ), ekmax ( 1 ) real ( dp ) :: dvol , dgvol , sgz , sg , ef2 real ( dp ) :: np_norm , p_energy_norm real ( dp ), parameter :: mev_to_joule = 1.602e-13 real ( dp ), parameter :: field_energy = 1.156e-06 integer , parameter :: zg_ind ( 6 ) = [ 3 , 3 , 4 , 4 , 4 , 3 ] integer , parameter :: yg_ind ( 6 ) = [ 3 , 4 , 3 , 4 , 3 , 4 ] integer , parameter :: xg_ind ( 6 ) = [ 4 , 3 , 3 , 3 , 4 , 4 ] !================================================ ! field_energy transforms the energy density u=E&#94;2/2 in adimensional ! form to energy density in Joule/mu&#94;3 ! field_energy =epsilon_0*(E_0&#94;2)/2 in SI or !              =(E_0&#94;2)/8pi         in cgs (Gaussian) units !================================================== dgvol = dx * dy * dz if ( ndim == 2 ) dgvol = dx * dy * dy ndv = nd2 + 1 j1 = jy1 k1 = kz1 i1 = ix1 i2 = nxp tloc ( nst ) = tnow tsp ( nst ) = tnow if ( nst == 1 ) then pavg = 0.0 favg = 0.0 eavg = 0.0 nde_sp = 0.0 nde_sm = 0.0 nde = 0.0 end if ekt ( 1 ) = real ( nx * ny * nz , dp ) dvol = 1. / ekt ( 1 ) if ( part ) then p_energy_norm = np_per_cell * mev_to_joule do ic = 1 , nsp ekm = 0.0 ekt = 0.0 ekmax = 0.0 ek_max = 0.0 np = loc_npart ( imody , imodz , imodx , ic ) ekt ( 1 ) = real ( np , dp ) call allreduce_dpreal ( sumv , ekt , ekm , 1 ) np_norm = 1. if ( ekm ( 1 ) > 0.0 ) np_norm = 1.0 / ekm ( 1 ) pmass = electron_mass * mass ( ic ) !In MeV ekt ( 1 ) = 0.0 ekm ( 1 ) = 0.0 if ( np > 0 ) then call energy_momenta ( spec ( ic ), ebfp , np , ekt , ekmax ( 1 )) !  WARNING: total variables multipied by a weight = 1/nmacro_per cell !  Momenta ekt(1:3) are averaged by the macroparticle total number !================================== ekt ( 4 ) = pmass * ekt ( 4 ) !Total angular momentum (Mev/c&#94;2) ekt ( 7 ) = pmass * ekt ( 7 ) !the ic-species TOTAL energy (MeV) ekmax ( 1 ) = pmass * ekmax ( 1 ) end if call allreduce_dpreal ( maxv , ekmax , ek_max , 1 ) !============= spectra section nde0 ( 1 : ne ) = 0.0 if ( np > 0 ) call energy_spect ( np , ek_max ( 1 ), ebfp ) nde1 ( 1 : ne ) = nde0 ( 1 : ne ) call allreduce_dpreal ( sumv , nde0 , nde1 , ne ) nde ( 1 : ne , nst , ic ) = nde1 ( 1 : ne ) if ( solid_target ) then nde0 ( 1 : ne ) = 0.0 nde1 ( 1 : ne ) = 0.0 if ( np > 0 ) call select_energy_spect ( np , ek_max ( 1 ), targ_in , & targ_end , ebfp ) nde2 ( 1 : ne ) = nde0 ( 1 : ne ) call allreduce_dpreal ( sumv , nde0 , nde2 , ne ) nde_sm ( 1 : ne , nst , ic ) = nde2 ( 1 : ne ) nde2 ( 1 : ne ) = nde1 ( 1 : ne ) call allreduce_dpreal ( sumv , nde1 , nde2 , ne ) nde_sp ( 1 : ne , nst , ic ) = nde2 ( 1 : ne ) end if !======================= end spectra section call allreduce_dpreal ( sumv , ekt , ekm , 7 ) do ik = 1 , curr_ndim ekm ( ik ) = ekm ( ik ) * np_norm !Average Momenta end do !======================= phase space integrated data for each species eksp_max ( nst , ic ) = ek_max ( 1 ) pavg ( 1 , nst , ic ) = p_energy_norm * ekm ( 7 ) !Total energy of ic species (Joule) pavg ( 2 , nst , ic ) = ek_max ( 1 ) ! Max energy (MeV) pavg ( 3 , nst , ic ) = mev_to_joule * ekm ( 4 ) !total angular Momenta pavg ( 4 : 6 , nst , ic ) = pmass * ekm ( 1 : 3 ) !averaged linear Momenta (MeV/c) pavg ( 10 , nst , ic ) = np_norm * ekm ( 6 ) !Mean charge pavg ( 11 , nst , ic ) = dvol * ekm ( 6 ) !Charge per cell ekt ( 1 : 3 ) = 0.0 if ( np > 0 ) then do ik = 1 , curr_ndim kk = ik + curr_ndim do ix = 1 , np sg = spec ( ic )% part ( ix , kk ) - ekm ( ik ) ekt ( ik ) = ekt ( ik ) + sg * sg ! <[p -<p>]&#94;2>, p=gamma*v/c end do end do end if call allreduce_dpreal ( sumv , ekt , ekm , 3 ) ekm ( 1 : 3 ) = np_norm * ekm ( 1 : 3 ) do ik = 1 , curr_ndim pavg ( 6 + ik , nst , ic ) = 1.e+03 * pmass * ekm ( ik ) ! !sigma&#94;2 of particle momenta (in KeV) end do end do end if if ( ionization ) call enb_ionz ( nst , tnow , gam_min ) !select ioniz.electrons with gamma > gam_min if ( high_gamma ) call enb_hgam ( nst , tnow , gam_min ) if ( inject_beam ) then bunch_bavg ( nst , :, :) = 0.0 tbunch ( nst ) = tnow do ik = 1 , nsb call enb_bunch ( nst , ik ) end do endif !   END PARTICLE SECTION !======================== Field  section ekt = 0.0 ekm = 0.0 if ( stretch ) then if ( ndim == 3 ) then do ik = 1 , nfield k = zg_ind ( ik ) !staggering of stretched grid cell j = yg_ind ( ik ) l = xg_ind ( ik ) do iz = k1 , nzp kk = iz - 2 sgz = 1. / loc_zg ( kk , k , imodz ) do iy = j1 , nyp jj = iy - 2 sg = sgz / loc_yg ( jj , j , imody ) do ix = i1 , i2 ii = ix - 2 dvol = sg / loc_xg ( ii , l , imodx ) ekt ( ik ) = ekt ( ik ) + dvol * ebf ( ix , iy , iz , ik ) * ebf ( ix , iy , iz , ik & ) end do end do end do end do else do ik = 1 , nfield j = yg_ind ( ik ) l = xg_ind ( ik ) do iz = k1 , nzp sgz = 1. do iy = j1 , nyp jj = iy - 2 sg = sgz / loc_yg ( jj , j , imody ) do ix = i1 , i2 ii = ix - 2 dvol = sg / loc_xg ( ii , l , imodx ) ekt ( ik ) = ekt ( ik ) + dvol * ebf ( ix , iy , iz , ik ) * ebf ( ix , iy , iz , ik & ) end do end do end do end do end if else do ik = 1 , nfield do iz = k1 , nzp do iy = j1 , nyp do ix = i1 , i2 ekt ( ik ) = ekt ( ik ) + ebf ( ix , iy , iz , ik ) * ebf ( ix , iy , iz , ik ) end do end do end do end do end if ekt ( 1 : nfield ) = dgvol * ekt ( 1 : nfield ) call allreduce_dpreal ( sumv , ekt , ekm , nfield ) favg ( 1 : 3 , nst ) = field_energy * ekm ( 1 : 3 ) !field itotal energy (in Joule) favg ( 7 : 9 , nst ) = field_energy * ekm ( 4 : 6 ) ekt = 0.0 do iz = k1 , nzp do iy = j1 , nyp do ix = i1 , i2 ef2 = dot_product ( ebf ( ix , iy , iz , 1 : curr_ndim ), & ebf ( ix , iy , iz , 1 : curr_ndim )) ekt ( 7 ) = max ( ekt ( 7 ), ef2 ) end do end do end do do ik = 1 , nfield if ( ekm ( ik ) > 0.0 ) ekt ( ik ) = maxval ( abs ( ebf ( i1 : i2 , j1 : nyp , k1 : nzp , ik ))) if ( ekt ( ik ) > giant_field ) then write ( 6 , * ) ' WARNING: Ebf field too big at component=' , ik write ( 6 , * ) 'max fields' , mype , ekt ( ik ) do iz = k1 , nzp do iy = j1 , nyp do ix = i1 , i2 if ( abs ( ebf ( ix , iy , iz , ik ) - ekt ( ik )) < epsilon ) then ii = ix jj = iy kk = iz end if end do end do end do write ( 6 , '(a23,3i4)' ) ' At the mpi_task=' , imodx , imody , imodz write ( 6 , '(a19,3i6)' ) ' At the local grid=' , ii , jj , kk end if end do ekm = 0.0 ! Max values call allreduce_dpreal ( maxv , ekt , ekm , 7 ) favg ( 4 : 6 , nst ) = e0 * ekm ( 1 : 3 ) !Max fields in TV/m favg ( 10 : 12 , nst ) = e0 * ekm ( 4 : 6 ) !===================================== if ( wake ) then if ( envelope ) then call envelope_struct_data ( nst ) !else ! call laser_struct_data(nst) end if end if if ( solid_target ) call fields_on_target ( nst ) end subroutine !-------------------------- subroutine bunch_corr ( bch , np_loc , np_norm , bcorr ) real ( dp ), intent ( in ) :: bch (:, :) integer , intent ( in ) :: np_loc real ( dp ), intent ( out ) :: bcorr ( 16 ) real ( dp ), intent ( in ) :: np_norm integer :: ik , kk , ndv real ( dp ) :: gmb , pp ( 3 ), mu ( 7 ), ekt ( 9 ), ekm ( 9 ) real ( dp ) :: corr2 ( 8 ), emy , emz , dgam , w_norm !===================== bcorr = 0.0 mu = 0.0 corr2 = 0.0 ndv = 2 * curr_ndim ekt = 0.0 if ( np_loc > 0 ) then if ( curr_ndim == 2 ) then do kk = 1 , np_loc wgh_cmp = bch ( kk , 5 ) ekt ( 1 : 2 ) = ekt ( 1 : 2 ) + wgh * bch ( kk , 1 : 2 ) ! <w*X>  <w*Y> pp ( 1 : 2 ) = bch ( kk , 3 : 4 ) ekt ( 3 ) = ekt ( 3 ) + wgh * pp ( 1 ) ekt ( 4 ) = ekt ( 4 ) + wgh * pp ( 2 ) gmb = sqrt ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 )) ekt ( ndv + 1 ) = ekt ( ndv + 1 ) + wgh * gmb ekt ( 8 ) = ekt ( 8 ) + wgh end do ekt ( 7 ) = ekt ( ndv + 1 ) ! <w*gam> ekt ( 6 ) = 0.0 ! <w*Pz> ekt ( 5 ) = ekt ( 4 ) ! <w*Py> ekt ( 4 ) = ekt ( 3 ) ! <w*Px> ekt ( 3 ) = 0.0 ! <w*z> else do kk = 1 , np_loc wgh_cmp = bch ( kk , 7 ) ekt ( 1 : 3 ) = ekt ( 1 : 3 ) + wgh * bch ( kk , 1 : 3 ) ! weight*(X,Y,Z) coordinates pp ( 1 : 3 ) = bch ( kk , 4 : 6 ) gmb = sqrt ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) + pp ( 3 ) * pp ( 3 )) ekt ( 4 : 6 ) = ekt ( 4 : 6 ) + wgh * pp ( 1 : 3 ) ekt ( 7 ) = ekt ( 7 ) + wgh * gmb ekt ( 8 ) = ekt ( 8 ) + wgh end do end if end if call allreduce_dpreal ( sumv , ekt , ekm , 8 ) w_norm = np_norm if ( ekm ( 8 ) > 0.0 ) w_norm = 1. / ekm ( 8 ) !=================== mu ( 1 : 3 ) = w_norm * ekm ( 1 : 3 ) !weighted averages <(x,y,z)> mu ( 4 : 7 ) = w_norm * ekm ( 4 : 7 ) !weighted averages <(Px,Py,Pz,gamma)> !=========== 2th moments ekm = 0.0 ekt = 0.0 if ( np_loc > 0 ) then if ( curr_ndim == 2 ) then do kk = 1 , np_loc wgh_cmp = bch ( kk , 5 ) ekt ( 1 ) = ekt ( 1 ) + wgh * bch ( kk , 1 ) * bch ( kk , 1 ) ekt ( 2 ) = ekt ( 2 ) + wgh * bch ( kk , 2 ) * bch ( kk , 2 ) pp ( 1 : 2 ) = bch ( kk , 3 : 4 ) ekt ( 3 ) = ekt ( 3 ) + wgh * pp ( 1 ) * pp ( 1 ) ! <w*p*p> ekt ( 4 ) = ekt ( 4 ) + wgh * pp ( 2 ) * pp ( 2 ) ekt ( 7 ) = ekt ( 7 ) + wgh * pp ( 2 ) * bch ( kk , 2 ) ! <y*w*py> gmb = 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) ekt ( 9 ) = ekt ( 9 ) + wgh * gmb ! <w*gam**2> end do ekt ( 6 ) = 0.0 ! <Pz*Pz> ekt ( 8 ) = 0.0 ! <z*Pz) ekt ( 5 ) = ekt ( 4 ) ! <Py*Py> ekt ( 4 ) = ekt ( 3 ) ! <Px*Px> ekt ( 3 ) = 0.0 ! <z*z> else do kk = 1 , np_loc wgh_cmp = bch ( kk , 7 ) ekt ( 1 : 3 ) = ekt ( 1 : 3 ) + wgh * bch ( kk , 1 : 3 ) * bch ( kk , 1 : 3 ) pp ( 1 : 3 ) = bch ( kk , 4 : 6 ) ekt ( 4 : 6 ) = ekt ( 4 : 6 ) + wgh * pp ( 1 : 3 ) * pp ( 1 : 3 ) ekt ( 7 ) = ekt ( 7 ) + wgh * pp ( 2 ) * bch ( kk , 2 ) ! <y*w*py> ekt ( 8 ) = ekt ( 8 ) + wgh * pp ( 3 ) * bch ( kk , 3 ) ! <z*w*pz> gmb = wgh * ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) + pp ( 3 ) * pp ( 3 )) ekt ( 9 ) = ekt ( 9 ) + gmb ! <(w*gam**2> end do end if end if call allreduce_dpreal ( sumv , ekt , ekm , 9 ) ekm ( 1 : 9 ) = w_norm * ekm ( 1 : 9 ) do ik = 1 , 6 corr2 ( ik ) = ekm ( ik ) - mu ( ik ) * mu ( ik ) ! <UU>-<U><U>   U[X,Y,Z,Px,Py,Pz] end do corr2 ( 7 ) = ekm ( 7 ) - mu ( 2 ) * mu ( 5 ) corr2 ( 8 ) = ekm ( 8 ) - mu ( 3 ) * mu ( 6 ) !    emy&#94;2= corr2_y*corr2_py -mixed ! <yy><p_yp_y>-(<yp_y>-<y><p_y>)&#94;2 emy = corr2 ( 2 ) * corr2 ( 5 ) - corr2 ( 7 ) * corr2 ( 7 ) emz = corr2 ( 3 ) * corr2 ( 6 ) - corr2 ( 8 ) * corr2 ( 8 ) gmb = mu ( 7 ) * mu ( 7 ) ! <gam><gam> dgam = 0.0 if ( gmb > 0.0 ) dgam = ekm ( 9 ) / gmb - 1.0 if ( dgam > 0.0 ) dgam = sqrt ( dgam ) !Dgamm/gamma bcorr ( 1 : 6 ) = mu ( 1 : 6 ) bcorr ( 7 : 12 ) = corr2 ( 1 : 6 ) bcorr ( 13 ) = emy bcorr ( 14 ) = emz bcorr ( 15 ) = mu ( 7 ) bcorr ( 16 ) = dgam !========================== end subroutine !=========================== subroutine enb_bunch ( nst , ib ) integer , intent ( in ) :: nst , ib integer :: ik , np , p , q real ( dp ) :: np_norm , bcorr ( 16 ), ekt ( 2 ), ekm ( 2 ) ik = 0 np = loc_npart ( imody , imodz , imodx , 1 ) ekt = 0.0 if ( np > 0 ) then select case ( curr_ndim ) case ( 2 ) do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , 5 ) if ( part_ind == ib ) then ekt ( 2 ) = ekt ( 2 ) + wgh ik = ik + 1 do q = 1 , nd2 + 1 ebfp ( ik , q ) = spec ( 1 )% part ( p , q ) end do end if end do case ( 3 ) do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , 7 ) if ( part_ind == ib ) then ekt ( 2 ) = ekt ( 2 ) + wgh ik = ik + 1 do q = 1 , nd2 + 1 ebfp ( ik , q ) = spec ( 1 )% part ( p , q ) end do end if end do end select end if !================================ ekt ( 1 ) = real ( ik , dp ) call allreduce_dpreal ( sumv , ekt , ekm , 2 ) bunch_number ( nst , ib ) = nint ( ekm ( 1 )) np_norm = 1. if ( ekm ( 1 ) > 0.0 ) np_norm = 1. / ekm ( 1 ) call bunch_corr ( ebfp , ik , np_norm , bcorr ) bunch_bavg ( nst , 1 : 16 , ib ) = bcorr ( 1 : 16 ) bcharge ( nst , ib ) = e_charge * np_per_cell * ekm ( 2 ) end subroutine !============================================ subroutine enb_ionz ( nst , t_loc , gmm ) integer , intent ( in ) :: nst real ( dp ), intent ( in ) :: t_loc , gmm integer :: ik , np , p , q real ( dp ) :: np_norm , bcorr ( 16 ), ekt ( 2 ), ekm ( 2 ) real ( dp ) :: pp ( 3 ), gamma real ( sp ) :: ch_ion ik = 0 ch_ion = real ( wgh_ion , sp ) np = loc_npart ( imody , imodz , imodx , 1 ) ekt = 0.0 if ( np > 0 ) then select case ( curr_ndim ) case ( 2 ) do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , 5 ) pp ( 1 : 2 ) = spec ( 1 )% part ( p , 3 : 4 ) gamma = sqrt ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 )) if ( part_ind < 0 ) then if ( gamma > gmm ) then ekt ( 2 ) = ekt ( 2 ) + wgh ik = ik + 1 do q = 1 , nd2 + 1 ebfp ( ik , q ) = spec ( 1 )% part ( p , q ) end do end if end if end do case ( 3 ) do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , 7 ) pp ( 1 : 3 ) = spec ( 1 )% part ( p , 4 : 6 ) gamma = sqrt ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) + pp ( 3 ) * pp ( 3 )) if ( part_ind < 0 ) then if ( gamma > gmm ) then ekt ( 2 ) = ekt ( 2 ) + wgh ik = ik + 1 do q = 1 , nd2 + 1 ebfp ( ik , q ) = spec ( 1 )% part ( p , q ) end do end if end if end do end select end if ionz_bavg ( nst , :) = 0.0 tionz ( nst ) = t_loc !================================ ekt ( 1 ) = real ( ik , dp ) call allreduce_dpreal ( sumv , ekt , ekm , 2 ) ionz_number ( nst ) = nint ( ekm ( 1 )) np_norm = 1. if ( ekm ( 1 ) > 0.0 ) np_norm = 1. / ekm ( 1 ) call bunch_corr ( ebfp , ik , np_norm , bcorr ) ionz_bavg ( nst , 1 : 16 ) = bcorr ( 1 : 16 ) ionz_charge ( nst ) = e_charge * np_per_cell * ekm ( 2 ) end subroutine !============================ subroutine enb_hgam ( nst , t_loc , gmm ) integer , intent ( in ) :: nst real ( dp ), intent ( in ) :: t_loc , gmm integer :: ik , np , p , q real ( dp ) :: np_norm , bcorr ( 16 ), ekt ( 2 ), ekm ( 2 ) real ( dp ) :: pp ( 3 ), gamma ik = 0 np = loc_npart ( imody , imodz , imodx , 1 ) ekt = 0.0 if ( np > 0 ) then select case ( curr_ndim ) case ( 2 ) do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , 5 ) pp ( 1 : 2 ) = spec ( 1 )% part ( p , 3 : 4 ) gamma = sqrt ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 )) if ( gamma > gmm ) then ekt ( 2 ) = ekt ( 2 ) + wgh ik = ik + 1 do q = 1 , nd2 + 1 ebfp ( ik , q ) = spec ( 1 )% part ( p , q ) end do end if end do case ( 3 ) do p = 1 , np wgh_cmp = spec ( 1 )% part ( p , 7 ) pp ( 1 : 3 ) = spec ( 1 )% part ( p , 4 : 6 ) gamma = sqrt ( 1. + pp ( 1 ) * pp ( 1 ) + pp ( 2 ) * pp ( 2 ) + pp ( 3 ) * pp ( 3 )) if ( gamma > gmm ) then ekt ( 2 ) = ekt ( 2 ) + wgh ik = ik + 1 do q = 1 , nd2 + 1 ebfp ( ik , q ) = spec ( 1 )% part ( p , q ) end do end if end do end select end if hgam_bavg ( nst , :) = 0.0 tgam ( nst ) = t_loc !================================ ekt ( 1 ) = real ( ik , dp ) call allreduce_dpreal ( sumv , ekt , ekm , 2 ) hgam_number ( nst ) = nint ( ekm ( 1 )) np_norm = 1. if ( ekm ( 1 ) > 0.0 ) np_norm = 1. / ekm ( 1 ) call bunch_corr ( ebfp , ik , np_norm , bcorr ) hgam_bavg ( nst , 1 : 16 ) = bcorr ( 1 : 16 ) hgam_charge ( nst ) = e_charge * np_per_cell * ekm ( 2 ) !========================== end subroutine !===================================== !   WRITE envar  DATA SECTION subroutine en_data ( nst , itr , idata ) integer , intent ( in ) :: nst , itr , idata call general_en_data ( nst , itr , idata ) if ( ionization ) call en_ionz_data ( nst , itr , idata ) if ( high_gamma ) call en_high_gamma_data ( nst , itr , idata ) end subroutine subroutine general_en_data ( nst , itr , idata ) integer , intent ( in ) :: nst , itr , idata character ( 6 ) :: fname = '      ' character ( 14 ), dimension ( 4 ), parameter :: sp_type = [ & '   Electrons  ' , '  A1-Z1 Ions  ' , '  A2-Z2 Ions  ' , & '  A3-Z3 Ions  ' ] character ( 14 ), dimension ( 11 ), parameter :: pe = [ ' Tot Ek[J]    ' , & ' Ek_max[Mev]  ' , ' Jz ang-moment' , '<px>-momentum ' , & '<py>-momentum ' , '<pz>-momentum ' , 'sigma_px[KeV] ' , & 'sigma_py[KeV] ' , 'sigma_pz[KeV] ' , 'Mean Charge   ' , & 'Charge percell' ] character ( 18 ), dimension ( 16 ), parameter :: fe = [ & '  Ex2(J)          ' , '  Ey2(J)          ' , '  Ez2(J)          ' , & '  Ex_max(TV/m)    ' , '  Ey_max(TV/m)    ' , '  Ez_max(TV/m)    ' , & '  Bx2(J)          ' , '  By2(J)          ' , '  Bz2(J)          ' , & '  Bx_max(TV/m)    ' , '  By_max(TV/m)    ' , '  Bz_max(TV/m)    ' , & '  E2(x<X_t)       ' , '  B2(x<X_t)       ' , '  E2(x>X_t)       ' , & '  B2(x>X_t)       ' ] character ( 18 ), dimension ( 6 ), parameter :: fe2 = [ & '  Ex2(J)          ' , '  Ey2(J)          ' , '  Bz2(J)          ' , & '  Ex_max(TV/m)    ' , '  Ey_max(TV/m)    ' , '  Bz_max(TV/m)    ' ] character ( 18 ), dimension ( 6 ), parameter :: feb2 = [ & '  Ex2(J)          ' , '  Ey2(J)          ' , '  Bz2(J)          ' , & '  Ex_max(GV/m)    ' , '  Ey_max(GV/m)    ' , '  Bz_max(GV/m)    ' ] character ( 18 ), dimension ( 16 ), parameter :: feb = [ & '  Ex2(J)          ' , '  Ey2(J)          ' , '  Ez2(J)          ' , & '  Ex_max(GV/m)    ' , '  Ey_max(GV/m)    ' , '  Ez_max(GV/m)    ' , & '  Bx2(J)          ' , '  By2(J)          ' , '  Bz2(J)          ' , & '  Bx_max(GV/m)    ' , '  By_max(GV/m)    ' , '  Bz_max(GV/m)    ' , & '  E2(x<X_t)       ' , '  B2(x<X_t)       ' , '  E2(x>X_t)       ' , & '  B2(x>X_t)       ' ] character ( 14 ), dimension ( 6 ), parameter :: lfenv = [ & '  COM(1)      ' , '   COM(2)     ' , ' COM(3)       ' , & '  COM(4)      ' , '  COM(5)      ' , '   COM(6)     ' ] character ( 18 ), dimension ( 5 ), parameter :: fenv = [ & '  Env_max         ' , '  Centroid        ' , '  Env radius      ' , & '  Env_energy      ' , '  Env_action      ' ] !character(14),dimension(5), parameter:: flaser=(/& ! '  Int_max     ',' Las_energy(J)','  < X_c >     ','   <W_y>      ',& ! '   < W_z >    '/) character ( 14 ), dimension ( 6 ), parameter :: flt = [ 'Ex2(J)        ' , & 'Ey2(J)        ' , 'Ez2(J)        ' , 'Bx2(J)        ' , & 'By2(J)        ' , 'Bz2(J)        ' ] character ( 12 ), dimension ( 4 ), parameter :: enspect = [ & 'Electron NdE' , ' A1-ion NdE ' , ' A2-ion NdE ' , ' A3-ion NdE ' ] integer :: ik , nfv , npv , nt , color integer , parameter :: lun = 10 nfv = 6 if ( curr_ndim == 3 ) nfv = 12 npv = 9 color = 0 if ( Two_color ) color = 1 ! if (iout<100) write (fname,'(a4,i2)') 'diag' ,idata ! if (iout< 10) write (fname,'(a5,i1)') 'diag0',idata write ( fname , '(a4,i2.2)' ) 'diag' , idata open ( lun , file = 'diagnostics/' // fname // '.dat' , form = 'formatted' ) write ( lun , * ) '    mod_id, dmodel_id,    LP_ord,   der_ord, & &    ibeam,     color,   n_field' write ( lun , '(7i11)' ) model_id , dmodel_id , lpf_ord , der_ord , ibeam , & color , nfield write ( lun , * ) '        Part,        Beam,        Wake, Solid_Target' write ( lun , '(4L13)' ) part , beam , wake , solid_target write ( lun , * ) 'Z1_i,  A1_i,   Z2_i,   A2_i,   iform,    str' write ( lun , '(6i6)' ) ion_min ( 1 ), atomic_number ( 1 ), ion_min ( 2 ), & atomic_number ( 2 ), iform , str_flag write ( lun , * ) ' xmax       xmin       ymax      ymin      ' write ( lun , '(4e12.4)' ) xmax , xmin , ymax , ymin if ( model_id <= 4 ) then write ( lun , * ) ' lam0       w0x       w0y        energy' write ( lun , '(4e11.4)' ) lam0 , w0_x , w0_y , lp_energy write ( lun , * ) ' a0        lp_int     lp_pow    energy_on_targ' write ( lun , '(4e12.4)' ) a0 , lp_intensity , lp_pow , energy_in_targ write ( lun , * ) ' targ_x1  targ_x2     n/nc       el_lp        ' write ( lun , '(4e12.4)' ) targ_in , targ_end , n_over_nc , el_lp if ( dmodel_id > 5 ) then write ( lun , * ) '  lx2        lx3        lx4         dw         lw ' write ( lun , '(5e12.4)' ) lpx ( 2 : 4 ), lpy ( 1 : 2 ) else write ( lun , * ) ' lx1        lx2        lx3        lx4        lx5 ' write ( lun , '(5e12.4)' ) lpx ( 1 : 5 ) end if write ( lun , * ) ' ompe2       nmacro       np_per_cell    ' write ( lun , '(3e12.4)' ) ompe , nmacro , np_per_cell write ( lun , * ) '    Nx      Ny      Nz    n_cell   Nsp  Nb_las' write ( lun , '(6i8)' ) nx , ny , nz , mp_per_cell ( 1 ), nsp , nb_laser write ( lun , * ) ' iter, nst, nvar npvar' write ( lun , '(4i6)' ) itr , nst , nfv , npv end if write ( lun , * ) '========== Fields section=======' if ( nfield < 6 ) then write ( lun , '(6a18)' ) fe2 ( 1 : 6 ) do ik = 1 , nst write ( lun , '(6e18.10)' ) favg ( 1 : 6 , ik ) end do else write ( lun , '(6a18)' ) fe ( 1 : 6 ) do ik = 1 , nst write ( lun , '(6e18.10)' ) favg ( 1 : 6 , ik ) end do write ( lun , '(6a18)' ) fe ( 7 : 12 ) do ik = 1 , nst write ( lun , '(6e18.10)' ) favg ( 7 : 12 , ik ) end do end if if ( wake ) then if ( envelope ) then write ( lun , * ) '====  the leading pulse integrated variables' write ( lun , '(5a18)' ) fenv ( 1 : 5 ) do ik = 1 , nst write ( lun , '(5e18.10)' ) eavg ( 1 : 5 , ik ) end do if ( Two_color ) then write ( lun , * ) '====  the injection pulse integrated variables' write ( lun , '(5a18)' ) fenv ( 1 : 5 ) do ik = 1 , nst write ( lun , '(5e18.10)' ) eavg1 ( 1 : 5 , ik ) end do end if end if end if if ( solid_target ) then write ( lun , * ) '====  Field energy on solid targets' if ( nfield == 6 ) then write ( lun , '(6a18)' ) flt ( 1 : 6 ) do ik = 1 , nst write ( lun , '(6e18.10)' ) eavg ( 1 : 6 , ik ) end do else write ( lun , '(3a18)' ) flt ( 1 : 3 ) do ik = 1 , nst write ( lun , '(3e18.10)' ) eavg ( 1 : 3 , ik ) end do end if end if close ( lun ) if ( nst > 0 ) then ! if (iout<100) write (fname,'(a4,i2)') 'spec' ,idata ! if (iout< 10) write (fname,'(a5,i1)') 'spec0',idata write ( fname , '(a4,i2.2)' ) 'spec' , idata open ( lun , file = 'diagnostics/' // fname // '.dat' , form = 'formatted' ) write ( lun , * ) 'mod_id,dmodel_id LP_ord,der_ord' write ( lun , '(4i8)' ) model_id , dmodel_id , lpf_ord , der_ord write ( lun , * ) 'Z1_i,A1_i,Z2_i,A2_i,iform, str' write ( lun , '(6i4)' ) ion_min ( 1 ), atomic_number ( 1 ), ion_min ( 2 ), & atomic_number ( 2 ), iform , str_flag write ( lun , * ) ' xmax       xmin       ymax      ymin      ' write ( lun , '(4e12.4)' ) xmax , xmin , ymax , ymin if ( model_id <= 4 ) then write ( lun , * ) ' lam0       w0x       w0y        tau' write ( lun , '(4e12.4)' ) lam0 , w0_x , w0_y , tau_fwhm write ( lun , * ) ' a0        lp_int     lp_pow' write ( lun , '(3e12.4)' ) a0 , lp_intensity , lp_pow write ( lun , * ) ' targ_x1  targ_x2     n/nc       el_lp        ' write ( lun , '(4e12.4)' ) targ_in , targ_end , n_over_nc , el_lp write ( lun , * ) & ' lx1        lx2          lx3          lx4        lx5 ' write ( lun , '(5e12.4)' ) lpx ( 1 : 5 ) write ( lun , * ) ' ompe2       nmacro       np_per_cell    ' write ( lun , '(3e12.4)' ) ompe , nmacro , np_per_cell end if write ( lun , * ) '    Nx      Ny      Nz    n_cell   Nsp  Nsb' write ( lun , '(6i8)' ) nx , ny , nz , mp_per_cell ( 1 ), nsp , nsb write ( lun , * ) ' iter, nst, nvar npvar' write ( lun , '(4i6)' ) itr , nst , nfv , npv write ( lun , * ) '             ENERGY SPECTRA            ' write ( lun , '(i4)' ) ne do ik = 1 , nsp write ( lun , * ) enspect ( ik ) do nt = 1 , nst write ( lun , * ) ' time   emax' write ( lun , '(2e13.5)' ) tsp ( nt ), eksp_max ( nt , ik ) write ( lun , * ) 'Global  spectral  data  ' write ( lun , '(6e13.5)' ) nde ( 1 : ne , nt , ik ) if ( solid_target ) then write ( lun , * ) 'Front side  selected spectral  data  ' write ( lun , '(6e13.5)' ) nde_sm ( 1 : ne , nt , ik ) write ( lun , * ) 'Rear side   selected spectral  data  ' write ( lun , '(6e13.5)' ) nde_sp ( 1 : ne , nt , ik ) end if end do end do close ( lun ) end if end subroutine !-------------------------- subroutine en_bdata ( nst , it , idata ) integer , intent ( in ) :: nst , it , idata character ( 7 ) :: bfname = '       ' character ( 14 ), dimension ( 16 ), parameter :: fb = [ '     <X>      ' , & '     <Y>      ' , '     <Z>      ' , '     <Px>     ' , & '     <Py>     ' , '     <Pz>     ' , '   <msqX>     ' , & '   <msqY>     ' , '   <msqZ>     ' , '  <msqPx>     ' , & '  <msqPy>     ' , '  <msqPz>     ' , '   <Emysq>    ' , & '   <Emzsq>    ' , '   <Gam>      ' , '   DGam/Gam   ' ] integer :: ib , nbvar , ik , color integer , parameter :: lun = 10 color = 0 if ( Two_color ) color = 1 nbvar = 16 write ( bfname , '(a5,i2.2)' ) 'bdiag' , idata open ( lun , file = 'diagnostics/' // bfname // '.dat' , form = 'formatted' ) write ( lun , * ) 'mod_id,dmodel_id LP_ord,der_ord, ibeam,  color' write ( lun , '(6i6)' ) model_id , dmodel_id , lpf_ord , der_ord , ibeam , & color write ( lun , * ) 'Z1_i,  A1_i,   Z2_i,   A2_i,   iform,    str' write ( lun , '(6i6)' ) ion_min ( 1 ), atomic_number ( 1 ), ion_min ( 2 ), & atomic_number ( 2 ), iform , str_flag write ( lun , * ) ' xmax       xmin       ymax      ymin      ' write ( lun , '(4e12.4)' ) xmax , xmin , ymax , ymin write ( lun , * ) ' ompe2       nmacro       np_per_cell    ' write ( lun , '(3e12.4)' ) ompe , nmacro , np_per_cell write ( lun , * ) '    Nx      Ny      Nz    n_cell   Nsp  Nbeam' write ( lun , '(6i8)' ) nx , ny , nz , mp_per_cell ( 1 ), nsp , nsb write ( lun , * ) ' iter, nst, npvar' write ( lun , '(3i6)' ) it , nst , nbvar write ( lun , * ) '=====================================' write ( lun , * ) 'time' write ( lun , '(6e13.4)' ) tbunch ( 1 : nst ) do ib = 1 , nsb write ( lun , * ) ' bunch numbers ' write ( lun , '(6i10)' ) bunch_number ( 1 : nst , ib ) write ( lun , * ) ' bunch charge(pC)' write ( lun , '(6e13.4)' ) bcharge ( 1 : nst , ib ) write ( lun , '(6a14)' ) fb ( 1 : 6 ) do ik = 1 , nst write ( lun , '(6e13.4)' ) bunch_bavg ( ik , 1 : 6 , ib ) end do write ( lun , '(6a14)' ) fb ( 7 : 12 ) do ik = 1 , nst write ( lun , '(6e13.4)' ) bunch_bavg ( ik , 7 : 12 , ib ) end do write ( lun , '(4a14)' ) fb ( 13 : 16 ) do ik = 1 , nst write ( lun , '(4e13.4)' ) bunch_bavg ( ik , 13 : 16 , ib ) end do end do close ( lun ) end subroutine subroutine en_ionz_data ( nst , itrz , data_id ) integer , intent ( in ) :: nst , itrz , data_id character ( 12 ) :: fname = '            ' character ( 14 ), dimension ( 16 ), parameter :: fb = [ '     <X>      ' , & '     <Y>      ' , '     <Z>      ' , '     <Px>     ' , & '     <Py>     ' , '     <Pz>     ' , '   <msqX>     ' , & '   <msqY>     ' , '   <msqZ>     ' , '  <msqPx>     ' , & '  <msqPy>     ' , '  <msqPz>     ' , '   <Emysq>    ' , & '   <Emzsq>    ' , '   <Gam>      ' , '   DGam/Gam   ' ] integer :: ik , color , npv integer , parameter :: lun = 20 color = 0 if ( Two_color ) color = 1 npv = 16 write ( fname , '(a10,i2.2)' ) 'ionz_emitt' , data_id open ( lun , file = 'diagnostics/' // fname // '.dat' , form = 'formatted' ) write ( lun , * ) 'mod_id,dmodel_id LP_ord,der_ord, ibeam,  color' write ( lun , '(6i6)' ) model_id , dmodel_id , lpf_ord , der_ord , ibeam , & color write ( lun , * ) 'Z1_i,  A1_i,   Z2_i,   A2_i,   iform,    str' write ( lun , '(6i6)' ) ion_min ( 1 ), atomic_number ( 1 ), ion_min ( 2 ), & atomic_number ( 2 ), iform , str_flag write ( lun , * ) ' xmax       xmin       ymax      ymin      ' write ( lun , '(4e12.4)' ) xmax , xmin , ymax , ymin if ( model_id <= 4 ) then write ( lun , * ) ' lam0       w0x       w0y        energy' write ( lun , '(4e11.4)' ) lam0 , w0_x , w0_y , lp_energy write ( lun , * ) ' a0        lp_int     lp_pow    energy_on_targ' write ( lun , '(4e12.4)' ) a0 , lp_intensity , lp_pow , energy_in_targ write ( lun , * ) ' targ_x1  targ_x2     n/nc       el_lp        ' write ( lun , '(4e12.4)' ) targ_in , targ_end , n_over_nc , el_lp end if write ( lun , * ) ' ompe2       nmacro       np_per_cell    ' write ( lun , '(3e12.4)' ) ompe , nmacro , np_per_cell write ( lun , * ) '    Nx      Ny      Nz    n_cell   Nsp  Nb_las' write ( lun , '(6i8)' ) nx , ny , nz , mp_per_cell ( 1 ), nsp , nb_laser write ( lun , * ) ' iter, nst, npvar' write ( lun , '(3i6)' ) itrz , nst , npv write ( lun , * ) '=====================================' write ( lun , * ) 'time' write ( lun , '(5e11.4)' ) tionz ( 1 : nst ) write ( lun , * ) ' ionization-hg numbers ' write ( lun , '(6i10)' ) ionz_number ( 1 : nst ) write ( lun , * ) ' ionization-hg charge(pC)' write ( lun , '(6e13.4)' ) ionz_charge ( 1 : nst ) write ( lun , '(6a14)' ) fb ( 1 : 6 ) do ik = 1 , nst write ( lun , '(6e13.4)' ) ionz_bavg ( ik , 1 : 6 ) end do write ( lun , '(6a14)' ) fb ( 7 : 12 ) do ik = 1 , nst write ( lun , '(6e13.4)' ) ionz_bavg ( ik , 7 : 12 ) end do write ( lun , '(4a14)' ) fb ( 13 : 16 ) do ik = 1 , nst write ( lun , '(4e13.4)' ) ionz_bavg ( ik , 13 : 16 ) end do close ( lun ) end subroutine subroutine en_high_gamma_data ( nst , itrz , data_id ) integer , intent ( in ) :: nst , itrz , data_id character ( 12 ) :: fname = '            ' character ( 14 ), dimension ( 16 ), parameter :: fb = [ '     <X>      ' , & '     <Y>      ' , '     <Z>      ' , '     <Px>     ' , & '     <Py>     ' , '     <Pz>     ' , '   <msqX>     ' , & '   <msqY>     ' , '   <msqZ>     ' , '  <msqPx>     ' , & '  <msqPy>     ' , '  <msqPz>     ' , '   <Emysq>    ' , & '   <Emzsq>    ' , '   <Gam>      ' , '   DGam/Gam   ' ] integer :: ik , color , npv integer , parameter :: lun = 10 color = 0 if ( Two_color ) color = 1 npv = 16 write ( fname , '(a10,i2.2)' ) 'higm_emitt' , data_id open ( lun , file = 'diagnostics/' // fname // '.dat' , form = 'formatted' ) write ( lun , * ) 'mod_id,dmodel_id LP_ord,der_ord, ibeam,  color' write ( lun , '(6i6)' ) model_id , dmodel_id , lpf_ord , der_ord , ibeam , & color write ( lun , * ) 'Z1_i,  A1_i,   Z2_i,   A2_i,   iform,    str' write ( lun , '(6i6)' ) ion_min ( 1 ), atomic_number ( 1 ), ion_min ( 2 ), & atomic_number ( 2 ), iform , str_flag write ( lun , * ) ' xmax       xmin       ymax      ymin      ' write ( lun , '(4e12.4)' ) xmax , xmin , ymax , ymin if ( model_id <= 4 ) then write ( lun , * ) ' lam0       w0x       w0y        energy' write ( lun , '(4e11.4)' ) lam0 , w0_x , w0_y , lp_energy write ( lun , * ) ' a0        lp_int     lp_pow    energy_on_targ' write ( lun , '(4e12.4)' ) a0 , lp_intensity , lp_pow , energy_in_targ write ( lun , * ) ' targ_x1  targ_x2     n/nc       el_lp        ' write ( lun , '(4e12.4)' ) targ_in , targ_end , n_over_nc , el_lp end if write ( lun , * ) ' ompe2       nmacro       np_per_cell    ' write ( lun , '(3e12.4)' ) ompe , nmacro , np_per_cell write ( lun , * ) '    Nx      Ny      Nz    n_cell   Nsp  Nb_las' write ( lun , '(6i8)' ) nx , ny , nz , mp_per_cell ( 1 ), nsp , nb_laser write ( lun , * ) ' iter, nst, npvar' write ( lun , '(3i6)' ) itrz , nst , npv write ( lun , * ) '=====================================' write ( lun , * ) 'time' write ( lun , '(5e11.4)' ) tloc ( 1 : nst ) write ( lun , * ) ' higamma numbers ' write ( lun , '(5i8)' ) hgam_number ( 1 : nst ) write ( lun , * ) ' higamma charge(pC) ' write ( lun , '(5E13.4)' ) hgam_charge ( 1 : nst ) write ( lun , '(6a14)' ) fb ( 1 : 6 ) do ik = 1 , nst write ( lun , '(6e13.4)' ) hgam_bavg ( ik , 1 : 6 ) end do write ( lun , '(6a14)' ) fb ( 7 : 12 ) do ik = 1 , nst write ( lun , '(6e13.4)' ) hgam_bavg ( ik , 7 : 12 ) end do write ( lun , '(4a14)' ) fb ( 13 : 16 ) do ik = 1 , nst write ( lun , '(4e13.4)' ) hgam_bavg ( ik , 13 : 16 ) end do close ( lun ) end subroutine !-------------------------- end module","tags":"","loc":"sourcefile/diag_part_and_fields.f90.html"},{"title":"read_input.f90 – ALaDyn","text":"This file depends on sourcefile~~read_input.f90~~EfferentGraph sourcefile~read_input.f90 read_input.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~read_input.f90->sourcefile~mpi_var.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~read_input.f90->sourcefile~code_util.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~read_input.f90->sourcefile~common_param.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~read_input.f90->sourcefile~control_bunch_input.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_input.f90~~AfferentGraph sourcefile~read_input.f90 read_input.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~read_input.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_input Source Code read_input.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module read_input use common_param use control_bunch_input use code_util use mpi_var implicit none private public :: read_main_input , write_read_nml integer :: nml_iounit = 1 , nml_ierr = 0 character ( 100 ) :: nml_error_message = '' contains subroutine read_main_input logical exist_nml logical exist_data inquire ( file = input_namelist_filename , exist = exist_nml ) inquire ( file = input_data_filename , exist = exist_data ) if ( exist_nml ) then call read_input_nml else write ( 6 , * ) 'No usable input file (.nml or .data) has been found' stop 5 end if end subroutine subroutine read_input_nml !=========================================================== != != Reads the input namelist != !=========================================================== namelist / grid / nx , ny , nz , ny_targ , k0 , yx_rat , zx_rat namelist / simulation / lpf_ord , der_ord , str_flag , iform , model_id , & dmodel_id , ibx , iby , ibz , ibeam namelist / target_description / nsp , nsb , ionz_lev , ionz_model , ion_min , & ion_max , atomic_number , mass_number , t0_pl , ppc , np_per_xc , & np_per_yc , np_per_zc , concentration , lpx , lpy , n0_ref , np1 , np2 , & r_c , l_disable_rng_seed namelist / laser / g_prof , nb_laser , t0_lp , xc_lp , tau_fwhm , w0_y , a0 , & lam0 , lp_delay , lp_offset , t1_lp , tau1_fwhm , w1_y , a1 , lam1 , & symmetrization_pulse , a_symm_rat , enable_ionization , y0_cent , & z0_cent , y1_cent , z1_cent , incid_angle namelist / beam_inject / nb_1 , xc_1 , gam_1 , sxb_1 , syb_1 , epsy_1 , & epsz_1 , dg_1 , charge_1 , ap1_twiss , bt1_twiss , t_inject namelist / moving_window / w_sh , wi_time , wf_time , w_speed namelist / output / nouts , iene , nvout , nden , npout , nbout , jump , pjump , & gam_min , xp0_out , xp1_out , yp_out , tmax , cfl , new_sim , id_new , & dump , l_force_singlefile_output , time_interval_dumps , & l_print_j_on_grid , l_first_output_on_restart , l_env_modulus namelist / tracking / tkjump , nkjump , txmin , txmax , tymin , tymax , tzmin , & tzmax , t_in , t_out , p_tracking namelist / mpiparams / nprocx , nprocy , nprocz !--- reading grid parameters ---! yx_rat = - 1. zx_rat = - 1. r_c = 0.0 open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , grid , iostat = nml_ierr ) nml_error_message = 'GRID' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error call consistency_check_grid !--- reading sim parameters ---! open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , simulation , iostat = nml_ierr ) nml_error_message = 'SIMULATION' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error !--- reading target parameters ---! mass_number ( 1 : 3 ) = 1.0 ppc = - 1 np_per_xc = - 1 np_per_yc = - 1 np_per_zc = - 1 l_disable_rng_seed = . false . concentration (:) = zero_dp concentration ( 1 ) = one_dp n0_ref = 1. open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , target_description , iostat = nml_ierr ) nml_error_message = 'TARGET_DESCRIPTION' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error !call consistency_check_number_of_particles call consistency_check_number_of_particles_comp !--- reading laser parameters ---! symmetrization_pulse = . false . a_symm_rat = 0. enable_ionization (:) = . true . y0_cent (:) = zero_dp z0_cent (:) = zero_dp y1_cent = zero_dp z1_cent = zero_dp incid_angle = zero_dp open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , laser , iostat = nml_ierr ) nml_error_message = 'LASER' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error if ( nsb > 0 ) then !--- reading injected beam parameters ---! open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , beam_inject , iostat = nml_ierr ) nml_error_message = 'BEAM' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error n_bunches = nsb nb_tot ( 1 ) = nb_1 * 100000 xc_bunch ( 1 ) = xc_1 gam ( 1 ) = gam_1 sxb ( 1 ) = sxb_1 syb ( 1 ) = syb_1 epsy ( 1 ) = epsy_1 epsz ( 1 ) = epsz_1 dg ( 1 ) = dg_1 bunch_charge ( 1 ) = charge_1 alpha_twiss ( 1 ) = ap1_twiss beta_twiss ( 1 ) = bt1_twiss end if !--- reading moving window parameters ---! open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , moving_window , iostat = nml_ierr ) nml_error_message = 'MOVING_WINDOW' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error !--- reading output parameters ---! time_interval_dumps = - 1. !if -1 use classical output l_force_singlefile_output = . true . l_first_output_on_restart = . false . l_print_j_on_grid = . true . l_env_modulus = . true . open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , output , iostat = nml_ierr ) nml_error_message = 'OUTPUT' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , tracking , iostat = nml_ierr ) nml_error_message = 'TRACKING' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error !--- reading mpi decomposition ---! nprocx = - 1 nprocy = - 1 nprocz = - 1 open ( nml_iounit , file = input_namelist_filename , status = 'old' ) read ( nml_iounit , mpiparams , iostat = nml_ierr ) nml_error_message = 'MPIPARAMS' close ( nml_iounit ) if ( nml_ierr > 0 ) call print_at_screen_nml_error end subroutine subroutine write_read_nml character ( len = 12 ) :: output_filename !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC !C !C write namelist on a file 'input_  .nml' !C !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC namelist / grid / nx , ny , nz , ny_targ , k0 , yx_rat , zx_rat namelist / simulation / lpf_ord , der_ord , str_flag , iform , model_id , & dmodel_id , ibx , iby , ibz , ibeam namelist / target_description / nsp , nsb , ionz_lev , ionz_model , ion_min , & ion_max , atomic_number , mass_number , t0_pl , ppc , np_per_xc , & np_per_yc , np_per_zc , concentration , lpx , lpy , n0_ref , np1 , np2 , & r_c namelist / laser / g_prof , nb_laser , t0_lp , xc_lp , tau_fwhm , w0_y , a0 , & lam0 , lp_delay , lp_offset , t1_lp , tau1_fwhm , w1_y , a1 , lam1 , & symmetrization_pulse , a_symm_rat , enable_ionization , y0_cent , & z0_cent , y1_cent , z1_cent , incid_angle namelist / moving_window / w_sh , wi_time , wf_time , w_speed namelist / output / nouts , iene , nvout , nden , npout , nbout , jump , pjump , & gam_min , xp0_out , xp1_out , yp_out , tmax , cfl , new_sim , id_new , & dump , l_force_singlefile_output , time_interval_dumps , & l_print_j_on_grid , l_first_output_on_restart , l_env_modulus namelist / tracking / tkjump , nkjump , txmin , txmax , tymin , tymax , tzmin , & tzmax , t_in , t_out , p_tracking namelist / mpiparams / nprocx , nprocy , nprocz namelist / number_bunches / n_bunches , l_particles , & l_intdiagnostics_pwfa , l_intdiagnostics_classic , & l_embunchevolution , number_of_slices namelist / bunches / nb_tot , bunch_type , bunch_shape , rhob , xc_bunch , & yc_bunch , zc_bunch , gam , sxb , syb , epsy , epsz , dg , charge_right , & charge_left , sigma_cut_bunch , ppc_x_bunch , ppc_y_bunch , ppc_z_bunch namelist / twiss / l_twiss , alpha_twiss , beta_twiss namelist / bpoloidal / l_bpoloidal , b_ex_poloidal , radius_poloidal write ( output_filename , 100 ) 'input_' , id_new , '.nml' 100 format ( a6 , i2 . 2 , a4 ) open ( nml_iounit , file = output_filename ) write ( nml_iounit , nml = grid , err = 110 ) write ( nml_iounit , nml = simulation , err = 110 ) write ( nml_iounit , nml = target_description , err = 110 ) write ( nml_iounit , nml = laser , err = 110 ) write ( nml_iounit , nml = moving_window , err = 110 ) write ( nml_iounit , nml = output , err = 110 ) if ( p_tracking ) write ( nml_iounit , nml = tracking , err = 110 ) write ( nml_iounit , nml = mpiparams , err = 110 ) write ( nml_iounit , nml = number_bunches , err = 110 ) write ( nml_iounit , nml = bunches , err = 110 ) write ( nml_iounit , nml = twiss , err = 110 ) write ( nml_iounit , nml = bpoloidal , err = 110 ) 110 continue close ( nml_iounit ) end subroutine subroutine consistency_check_number_of_particles_comp if ( all ( ppc >= 1 )) then call from_ppc_to_npx_npy_npz else if ( all ( np_per_zc == - 1 )) then np_per_zc = np_per_yc end if end subroutine subroutine consistency_check_grid if ( zx_rat < 0. . and . yx_rat > 0. ) then zx_rat = yx_rat !write(6,'(A)') \"force zx_rat equal to yx_rat\" else if ( zx_rat > 0. . and . yx_rat < 0. ) then yx_rat = zx_rat !write(6,'(A)') \"force yx_rat equal to zx_rat\" else if ( zx_rat < 0. . and . yx_rat < 0. ) then yx_rat = 1. zx_rat = 1. !write(6,'(A)') \"force yx_rat=1 and zx_rat=1\" end if end subroutine !------------------------------------------------------! subroutine consistency_check_number_of_particles !excluded temporarily because it doesn't deal with few cases, most of all np_per_xc=0 !--->case 0: ppc is the only defined (new nml) if ( all ( ppc >= 1 ) . and . all ( np_per_xc == - 1 ) . and . & all ( np_per_yc == - 1 ) . and . all ( np_per_zc == - 1 )) then call from_ppc_to_npx_npy_npz !--->case 1: np_per_zc not defined: copy from np_per_yc else if ( all ( ppc == - 1 ) . and . all ( np_per_xc >= 0 ) . and . & all ( np_per_yc >= 0 ) . and . all ( np_per_zc == - 1 )) then np_per_zc = np_per_yc !--->case 3: new and old methods both defined else if ( all ( ppc >= 1 ) . and . ( all ( np_per_xc >= 1 ) . or . all ( np_per_yc >= & 1 ) . or . all ( np_per_zc >= 1 ))) then np_per_xc = - 1 np_per_yc = - 1 np_per_zc = - 1 call from_ppc_to_npx_npy_npz !--->case default else ppc = 8 call from_ppc_to_npx_npy_npz end if end subroutine !------> Particle organisation subroutine from_ppc_to_npx_npy_npz !--->Subdivide ppc into np_per_xc,np_per_yc and theoretically into np_per_zc !logical isprime integer i , number_of_factors integer , allocatable , dimension (:) :: factors !verify input 'ppc' are not prime numbers do i = 1 , 6 do while ( isprime ( ppc ( i ))) !if(pe0) write(6,'(A,I1,A,I3)')'The input parameter ppc(',i,') is prime - corrected to >',ppc(i)+1 ppc ( i ) = ppc ( i ) + 1 end do end do !subdivide ppc into np_per_xc,yc,zc do i = 1 , 6 allocate ( factors ( ppc ( i ) / 2 )) call primefactors ( ppc ( i ), factors , number_of_factors ) if ( ndim == 2 ) then np_per_xc ( i ) = factors ( 1 ) np_per_yc ( i ) = product ( factors ( 2 : number_of_factors )) !if(pe0) write(6,'(A,I2,A,I3,A,I3,A)') 'layer:',i,' > ',np_per_xc(i),'*',np_per_yc(i),' particles' else if ( ndim == 3 ) then if ( number_of_factors > 2 ) then np_per_xc ( i ) = factors ( 1 ) np_per_yc ( i ) = factors ( 2 ) np_per_zc ( i ) = product ( factors ( 3 : number_of_factors )) else np_per_xc ( i ) = 1 np_per_yc ( i ) = factors ( 1 ) np_per_zc ( i ) = factors ( 2 ) end if !if(pe0) write(6,'(A,I2,A,I3,A,I3,A,I3,A)') 'layer:',i,' > ',np_per_xc(i),'*',np_per_yc(i),'*',np_per_zc(i),' particles' end if deallocate ( factors ) end do end subroutine function isprime ( num ) integer , intent ( in ) :: num !input number integer :: i logical :: isprime isprime = . true . do i = 2 , num - 1 if ( mod ( num , i ) == 0 ) then isprime = . false . exit end if end do end function subroutine primefactors ( num , factors , number_factors ) integer , intent ( in ) :: num !input number integer , intent ( out ), dimension (( num / 2 )) :: factors !Array to store factors integer , intent ( inout ) :: number_factors integer :: i , n i = 2 !Eligible factor number_factors = 1 !Number of factors n = num !store input number into a temporary variable do if ( mod ( n , i ) == 0 ) then !If i divides 2, it is a factor factors ( number_factors ) = i number_factors = number_factors + 1 n = n / i else i = i + 1 !Not a factor. Move to next number end if if ( n == 1 ) then !Since f is incremented after a factor is found number_factors = number_factors - 1 !its value will be one more than the number of factors !Hence the value of number_factors is decremented exit end if end do end subroutine !--- *** *** *** ---! subroutine print_at_screen_nml_error !character(100) :: line !backspace(nml_iounit) !read(nml_iounit,fmt='(A)') line write ( * , '(A)' ) '*** *** *** *** *** *** *** *** *** *** *** ***' write ( * , '(A)' ) 'Error in namelist:      ' // & trim ( nml_error_message ) !write(*,'(A)')    'Invalid namelist entry: '//trim(line) write ( * , '(A,I5)' ) 'iostat type of error:   ' , nml_ierr write ( * , '(A)' ) '*** *** *** *** *** *** *** *** *** *** *** ***' !stop end subroutine !--- *** *** *** ---! subroutine select_number_of_bunch_particles () integer :: i do i = 1 , n_bunches if ( ppc_x_bunch ( i ) == - 1 . and . ppc_y_bunch ( i ) == - 1 . and . & ppc_z_bunch ( i ) == - 1 . and . nb_tot ( i ) == - 1 ) then ppc_bunch ( i , :) = 1 nb_tot ( i ) = - 1 else if ( ppc_x_bunch ( i ) >= 1 . and . ppc_y_bunch ( i ) >= 1 . and . & ppc_z_bunch ( i ) >= 1 . and . nb_tot ( i ) >= 1 ) then ppc_bunch ( i , 1 ) = ppc_x_bunch ( i ) ppc_bunch ( i , 2 ) = ppc_y_bunch ( i ) ppc_bunch ( i , 3 ) = ppc_z_bunch ( i ) nb_tot ( i ) = - 1 else ppc_bunch ( i , 1 ) = ppc_x_bunch ( i ) ppc_bunch ( i , 2 ) = ppc_y_bunch ( i ) ppc_bunch ( i , 3 ) = ppc_z_bunch ( i ) nb_tot ( i ) = - 1 end if end do end subroutine end module","tags":"","loc":"sourcefile/read_input.f90.html"},{"title":"pic_dump.f90 – ALaDyn","text":"This file depends on sourcefile~~pic_dump.f90~~EfferentGraph sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~pic_dump.f90->sourcefile~array_alloc.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~pic_dump.f90->sourcefile~common_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~pic_dump.f90->sourcefile~code_util.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~pic_dump.f90->sourcefile~grid_param.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~util.f90 util.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~pic_dump.f90~~AfferentGraph sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules pic_dump Source Code pic_dump.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module pic_dump use array_alloc use code_util use common_param use grid_param use parallel implicit none real ( dp ), allocatable , private :: send_buff (:), recv_buff (:) contains subroutine dump_data ( it_loc , tloc ) integer , intent ( in ) :: it_loc real ( dp ), intent ( in ) :: tloc character ( 9 ) :: fname = '         ' character ( 9 ) :: fname_yz = '         ' character ( 9 ) :: fname_ebf = '         ' character ( 9 ) :: fname_env = '         ' character ( 9 ) :: fname_fl = '         ' character ( 9 ) :: fname_part = '         ' character ( 9 ) :: fname_bunchpart = '         ' character ( 9 ) :: fname_bunch0 = '        ' character ( 9 ) :: fname_bunch1 = '        ' !=== BE CAREFUL: FILE NAMES HAVE BEEN INITIALIZED TO ONLY ALLOW A MAXIMUM ! 99 CORES ALONG Z. IF MORE ARE NEEDED, IT IS NECESSARY TO CHANGE FROM ! CHARACTER(11) TO CHARACTER(12) (OR MORE) === character ( 11 ) :: fnamel_part = '           ' character ( 11 ) :: fnamel_bunchpart = '           ' character ( 11 ) :: fnamel_bunch0 = '           ' character ( 11 ) :: fnamel_bunch1 = '           ' character ( 11 ) :: fnamel_ebf = '           ' character ( 11 ) :: fnamel_env = '           ' character ( 11 ) :: fnamel_fl = '           ' character ( 11 ) :: foldername = '           ' character ( 25 ) :: fname_out = '                         ' character ( 27 ) :: fnamel_out = '                           ' integer ( offset_kind ) :: disp_col , disp integer :: max_npt_size integer :: np , ic , lun , i , j , k , kk , ipe , lenbuff integer :: nxf_loc , nyf_loc , nzf_loc , ndv , ndvb integer :: npt_arr ( npe , nsp ), ip_loc ( npe ), ip_loc_bunch ( npe ) integer :: loc_grid_size ( npe ), loc2d_grid_size ( npe ), lenw ( npe ) integer :: grid_size_max , grid2d_size_max integer :: env_cp , env1_cp , fl_cp , ebf_cp real ( dp ) :: rdata ( 10 ) integer :: ndata ( 10 ) integer :: dist_npy ( npe_yloc , nsp ), dist_npz ( npe_zloc , nsp ) logical :: sd !============== write ( fname , '(a9)' ) 'Comm-data' write ( fname_yz , '(a9)' ) 'Dist-wgyz' write ( fname_ebf , '(a9)' ) 'EB-fields' write ( fname_env , '(a9)' ) 'ENVfields' write ( fname_fl , '(a9)' ) 'FL-fields' write ( fname_part , '(a9)' ) 'Particles' write ( fname_bunchpart , '(a9)' ) 'BunchPart' write ( fname_bunch0 , '(a9)' ) 'Bunch-EB0' write ( fname_bunch1 , '(a9)' ) 'Bunch-EB1' write ( foldername , '(a11)' ) 'dumpRestart' !================field array sizes nxf_loc = size ( ebf , 1 ) nyf_loc = size ( ebf , 2 ) nzf_loc = size ( ebf , 3 ) ebf_cp = size ( ebf , 4 ) loc_grid_size ( mype + 1 ) = nxf_loc * nyf_loc * nzf_loc !allowing for different grid sizes among mpi_tasks loc2d_grid_size ( mype + 1 ) = nyf_loc * nzf_loc lenbuff = ebf_cp if ( envelope ) then env1_cp = 0 env_cp = size ( env , 4 ) if ( Two_color ) env1_cp = env_cp lenbuff = max ( lenbuff , env_cp + env1_cp ) end if grid2d_size_max = 0 if ( hybrid ) then fl_cp = size ( up , 4 ) lenbuff = max ( lenbuff , 2 * fl_cp ) kk = loc2d_grid_size ( mype + 1 ) call intvec_distribute ( kk , loc2d_grid_size , npe ) grid2d_size_max = maxval ( loc2d_grid_size ( 1 : npe )) end if !=============================== kk = loc_grid_size ( mype + 1 ) call intvec_distribute ( kk , loc_grid_size , npe ) grid_size_max = maxval ( loc_grid_size ( 1 : npe )) lenbuff = lenbuff * grid_size_max + grid2d_size_max !=============================== ndv = nd2 + 1 do i = 1 , nsp kk = loc_npart ( imody , imodz , imodx , i ) call intvec_distribute ( kk , ip_loc , npe ) npt_arr ( 1 : npe , i ) = ip_loc ( 1 : npe ) end do do i = 1 , npe ip_loc ( i ) = sum ( npt_arr ( i , 1 : nsp )) end do max_npt_size = ndv * maxval ( ip_loc ( 1 : npe )) lenbuff = max ( lenbuff , max_npt_size ) !=============================== dist_npy (:, :) = 0 dist_npz (:, :) = 0 dist_npy ( imody + 1 , 1 : nsp ) = loc_npty ( 1 : nsp ) dist_npz ( imodz + 1 , 1 : nsp ) = loc_nptz ( 1 : nsp ) !=============================== if (. not . pe0y ) then sd = . true . call exchange_rdata_int ( loc_npty , sd , nsp , pe_min_y , 1 , 100 + imody ) else sd = . false . do ipe = 1 , npe_yloc - 1 call exchange_rdata_int ( loc_npty , sd , nsp , ipe , 1 , 100 + ipe ) dist_npy ( ipe + 1 , 1 : nsp ) = loc_npty ( 1 : nsp ) end do end if if (. not . pe0z ) then sd = . true . call exchange_rdata_int ( loc_nptz , sd , nsp , pe_min_z , 2 , 100 + imodz ) else sd = . false . do ipe = 1 , npe_zloc - 1 call exchange_rdata_int ( loc_nptz , sd , nsp , ipe , 2 , 100 + ipe ) dist_npz ( ipe + 1 , 1 : nsp ) = loc_nptz ( 1 : nsp ) end do end if !========================= ndata = 0 rdata = 0.0 !==================== rdata ( 1 ) = tloc rdata ( 2 ) = j0_norm rdata ( 3 ) = ompe rdata ( 4 ) = targ_in rdata ( 5 ) = targ_end rdata ( 6 ) = lp_in ( 1 ) rdata ( 7 ) = xp0_out rdata ( 8 ) = xp1_out rdata ( 9 ) = x ( 1 ) ndata ( 1 ) = it_loc ndata ( 2 ) = nxf_loc ndata ( 3 ) = nyf_loc ndata ( 4 ) = nzf_loc ndata ( 5 ) = nptx_max ndata ( 6 ) = size ( x ) ndata ( 7 ) = nxf ndata ( 8 ) = nd2 !========================== !============== lun = 10 if ( pe0 ) then open ( lun , file = 'dumpRestart/' // fname // '.bin' , form = 'unformatted' , & status = 'unknown' ) write ( lun ) rdata ( 1 : 10 ) write ( lun ) ndata ( 1 : 10 ) write ( lun ) nptx ( 1 : nsp ) !the index of particles inside the box write ( lun ) sptx_max ( 1 : nsp ) !the max index inside the target !===================== if ( targ_end > xmax ) then do i = 1 , nsp do j = 1 , nptx_max write ( lun ) xpt ( j , i ), wghpt ( j , i ) end do end do if ( hybrid ) then if ( nxf > 0 ) then write ( lun ) fluid_x_profile ( 1 : nxf ) end if end if end if write ( lun ) npt_arr ( 1 : npe , 1 : nsp ) write ( lun ) dist_npy ( 1 : npe_yloc , 1 : nsp ) write ( lun ) dist_npz ( 1 : npe_zloc , 1 : nsp ) !================== close ( lun ) end if !end pe0 write on fname if ( pe0 ) write ( 6 , * ) 'End write Common data' !=========================== allocate ( send_buff ( lenbuff )) !to be used for all mpi_write() !===================== !=== PARTICLES DUMP SECTION ==== if ( max_npt_size > 0 ) then write ( fnamel_part , '(a9,i2.2)' ) 'Particles' , imodz fnamel_out = 'dumpRestart/' // fnamel_part // '.bin' lenw ( 1 : npe ) = ndv * ip_loc ( 1 : npe ) max_npt_size = maxval ( lenw ( 1 : npe )) kk = 0 do ic = 1 , nsp np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then do j = 1 , ndv do i = 1 , np kk = kk + 1 send_buff ( kk ) = spec ( ic )% part ( i , j ) end do end do end if end do disp_col = 0 if ( mod ( mype , npe_yloc ) > 0 ) disp_col = sum ( lenw ( imodz * npe_yloc + 1 : mype ) & ) disp_col = 8 * disp_col call mpi_write_col_dp ( send_buff , lenw ( mype + 1 ), disp_col , 27 , & fnamel_out ) if ( pe0 ) write ( 6 , * ) 'Particles data dumped' endif !=== END PARTICLES DUMP SECTION === !=== ELECTROMAGNETIC FIELD DUMP SECTION === write ( fnamel_ebf , '(a9,i2.2)' ) 'EB-fields' , imodz fnamel_out = 'dumpRestart/' // fnamel_ebf // '.bin' lenw ( 1 : npe ) = ebf_cp * loc_grid_size ( 1 : npe ) kk = 0 do ic = 1 , ebf_cp do k = 1 , nzf_loc do j = 1 , nyf_loc do i = 1 , nxf_loc kk = kk + 1 send_buff ( kk ) = ebf ( i , j , k , ic ) end do end do end do end do disp = lenw ( 1 + mype ) disp_col = imody * disp disp_col = 8 * disp_col call mpi_write_col_dp ( send_buff , lenw ( 1 + mype ), disp_col , 27 , & fnamel_out ) if ( pe0 ) write ( 6 , * ) 'Electromagnetic fields data dumped' !=== END ELECTROMAGNETIC FIELD DUMP SECTION === !=== ENVELOPE FIELD DUMP SECTION === if ( envelope ) then write ( fnamel_env , '(a9,i2.2)' ) 'ENVfields' , imodz fnamel_out = 'dumpRestart/' // fnamel_env // '.bin' lenw ( 1 : npe ) = ( env_cp + env1_cp ) * loc_grid_size ( 1 : npe ) kk = 0 do ic = 1 , env_cp do k = 1 , nzf_loc do j = 1 , nyf_loc do i = 1 , nxf_loc kk = kk + 1 send_buff ( kk ) = env ( i , j , k , ic ) end do end do end do end do if ( Two_color ) then do ic = 1 , env1_cp do k = 1 , nzf_loc do j = 1 , nyf_loc do i = 1 , nxf_loc kk = kk + 1 send_buff ( kk ) = env1 ( i , j , k , ic ) end do end do end do end do end if disp = lenw ( 1 + mype ) disp_col = imody * disp disp_col = 8 * disp_col call mpi_write_col_dp ( send_buff , lenw ( mype + 1 ), disp_col , 27 , & fnamel_out ) if ( pe0 ) write ( 6 , * ) 'Envelope field data dumped' end if !=== END ENVELOPE FIELD DUMP SECTION === !=== FLUID DUMP SECTION === if ( hybrid ) then write ( fnamel_fl , '(a9,i2.2)' ) 'FL-fields' , imodz fnamel_out = 'dumpRestart/' // fnamel_fl // '.bin' lenw ( 1 : npe ) = 2 * fl_cp * loc_grid_size ( 1 : npe ) + loc2d_grid_size ( 1 : npe ) kk = 0 do k = 1 , nzf_loc do j = 1 , nyf_loc kk = kk + 1 send_buff ( kk ) = fluid_yz_profile ( j , k ) end do end do do ic = 1 , fl_cp do k = 1 , nzf_loc do j = 1 , nyf_loc do i = 1 , nxf_loc kk = kk + 1 send_buff ( kk ) = up ( i , j , k , ic ) end do end do end do end do do ic = 1 , fl_cp do k = 1 , nzf_loc do j = 1 , nyf_loc do i = 1 , nxf_loc kk = kk + 1 send_buff ( kk ) = up0 ( i , j , k , ic ) end do end do end do end do disp = lenw ( 1 + mype ) disp_col = imody * disp disp_col = 8 * disp_col call mpi_write_col_dp ( send_buff , lenw ( 1 + mype ), disp_col , 27 , & fnamel_out ) if ( pe0 ) write ( 6 , * ) 'Fluid density and momentum data dumped' end if !=== END FLUID DUMP SECTION === !============== write (y,z,wghyz initial part distribution if ( part ) then fname_out = 'dumpRestart/' // fname_yz // '.bin' kk = 0 do ic = 1 , nsp if ( loc_npty ( ic ) > 0 ) then do i = 1 , loc_npty ( ic ) kk = kk + 1 send_buff ( kk ) = loc_ypt ( i , ic ) end do end if end do do ic = 1 , nsp if ( loc_nptz ( ic ) > 0 ) then do j = 1 , loc_nptz ( ic ) kk = kk + 1 send_buff ( kk ) = loc_zpt ( j , ic ) end do end if end do !=============================== do ic = 1 , nsp if ( loc_nptz ( ic ) > 0 ) then do j = 1 , loc_nptz ( ic ) if ( loc_npty ( ic ) > 0 ) then do i = 1 , loc_npty ( ic ) kk = kk + 1 send_buff ( kk ) = loc_wghyz ( i , j , ic ) end do end if end do end if end do call intvec_distribute ( kk , lenw , npe ) disp = 0 if ( mype > 0 ) disp = sum ( lenw ( 1 : mype )) disp = 8 * disp call mpi_write_dp ( send_buff , lenw ( mype + 1 ), disp , 25 , fname_out ) if ( pe0 ) write ( 6 , * ) & 'Incoming plasma target transverse distribution data dumped' end if deallocate ( send_buff ) !==================== unix_time_last_dump = unix_time_now if ( pe0 ) write ( 6 , * ) 'END TOTAL DUMP WRITE' end subroutine !============================================================== subroutine restart ( it_loc , tloc ) integer , intent ( out ) :: it_loc real ( dp ), intent ( out ) :: tloc character ( 9 ) :: fname = '         ' character ( 9 ) :: fname_yz = '         ' character ( 9 ) :: fname_ebf = '         ' character ( 9 ) :: fname_env = '         ' character ( 9 ) :: fname_fl = '         ' character ( 9 ) :: fname_part = '         ' character ( 9 ) :: fname_bunch0 = '        ' character ( 9 ) :: fname_bunch1 = '        ' character ( 9 ) :: fname_bunchpart = '         ' character ( 11 ) :: fnamel_part = '           ' character ( 11 ) :: fnamel_bunch0 = '           ' character ( 11 ) :: fnamel_bunch1 = '           ' character ( 11 ) :: fnamel_bunchpart = '           ' character ( 11 ) :: fnamel_ebf = '           ' character ( 11 ) :: fnamel_env = '           ' character ( 11 ) :: fnamel_fl = '           ' character ( 11 ) :: foldername = '           ' character ( 25 ) :: fname_out = '                         ' character ( 27 ) :: fnamel_out = '                           ' integer ( offset_kind ) :: disp_col , disp integer :: max_npt_size , ipe , npt_arr ( npe , nsp ) integer :: k1 , ndv , np , ic , lun , i , j , k , kk , lenw ( npe ), lenbuff , & k2 , k3 integer :: ip_loc ( npe ), loc_grid_size ( npe ), loc2d_grid_size ( npe ) integer :: grid_size_max , grid2d_size_max integer :: env_cp , env1_cp , fl_cp , ebf_cp integer :: ndata ( 10 ), nps_loc ( 4 ), n1_old integer :: n1_loc , n2_loc , n3_loc , nypt_max , nzpt_max integer :: dist_npy ( npe_yloc , nsp ), dist_npz ( npe_zloc , nsp ) real ( dp ) :: rdata ( 10 ), x0_new logical :: sd !============== write ( fname , '(a9)' ) 'Comm-data' write ( fname_ebf , '(a9)' ) 'EB-fields' write ( fname_env , '(a9)' ) 'ENVfields' write ( fname_fl , '(a9)' ) 'FL-fields' write ( fname_part , '(a9)' ) 'Particles' write ( fname_bunch0 , '(a9)' ) 'Bunch-EB0' write ( fname_bunch1 , '(a9)' ) 'Bunch-EB1' write ( fname_bunchpart , '(a9)' ) 'BunchPart' write ( foldername , '(a11)' ) 'dumpRestart' write ( fname_yz , '(a9)' ) 'Dist-wgyz' !==============       Already defined data n1_loc = size ( ebf , 1 ) n2_loc = size ( ebf , 2 ) n3_loc = size ( ebf , 3 ) ebf_cp = size ( ebf , 4 ) !=================== loc_grid_size ( mype + 1 ) = n1_loc * n2_loc * n3_loc loc2d_grid_size ( mype + 1 ) = n2_loc * n3_loc lenbuff = ebf_cp if ( envelope ) then env1_cp = 0 env_cp = size ( env , 4 ) if ( Two_color ) env1_cp = size ( env1 , 4 ) lenbuff = max ( lenbuff , env_cp + env1_cp ) end if grid2d_size_max = 0 if ( hybrid ) then fl_cp = size ( up , 4 ) lenbuff = max ( lenbuff , 2 * fl_cp ) kk = loc2d_grid_size ( mype + 1 ) call intvec_distribute ( kk , loc2d_grid_size , npe ) grid2d_size_max = maxval ( loc2d_grid_size ( 1 : npe )) end if kk = loc_grid_size ( mype + 1 ) call intvec_distribute ( kk , loc_grid_size , npe ) grid_size_max = maxval ( loc_grid_size ( 1 : npe )) lenbuff = lenbuff * grid_size_max + grid2d_size_max !=================== if ( pe0 ) write ( 6 , * ) 'Max size of recieve buffer' , lenbuff lun = 10 if ( pe0 ) then open ( lun , file = 'dumpRestart/' // fname // '.bin' , form = 'unformatted' , & status = 'unknown' ) read ( lun ) rdata ( 1 : 10 ) read ( lun ) ndata ( 1 : 10 ) read ( lun ) nptx ( 1 : nsp ) read ( lun ) sptx_max ( 1 : nsp ) it_loc = ndata ( 1 ) nptx_max = ndata ( 5 ) n1_old = ndata ( 6 ) nxf = ndata ( 7 ) ndv = ndata ( 8 ) + 1 !========================= tloc = rdata ( 1 ) targ_in = rdata ( 4 ) targ_end = rdata ( 5 ) lp_in ( 1 ) = rdata ( 6 ) x0_new = rdata ( 9 ) !============================= if ( targ_end > xmax + x0_new ) then allocate ( xpt ( nptx_max , nsp )) allocate ( wghpt ( nptx_max , nsp )) do i = 1 , nsp do j = 1 , nptx_max read ( lun ) xpt ( j , i ), wghpt ( j , i ) end do end do if ( hybrid ) then if ( nxf > 0 ) then allocate ( fluid_x_profile ( nxf )) read ( lun ) fluid_x_profile ( 1 : nxf ) end if end if end if !==================== dumped by pe0 even if no particles are present read ( lun ) npt_arr ( 1 : npe , 1 : nsp ) read ( lun ) dist_npy ( 1 : npe_yloc , 1 : nsp ) read ( lun ) dist_npz ( 1 : npe_zloc , 1 : nsp ) close ( lun ) end if !end pe0 read on fname !========================= distribute comm data kk = size ( rdata ) k1 = size ( ndata ) k2 = size ( nptx ) k3 = size ( sptx_max ) call vint_bcast ( ndata , k1 ) call vint_bcast ( nptx , k2 ) call vint_bcast ( sptx_max , k3 ) call real_bcast ( rdata , kk ) it_loc = ndata ( 1 ) nptx_max = ndata ( 5 ) n1_old = ndata ( 6 ) nxf = ndata ( 7 ) ndv = ndata ( 8 ) + 1 !========================= tloc = rdata ( 1 ) targ_in = rdata ( 4 ) targ_end = rdata ( 5 ) lp_in ( 1 ) = rdata ( 6 ) x0_new = rdata ( 9 ) if ( x0_new > 0.0 ) then x = x + x0_new xh = xh + x0_new xmin = xmin + x0_new xmax = xmax + x0_new loc_xgrid ( imodx )% gmin = loc_xgrid ( imodx )% gmin + x0_new loc_xgrid ( imodx )% gmax = loc_xgrid ( imodx )% gmax + x0_new xp0_out = xp0_out + x0_new xp1_out = xp1_out + x0_new xmn = loc_xgrid ( imodx )% gmin end if if ( targ_end > xmax ) then if ( mype > 0 ) then allocate ( xpt ( nptx_max , nsp )) allocate ( wghpt ( nptx_max , nsp )) if ( hybrid ) then if ( nxf > 0 ) allocate ( fluid_x_profile ( nxf )) end if end if if ( pe0 ) then sd = . true . do ipe = 1 , npe - 1 call exchange_2d_grdata ( sd , xpt , nptx_max , nsp , ipe , ipe + 100 ) call exchange_2d_grdata ( sd , wghpt , nptx_max , nsp , ipe , ipe + 400 ) end do else sd = . false . call exchange_2d_grdata ( sd , xpt , nptx_max , nsp , pe_min , mype + 100 ) call exchange_2d_grdata ( sd , wghpt , nptx_max , nsp , pe_min , mype + 400 ) endif !=========================== if ( hybrid ) then if ( nxf > 0 ) then if ( pe0 ) then sd = . true . do ipe = 1 , npe - 1 call exchange_1d_grdata ( sd , fluid_x_profile , nxf , ipe , ipe + 10 ) end do else sd = . false . call exchange_1d_grdata ( sd , fluid_x_profile , nxf , pe_min , mype + 10 ) endif end if end if end if !Pe0 distributes npart => npt(npe,nsp) call vint_2d_bcast ( npt_arr , npe , nsp ) do i = 1 , npe ip_loc ( i ) = sum ( npt_arr ( i , 1 : nsp )) end do max_npt_size = ndv * maxval ( ip_loc ( 1 : npe )) lenbuff = max ( lenbuff , max_npt_size ) ipe = 0 do i = 0 , npe_xloc - 1 do j = 0 , npe_zloc - 1 do k = 0 , npe_yloc - 1 loc_npart ( k , j , i , 1 : nsp ) = npt_arr ( ipe + 1 , 1 : nsp ) ipe = ipe + 1 end do end do end do !========== distributes npty,nptz initial particle distribution call vint_2d_bcast ( dist_npy , npe_yloc , nsp ) call vint_2d_bcast ( dist_npz , npe_zloc , nsp ) loc_npty ( 1 : nsp ) = dist_npy ( imody + 1 , 1 : nsp ) loc_nptz ( 1 : nsp ) = dist_npz ( imodz + 1 , 1 : nsp ) nypt_max = maxval ( loc_npty ( 1 : nsp )) nzpt_max = maxval ( loc_nptz ( 1 : nsp )) allocate ( loc_ypt ( nypt_max , nsp )) allocate ( loc_zpt ( nzpt_max , nsp )) allocate ( loc_wghyz ( nypt_max , nzpt_max , nsp )) ! x() defined on the grid module starting from x(1)=0.0 !---------- Particle read !============================================ allocate ( recv_buff ( lenbuff )) recv_buff (:) = 0.0 !=== FLUID RESTART SECTION === if ( hybrid ) then write ( fnamel_fl , '(a9,i2.2)' ) 'FL-fields' , imodz fnamel_out = 'dumpRestart/' // fnamel_fl // '.bin' lenw ( 1 : npe ) = 2 * fl_cp * loc_grid_size ( 1 : npe ) + loc2d_grid_size ( 1 : npe ) !========================== disp = lenw ( 1 + mype ) disp_col = imody * disp disp_col = 8 * disp_col call mpi_read_col_dp ( recv_buff , lenw ( 1 + mype ), disp_col , 27 , & fnamel_out ) kk = 0 do k = 1 , n3_loc do j = 1 , n2_loc kk = kk + 1 fluid_yz_profile ( j , k ) = recv_buff ( kk ) end do end do do ic = 1 , fl_cp do k = 1 , n3_loc do j = 1 , n2_loc do i = 1 , n1_loc kk = kk + 1 up ( i , j , k , ic ) = recv_buff ( kk ) end do end do end do end do do ic = 1 , fl_cp do k = 1 , n3_loc do j = 1 , n2_loc do i = 1 , n1_loc kk = kk + 1 up0 ( i , j , k , ic ) = recv_buff ( kk ) end do end do end do end do if ( pe0 ) write ( 6 , * ) 'Fluid density and momentum data read' end if !=== END FLUID RESTART SECTION === !=== ENVELOPE RESTART SECTION === if ( envelope ) then write ( fnamel_env , '(a9,i2.2)' ) 'ENVfields' , imodz fnamel_out = 'dumpRestart/' // fnamel_env // '.bin' lenw ( 1 : npe ) = ( env_cp + env1_cp ) * loc_grid_size ( 1 : npe ) !================== disp = lenw ( 1 + mype ) disp_col = imody * disp disp_col = 8 * disp_col call mpi_read_col_dp ( recv_buff , lenw ( 1 + mype ), disp_col , 27 , & fnamel_out ) !====================== kk = 0 do ic = 1 , env_cp do k = 1 , n3_loc do j = 1 , n2_loc do i = 1 , n1_loc kk = kk + 1 env ( i , j , k , ic ) = recv_buff ( kk ) end do end do end do end do if ( Two_color ) then do ic = 1 , env1_cp do k = 1 , n3_loc do j = 1 , n2_loc do i = 1 , n1_loc kk = kk + 1 env1 ( i , j , k , ic ) = recv_buff ( kk ) end do end do end do end do end if if ( pe0 ) write ( 6 , * ) 'Envelope field data read' end if !=== END ENVELOPE RESTART SECTION === !=== FIELD RESTART SECTION === write ( fnamel_ebf , '(a9,i2.2)' ) 'EB-fields' , imodz fnamel_out = 'dumpRestart/' // fnamel_ebf // '.bin' lenw ( 1 : npe ) = ebf_cp * loc_grid_size ( 1 : npe ) !========================= disp = lenw ( 1 + mype ) disp_col = imody * disp disp_col = 8 * disp_col call mpi_read_col_dp ( recv_buff , lenw ( 1 + mype ), disp_col , 27 , & fnamel_out ) !=========================== kk = 0 do ic = 1 , ebf_cp do k = 1 , n3_loc do j = 1 , n2_loc do i = 1 , n1_loc kk = kk + 1 ebf ( i , j , k , ic ) = recv_buff ( kk ) end do end do end do end do if ( pe0 ) write ( 6 , * ) 'Electromagnetic fields data read' !=== END FIELD RESTART SECTION=== do i = 1 , nsp nps_loc ( i ) = maxval ( npt_arr ( 1 : npe , i )) end do np_max = maxval ( nps_loc ( 1 : nsp )) if ( np_max > 0 ) then !READS particles (if any) write ( fnamel_part , '(a9,i2.2)' ) 'Particles' , imodz fnamel_out = 'dumpRestart/' // fnamel_part // '.bin' call p_alloc ( np_max , ndv , nps_loc , nsp , lpf_ord , 1 , 1 , mem_psize ) lenw ( 1 : npe ) = ndv * ip_loc ( 1 : npe ) !======================= disp_col = 0 if ( mod ( mype , npe_yloc ) > 0 ) disp_col = sum ( lenw ( imodz * npe_yloc + 1 : mype ) & ) disp_col = 8 * disp_col call mpi_read_col_dp ( recv_buff , lenw ( 1 + mype ), disp_col , 27 , & fnamel_out ) !============================== kk = 0 do ic = 1 , nsp np = loc_npart ( imody , imodz , imodx , ic ) if ( np > 0 ) then do j = 1 , ndv do i = 1 , np kk = kk + 1 spec ( ic )% part ( i , j ) = recv_buff ( kk ) end do end do end if end do end if !================================= fname_out = 'dumpRestart/' // fname_yz // '.bin' kk = 0 do ic = 1 , nsp if ( loc_npty ( ic ) > 0 ) then do i = 1 , loc_npty ( ic ) kk = kk + 1 end do end if end do do ic = 1 , nsp if ( loc_nptz ( ic ) > 0 ) then do j = 1 , loc_nptz ( ic ) kk = kk + 1 end do end if end do do ic = 1 , nsp if ( loc_nptz ( ic ) > 0 ) then do j = 1 , loc_nptz ( ic ) if ( loc_npty ( ic ) > 0 ) then do i = 1 , loc_npty ( ic ) kk = kk + 1 end do end if end do end if end do call intvec_distribute ( kk , lenw , npe ) np_max = maxval ( lenw ( 1 : npe )) if ( np_max > 0 ) then disp = 0 if ( mype > 0 ) disp = sum ( lenw ( 1 : mype )) disp = 8 * disp call mpi_read_dp ( recv_buff , lenw ( mype + 1 ), disp , 25 , fname_out ) kk = 0 do ic = 1 , nsp do i = 1 , loc_npty ( ic ) kk = kk + 1 loc_ypt ( i , ic ) = recv_buff ( kk ) end do end do do ic = 1 , nsp do j = 1 , loc_nptz ( ic ) kk = kk + 1 loc_zpt ( j , ic ) = recv_buff ( kk ) end do end do do ic = 1 , nsp do j = 1 , loc_nptz ( ic ) do i = 1 , loc_npty ( ic ) kk = kk + 1 loc_wghyz ( i , j , ic ) = recv_buff ( kk ) end do end do end do end if !end of part read if ( pe0 ) write ( 6 , * ) 'Particles data read' !============================================ deallocate ( recv_buff ) !=============================== if ( pe0 ) write ( 6 , * ) 'END TOTAL DUMP READ' end subroutine !=========================== end module","tags":"","loc":"sourcefile/pic_dump.f90.html"},{"title":"system_utilities.f90 – ALaDyn","text":"This file depends on sourcefile~~system_utilities.f90~~EfferentGraph sourcefile~system_utilities.f90 system_utilities.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~system_utilities.f90->sourcefile~mpi_var.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~system_utilities.f90~~AfferentGraph sourcefile~system_utilities.f90 system_utilities.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~system_utilities.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules system_utilities Source Code system_utilities.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module system_utilities use mpi_var implicit none contains !-------------------------- subroutine create_timestep_folder ( iout ) integer , intent ( in ) :: iout character ( 4 ) :: foldername write ( foldername , '(i4.4)' ) iout if ( pe0 ) call create_folder ( foldername ) end subroutine subroutine create_initial_folders if ( pe0 ) call create_folder ( 'dumpRestart' ) if ( pe0 ) call create_folder ( 'diagnostics' ) end subroutine !--------------------------- end module","tags":"","loc":"sourcefile/system_utilities.f90.html"},{"title":"set_init_param.f90 – ALaDyn","text":"This file depends on sourcefile~~set_init_param.f90~~EfferentGraph sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~set_init_param.f90->sourcefile~ionz_data.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~set_init_param.f90->sourcefile~phys_param.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~set_init_param.f90->sourcefile~control_bunch_input.f90 sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~set_init_param.f90->sourcefile~common_param.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~set_init_param.f90->sourcefile~code_util.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~set_init_param.f90->sourcefile~grid_param.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~set_grid_param.f90->sourcefile~common_param.f90 sourcefile~set_grid_param.f90->sourcefile~grid_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~set_grid_param.f90->sourcefile~mpi_var.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~set_init_param.f90~~AfferentGraph sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~start_all.f90 start_all.F90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules set_init_param Source Code set_init_param.f90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module set_init_param use code_util use phys_param use common_param use grid_param , only : nx_stretch , ny_stretch , nz_stretch use set_grid_param use ionz_data use control_bunch_input implicit none contains subroutine set_initial_param ! sets general parameters and grid depending on initial conditions integer :: i real ( dp ) :: gvol , gvol_inv , nm_fact , ncell real ( dp ) :: aph_fwhm , c1_fact , c2_fact !================== grid dimension definition ============== ndim = 1 if ( ny > 1 ) ndim = 2 if ( nz > 1 ) ndim = 3 !===========time integrator schemes t_ord = lpf_ord if ( t_ord == 4 ) der_ord = t_ord !=================================== nx_loc = nx / nprocx ny_loc = ny / nprocy nz_loc = nz / nprocz sh_targ = ny / 2 - ny_targ / 2 nx_stretch = 0 stretch = . false . ny_stretch = 0 nz_stretch = 0 if ( ndim < 2 ) str_flag = 0 if ( model_id > 4 ) str_flag = 0 !=================== if ( str_flag == 1 ) then !size_of_stretch defined in phys_param module => common_param stretch = . true . ny_stretch = nint ( real ( ny , dp ) * size_of_stretch_along_y ) !set to ny/6 end if if ( str_flag == 2 ) then stretch = . true . ny_stretch = nint ( real ( ny , dp ) * 1.5 * size_of_stretch_along_y ) !set to ny/4 end if nz_stretch = ny_stretch loc_nyc_max = loc_ygr_max loc_nzc_max = loc_zgr_max loc_nxc_max = loc_xgr_max !=========Sets grid data============= gvol_inv = 1. gvol = 1. dx = 1. / k0 call set_grid ( nx , ny , nz , ibx , nx_stretch , ny_stretch , k0 , yx_rat , & zx_rat ) dt = cfl * dx select case ( ndim ) case ( 1 ) dt = cfl / sqrt ( dx_inv * dx_inv ) gvol_inv = dx_inv * dx_inv * dx_inv case ( 2 ) dt = cfl / sqrt ( dx_inv * dx_inv + dy_inv * dy_inv ) gvol_inv = dx_inv * dy_inv * dy_inv case ( 3 ) dt = cfl / sqrt ( dx_inv * dx_inv + dy_inv * dy_inv + dz_inv * dz_inv ) gvol_inv = dx_inv * dy_inv * dz_inv end select gvol = 1. / gvol_inv djc ( 1 ) = dx djc ( 2 : 3 ) = 0.0 if ( ndim == 2 ) then djc ( 1 ) = 0.5 * dx djc ( 2 ) = 0.5 * dy end if if ( ndim == 3 ) then djc ( 1 ) = dx / 3. djc ( 2 ) = dy / 3. djc ( 3 ) = dz / 3. end if ymin_t = y ( 1 ) ymax_t = y ( ny + 1 ) zmin_t = z ( 1 ) zmax_t = z ( nz + 1 ) if ( ndim > 1 ) then ymin_t = y ( sh_targ + 1 ) ymax_t = y ( ny + 1 - sh_targ ) end if if ( ndim > 2 ) then zmin_t = z ( 1 + sh_targ ) zmax_t = z ( nz + 1 - sh_targ ) end if !====================================== hybrid = . false . high_gamma = . false . if ( gam_min > 1.0 ) high_gamma = . true . test = . false . part = . false . lp_active = . false . lp_inject = . false . ionization = . false . charge_cons = . false . if ( iform < 2 ) charge_cons = . true . inject_beam = . false . beam = . false . relativistic = . false . ions = . false . envelope = . false . circ_lp = . false . plane_wave = . false . Two_color = . false . wake = . false . solid_target = . false . channel = . false . nm_fact = 1. if ( nsp > 1 ) ions = . true . lp_active = . true . if ( ibeam == 2 ) hybrid = . true . !============================================ if ( iby == 2 ) plane_wave = . true . mod_ord = 1 if ( model_id < 3 ) lin_lp = . true . if ( model_id == 3 ) circ_lp = . true . if ( model_id == 4 ) then mod_ord = 2 envelope = . true . end if relativistic = . true . nfield = 3 curr_ndim = 2 nbfield = 4 if ( ndim > 2 ) then nfield = 6 curr_ndim = ndim nbfield = 6 end if if ( circ_lp ) then nfield = 6 curr_ndim = 3 end if if ( lp_offset > 0.0 ) Two_color = . true . !=============================== ! Multispecies target with max 3 ionic species (nsp=4) !================= !========================== particle on cells do i = 1 , 6 mp_per_cell ( i ) = np_per_xc ( i ) * np_per_yc ( i ) if ( ndim == 3 ) mp_per_cell ( i ) = np_per_xc ( i ) * np_per_yc ( i ) * np_per_zc ( i ) end do j0_norm = 1. nref = mp_per_cell ( 1 ) ratio_mpc = 1. if ( mp_per_cell ( 1 ) > 0 ) then j0_norm = 1. / real ( nref , dp ) do i = 1 , 6 ratio_mpc ( i ) = 0.0 if ( mp_per_cell ( i ) > 0 ) ratio_mpc ( i ) = real ( mp_per_cell ( 1 ), dp ) / & real ( mp_per_cell ( i ), dp ) end do end if ratio_mpfluid = 1.0 if ( hybrid ) then ratio_mpfluid = 0.1 if ( mp_per_cell ( 1 ) == 0 ) ratio_mpfluid = 0.0 if ( ny_targ == 0 ) ratio_mpfluid = 0.0 end if j0_norm = j0_norm * ratio_mpfluid !========================== multispecies ! mass-charge parameters four species: three ion species+ electrons ! Ions charges defined by initial conditions. unit_charge ( 1 ) = electron_charge_norm unit_charge ( 2 ) = ion_min ( 1 ) * proton_charge_norm unit_charge ( 3 ) = ion_min ( 2 ) * proton_charge_norm unit_charge ( 4 ) = ion_min ( 3 ) * proton_charge_norm !================================= mass ( 1 ) = electron_mass_norm mass ( 2 ) = mass_number ( 1 ) * proton_mass_norm mass ( 3 ) = mass_number ( 2 ) * proton_mass_norm mass ( 4 ) = mass_number ( 3 ) * proton_mass_norm do i = 1 , 4 mass_rat ( i ) = 1. / mass ( i ) charge_to_mass ( i ) = unit_charge ( i ) * mass_rat ( i ) end do lorentz_fact ( 1 : 4 ) = mass_rat ( 1 : 4 ) !for (E,B) fields in mc2/e/l0(mu) unit e0 = electron_mass !===================================== ! Check species molecular number !===================================== if ( nsp > 1 ) then do i = 1 , nsp - 1 call set_atoms_per_molecule ( atomic_number ( i ), n_mol_atoms ( i )) !Defined in ionz_data module end do end if !====================================== ! Set ionization param ! WARNING  ion ordering in input data must set ionizing species first !========================================================== !wgh_ion=j0_norm nsp_ionz = 1 if ( nsp > 1 ) then do i = 1 , nsp - 1 !index of ionizing ion species 2,.. nsp_ionz <= nsp if ( ion_min ( i ) < ion_max ( i )) nsp_ionz = i + 1 end do nsp_ionz = min ( nsp_ionz , nsp ) do i = 1 , 3 if ( mass_number ( i ) < 1. ) call set_atomic_weight ( atomic_number ( i ), & mass_number ( i )) end do if ( ionz_lev > 0 ) ionization = . true . if ( ionization ) call set_ionization_coeff ( atomic_number , nsp_ionz ) !uses ion index 1,2,,,nsp-1 wgh_ion = concentration ( 1 ) / ( real ( mp_per_cell ( 2 ), dp )) !if(ion_min(1)>1)wgh_ion=1./(real(ion_min(1),dp)*real(mp_per_cell(2),dp)) end if !=======Moving window if ( w_speed < 0.0 ) then vbeam = - w_speed comoving = . true . else comoving = . false . vbeam = 0.0 end if !==================================== ! Code units for background plasma number density ! Enter n0_ref= in 10&#94;18/cc= 10&#94;6/mu&#94;3 units (reference_density) ! l_u =1mu ! omp&#94;2_norm=(l_u/c)&#94;2*[4*pi *n0_ref*e&#94;2/m_e]=4*pi*rc0*n0_ref ! rc0= class elect. radius in 10&#94;{-9}[mu] units ! l_u&#94;2*rc0  in 10&#94;{-9} [mu&#94;3] !====================================================== ompe = 4. * pi * rc0 * ( reference_density * 1.e-6 ) !squared adimensional unit frequency at reference_density=1.e+06/mu&#94;3 ompe = 1.e-03 * ompe !========================================== np_per_cell = 1 !======================= n_plasma = 0 if ( nsp > 1 ) then do i = 1 , nsp - 1 n_plasma = n_plasma + concentration ( i ) * n_mol_atoms ( i ) * ion_min ( i ) end do if ( n_plasma < epsilon ) then np_per_xc ( 1 ) = 0 np_per_yc ( 1 ) = 0 n_plasma = zero_dp end if else if ( nsp == 1 ) then n_plasma = one_dp end if ncrit = pi / ( rc0 * lam0 * lam0 ) !critical density in unit nc=10&#94;21/cm&#94;3=10&#94;9/mu&#94;3 ! 1.e-03*ncrit    in unit reference_density nm_fact = ncrit * ( 1.e+3 ) ! nm_fact critical density in (10&#94;6/mu&#94;3) units ! n0_ref*n_plasma electron density in 10&#94;6/mu&#94;3 ! (reference_density) units n_over_nc = 1.e-03 * n_plasma * n0_ref / ncrit if ( n_over_nc > 1. ) then solid_target = . true . else wake = . true . end if !========================== ! Target parameters  using n_over_nc !=================================== ! Laser/envelope parameters !E=in unit mc&#94;2/(e*l0)=[TV/m]/E0; E0*E in [TV/m]=[MV/mu] unit !E0(A,phi) in MV unit oml = pi2 / lam0 !laser frequency in unit c/l0 om1 = pi2 / lam1 !laser frequency in unit c/l0 lp_amp = a0 * oml lp1_amp = a1 * om1 !field in unit 0.51 MV/m lp_max = 1.5 * lp_amp if ( Two_color ) lp_max = max ( lp_max , 1.5 * lp1_amp ) !============================= nc0 = oml * oml !nc0=(2*pi/lam0)** 2 !=============================== ! Parabolic plasma channel profile const  r_c=w0_y matched condition chann_fact = 0.0 if ( r_c > 0.0 ) then channel = . true . c1_fact = w0_y * w0_y / ( r_c * r_c ) c2_fact = lam0 * lam0 / ( r_c * r_c ) chann_fact = c1_fact * c2_fact / ( pi * pi * n_over_nc ) end if !========== Laser parameters lp_intensity = 1.37 * ( a0 / lam0 ) * ( a0 / lam0 ) !in units 10&#94;18 W/cm&#94;2 lp_rad = w0_y * sqrt ( 2. * log ( 2. )) !FWHM focal spot zr = pi * w0_y * w0_y / lam0 lp1_rad = w1_y * sqrt ( 2. * log ( 2. )) !FWHM focal spot zr1 = pi * w1_y * w1_y / lam1 lp_pow = 0.5 * pi * lp_intensity * w0_y * w0_y !in units 10&#94;10 W if ( ndim == 2 ) lp_pow = 0.5 * dy * lp_intensity * w0_y !in units 10&#94;10 W lp_pow = 0.01 * lp_pow !in TW= 1.e-03[J/fs]  units if ( plane_wave ) then !plane LP wave lp_pow = 0.01 * lp_intensity * ly_box * lz_box !in TW = 10&#94;{-3}J/fs zr = 0.0 end if !======= Defines scales (w0_x,w1_x) in longitudinal (t-x) pulse profile if ( g_prof ) then aph_fwhm = sqrt ( 2. * log ( 2. )) else aph_fwhm = 2. * acos ( sqrt ( 0.5 * sqrt ( 2. ))) / pi !aph_fwhm=2.*acos(sqrt(sqrt(0.5*sqrt(2.))))/pi this is only valid for cos&#94;4 pulse shape end if lx_fwhm = tau_fwhm * speed_of_light ! In micron unit w0_x = lx_fwhm / aph_fwhm w1_x = speed_of_light * tau1_fwhm / aph_fwhm !================= lp_energy = 1.e-03 * tau_fwhm * lp_pow energy_in_targ = 0.0 el_lp = lam0 if ( n_over_nc > 0.0 ) then p_c = 0.0174 / n_over_nc !Critical power in TW lambda_p = lam0 / sqrt ( n_over_nc ) el_lp = lambda_p / pi2 el_d = t0_pl ( 1 ) * el_lp !Debye length t0_pl(1)= V_T/c at t=0 omega_p = 1. / el_lp end if bet0 = 0.0 lpvol = el_lp * el_lp * el_lp if ( nsb > 0 ) inject_beam = . true . !===================== if ( inject_beam ) then !ON input phase space coordinates, beam size, !         total macro-particle number nb_tot(1), total charge (pC) !==================================== do i = 1 , nsb jb_norm ( i ) = 1. gam0 = gam ( i ) !the initial gamma factor u0_b = sqrt ( gam0 * gam0 - 1. ) !the uniform beam x-momentum bet0 = u0_b / gam0 !the uniform beam velocity !================== b_charge = nb_tot ( i ) * e_charge !the charge of bunch macro-particle np_per_nmacro = bunch_charge ( i ) / b_charge !real particles/macro particles=real charge/macro charge !=============== if ( ndim < 3 ) then bunch_volume ( i ) = pi2 * sxb ( i ) * syb ( i ) * dy !the bunch volume (mu&#94;3) in 2D Gaussian else bunch_volume ( i ) = pi2 * sqrt ( pi2 ) * sxb ( i ) * syb ( i ) * syb ( i ) !the bunch volume (mu&#94;3) in 3D Gussian bunch end if rhob ( i ) = bunch_charge ( i ) / ( e_charge * bunch_volume ( i )) !physical bunch density (1/mu&#94;3) rhob ( i ) = 1.e-06 * rhob ( i ) / n0_ref !ratio beam density/background plasma density ncell = bunch_volume ( i ) * gvol_inv nb_per_cell ( i ) = nint ( nb_tot ( i ) / ncell ) if ( nb_per_cell ( i ) > 0 ) jb_norm ( i ) = rhob ( i ) / nb_per_cell ( i ) ! end do end if !=================================== !  SET PARAM all cases if ( hybrid ) nfcomp = curr_ndim + 1 nsp_run = nsp if ( wake ) then nsp_run = 1 !only electrons running if ( dmodel_id == 3 ) wgh_ion = np1 * wgh_ion end if !==============  in 2D dz=dy mp_per_cell =mp_x*mp_y,  mp_z=1 np_per_cell = nm_fact * n_over_nc * gvol !here the real particle number per cell !=========================== if ( mp_per_cell ( 1 ) > 0 ) then nmacro = nref * gvol_inv macro_charge = np_per_cell * e_charge !real charge [in pC units]/cell !=========================================== !all parameters to be multiplied by the macro weight= j0_norm=1/mp_per_cell !========================== ! j0_norm*np_percell = number of real particles for each ! macroparticle !======================== nmacro = nref * real ( nx * ny * nz , dp ) ! here the total initial nmacro particles end if !========================= Memory allocation nx_alloc = nint ( dx_inv * sum ( lpx ( 1 : 5 ))) nx_alloc = min ( nx_loc , nx_alloc ) npt_buffer = 0 do i = 1 , nsp npt_buffer ( i ) = nx_alloc * ny_loc * nz_loc * mp_per_cell ( i ) end do !=============================== !density per macroparticle: np_per_nmacro=nm_fact*n_over_nc/nmacro !np_per_nmacro= electron density over el_macro density !multiplied by nb_over_np gives the bunch elecron density over bunch macro !under the condition :np_per_cell is the same for plasma and bunch macro !----------------------------- pot_ndim = 0 nd2 = 2 * curr_ndim nj_dim = curr_ndim if ( envelope ) nj_dim = curr_ndim + 1 end subroutine end module","tags":"","loc":"sourcefile/set_init_param.f90.html"},{"title":"start_all.F90 – ALaDyn","text":"This file depends on sourcefile~~start_all.f90~~EfferentGraph sourcefile~start_all.f90 start_all.F90 sourcefile~pic_in.f90 pic_in.f90 sourcefile~start_all.f90->sourcefile~pic_in.f90 sourcefile~read_input.f90 read_input.f90 sourcefile~start_all.f90->sourcefile~read_input.f90 sourcefile~run_data_info.f90 run_data_info.f90 sourcefile~start_all.f90->sourcefile~run_data_info.f90 sourcefile~array_alloc.f90 array_alloc.f90 sourcefile~start_all.f90->sourcefile~array_alloc.f90 sourcefile~set_init_param.f90 set_init_param.f90 sourcefile~start_all.f90->sourcefile~set_init_param.f90 sourcefile~set_grid_param.f90 set_grid_param.f90 sourcefile~start_all.f90->sourcefile~set_grid_param.f90 sourcefile~pic_dump.f90 pic_dump.f90 sourcefile~start_all.f90->sourcefile~pic_dump.f90 sourcefile~system_utilities.f90 system_utilities.f90 sourcefile~start_all.f90->sourcefile~system_utilities.f90 sourcefile~ionize.f90 ionize.f90 sourcefile~start_all.f90->sourcefile~ionize.f90 sourcefile~init_laser_field.f90 init_laser_field.f90 sourcefile~pic_in.f90->sourcefile~init_laser_field.f90 sourcefile~init_part_distrib.f90 init_part_distrib.f90 sourcefile~pic_in.f90->sourcefile~init_part_distrib.f90 sourcefile~control_bunch_input.f90 control_bunch_input.f90 sourcefile~read_input.f90->sourcefile~control_bunch_input.f90 sourcefile~common_param.f90 common_param.f90 sourcefile~read_input.f90->sourcefile~common_param.f90 sourcefile~mpi_var.f90 mpi_var.f90 sourcefile~read_input.f90->sourcefile~mpi_var.f90 sourcefile~code_util.f90 code_util.f90 sourcefile~read_input.f90->sourcefile~code_util.f90 sourcefile~ionz_data.f90 ionz_data.f90 sourcefile~run_data_info.f90->sourcefile~ionz_data.f90 sourcefile~phys_param.f90 phys_param.f90 sourcefile~run_data_info.f90->sourcefile~phys_param.f90 sourcefile~run_data_info.f90->sourcefile~control_bunch_input.f90 sourcefile~pstruct_data.f90 pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~pstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~common_param.f90 sourcefile~parallel.f90 parallel.F90 sourcefile~run_data_info.f90->sourcefile~parallel.f90 sourcefile~fstruct_data.f90 fstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~fstruct_data.f90 sourcefile~run_data_info.f90->sourcefile~code_util.f90 sourcefile~grid_param.f90 grid_param.f90 sourcefile~run_data_info.f90->sourcefile~grid_param.f90 sourcefile~array_alloc.f90->sourcefile~pstruct_data.f90 sourcefile~array_alloc.f90->sourcefile~fstruct_data.f90 sourcefile~set_init_param.f90->sourcefile~set_grid_param.f90 sourcefile~set_init_param.f90->sourcefile~ionz_data.f90 sourcefile~set_init_param.f90->sourcefile~phys_param.f90 sourcefile~set_init_param.f90->sourcefile~control_bunch_input.f90 sourcefile~set_init_param.f90->sourcefile~common_param.f90 sourcefile~set_init_param.f90->sourcefile~code_util.f90 sourcefile~set_init_param.f90->sourcefile~grid_param.f90 sourcefile~set_grid_param.f90->sourcefile~common_param.f90 sourcefile~set_grid_param.f90->sourcefile~mpi_var.f90 sourcefile~set_grid_param.f90->sourcefile~grid_param.f90 sourcefile~pic_dump.f90->sourcefile~array_alloc.f90 sourcefile~pic_dump.f90->sourcefile~common_param.f90 sourcefile~pic_dump.f90->sourcefile~parallel.f90 sourcefile~pic_dump.f90->sourcefile~code_util.f90 sourcefile~pic_dump.f90->sourcefile~grid_param.f90 sourcefile~system_utilities.f90->sourcefile~mpi_var.f90 sourcefile~ionize.f90->sourcefile~array_alloc.f90 sourcefile~ionize.f90->sourcefile~ionz_data.f90 sourcefile~util.f90 util.f90 sourcefile~ionize.f90->sourcefile~util.f90 sourcefile~ionize.f90->sourcefile~common_param.f90 sourcefile~ionize.f90->sourcefile~mpi_var.f90 sourcefile~precision_def.f90 precision_def.F90 sourcefile~ionz_data.f90->sourcefile~precision_def.f90 sourcefile~phys_param.f90->sourcefile~precision_def.f90 sourcefile~util.f90->sourcefile~code_util.f90 sourcefile~util.f90->sourcefile~precision_def.f90 sourcefile~control_bunch_input.f90->sourcefile~precision_def.f90 sourcefile~init_laser_field.f90->sourcefile~pstruct_data.f90 sourcefile~init_laser_field.f90->sourcefile~fstruct_data.f90 sourcefile~init_grid_fields.f90 init_grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~init_grid_fields.f90 sourcefile~grid_fields.f90 grid_fields.f90 sourcefile~init_laser_field.f90->sourcefile~grid_fields.f90 sourcefile~struct_def.f90 struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~struct_def.f90 sourcefile~pstruct_data.f90->sourcefile~precision_def.f90 sourcefile~common_param.f90->sourcefile~precision_def.f90 sourcefile~parallel.f90->sourcefile~util.f90 sourcefile~parallel.f90->sourcefile~common_param.f90 sourcefile~parallel.f90->sourcefile~mpi_var.f90 sourcefile~init_part_distrib.f90->sourcefile~array_alloc.f90 sourcefile~init_part_distrib.f90->sourcefile~phys_param.f90 sourcefile~init_part_distrib.f90->sourcefile~util.f90 sourcefile~init_part_distrib.f90->sourcefile~common_param.f90 sourcefile~init_part_distrib.f90->sourcefile~mpi_var.f90 sourcefile~init_part_distrib.f90->sourcefile~code_util.f90 sourcefile~init_part_distrib.f90->sourcefile~grid_param.f90 sourcefile~fstruct_data.f90->sourcefile~precision_def.f90 sourcefile~mpi_var.f90->sourcefile~precision_def.f90 sourcefile~code_util.f90->sourcefile~precision_def.f90 sourcefile~grid_param.f90->sourcefile~struct_def.f90 sourcefile~grid_param.f90->sourcefile~precision_def.f90 sourcefile~struct_def.f90->sourcefile~precision_def.f90 sourcefile~init_grid_fields.f90->sourcefile~phys_param.f90 sourcefile~init_grid_fields.f90->sourcefile~pstruct_data.f90 sourcefile~init_grid_fields.f90->sourcefile~fstruct_data.f90 sourcefile~grid_field_param.f90 grid_field_param.f90 sourcefile~init_grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_fields.f90->sourcefile~parallel.f90 sourcefile~grid_fields.f90->sourcefile~grid_field_param.f90 sourcefile~grid_field_param.f90->sourcefile~common_param.f90 sourcefile~grid_field_param.f90->sourcefile~mpi_var.f90 sourcefile~grid_field_param.f90->sourcefile~grid_param.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~start_all.f90~~AfferentGraph sourcefile~start_all.f90 start_all.F90 sourcefile~aladyn.f90 ALaDyn.F90 sourcefile~aladyn.f90->sourcefile~start_all.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules start_all Source Code start_all.F90 Source Code !*****************************************************************************************************! !                            Copyright 2008-2020  The ALaDyn Collaboration                            ! !*****************************************************************************************************! !*****************************************************************************************************! !  This file is part of ALaDyn.                                                                       ! !                                                                                                     ! !  ALaDyn is free software: you can redistribute it and/or modify                                     ! !  it under the terms of the GNU General Public License as published by                               ! !  the Free Software Foundation, either version 3 of the License, or                                  ! !  (at your option) any later version.                                                                ! !                                                                                                     ! !  ALaDyn is distributed in the hope that it will be useful,                                          ! !  but WITHOUT ANY WARRANTY; without even the implied warranty of                                     ! !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                                      ! !  GNU General Public License for more details.                                                       ! !                                                                                                     ! !  You should have received a copy of the GNU General Public License                                  ! !  along with ALaDyn.  If not, see <http://www.gnu.org/licenses/>.                                    ! !*****************************************************************************************************! module start_all use array_alloc use set_init_param use read_input use set_grid_param use ionize use pic_in use pic_dump use run_data_info use system_utilities implicit none contains !> Start subroutine. It reads the input file, initializes !> the variables and allocates the needed arrays before to start the !> simulation. subroutine Start integer :: iic , ncmp , n , i !enable loop to attach with gdb only if really needed !WARNING if enabled with no need, the program sleeps at start without doing anything! !To enable the flag, uncomment the corresponding line in CMakeLists.txt #ifdef ENABLE_GDB_ATTACH call gdbattach #endif call read_main_input call check_grid_size call set_initial_param !Read parameters from input.nml file call start_parallel ( nd2 , nsp , nsb ) if ( mpi_err > 0 ) then if ( pe0 ) write ( 6 , * ) ' ERROR in mpi domain decomposition' call End_parallel stop end if if ( mod ( nx , nprocx ) /= 0 ) then if ( pe0 ) write ( 6 , * ) ' ===================================================' if ( pe0 ) write ( 6 , * ) ' WARNING: Number of cells in the X direction is not ' if ( pe0 ) write ( 6 , * ) ' an integer multiple of the number of cores requested.' if ( pe0 ) write ( 6 , * ) ' ===================================================' end if if ( ndim > 1 ) then if ( mod ( ny , nprocy ) /= 0 ) then if ( pe0 ) write ( 6 , * ) ' ===================================================' if ( pe0 ) write ( 6 , * ) ' WARNING: Number of cells in the Y direction is not ' if ( pe0 ) write ( 6 , * ) ' an integer multiple of the number of cores requested.' if ( pe0 ) write ( 6 , * ) ' ===================================================' end if end if if ( ndim > 2 ) then if ( mod ( nz , nprocz ) /= 0 ) then if ( pe0 ) write ( 6 , * ) ' ===================================================' if ( pe0 ) write ( 6 , * ) ' WARNING: Number of cells in the Z direction is not ' if ( pe0 ) write ( 6 , * ) ' an integer multiple of the number of cores requested.' if ( pe0 ) write ( 6 , * ) ' ===================================================' end if end if !sets parameters related to initial condition !=== Ascii art generated on http://patorjk.com/software/taag using the Star Wars font === if ( pe0 ) then write ( 6 , * ) '    ___   _          ______              _____  _____ ' write ( 6 , * ) '   / _ \\ | |         |  _  \\            |____ ||  _  |' write ( 6 , * ) '  / /_\\ \\| |     __ _| | | |_   _ _ __      / /| |/| |' write ( 6 , * ) '  |  _  || |    / _  | | | | | | |  _ \\     \\ \\|  /| |' write ( 6 , * ) '  | | | || |___| (_| | |/ /| |_| | | | |.___/ /\\ |_/ /' write ( 6 , * ) '  \\_| |_/\\_____/\\__,_|___/  \\__, |_| |_|\\____(_)\\___/ ' write ( 6 , * ) '                             __/ |                    ' write ( 6 , * ) '                            |___/                     ' end if if ( pe0 ) then write ( 6 , * ) '======================================================' write ( 6 , '(a33,i1,a1,i2,a17)' ) ' =               Code version    ' , & major_version , '.' , minor_version , '                =' write ( 6 , * ) '======================================================' call create_initial_folders call write_read_nml end if !call set_grid() to define global grid and grid !parameters call mpi_loc_grid ( nx_loc , ny_loc , nz_loc , nprocx , nprocy , nprocz ) call set_fyzxgrid ( npe_yloc , npe_zloc , npe_xloc , sh_ix ) if ( stretch ) call set_str_ind ( npe_yloc , npe_zloc , ndim ) call set_loc_grid_param call set_output_grid ( jump , nprocx , nprocy , nprocz ) if ( inject_beam ) then call set_ftgrid ( stretch , nprocx , nprocy , nprocz ) if ( pe0 ) then if ( stretch ) then open ( 10 , file = 'beam_overset_grid.dat' ) write ( 10 , * ) 'str to uniform grid' , ny , n2ft , n2ft_loc , nz , n3ft , n3ft_loc iic = 0 do i = 1 , ny_loc n = yft_ind ( i , iic ) write ( 10 , * ) i , n , loc_yg ( i , 1 , iic ), loc_yft ( n , iic ) end do do iic = 0 , nprocy / 2 - 1 n = loc_yftgrid ( iic )% ng write ( 10 , * ) 'pey' , iic write ( 10 , * ) n , 4 * n write ( 10 , * ) loc_ygrid ( iic )% gmin , loc_ygrid ( iic )% gmax write ( 10 , * ) loc_yftgrid ( iic )% gmin , loc_yftgrid ( iic + 3 )% gmax write ( 10 , * ) loc_yft ( 1 , iic ), loc_yft ( 4 * n , iic ) write ( 10 , * ) '====================' end do iic = nprocy / 2 n = loc_yftgrid ( iic )% ng write ( 10 , * ) 'pey' , iic write ( 10 , * ) n , 4 * n write ( 10 , * ) loc_ygrid ( iic )% gmin , loc_ygrid ( iic )% gmax write ( 10 , * ) loc_yftgrid ( iic - 1 )% gmin , loc_yftgrid ( iic + 2 )% gmax write ( 10 , * ) loc_yft ( 1 , iic ), loc_yft ( 4 * n , iic ) write ( 10 , * ) '====================' iic = nprocy / 2 + 1 n = loc_yftgrid ( iic )% ng write ( 10 , * ) 'pey' , iic write ( 10 , * ) n , 4 * n write ( 10 , * ) loc_ygrid ( iic )% gmin , loc_ygrid ( iic )% gmax write ( 10 , * ) loc_yftgrid ( iic - 2 )% gmin , loc_yftgrid ( iic + 1 )% gmax write ( 10 , * ) loc_yft ( 1 , iic ), loc_yft ( 4 * n , iic ) write ( 10 , * ) '====================' do iic = nprocy / 2 + 2 , nprocy - 1 n = loc_yftgrid ( iic )% ng write ( 10 , * ) 'pey' , iic write ( 10 , * ) n , 4 * n write ( 10 , * ) loc_ygrid ( iic )% gmin , loc_ygrid ( iic )% gmax write ( 10 , * ) loc_yftgrid ( iic - 3 )% gmin , loc_yftgrid ( iic )% gmax write ( 10 , * ) loc_yft ( 1 , iic ), loc_yft ( 4 * n , iic ) write ( 10 , * ) '====================' end do close ( 10 ) endif endif endif !Exit !loc_xgrid(nprocx),loc_ygrid(nprocy),loc_ygrid(nprocz) local grid data !local grid parameters and !coordinate struct  loc_xg,loc_yg,loc_zg !====================================== call set_field_param !defines (nhx(nprocx), nhy(nprocy),nhz(nprocz) arrays of grid points mem_size = 0 mem_psize = 0 if ( nvout > nfield ) nvout = nfield ! for output data !allocates wdata() and gwdata() !===================== ncmp = nfield ! Allocates basic arrays, defines grid parameters, boundary index etc call v_alloc ( nxp , nyp , nzp , nfield , nj_dim , ndim , ibeam , lpf_ord , & der_ord , envelope , Two_color , comoving , mem_size ) if ( hybrid ) then call fluid_alloc ( nxp , nyp , nzp , nfcomp , ndim , lpf_ord , mem_size ) ncmp = max ( ncmp , nfcomp ) end if call mpi_buffer_alloc ( nx_loc , ny_loc , nz_loc , ncmp ) !local arrays and coefficients for space derivatives diag = . true . if ( iene == 0 ) then diag = . false . iene = 1 end if tpart = . false . inject_ind = - 1 !======================== write_every = 100 !============ if ( ionization ) then do iic = 2 , nsp_ionz call set_field_ioniz_wfunction ( ion_min ( iic - 1 ), atomic_number ( iic - 1 ), & iic , ionz_lev , ionz_model , lp_max , dt ) end do if ( pe0 ) call ioniz_data ( lp_max , ion_min , atomic_number , ionz_lev , & ionz_model ) end if !     Extended local grid select case ( new_sim ) !====== Fields and current arrays allocated on [1: N_loc+5] case ( 0 ) iout = id_new ienout = 0 call init tstart = 0.0 last_iter = 0 tdia = tstart tout = tstart dt_loc = dt iter_max = 1 dtout = ( tmax - tstart ) / nouts dtdia = ( tmax - tstart ) / iene if ( tmax > 0.0 ) then iter_max = int ( tmax / dt ) dt_loc = tmax / float ( iter_max ) end if if ( iter_max < 1000 ) write_every = nint ( 0.1 * iter_max ) if ( pe0 ) write ( * , * ) 'write_every param =' , write_every case ( 1 ) if (. not . l_first_output_on_restart ) then iout = id_new ienout = 0 else iout = id_new + 1 ienout = 0 end if call restart ( last_iter , tstart ) call MPI_BARRIER ( comm , error ) call set_fxgrid ( npe_xloc , sh_ix ) if ( tmax > 0.0 ) then iter_max = int ( tmax / dt ) dt_loc = tmax / float ( iter_max ) end if if ( iter_max < 1000 ) write_every = nint ( 0.1 * iter_max ) dtout = tmax / nouts dtdia = tmax / iene tmax = tmax + tstart if (. not . l_first_output_on_restart ) then tdia = tstart + dtdia tout = tstart + dtout else tdia = tstart tout = tstart end if ! to count outputs in energy-data (iene+1 times) end select contains ! in general data (nouts+1 times) subroutine check_grid_size if ( mod ( nx , 2 ) /= 0 ) then write ( 6 , * ) ' Wrong x dimension' stop end if if ( ny == 0 ) then write ( 6 , * ) ' Wrong y dimension' stop end if if ( ny > 1 ) then if ( mod ( ny , 2 ) /= 0 ) then write ( 6 , * ) ' Wrong y dimension' stop end if end if end subroutine end subroutine ! reads from dump evolved data !============================= end module","tags":"","loc":"sourcefile/start_all.f90.html"},{"title":"species – ALaDyn ","text":"type, public :: species Contents Variables part Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: part (:,:)","tags":"","loc":"type/species.html"},{"title":"grid – ALaDyn ","text":"type, public :: grid Contents Variables ng p_ind gmin gmax min_cell max_cell Components Type Visibility Attributes Name Initial integer, public :: ng Number of cells in a given direction of the grid integer, public :: p_ind (2) Minimum and maximum cell number of the grid real(kind=dp), public :: gmin Value of the corresponding axis at the minimum cell real(kind=dp), public :: gmax Value of the corresponding axis at the maximum cell integer, public :: min_cell Initial cell of the grid in absolute units (i.e. respect to the total grid) integer, public :: max_cell Final cell of the grid in absolute units (i.e. respect to the total grid)","tags":"","loc":"type/grid.html"},{"title":"sgrid – ALaDyn ","text":"type, public :: sgrid Contents Variables sind smin smax Components Type Visibility Attributes Name Initial integer, public :: sind (2) Initial and final stretched cell (sind(1) also coincides with the number of\nstretched cells) real(kind=dp), public :: smin Axis value on the boundary between stretched and unstretched grid (left side of the box) real(kind=dp), public :: smax Axis value on the boundary between stretched and unstretched grid (right side of the box)","tags":"","loc":"type/sgrid.html"},{"title":"index_array – ALaDyn ","text":"type, public :: index_array Type defining an array of consecutive integer numbers, useful as\n indices in arrays. Contents Variables indices Constructor index_array Type-Bound Procedures find_index Components Type Visibility Attributes Name Initial integer, public, allocatable :: indices (:) Constructor public interface index_array public function new_index_array (length) result(this) Constructor for the index_array type Arguments Type Intent Optional Attributes Name integer, intent(in) :: length Return Value type( index_array ) Type-Bound Procedures procedure, public :: find_index public subroutine find_index (index_in, mask) Type bound procedure that finds and pack all the array indices\n according to the given mask Arguments Type Intent Optional Attributes Name class( index_array ), intent(inout) :: index_in logical, intent(in) :: mask (:)","tags":"","loc":"type/index_array.html"},{"title":"str_params – ALaDyn ","text":"type, private :: str_params Contents Variables const smin smax nl_stretch xs dli_inv ratio dl_inv init_cell Components Type Visibility Attributes Name Initial real(kind=dp), public :: const real(kind=dp), public :: smin real(kind=dp), public :: smax real(kind=dp), public :: nl_stretch real(kind=dp), public :: xs real(kind=dp), public :: dli_inv real(kind=dp), public :: ratio real(kind=dp), public :: dl_inv real(kind=dp), public :: init_cell","tags":"","loc":"type/str_params.html"},{"title":"fftw_iodim – ALaDyn ","text":"type, public, bind(C) :: fftw_iodim Contents Variables n is os Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os","tags":"","loc":"type/fftw_iodim.html"},{"title":"fftw_iodim64 – ALaDyn ","text":"type, public, bind(C) :: fftw_iodim64 Contents Variables n is os Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os","tags":"","loc":"type/fftw_iodim64.html"},{"title":"fftwf_iodim – ALaDyn ","text":"type, public, bind(C) :: fftwf_iodim Contents Variables n is os Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os","tags":"","loc":"type/fftwf_iodim.html"},{"title":"fftwf_iodim64 – ALaDyn ","text":"type, public, bind(C) :: fftwf_iodim64 Contents Variables n is os Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os","tags":"","loc":"type/fftwf_iodim64.html"},{"title":"fftw_iodim – ALaDyn ","text":"type, public, bind(C) :: fftw_iodim Contents Variables n is os Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os","tags":"","loc":"type/fftw_iodim~2.html"},{"title":"fftw_iodim64 – ALaDyn ","text":"type, public, bind(C) :: fftw_iodim64 Contents Variables n is os Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os","tags":"","loc":"type/fftw_iodim64~2.html"},{"title":"fftwf_iodim – ALaDyn ","text":"type, public, bind(C) :: fftwf_iodim Contents Variables n is os Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os","tags":"","loc":"type/fftwf_iodim~2.html"},{"title":"fftwf_iodim64 – ALaDyn ","text":"type, public, bind(C) :: fftwf_iodim64 Contents Variables n is os Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os","tags":"","loc":"type/fftwf_iodim64~2.html"},{"title":"Lp_cycle – ALaDyn","text":"subroutine Lp_cycle() LP_CYCLE: collects the Laser-plasma dynamics evolved as a standard PIC. Arguments None Calls proc~~lp_cycle~~CallsGraph proc~lp_cycle Lp_cycle proc~data_out data_out proc~lp_cycle->proc~data_out proc~lp_run lp_run proc~lp_cycle->proc~lp_run proc~error_message error_message proc~lp_cycle->proc~error_message proc~timing timing proc~lp_cycle->proc~timing proc~part_pdata_out part_pdata_out proc~data_out->proc~part_pdata_out create_timestep_folder create_timestep_folder proc~data_out->create_timestep_folder proc~env_two_fields_out env_two_fields_out proc~data_out->proc~env_two_fields_out proc~fields_out fields_out proc~data_out->proc~fields_out proc~prl_den_energy_interp prl_den_energy_interp proc~data_out->proc~prl_den_energy_interp proc~env_fields_out env_fields_out proc~data_out->proc~env_fields_out proc~fields_out_new fields_out_new proc~data_out->proc~fields_out_new proc~fluid_den_mom_out fluid_den_mom_out proc~data_out->proc~fluid_den_mom_out proc~den_energy_out den_energy_out proc~data_out->proc~den_energy_out proc~envar Envar proc~data_out->proc~envar proc~lpf2_evolve lpf2_evolve proc~lp_run->proc~lpf2_evolve proc~comoving_coordinate comoving_coordinate proc~lp_run->proc~comoving_coordinate proc~lp_window_xshift lp_window_xshift proc~lp_run->proc~lp_window_xshift proc~part_numbers Part_numbers proc~timing->proc~part_numbers proc~max_pmemory_check Max_pmemory_check proc~timing->proc~max_pmemory_check proc~tot_num_part tot_num_part proc~timing->proc~tot_num_part loc_npart loc_npart proc~part_pdata_out->loc_npart proc~endian endian proc~part_pdata_out->proc~endian proc~intvec_distribute intvec_distribute proc~part_pdata_out->proc~intvec_distribute proc~mpi_write_part mpi_write_part proc~part_pdata_out->proc~mpi_write_part proc~pfields_prepare pfields_prepare proc~lpf2_evolve->proc~pfields_prepare ion_min ion_min proc~lpf2_evolve->ion_min proc~lpf2_evolve->loc_npart ebfp ebfp proc~lpf2_evolve->ebfp proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~lpf2_evolve->proc~update_adam_bash_fluid_variables proc~advance_lpf_fields advance_lpf_fields proc~lpf2_evolve->proc~advance_lpf_fields proc~set_momentum_density_flux set_momentum_density_flux proc~lpf2_evolve->proc~set_momentum_density_flux init_random_seed init_random_seed proc~lpf2_evolve->init_random_seed atomic_number atomic_number proc~lpf2_evolve->atomic_number jc jc proc~lpf2_evolve->jc proc~fluid_curr_accumulate fluid_curr_accumulate proc~lpf2_evolve->proc~fluid_curr_accumulate spec spec proc~lpf2_evolve->spec proc~part_numbers->loc_npart proc~part_numbers->proc~intvec_distribute proc~exchange_pdata exchange_pdata proc~env_two_fields_out->proc~exchange_pdata proc~fields_out->proc~endian proc~fields_out->proc~exchange_pdata proc~prl_den_energy_interp->loc_npart env env proc~prl_den_energy_interp->env proc~den_zyxbd den_zyxbd proc~prl_den_energy_interp->proc~den_zyxbd loc_zg loc_zg proc~prl_den_energy_interp->loc_zg loc_yg loc_yg proc~prl_den_energy_interp->loc_yg mass mass proc~prl_den_energy_interp->mass proc~prl_den_energy_interp->jc proc~prl_den_energy_interp->spec proc~cell_part_dist cell_part_dist proc~comoving_coordinate->proc~cell_part_dist proc~particles_inject particles_inject proc~comoving_coordinate->proc~particles_inject proc~env_fields_out->proc~exchange_pdata proc~allreduce_dpreal allreduce_dpreal proc~max_pmemory_check->proc~allreduce_dpreal proc~lp_window_xshift->proc~part_numbers proc~fluid_left_xshift fluid_left_xshift proc~lp_window_xshift->proc~fluid_left_xshift proc~fields_left_xshift fields_left_xshift proc~lp_window_xshift->proc~fields_left_xshift proc~lp_window_xshift->proc~cell_part_dist proc~lp_window_xshift->proc~particles_inject proc~tot_num_part->loc_npart proc~fields_out_new->proc~endian proc~mpi_write_field mpi_write_field proc~fields_out_new->proc~mpi_write_field proc~fluid_den_mom_out->proc~endian proc~fluid_den_mom_out->proc~exchange_pdata proc~den_energy_out->proc~endian proc~den_energy_out->proc~exchange_pdata proc~envar->loc_npart proc~enb_bunch enb_bunch proc~envar->proc~enb_bunch proc~envar->mass proc~envar->proc~allreduce_dpreal proc~envelope_struct_data envelope_struct_data proc~envar->proc~envelope_struct_data proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~pfields_prepare->proc~fill_ebfield_yzxbdsdata proc~field_xyzbd field_xyzbd proc~pfields_prepare->proc~field_xyzbd mpi_send mpi_send proc~intvec_distribute->mpi_send mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open proc~exchange_bdx_data exchange_bdx_data proc~fluid_left_xshift->proc~exchange_bdx_data proc~fields_left_xshift->proc~exchange_bdx_data proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata lorentz_fact lorentz_fact proc~update_adam_bash_fluid_variables->lorentz_fact proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~field_xyzbd unit_charge unit_charge proc~update_adam_bash_fluid_variables->unit_charge proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~field_xadvect field_xadvect proc~advance_lpf_fields->proc~field_xadvect proc~rotb rotb proc~advance_lpf_fields->proc~rotb proc~rote rote proc~advance_lpf_fields->proc~rote proc~ef_bds ef_bds proc~advance_lpf_fields->proc~ef_bds proc~bf_bds bf_bds proc~advance_lpf_fields->proc~bf_bds proc~cell_part_dist->loc_npart proc~cell_part_dist->ebfp proc~cell_part_dist->spec proc~v_realloc v_realloc proc~cell_part_dist->proc~v_realloc proc~mpi_write_field->mpi_file_set_view proc~mpi_write_field->mpi_file_write proc~mpi_write_field->mpi_file_close proc~mpi_write_field->mpi_file_open proc~enb_bunch->loc_npart proc~enb_bunch->proc~allreduce_dpreal proc~bunch_corr bunch_corr proc~enb_bunch->proc~bunch_corr proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate->proc~field_xyzbd proc~fluid_curr_accumulate->unit_charge proc~particles_inject->loc_npart v_realloc v_realloc proc~particles_inject->v_realloc proc~add_particles add_particles proc~particles_inject->proc~add_particles mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce proc~envelope_struct_data->proc~allreduce_dpreal proc~bunch_corr->proc~allreduce_dpreal proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 proc~rotb->loc_zg proc~rotb->loc_yg proc~rote->loc_zg proc~rote->loc_yg proc~ef_bds->loc_zg proc~ef_bds->loc_yg loc_zgrid loc_zgrid proc~ef_bds->loc_zgrid loc_xg loc_xg proc~ef_bds->loc_xg proc~nc_fluid_density_momenta->loc_zg proc~nc_fluid_density_momenta->loc_yg proc~init_random_seed init_random_seed proc~add_particles->proc~init_random_seed proc~gasdev gasdev proc~add_particles->proc~gasdev proc~bf_bds->loc_zg proc~bf_bds->loc_yg proc~bf_bds->loc_xg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~lp_cycle~~CalledByGraph proc~lp_cycle Lp_cycle program~aladyn aladyn program~aladyn->proc~lp_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/lp_cycle.html"},{"title":"Env_cycle – ALaDyn","text":"subroutine Env_cycle() Arguments None Calls proc~~env_cycle~~CallsGraph proc~env_cycle Env_cycle proc~timing timing proc~env_cycle->proc~timing proc~part_numbers Part_numbers proc~env_cycle->proc~part_numbers proc~error_message error_message proc~env_cycle->proc~error_message proc~data_out data_out proc~env_cycle->proc~data_out proc~env_run env_run proc~env_cycle->proc~env_run proc~beam_inject beam_inject proc~env_cycle->proc~beam_inject proc~timing->proc~part_numbers proc~max_pmemory_check Max_pmemory_check proc~timing->proc~max_pmemory_check proc~tot_num_part tot_num_part proc~timing->proc~tot_num_part loc_npart loc_npart proc~part_numbers->loc_npart proc~intvec_distribute intvec_distribute proc~part_numbers->proc~intvec_distribute proc~part_pdata_out part_pdata_out proc~data_out->proc~part_pdata_out proc~env_two_fields_out env_two_fields_out proc~data_out->proc~env_two_fields_out proc~fields_out fields_out proc~data_out->proc~fields_out proc~envar Envar proc~data_out->proc~envar create_timestep_folder create_timestep_folder proc~data_out->create_timestep_folder proc~env_fields_out env_fields_out proc~data_out->proc~env_fields_out proc~fields_out_new fields_out_new proc~data_out->proc~fields_out_new proc~fluid_den_mom_out fluid_den_mom_out proc~data_out->proc~fluid_den_mom_out proc~den_energy_out den_energy_out proc~data_out->proc~den_energy_out proc~prl_den_energy_interp prl_den_energy_interp proc~data_out->proc~prl_den_energy_interp proc~comoving_coordinate comoving_coordinate proc~env_run->proc~comoving_coordinate proc~lp_window_xshift lp_window_xshift proc~env_run->proc~lp_window_xshift proc~env_lpf2_evolve env_lpf2_evolve proc~env_run->proc~env_lpf2_evolve loc_nbpart loc_nbpart proc~beam_inject->loc_nbpart pot pot proc~beam_inject->pot proc~beam_data beam_data proc~beam_inject->proc~beam_data proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~beam_inject->proc~fill_ebfield_yzxbdsdata proc~mpi_beam_ftgrid_distribute mpi_beam_ftgrid_distribute proc~beam_inject->proc~mpi_beam_ftgrid_distribute proc~beam_inject->loc_npart lp_end lp_end proc~beam_inject->lp_end ebf ebf proc~beam_inject->ebf proc~mpi_beam_distribute mpi_beam_distribute proc~beam_inject->proc~mpi_beam_distribute ebfp ebfp proc~beam_inject->ebfp ebf_bunch ebf_bunch proc~beam_inject->ebf_bunch proc~initial_beam_fields initial_beam_fields proc~beam_inject->proc~initial_beam_fields proc~p_alloc p_alloc proc~beam_inject->proc~p_alloc proc~init_random_seed init_random_seed proc~beam_inject->proc~init_random_seed jc jc proc~beam_inject->jc ebfb ebfb proc~beam_inject->ebfb spec spec proc~beam_inject->spec bunch bunch proc~beam_inject->bunch proc~part_pdata_out->loc_npart proc~part_pdata_out->proc~intvec_distribute proc~mpi_write_part mpi_write_part proc~part_pdata_out->proc~mpi_write_part proc~endian endian proc~part_pdata_out->proc~endian proc~exchange_pdata exchange_pdata proc~env_two_fields_out->proc~exchange_pdata proc~fields_out->proc~exchange_pdata proc~fields_out->proc~endian proc~beam_data->ebfb exchange_2d_grdata exchange_2d_grdata proc~beam_data->exchange_2d_grdata unit_charge unit_charge proc~beam_data->unit_charge proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~mpi_beam_ftgrid_distribute->loc_nbpart proc~mpi_beam_ftgrid_distribute->ebfb proc~mpi_beam_ftgrid_distribute->bunch proc~cell_part_dist cell_part_dist proc~comoving_coordinate->proc~cell_part_dist proc~particles_inject particles_inject proc~comoving_coordinate->proc~particles_inject proc~lp_window_xshift->proc~part_numbers proc~fluid_left_xshift fluid_left_xshift proc~lp_window_xshift->proc~fluid_left_xshift proc~fields_left_xshift fields_left_xshift proc~lp_window_xshift->proc~fields_left_xshift proc~lp_window_xshift->proc~cell_part_dist proc~lp_window_xshift->proc~particles_inject mpi_send mpi_send proc~intvec_distribute->mpi_send mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast proc~mpi_beam_distribute->loc_nbpart proc~mpi_beam_distribute->ebfb proc~mpi_beam_distribute->bunch proc~envar->loc_npart proc~enb_bunch enb_bunch proc~envar->proc~enb_bunch mass mass proc~envar->mass proc~allreduce_dpreal allreduce_dpreal proc~envar->proc~allreduce_dpreal proc~envelope_struct_data envelope_struct_data proc~envar->proc~envelope_struct_data proc~env_fields_out->proc~exchange_pdata proc~max_pmemory_check->proc~allreduce_dpreal loc_zg loc_zg proc~initial_beam_fields->loc_zg loc_yg loc_yg proc~initial_beam_fields->loc_yg proc~env_lpf2_evolve->loc_npart proc~env_lpf2_evolve->ebfp proc~env_lpf2_evolve->proc~init_random_seed proc~env_lpf2_evolve->jc proc~env_lpf2_evolve->spec proc~advance_lpf_envelope advance_lpf_envelope proc~env_lpf2_evolve->proc~advance_lpf_envelope ion_min ion_min proc~env_lpf2_evolve->ion_min proc~env_fields_average env_fields_average proc~env_lpf2_evolve->proc~env_fields_average proc~env_two_fields_average env_two_fields_average proc~env_lpf2_evolve->proc~env_two_fields_average proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables enable_ionization enable_ionization proc~env_lpf2_evolve->enable_ionization flux flux proc~env_lpf2_evolve->flux proc~advance_lpf_fields advance_lpf_fields proc~env_lpf2_evolve->proc~advance_lpf_fields proc~set_env_momentum_density_flux set_env_momentum_density_flux proc~env_lpf2_evolve->proc~set_env_momentum_density_flux proc~env_den_collect env_den_collect proc~env_lpf2_evolve->proc~env_den_collect proc~env_amp_two_fields_prepare env_amp_two_fields_prepare proc~env_lpf2_evolve->proc~env_amp_two_fields_prepare proc~curr_mpi_collect curr_mpi_collect proc~env_lpf2_evolve->proc~curr_mpi_collect atomic_number atomic_number proc~env_lpf2_evolve->atomic_number proc~env_amp_prepare env_amp_prepare proc~env_lpf2_evolve->proc~env_amp_prepare set_env_density set_env_density proc~env_lpf2_evolve->set_env_density proc~fluid_curr_accumulate fluid_curr_accumulate proc~env_lpf2_evolve->proc~fluid_curr_accumulate proc~mpi_write_field mpi_write_field proc~fields_out_new->proc~mpi_write_field proc~fields_out_new->proc~endian proc~fluid_den_mom_out->proc~exchange_pdata proc~fluid_den_mom_out->proc~endian proc~tot_num_part->loc_npart proc~den_energy_out->proc~exchange_pdata proc~den_energy_out->proc~endian proc~prl_den_energy_interp->loc_npart proc~prl_den_energy_interp->jc proc~prl_den_energy_interp->spec env env proc~prl_den_energy_interp->env proc~den_zyxbd den_zyxbd proc~prl_den_energy_interp->proc~den_zyxbd proc~prl_den_energy_interp->loc_zg proc~prl_den_energy_interp->loc_yg proc~prl_den_energy_interp->mass proc~advance_lpf_envelope->proc~fill_ebfield_yzxbdsdata proc~env_maxw_solve env_maxw_solve proc~advance_lpf_envelope->proc~env_maxw_solve proc~env_bds env_bds proc~advance_lpf_envelope->proc~env_bds proc~env_lpf_solve env_lpf_solve proc~advance_lpf_envelope->proc~env_lpf_solve env_grad env_grad proc~env_fields_average->env_grad mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open proc~fluid_left_xshift->proc~exchange_bdx_data proc~fields_left_xshift->proc~exchange_bdx_data proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata proc~update_adam_bash_fluid_variables->unit_charge lorentz_fact lorentz_fact proc~update_adam_bash_fluid_variables->lorentz_fact proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta proc~field_xyzbd field_xyzbd proc~update_adam_bash_fluid_variables->proc~field_xyzbd proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~field_xadvect field_xadvect proc~advance_lpf_fields->proc~field_xadvect proc~rotb rotb proc~advance_lpf_fields->proc~rotb proc~rote rote proc~advance_lpf_fields->proc~rote proc~ef_bds ef_bds proc~advance_lpf_fields->proc~ef_bds proc~bf_bds bf_bds proc~advance_lpf_fields->proc~bf_bds proc~env_den_collect->loc_zg proc~env_den_collect->loc_yg fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~env_den_collect->fill_curr_yzxbdsdata den_zyxbd den_zyxbd proc~env_den_collect->den_zyxbd proc~env_amp_two_fields_prepare->env_grad proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~curr_mpi_collect->proc~fill_curr_yzxbdsdata proc~jc_xyzbd jc_xyzbd proc~curr_mpi_collect->proc~jc_xyzbd djc djc proc~curr_mpi_collect->djc proc~cell_part_dist->loc_npart proc~cell_part_dist->ebfp proc~cell_part_dist->spec proc~v_realloc v_realloc proc~cell_part_dist->proc~v_realloc proc~env_amp_prepare->env_grad proc~mpi_write_field->mpi_file_set_view proc~mpi_write_field->mpi_file_write proc~mpi_write_field->mpi_file_close proc~mpi_write_field->mpi_file_open proc~enb_bunch->loc_npart proc~enb_bunch->proc~allreduce_dpreal proc~bunch_corr bunch_corr proc~enb_bunch->proc~bunch_corr proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate->unit_charge proc~fluid_curr_accumulate->proc~field_xyzbd proc~particles_inject->loc_npart v_realloc v_realloc proc~particles_inject->v_realloc proc~add_particles add_particles proc~particles_inject->proc~add_particles mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce proc~envelope_struct_data->proc~allreduce_dpreal proc~bunch_corr->proc~allreduce_dpreal proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 proc~rotb->loc_zg proc~rotb->loc_yg proc~potential_lapl potential_lapl proc~env_maxw_solve->proc~potential_lapl proc~rote->loc_zg proc~rote->loc_yg proc~ef_bds->loc_zg proc~ef_bds->loc_yg loc_zgrid loc_zgrid proc~ef_bds->loc_zgrid loc_xg loc_xg proc~ef_bds->loc_xg proc~nc_fluid_density_momenta->loc_zg proc~nc_fluid_density_momenta->loc_yg proc~env_bds->loc_zg proc~env_bds->loc_yg proc~pp_lapl pp_lapl proc~env_lpf_solve->proc~pp_lapl proc~add_particles->proc~init_random_seed proc~gasdev gasdev proc~add_particles->proc~gasdev proc~bf_bds->loc_zg proc~bf_bds->loc_yg proc~bf_bds->loc_xg proc~pp_lapl->loc_zg proc~pp_lapl->loc_yg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_cycle~~CalledByGraph proc~env_cycle Env_cycle program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_cycle.html"},{"title":"data_out – ALaDyn","text":"subroutine data_out() Arguments None Calls proc~~data_out~~CallsGraph proc~data_out data_out proc~part_pdata_out part_pdata_out proc~data_out->proc~part_pdata_out create_timestep_folder create_timestep_folder proc~data_out->create_timestep_folder proc~env_two_fields_out env_two_fields_out proc~data_out->proc~env_two_fields_out proc~fields_out fields_out proc~data_out->proc~fields_out proc~prl_den_energy_interp prl_den_energy_interp proc~data_out->proc~prl_den_energy_interp proc~env_fields_out env_fields_out proc~data_out->proc~env_fields_out proc~fields_out_new fields_out_new proc~data_out->proc~fields_out_new proc~fluid_den_mom_out fluid_den_mom_out proc~data_out->proc~fluid_den_mom_out proc~den_energy_out den_energy_out proc~data_out->proc~den_energy_out proc~envar Envar proc~data_out->proc~envar proc~mpi_write_part mpi_write_part proc~part_pdata_out->proc~mpi_write_part loc_npart loc_npart proc~part_pdata_out->loc_npart proc~intvec_distribute intvec_distribute proc~part_pdata_out->proc~intvec_distribute proc~endian endian proc~part_pdata_out->proc~endian proc~exchange_pdata exchange_pdata proc~env_two_fields_out->proc~exchange_pdata proc~fields_out->proc~exchange_pdata proc~fields_out->proc~endian spec spec proc~prl_den_energy_interp->spec env env proc~prl_den_energy_interp->env loc_yg loc_yg proc~prl_den_energy_interp->loc_yg proc~prl_den_energy_interp->loc_npart proc~den_zyxbd den_zyxbd proc~prl_den_energy_interp->proc~den_zyxbd jc jc proc~prl_den_energy_interp->jc loc_zg loc_zg proc~prl_den_energy_interp->loc_zg mass mass proc~prl_den_energy_interp->mass proc~env_fields_out->proc~exchange_pdata proc~mpi_write_field mpi_write_field proc~fields_out_new->proc~mpi_write_field proc~fields_out_new->proc~endian proc~fluid_den_mom_out->proc~exchange_pdata proc~fluid_den_mom_out->proc~endian proc~den_energy_out->proc~exchange_pdata proc~den_energy_out->proc~endian proc~allreduce_dpreal allreduce_dpreal proc~envar->proc~allreduce_dpreal proc~envar->loc_npart proc~enb_bunch enb_bunch proc~envar->proc~enb_bunch proc~envar->mass proc~envelope_struct_data envelope_struct_data proc~envar->proc~envelope_struct_data mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce proc~mpi_write_field->mpi_file_close proc~mpi_write_field->mpi_file_open proc~mpi_write_field->mpi_file_set_view proc~mpi_write_field->mpi_file_write mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send proc~enb_bunch->proc~allreduce_dpreal proc~enb_bunch->loc_npart proc~bunch_corr bunch_corr proc~enb_bunch->proc~bunch_corr proc~envelope_struct_data->proc~allreduce_dpreal proc~bunch_corr->proc~allreduce_dpreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~data_out~~CalledByGraph proc~data_out data_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code data_out Source Code subroutine data_out integer :: i , iic , idata idata = iout if ( diag ) then if ( tnow >= tdia ) then ienout = ienout + 1 call Envar ( ienout ) tdia = tdia + dtdia if ( pe0 ) then write ( 6 , '(a10,i3,a10,e11.4)' ) ' rms data ' , ienout , & ' at time =' , tnow write ( 6 , * ) '==========================' endif end if end if if ( tnow >= tout ) then call create_timestep_folder ( iout ) tout = tout + dtout if ( diag ) then if ( pe0 ) call en_data ( ienout , iter , idata ) end if !================== if ( nvout > 0 ) then if ( mod_ord == 2 ) then if ( L_env_modulus ) then i = 0 call env_fields_out ( env , i ) if ( Two_color ) call env_fields_out ( env1 , - 1 ) !EXIT |A| else if ( Two_color ) then do i = 1 , 2 call env_two_fields_out ( env , env1 , i ) end do else do i = 1 , 2 call env_fields_out ( env , i ) !EXIT [Ar,Ai] end do end if end if end if do i = 1 , nvout if ( l_force_singlefile_output ) then call fields_out ( ebf , i , i ) !i to label field name else call fields_out_new ( ebf , i , i ) end if end do end if if ( nden > 0 ) then do i = 1 , nsp call prl_den_energy_interp ( i , nden ) do iic = 1 , min ( 2 , nden ) call den_energy_out ( i , iic , iic ) end do end do end if if ( hybrid ) then do i = 1 , nfcomp call fluid_den_mom_out ( up , i , nfcomp ) end do end if if ( ionization ) call part_ionz_out ( tnow ) if ( gam_min > 1. ) call part_high_gamma_out ( gam_min , tnow ) if ( npout > 0 ) then iic = npout if ( iic <= nsp ) then call part_pdata_out ( tnow , xp0_out , xp1_out , yp_out , iic , pjump ) else do i = 1 , nsp call part_pdata_out ( tnow , xp0_out , xp1_out , yp_out , i , pjump ) end do end if end if call CPU_TIME ( unix_time_now ) if ( pe0 ) then write ( 6 , '(a10,i6,a10,e11.4,a10,e11.4)' ) 'iter = ' , iter , ' t = ' , & tnow , ' dt = ' , dt_loc write ( 6 , * ) ' END DATA WRITE' write ( 6 , '(a16,f12.3)' ) ' Time elapsed = ' , & unix_time_now - unix_time_begin end if if ( dump > 0 . and . time_interval_dumps < 0.0 ) then if ( iter > 0 ) call dump_data ( iter , tnow ) endif iout = iout + 1 end if call CPU_TIME ( unix_time_now ) !if((unix_time_now - unix_time_last_dump) > time_interval_dumps .and. time_interval_dumps > 0.0) then ! call dump_data(iter,tnow) !endif end subroutine data_out","tags":"","loc":"proc/data_out.html"},{"title":"set_field_ioniz_wfunction – ALaDyn","text":"public subroutine set_field_ioniz_wfunction(z0, zm, loc_ion, nz_lev, nz_model, e_max, dt_in) Arguments Type Intent Optional Attributes Name integer, intent(in) :: z0 integer, intent(in) :: zm integer, intent(in) :: loc_ion integer, intent(in) :: nz_lev integer, intent(in) :: nz_model real(kind=dp), intent(in) :: e_max real(kind=dp), optional :: dt_in Contents None","tags":"","loc":"proc/set_field_ioniz_wfunction.html"},{"title":"ionization_electrons_inject – ALaDyn","text":"private subroutine ionization_electrons_inject(ion_ch_inc, ic, np, np_el, new_np_el) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ion_ch_inc (:) integer, intent(in) :: ic integer, intent(in) :: np integer, intent(inout) :: np_el integer, intent(in) :: new_np_el Calls proc~~ionization_electrons_inject~~CallsGraph proc~ionization_electrons_inject ionization_electrons_inject spec spec proc~ionization_electrons_inject->spec proc~gasdev gasdev proc~ionization_electrons_inject->proc~gasdev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ionization_electrons_inject~~CalledByGraph proc~ionization_electrons_inject ionization_electrons_inject proc~ionization_cycle ionization_cycle proc~ionization_cycle->proc~ionization_electrons_inject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ionization_electrons_inject.html"},{"title":"env_ionization_electrons_inject – ALaDyn","text":"private subroutine env_ionization_electrons_inject(sp_field, ion_ch_inc, ic, np, np_el, new_np_el) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sp_field (:,:) integer, intent(in) :: ion_ch_inc (:) integer, intent(in) :: ic integer, intent(in) :: np integer, intent(inout) :: np_el integer, intent(in) :: new_np_el Calls proc~~env_ionization_electrons_inject~~CallsGraph proc~env_ionization_electrons_inject env_ionization_electrons_inject spec spec proc~env_ionization_electrons_inject->spec proc~gasdev gasdev proc~env_ionization_electrons_inject->proc~gasdev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_ionization_electrons_inject~~CalledByGraph proc~env_ionization_electrons_inject env_ionization_electrons_inject proc~ionization_cycle ionization_cycle proc~ionization_cycle->proc~env_ionization_electrons_inject Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_ionization_electrons_inject.html"},{"title":"part_ionize – ALaDyn","text":"private subroutine part_ionize(sp_loc, amp_aux, np, ic, new_np_el, ion_ch_inc) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: amp_aux (:,:) integer, intent(in) :: np integer, intent(in) :: ic integer, intent(inout) :: new_np_el integer, intent(inout) :: ion_ch_inc (:) Called by proc~~part_ionize~~CalledByGraph proc~part_ionize part_ionize proc~ionization_cycle ionization_cycle proc~ionization_cycle->proc~part_ionize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_ionize.html"},{"title":"ionization_cycle – ALaDyn","text":"public subroutine ionization_cycle(sp_loc, sp_aux, np, ic, itloc, mom_id, def_inv) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: sp_aux (:,:) integer, intent(in) :: np integer, intent(in) :: ic integer, intent(in) :: itloc integer, intent(in) :: mom_id real(kind=dp), intent(in) :: def_inv Calls proc~~ionization_cycle~~CallsGraph proc~ionization_cycle ionization_cycle proc~env_ionization_electrons_inject env_ionization_electrons_inject proc~ionization_cycle->proc~env_ionization_electrons_inject proc~v_realloc v_realloc proc~ionization_cycle->proc~v_realloc proc~part_ionize part_ionize proc~ionization_cycle->proc~part_ionize ebfp ebfp proc~ionization_cycle->ebfp proc~ionization_electrons_inject ionization_electrons_inject proc~ionization_cycle->proc~ionization_electrons_inject spec spec proc~ionization_cycle->spec proc~env_ionization_electrons_inject->spec proc~gasdev gasdev proc~env_ionization_electrons_inject->proc~gasdev proc~ionization_electrons_inject->spec proc~ionization_electrons_inject->proc~gasdev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ionization_cycle.html"},{"title":"set_atomic_weight – ALaDyn","text":"public subroutine set_atomic_weight(at_number, w_number) Arguments Type Intent Optional Attributes Name integer, intent(in) :: at_number real(kind=dp), intent(out) :: w_number Contents None","tags":"","loc":"proc/set_atomic_weight.html"},{"title":"set_atoms_per_molecule – ALaDyn","text":"public subroutine set_atoms_per_molecule(at_number, n_mol_atoms) Arguments Type Intent Optional Attributes Name integer, intent(in) :: at_number integer, intent(inout) :: n_mol_atoms Contents None","tags":"","loc":"proc/set_atoms_per_molecule.html"},{"title":"set_ionization_coeff – ALaDyn","text":"public subroutine set_ionization_coeff(an, sp_ionz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: an (:) integer, intent(in) :: sp_ionz Contents None","tags":"","loc":"proc/set_ionization_coeff.html"},{"title":"set_impact_ioniz_wfunction – ALaDyn","text":"public subroutine set_impact_ioniz_wfunction(zm, imod) Arguments Type Intent Optional Attributes Name integer, intent(in) :: zm integer, intent(in) :: imod Contents None","tags":"","loc":"proc/set_impact_ioniz_wfunction.html"},{"title":"add_particles – ALaDyn","text":"public subroutine add_particles(np, i1, i2, ic) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: ic Calls proc~~add_particles~~CallsGraph proc~add_particles add_particles proc~init_random_seed init_random_seed proc~add_particles->proc~init_random_seed proc~gasdev gasdev proc~add_particles->proc~gasdev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_particles~~CalledByGraph proc~add_particles add_particles proc~particles_inject particles_inject proc~particles_inject->proc~add_particles proc~comoving_coordinate comoving_coordinate proc~comoving_coordinate->proc~particles_inject proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~particles_inject proc~env_run env_run proc~env_run->proc~comoving_coordinate proc~env_run->proc~lp_window_xshift proc~lp_run lp_run proc~lp_run->proc~comoving_coordinate proc~lp_run->proc~lp_window_xshift proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/add_particles.html"},{"title":"particles_inject – ALaDyn","text":"public subroutine particles_inject(xmx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xmx Calls proc~~particles_inject~~CallsGraph proc~particles_inject particles_inject proc~add_particles add_particles proc~particles_inject->proc~add_particles v_realloc v_realloc proc~particles_inject->v_realloc loc_npart loc_npart proc~particles_inject->loc_npart proc~init_random_seed init_random_seed proc~add_particles->proc~init_random_seed proc~gasdev gasdev proc~add_particles->proc~gasdev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~particles_inject~~CalledByGraph proc~particles_inject particles_inject proc~comoving_coordinate comoving_coordinate proc~comoving_coordinate->proc~particles_inject proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~particles_inject proc~env_run env_run proc~env_run->proc~comoving_coordinate proc~env_run->proc~lp_window_xshift proc~lp_run lp_run proc~lp_run->proc~comoving_coordinate proc~lp_run->proc~lp_window_xshift proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/particles_inject.html"},{"title":"reset_loc_xgrid – ALaDyn","text":"public subroutine reset_loc_xgrid() Arguments None Contents None","tags":"","loc":"proc/reset_loc_xgrid.html"},{"title":"comoving_coordinate – ALaDyn","text":"public subroutine comoving_coordinate(vb, w_nst, loc_it) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vb integer, intent(in) :: w_nst integer, intent(in) :: loc_it Calls proc~~comoving_coordinate~~CallsGraph proc~comoving_coordinate comoving_coordinate proc~particles_inject particles_inject proc~comoving_coordinate->proc~particles_inject proc~cell_part_dist cell_part_dist proc~comoving_coordinate->proc~cell_part_dist proc~add_particles add_particles proc~particles_inject->proc~add_particles loc_npart loc_npart proc~particles_inject->loc_npart v_realloc v_realloc proc~particles_inject->v_realloc proc~cell_part_dist->loc_npart proc~v_realloc v_realloc proc~cell_part_dist->proc~v_realloc ebfp ebfp proc~cell_part_dist->ebfp spec spec proc~cell_part_dist->spec proc~init_random_seed init_random_seed proc~add_particles->proc~init_random_seed proc~gasdev gasdev proc~add_particles->proc~gasdev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~comoving_coordinate~~CalledByGraph proc~comoving_coordinate comoving_coordinate proc~env_run env_run proc~env_run->proc~comoving_coordinate proc~lp_run lp_run proc~lp_run->proc~comoving_coordinate proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/comoving_coordinate.html"},{"title":"lp_window_xshift – ALaDyn","text":"public subroutine lp_window_xshift(witr, init_iter) Arguments Type Intent Optional Attributes Name integer, intent(in) :: witr integer, intent(in) :: init_iter Calls proc~~lp_window_xshift~~CallsGraph proc~lp_window_xshift lp_window_xshift proc~fluid_left_xshift fluid_left_xshift proc~lp_window_xshift->proc~fluid_left_xshift proc~fields_left_xshift fields_left_xshift proc~lp_window_xshift->proc~fields_left_xshift proc~particles_inject particles_inject proc~lp_window_xshift->proc~particles_inject proc~part_numbers Part_numbers proc~lp_window_xshift->proc~part_numbers proc~cell_part_dist cell_part_dist proc~lp_window_xshift->proc~cell_part_dist proc~exchange_bdx_data exchange_bdx_data proc~fluid_left_xshift->proc~exchange_bdx_data proc~fields_left_xshift->proc~exchange_bdx_data proc~add_particles add_particles proc~particles_inject->proc~add_particles loc_npart loc_npart proc~particles_inject->loc_npart v_realloc v_realloc proc~particles_inject->v_realloc proc~part_numbers->loc_npart proc~intvec_distribute intvec_distribute proc~part_numbers->proc~intvec_distribute proc~cell_part_dist->loc_npart proc~v_realloc v_realloc proc~cell_part_dist->proc~v_realloc ebfp ebfp proc~cell_part_dist->ebfp spec spec proc~cell_part_dist->spec proc~init_random_seed init_random_seed proc~add_particles->proc~init_random_seed proc~gasdev gasdev proc~add_particles->proc~gasdev mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~lp_window_xshift~~CalledByGraph proc~lp_window_xshift lp_window_xshift proc~env_run env_run proc~env_run->proc~lp_window_xshift proc~lp_run lp_run proc~lp_run->proc~lp_window_xshift proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/lp_window_xshift.html"},{"title":"fluid_curr_accumulate – ALaDyn","text":"public subroutine fluid_curr_accumulate(flx, curr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: flx (:,:,:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) Calls proc~~fluid_curr_accumulate~~CallsGraph proc~fluid_curr_accumulate fluid_curr_accumulate proc~field_xyzbd field_xyzbd proc~fluid_curr_accumulate->proc~field_xyzbd proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata unit_charge unit_charge proc~fluid_curr_accumulate->unit_charge proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fluid_curr_accumulate~~CalledByGraph proc~fluid_curr_accumulate fluid_curr_accumulate proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~fluid_curr_accumulate proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~fluid_curr_accumulate proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fluid_curr_accumulate.html"},{"title":"set_env_momentum_density_flux – ALaDyn","text":"public subroutine set_env_momentum_density_flux(uv, ef, curr, eb_tot, flx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: uv (:,:,:,:) real(kind=dp), intent(in) :: ef (:,:,:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(out) :: eb_tot (:,:,:,:) real(kind=dp), intent(out) :: flx (:,:,:,:) Called by proc~~set_env_momentum_density_flux~~CalledByGraph proc~set_env_momentum_density_flux set_env_momentum_density_flux proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~set_env_momentum_density_flux proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_env_momentum_density_flux.html"},{"title":"set_momentum_density_flux – ALaDyn","text":"public subroutine set_momentum_density_flux(uv, flx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: uv (:,:,:,:) real(kind=dp), intent(inout) :: flx (:,:,:,:) Called by proc~~set_momentum_density_flux~~CalledByGraph proc~set_momentum_density_flux set_momentum_density_flux proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~set_momentum_density_flux proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run program~aladyn aladyn program~aladyn->proc~lp_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_momentum_density_flux.html"},{"title":"update_adam_bash_fluid_variables – ALaDyn","text":"public subroutine update_adam_bash_fluid_variables(u, u0, flx, ef) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: u (:,:,:,:) real(kind=dp), intent(inout) :: u0 (:,:,:,:) real(kind=dp), intent(inout) :: flx (:,:,:,:) real(kind=dp), intent(inout) :: ef (:,:,:,:) Calls proc~~update_adam_bash_fluid_variables~~CallsGraph proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~field_xyzbd field_xyzbd proc~update_adam_bash_fluid_variables->proc~field_xyzbd proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta unit_charge unit_charge proc~update_adam_bash_fluid_variables->unit_charge lorentz_fact lorentz_fact proc~update_adam_bash_fluid_variables->lorentz_fact proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data loc_yg loc_yg proc~nc_fluid_density_momenta->loc_yg loc_zg loc_zg proc~nc_fluid_density_momenta->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_adam_bash_fluid_variables~~CalledByGraph proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~update_adam_bash_fluid_variables proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/update_adam_bash_fluid_variables.html"},{"title":"set_lpf_acc – ALaDyn","text":"public subroutine set_lpf_acc(ef, sp_loc, apt, np, nf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: apt (:,:) integer, intent(in) :: np integer, intent(in) :: nf Calls proc~~set_lpf_acc~~CallsGraph proc~set_lpf_acc set_lpf_acc proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc proc~set_part2d_hcell_acc set_part2d_hcell_acc proc~set_lpf_acc->proc~set_part2d_hcell_acc proc~set_part1d_acc set_part1d_acc proc~set_lpf_acc->proc~set_part1d_acc proc~qlh_3d_spline qlh_3d_spline proc~set_part3d_hcell_acc->proc~qlh_3d_spline proc~set_local_3d_positions set_local_3d_positions proc~set_part3d_hcell_acc->proc~set_local_3d_positions proc~qlh_2d_spline qlh_2d_spline proc~set_part2d_hcell_acc->proc~qlh_2d_spline proc~set_local_2d_positions set_local_2d_positions proc~set_part2d_hcell_acc->proc~set_local_2d_positions proc~qqh_1d_spline qqh_1d_spline proc~set_part1d_acc->proc~qqh_1d_spline proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_lpf_acc.html"},{"title":"field_charge_multiply – ALaDyn","text":"public subroutine field_charge_multiply(sp_loc, apt, np, ncmp) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: apt (:,:) integer, intent(in) :: np integer, intent(in) :: ncmp Contents None","tags":"","loc":"proc/field_charge_multiply.html"},{"title":"curr_accumulate – ALaDyn","text":"public subroutine curr_accumulate(sp_loc, pdata, curr, npt) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pdata (:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: npt Calls proc~~curr_accumulate~~CallsGraph proc~curr_accumulate curr_accumulate proc~ncdef_3d_curr ncdef_3d_curr proc~curr_accumulate->proc~ncdef_3d_curr proc~ncdef_2d_curr ncdef_2d_curr proc~curr_accumulate->proc~ncdef_2d_curr proc~esirkepov_2d_curr esirkepov_2d_curr proc~curr_accumulate->proc~esirkepov_2d_curr proc~esirkepov_3d_curr esirkepov_3d_curr proc~curr_accumulate->proc~esirkepov_3d_curr proc~qlh_3d_spline qlh_3d_spline proc~ncdef_3d_curr->proc~qlh_3d_spline proc~set_local_3d_positions set_local_3d_positions proc~ncdef_3d_curr->proc~set_local_3d_positions proc~qlh_2d_spline qlh_2d_spline proc~ncdef_2d_curr->proc~qlh_2d_spline proc~set_local_2d_positions set_local_2d_positions proc~ncdef_2d_curr->proc~set_local_2d_positions proc~qden_2d_wgh qden_2d_wgh proc~esirkepov_2d_curr->proc~qden_2d_wgh proc~esirkepov_2d_curr->proc~set_local_2d_positions proc~qden_3d_wgh qden_3d_wgh proc~esirkepov_3d_curr->proc~qden_3d_wgh proc~esirkepov_3d_curr->proc~set_local_3d_positions proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/curr_accumulate.html"},{"title":"curr_mpi_collect – ALaDyn","text":"public subroutine curr_mpi_collect(curr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) Calls proc~~curr_mpi_collect~~CallsGraph proc~curr_mpi_collect curr_mpi_collect proc~jc_xyzbd jc_xyzbd proc~curr_mpi_collect->proc~jc_xyzbd proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~curr_mpi_collect->proc~fill_curr_yzxbdsdata djc djc proc~curr_mpi_collect->djc proc~exchange_bdx_data exchange_bdx_data proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~curr_mpi_collect~~CalledByGraph proc~curr_mpi_collect curr_mpi_collect proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~curr_mpi_collect proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/curr_mpi_collect.html"},{"title":"pfields_prepare – ALaDyn","text":"public subroutine pfields_prepare(ef, nc, spr, spl) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) integer, intent(in) :: nc integer, intent(in) :: spr integer, intent(in) :: spl Calls proc~~pfields_prepare~~CallsGraph proc~pfields_prepare pfields_prepare proc~field_xyzbd field_xyzbd proc~pfields_prepare->proc~field_xyzbd proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~pfields_prepare->proc~fill_ebfield_yzxbdsdata proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pfields_prepare~~CalledByGraph proc~pfields_prepare pfields_prepare proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~pfields_prepare proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run program~aladyn aladyn program~aladyn->proc~lp_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pfields_prepare.html"},{"title":"advance_lpf_fields – ALaDyn","text":"public subroutine advance_lpf_fields(ef, curr, ibd) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: curr (:,:,:,:) integer, intent(in) :: ibd Calls proc~~advance_lpf_fields~~CallsGraph proc~advance_lpf_fields advance_lpf_fields proc~ef_bds ef_bds proc~advance_lpf_fields->proc~ef_bds proc~bf_bds bf_bds proc~advance_lpf_fields->proc~bf_bds proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~field_xadvect field_xadvect proc~advance_lpf_fields->proc~field_xadvect proc~rotb rotb proc~advance_lpf_fields->proc~rotb proc~rote rote proc~advance_lpf_fields->proc~rote loc_zgrid loc_zgrid proc~ef_bds->loc_zgrid loc_yg loc_yg proc~ef_bds->loc_yg loc_xg loc_xg proc~ef_bds->loc_xg loc_zg loc_zg proc~ef_bds->loc_zg proc~bf_bds->loc_yg proc~bf_bds->loc_xg proc~bf_bds->loc_zg proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 proc~rotb->loc_yg proc~rotb->loc_zg proc~rote->loc_yg proc~rote->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~advance_lpf_fields~~CalledByGraph proc~advance_lpf_fields advance_lpf_fields proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~advance_lpf_fields proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/advance_lpf_fields.html"},{"title":"advance_lpf_envelope – ALaDyn","text":"public subroutine advance_lpf_envelope(curr, evf, omg) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(inout) :: evf (:,:,:,:) real(kind=dp), intent(in) :: omg Calls proc~~advance_lpf_envelope~~CallsGraph proc~advance_lpf_envelope advance_lpf_envelope proc~env_maxw_solve env_maxw_solve proc~advance_lpf_envelope->proc~env_maxw_solve proc~env_bds env_bds proc~advance_lpf_envelope->proc~env_bds proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~advance_lpf_envelope->proc~fill_ebfield_yzxbdsdata proc~env_lpf_solve env_lpf_solve proc~advance_lpf_envelope->proc~env_lpf_solve proc~potential_lapl potential_lapl proc~env_maxw_solve->proc~potential_lapl loc_yg loc_yg proc~env_bds->loc_yg loc_zg loc_zg proc~env_bds->loc_zg proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~pp_lapl pp_lapl proc~env_lpf_solve->proc~pp_lapl proc~pp_lapl->loc_yg proc~pp_lapl->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~advance_lpf_envelope~~CalledByGraph proc~advance_lpf_envelope advance_lpf_envelope proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/advance_lpf_envelope.html"},{"title":"wave_field_left_inject – ALaDyn","text":"public subroutine wave_field_left_inject(ef, x_left) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: x_left Calls proc~~wave_field_left_inject~~CallsGraph proc~wave_field_left_inject wave_field_left_inject lp_in lp_in proc~wave_field_left_inject->lp_in proc~inflow_lp_fields inflow_lp_fields proc~wave_field_left_inject->proc~inflow_lp_fields lp_end lp_end proc~wave_field_left_inject->lp_end xf_loc xf_loc proc~wave_field_left_inject->xf_loc proc~get_plane_wave_lp get_plane_wave_lp proc~inflow_lp_fields->proc~get_plane_wave_lp proc~get_laser_fields_lp get_laser_fields_lp proc~inflow_lp_fields->proc~get_laser_fields_lp proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~inflow_lp_fields->proc~get_2dlaser_fields_lp loc_yg loc_yg proc~inflow_lp_fields->loc_yg loc_xg loc_xg proc~inflow_lp_fields->loc_xg proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~inflow_lp_fields->proc~get_2dlaser_gprof_fields_lp loc_zg loc_zg proc~inflow_lp_fields->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/wave_field_left_inject.html"},{"title":"advect_bunch_fields – ALaDyn","text":"public subroutine advect_bunch_fields(fb, curr, v_b) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: fb (:,:,:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(in) :: v_b Calls proc~~advect_bunch_fields~~CallsGraph proc~advect_bunch_fields advect_bunch_fields proc~fill_ebfield_xbdsdata fill_ebfield_xbdsdata proc~advect_bunch_fields->proc~fill_ebfield_xbdsdata proc~field_xadvect field_xadvect proc~advect_bunch_fields->proc~field_xadvect proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_xbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/advect_bunch_fields.html"},{"title":"init_lpf_momenta – ALaDyn","text":"public subroutine init_lpf_momenta(sp_loc, pt, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ic Contents None","tags":"","loc":"proc/init_lpf_momenta.html"},{"title":"lpf_momenta_and_positions – ALaDyn","text":"public subroutine lpf_momenta_and_positions(sp_loc, pt, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ic Contents None","tags":"","loc":"proc/lpf_momenta_and_positions.html"},{"title":"lpf_env_momenta – ALaDyn","text":"public subroutine lpf_env_momenta(sp_loc, f_pt, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: f_pt (:,:) integer, intent(in) :: np integer, intent(in) :: ic Contents None","tags":"","loc":"proc/lpf_env_momenta.html"},{"title":"lpf_env_positions – ALaDyn","text":"public subroutine lpf_env_positions(sp_loc, f_pt, np) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: f_pt (:,:) integer, intent(in) :: np Contents None","tags":"","loc":"proc/lpf_env_positions.html"},{"title":"lpf2_evolve – ALaDyn","text":"public subroutine lpf2_evolve(iter_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter_loc Calls proc~~lpf2_evolve~~CallsGraph proc~lpf2_evolve lpf2_evolve proc~set_momentum_density_flux set_momentum_density_flux proc~lpf2_evolve->proc~set_momentum_density_flux proc~fluid_curr_accumulate fluid_curr_accumulate proc~lpf2_evolve->proc~fluid_curr_accumulate spec spec proc~lpf2_evolve->spec proc~pfields_prepare pfields_prepare proc~lpf2_evolve->proc~pfields_prepare init_random_seed init_random_seed proc~lpf2_evolve->init_random_seed ion_min ion_min proc~lpf2_evolve->ion_min proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~lpf2_evolve->proc~update_adam_bash_fluid_variables loc_npart loc_npart proc~lpf2_evolve->loc_npart atomic_number atomic_number proc~lpf2_evolve->atomic_number ebfp ebfp proc~lpf2_evolve->ebfp proc~advance_lpf_fields advance_lpf_fields proc~lpf2_evolve->proc~advance_lpf_fields jc jc proc~lpf2_evolve->jc proc~field_xyzbd field_xyzbd proc~fluid_curr_accumulate->proc~field_xyzbd proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata unit_charge unit_charge proc~fluid_curr_accumulate->unit_charge proc~pfields_prepare->proc~field_xyzbd proc~pfields_prepare->proc~fill_ebfield_yzxbdsdata proc~update_adam_bash_fluid_variables->proc~field_xyzbd proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->unit_charge lorentz_fact lorentz_fact proc~update_adam_bash_fluid_variables->lorentz_fact proc~rote rote proc~advance_lpf_fields->proc~rote proc~ef_bds ef_bds proc~advance_lpf_fields->proc~ef_bds proc~bf_bds bf_bds proc~advance_lpf_fields->proc~bf_bds proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~field_xadvect field_xadvect proc~advance_lpf_fields->proc~field_xadvect proc~rotb rotb proc~advance_lpf_fields->proc~rotb loc_yg loc_yg proc~rote->loc_yg loc_zg loc_zg proc~rote->loc_zg loc_zgrid loc_zgrid proc~ef_bds->loc_zgrid proc~ef_bds->loc_yg loc_xg loc_xg proc~ef_bds->loc_xg proc~ef_bds->loc_zg proc~bf_bds->loc_yg proc~bf_bds->loc_xg proc~bf_bds->loc_zg proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 proc~nc_fluid_density_momenta->loc_yg proc~nc_fluid_density_momenta->loc_zg proc~rotb->loc_yg proc~rotb->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~lpf2_evolve~~CalledByGraph proc~lpf2_evolve lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run program~aladyn aladyn program~aladyn->proc~lp_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/lpf2_evolve.html"},{"title":"lp_run – ALaDyn","text":"public subroutine lp_run(t_loc, iter_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: t_loc integer, intent(in) :: iter_loc Calls proc~~lp_run~~CallsGraph proc~lp_run lp_run proc~comoving_coordinate comoving_coordinate proc~lp_run->proc~comoving_coordinate proc~lpf2_evolve lpf2_evolve proc~lp_run->proc~lpf2_evolve proc~lp_window_xshift lp_window_xshift proc~lp_run->proc~lp_window_xshift proc~particles_inject particles_inject proc~comoving_coordinate->proc~particles_inject proc~cell_part_dist cell_part_dist proc~comoving_coordinate->proc~cell_part_dist proc~set_momentum_density_flux set_momentum_density_flux proc~lpf2_evolve->proc~set_momentum_density_flux proc~fluid_curr_accumulate fluid_curr_accumulate proc~lpf2_evolve->proc~fluid_curr_accumulate spec spec proc~lpf2_evolve->spec proc~pfields_prepare pfields_prepare proc~lpf2_evolve->proc~pfields_prepare init_random_seed init_random_seed proc~lpf2_evolve->init_random_seed ion_min ion_min proc~lpf2_evolve->ion_min proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~lpf2_evolve->proc~update_adam_bash_fluid_variables loc_npart loc_npart proc~lpf2_evolve->loc_npart atomic_number atomic_number proc~lpf2_evolve->atomic_number ebfp ebfp proc~lpf2_evolve->ebfp proc~advance_lpf_fields advance_lpf_fields proc~lpf2_evolve->proc~advance_lpf_fields jc jc proc~lpf2_evolve->jc proc~lp_window_xshift->proc~particles_inject proc~fluid_left_xshift fluid_left_xshift proc~lp_window_xshift->proc~fluid_left_xshift proc~fields_left_xshift fields_left_xshift proc~lp_window_xshift->proc~fields_left_xshift proc~part_numbers Part_numbers proc~lp_window_xshift->proc~part_numbers proc~lp_window_xshift->proc~cell_part_dist proc~particles_inject->loc_npart proc~add_particles add_particles proc~particles_inject->proc~add_particles v_realloc v_realloc proc~particles_inject->v_realloc proc~field_xyzbd field_xyzbd proc~fluid_curr_accumulate->proc~field_xyzbd proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata unit_charge unit_charge proc~fluid_curr_accumulate->unit_charge proc~exchange_bdx_data exchange_bdx_data proc~fluid_left_xshift->proc~exchange_bdx_data proc~fields_left_xshift->proc~exchange_bdx_data proc~pfields_prepare->proc~field_xyzbd proc~pfields_prepare->proc~fill_ebfield_yzxbdsdata proc~part_numbers->loc_npart proc~intvec_distribute intvec_distribute proc~part_numbers->proc~intvec_distribute proc~cell_part_dist->spec proc~cell_part_dist->loc_npart proc~cell_part_dist->ebfp proc~v_realloc v_realloc proc~cell_part_dist->proc~v_realloc proc~update_adam_bash_fluid_variables->proc~field_xyzbd proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->unit_charge lorentz_fact lorentz_fact proc~update_adam_bash_fluid_variables->lorentz_fact proc~rote rote proc~advance_lpf_fields->proc~rote proc~ef_bds ef_bds proc~advance_lpf_fields->proc~ef_bds proc~bf_bds bf_bds proc~advance_lpf_fields->proc~bf_bds proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~field_xadvect field_xadvect proc~advance_lpf_fields->proc~field_xadvect proc~rotb rotb proc~advance_lpf_fields->proc~rotb proc~init_random_seed init_random_seed proc~add_particles->proc~init_random_seed proc~gasdev gasdev proc~add_particles->proc~gasdev loc_yg loc_yg proc~rote->loc_yg loc_zg loc_zg proc~rote->loc_zg loc_zgrid loc_zgrid proc~ef_bds->loc_zgrid proc~ef_bds->loc_yg loc_xg loc_xg proc~ef_bds->loc_xg proc~ef_bds->loc_zg proc~bf_bds->loc_yg proc~bf_bds->loc_xg proc~bf_bds->loc_zg proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 proc~nc_fluid_density_momenta->loc_yg proc~nc_fluid_density_momenta->loc_zg mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send proc~rotb->loc_yg proc~rotb->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~lp_run~~CalledByGraph proc~lp_run lp_run proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run program~aladyn aladyn program~aladyn->proc~lp_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/lp_run.html"},{"title":"env_den_collect – ALaDyn","text":"public subroutine env_den_collect(source_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: source_in (:,:,:,:) Calls proc~~env_den_collect~~CallsGraph proc~env_den_collect env_den_collect fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~env_den_collect->fill_curr_yzxbdsdata den_zyxbd den_zyxbd proc~env_den_collect->den_zyxbd loc_yg loc_yg proc~env_den_collect->loc_yg loc_zg loc_zg proc~env_den_collect->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_den_collect~~CalledByGraph proc~env_den_collect env_den_collect proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~env_den_collect proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_den_collect.html"},{"title":"env_two_fields_average – ALaDyn","text":"public subroutine env_two_fields_average(evf, ev1f, av, spl_in, spr_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: evf (:,:,:,:) real(kind=dp), intent(in) :: ev1f (:,:,:,:) real(kind=dp), intent(out) :: av (:,:,:,:) integer, intent(in) :: spl_in integer, intent(in) :: spr_in Called by proc~~env_two_fields_average~~CalledByGraph proc~env_two_fields_average env_two_fields_average proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~env_two_fields_average proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_two_fields_average.html"},{"title":"env_fields_average – ALaDyn","text":"public subroutine env_fields_average(evf, av, spl_in, spr_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: evf (:,:,:,:) real(kind=dp), intent(out) :: av (:,:,:,:) integer, intent(in) :: spl_in integer, intent(in) :: spr_in Calls proc~~env_fields_average~~CallsGraph proc~env_fields_average env_fields_average env_grad env_grad proc~env_fields_average->env_grad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_fields_average~~CalledByGraph proc~env_fields_average env_fields_average proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~env_fields_average proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_fields_average.html"},{"title":"env_amp_prepare – ALaDyn","text":"public subroutine env_amp_prepare(envf, av, ord, spl_in, spr_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: envf (:,:,:,:) real(kind=dp), intent(out) :: av (:,:,:,:) integer, intent(in) :: ord integer, intent(in) :: spl_in integer, intent(in) :: spr_in Calls proc~~env_amp_prepare~~CallsGraph proc~env_amp_prepare env_amp_prepare env_grad env_grad proc~env_amp_prepare->env_grad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_amp_prepare~~CalledByGraph proc~env_amp_prepare env_amp_prepare proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~env_amp_prepare proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_amp_prepare.html"},{"title":"env_amp_two_fields_prepare – ALaDyn","text":"public subroutine env_amp_two_fields_prepare(envf, env1f, av, ord, spl_in, spr_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: envf (:,:,:,:) real(kind=dp), intent(in) :: env1f (:,:,:,:) real(kind=dp), intent(out) :: av (:,:,:,:) integer, intent(in) :: ord integer, intent(in) :: spl_in integer, intent(in) :: spr_in Calls proc~~env_amp_two_fields_prepare~~CallsGraph proc~env_amp_two_fields_prepare env_amp_two_fields_prepare env_grad env_grad proc~env_amp_two_fields_prepare->env_grad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_amp_two_fields_prepare~~CalledByGraph proc~env_amp_two_fields_prepare env_amp_two_fields_prepare proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~env_amp_two_fields_prepare proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_amp_two_fields_prepare.html"},{"title":"env_lpf2_evolve – ALaDyn","text":"public subroutine env_lpf2_evolve(it_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it_loc Calls proc~~env_lpf2_evolve~~CallsGraph proc~env_lpf2_evolve env_lpf2_evolve proc~advance_lpf_envelope advance_lpf_envelope proc~env_lpf2_evolve->proc~advance_lpf_envelope ion_min ion_min proc~env_lpf2_evolve->ion_min loc_npart loc_npart proc~env_lpf2_evolve->loc_npart ebfp ebfp proc~env_lpf2_evolve->ebfp proc~env_fields_average env_fields_average proc~env_lpf2_evolve->proc~env_fields_average proc~env_two_fields_average env_two_fields_average proc~env_lpf2_evolve->proc~env_two_fields_average proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables enable_ionization enable_ionization proc~env_lpf2_evolve->enable_ionization flux flux proc~env_lpf2_evolve->flux proc~advance_lpf_fields advance_lpf_fields proc~env_lpf2_evolve->proc~advance_lpf_fields proc~set_env_momentum_density_flux set_env_momentum_density_flux proc~env_lpf2_evolve->proc~set_env_momentum_density_flux proc~env_den_collect env_den_collect proc~env_lpf2_evolve->proc~env_den_collect proc~env_amp_two_fields_prepare env_amp_two_fields_prepare proc~env_lpf2_evolve->proc~env_amp_two_fields_prepare proc~init_random_seed init_random_seed proc~env_lpf2_evolve->proc~init_random_seed proc~curr_mpi_collect curr_mpi_collect proc~env_lpf2_evolve->proc~curr_mpi_collect atomic_number atomic_number proc~env_lpf2_evolve->atomic_number proc~env_amp_prepare env_amp_prepare proc~env_lpf2_evolve->proc~env_amp_prepare set_env_density set_env_density proc~env_lpf2_evolve->set_env_density jc jc proc~env_lpf2_evolve->jc proc~fluid_curr_accumulate fluid_curr_accumulate proc~env_lpf2_evolve->proc~fluid_curr_accumulate spec spec proc~env_lpf2_evolve->spec proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~advance_lpf_envelope->proc~fill_ebfield_yzxbdsdata proc~env_maxw_solve env_maxw_solve proc~advance_lpf_envelope->proc~env_maxw_solve proc~env_bds env_bds proc~advance_lpf_envelope->proc~env_bds proc~env_lpf_solve env_lpf_solve proc~advance_lpf_envelope->proc~env_lpf_solve env_grad env_grad proc~env_fields_average->env_grad proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata lorentz_fact lorentz_fact proc~update_adam_bash_fluid_variables->lorentz_fact proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta proc~field_xyzbd field_xyzbd proc~update_adam_bash_fluid_variables->proc~field_xyzbd unit_charge unit_charge proc~update_adam_bash_fluid_variables->unit_charge proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~field_xadvect field_xadvect proc~advance_lpf_fields->proc~field_xadvect proc~rotb rotb proc~advance_lpf_fields->proc~rotb proc~rote rote proc~advance_lpf_fields->proc~rote proc~ef_bds ef_bds proc~advance_lpf_fields->proc~ef_bds proc~bf_bds bf_bds proc~advance_lpf_fields->proc~bf_bds fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~env_den_collect->fill_curr_yzxbdsdata loc_zg loc_zg proc~env_den_collect->loc_zg den_zyxbd den_zyxbd proc~env_den_collect->den_zyxbd loc_yg loc_yg proc~env_den_collect->loc_yg proc~env_amp_two_fields_prepare->env_grad proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~curr_mpi_collect->proc~fill_curr_yzxbdsdata proc~jc_xyzbd jc_xyzbd proc~curr_mpi_collect->proc~jc_xyzbd djc djc proc~curr_mpi_collect->djc proc~env_amp_prepare->env_grad proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate->proc~field_xyzbd proc~fluid_curr_accumulate->unit_charge proc~exchange_bdx_data exchange_bdx_data proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 proc~rotb->loc_zg proc~rotb->loc_yg proc~potential_lapl potential_lapl proc~env_maxw_solve->proc~potential_lapl proc~rote->loc_zg proc~rote->loc_yg proc~ef_bds->loc_zg proc~ef_bds->loc_yg loc_zgrid loc_zgrid proc~ef_bds->loc_zgrid loc_xg loc_xg proc~ef_bds->loc_xg proc~nc_fluid_density_momenta->loc_zg proc~nc_fluid_density_momenta->loc_yg proc~env_bds->loc_zg proc~env_bds->loc_yg proc~pp_lapl pp_lapl proc~env_lpf_solve->proc~pp_lapl proc~bf_bds->loc_zg proc~bf_bds->loc_yg proc~bf_bds->loc_xg proc~pp_lapl->loc_zg proc~pp_lapl->loc_yg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_lpf2_evolve~~CalledByGraph proc~env_lpf2_evolve env_lpf2_evolve proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_lpf2_evolve.html"},{"title":"env_run – ALaDyn","text":"public subroutine env_run(t_loc, iter_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: t_loc integer, intent(in) :: iter_loc Calls proc~~env_run~~CallsGraph proc~env_run env_run proc~comoving_coordinate comoving_coordinate proc~env_run->proc~comoving_coordinate proc~lp_window_xshift lp_window_xshift proc~env_run->proc~lp_window_xshift proc~env_lpf2_evolve env_lpf2_evolve proc~env_run->proc~env_lpf2_evolve proc~cell_part_dist cell_part_dist proc~comoving_coordinate->proc~cell_part_dist proc~particles_inject particles_inject proc~comoving_coordinate->proc~particles_inject proc~fluid_left_xshift fluid_left_xshift proc~lp_window_xshift->proc~fluid_left_xshift proc~fields_left_xshift fields_left_xshift proc~lp_window_xshift->proc~fields_left_xshift proc~lp_window_xshift->proc~cell_part_dist proc~lp_window_xshift->proc~particles_inject proc~part_numbers Part_numbers proc~lp_window_xshift->proc~part_numbers proc~advance_lpf_envelope advance_lpf_envelope proc~env_lpf2_evolve->proc~advance_lpf_envelope ion_min ion_min proc~env_lpf2_evolve->ion_min loc_npart loc_npart proc~env_lpf2_evolve->loc_npart ebfp ebfp proc~env_lpf2_evolve->ebfp proc~env_fields_average env_fields_average proc~env_lpf2_evolve->proc~env_fields_average proc~env_two_fields_average env_two_fields_average proc~env_lpf2_evolve->proc~env_two_fields_average proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables enable_ionization enable_ionization proc~env_lpf2_evolve->enable_ionization flux flux proc~env_lpf2_evolve->flux proc~advance_lpf_fields advance_lpf_fields proc~env_lpf2_evolve->proc~advance_lpf_fields proc~set_env_momentum_density_flux set_env_momentum_density_flux proc~env_lpf2_evolve->proc~set_env_momentum_density_flux proc~env_den_collect env_den_collect proc~env_lpf2_evolve->proc~env_den_collect proc~env_amp_two_fields_prepare env_amp_two_fields_prepare proc~env_lpf2_evolve->proc~env_amp_two_fields_prepare proc~init_random_seed init_random_seed proc~env_lpf2_evolve->proc~init_random_seed proc~curr_mpi_collect curr_mpi_collect proc~env_lpf2_evolve->proc~curr_mpi_collect atomic_number atomic_number proc~env_lpf2_evolve->atomic_number proc~env_amp_prepare env_amp_prepare proc~env_lpf2_evolve->proc~env_amp_prepare set_env_density set_env_density proc~env_lpf2_evolve->set_env_density jc jc proc~env_lpf2_evolve->jc proc~fluid_curr_accumulate fluid_curr_accumulate proc~env_lpf2_evolve->proc~fluid_curr_accumulate spec spec proc~env_lpf2_evolve->spec proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~advance_lpf_envelope->proc~fill_ebfield_yzxbdsdata proc~env_maxw_solve env_maxw_solve proc~advance_lpf_envelope->proc~env_maxw_solve proc~env_bds env_bds proc~advance_lpf_envelope->proc~env_bds proc~env_lpf_solve env_lpf_solve proc~advance_lpf_envelope->proc~env_lpf_solve env_grad env_grad proc~env_fields_average->env_grad proc~exchange_bdx_data exchange_bdx_data proc~fluid_left_xshift->proc~exchange_bdx_data proc~fields_left_xshift->proc~exchange_bdx_data proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata lorentz_fact lorentz_fact proc~update_adam_bash_fluid_variables->lorentz_fact proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta proc~field_xyzbd field_xyzbd proc~update_adam_bash_fluid_variables->proc~field_xyzbd unit_charge unit_charge proc~update_adam_bash_fluid_variables->unit_charge proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~field_xadvect field_xadvect proc~advance_lpf_fields->proc~field_xadvect proc~rotb rotb proc~advance_lpf_fields->proc~rotb proc~rote rote proc~advance_lpf_fields->proc~rote proc~ef_bds ef_bds proc~advance_lpf_fields->proc~ef_bds proc~bf_bds bf_bds proc~advance_lpf_fields->proc~bf_bds fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~env_den_collect->fill_curr_yzxbdsdata loc_zg loc_zg proc~env_den_collect->loc_zg den_zyxbd den_zyxbd proc~env_den_collect->den_zyxbd loc_yg loc_yg proc~env_den_collect->loc_yg proc~env_amp_two_fields_prepare->env_grad proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~curr_mpi_collect->proc~fill_curr_yzxbdsdata proc~jc_xyzbd jc_xyzbd proc~curr_mpi_collect->proc~jc_xyzbd djc djc proc~curr_mpi_collect->djc proc~cell_part_dist->loc_npart proc~cell_part_dist->ebfp proc~cell_part_dist->spec proc~v_realloc v_realloc proc~cell_part_dist->proc~v_realloc proc~env_amp_prepare->env_grad proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate->proc~field_xyzbd proc~fluid_curr_accumulate->unit_charge proc~particles_inject->loc_npart v_realloc v_realloc proc~particles_inject->v_realloc proc~add_particles add_particles proc~particles_inject->proc~add_particles proc~part_numbers->loc_npart proc~intvec_distribute intvec_distribute proc~part_numbers->proc~intvec_distribute proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 proc~rotb->loc_zg proc~rotb->loc_yg proc~potential_lapl potential_lapl proc~env_maxw_solve->proc~potential_lapl mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send proc~rote->loc_zg proc~rote->loc_yg proc~ef_bds->loc_zg proc~ef_bds->loc_yg loc_zgrid loc_zgrid proc~ef_bds->loc_zgrid loc_xg loc_xg proc~ef_bds->loc_xg proc~nc_fluid_density_momenta->loc_zg proc~nc_fluid_density_momenta->loc_yg proc~env_bds->loc_zg proc~env_bds->loc_yg proc~pp_lapl pp_lapl proc~env_lpf_solve->proc~pp_lapl proc~add_particles->proc~init_random_seed proc~gasdev gasdev proc~add_particles->proc~gasdev proc~bf_bds->loc_zg proc~bf_bds->loc_yg proc~bf_bds->loc_xg proc~pp_lapl->loc_zg proc~pp_lapl->loc_yg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_run~~CalledByGraph proc~env_run env_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_run.html"},{"title":"is_zero – ALaDyn","text":"public function is_zero(value) result(check) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: value Return Value logical Contents None","tags":"","loc":"proc/is_zero.html"},{"title":"init_random_seed – ALaDyn","text":"public subroutine init_random_seed(myrank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: myrank Called by proc~~init_random_seed~~CalledByGraph proc~init_random_seed init_random_seed proc~add_particles add_particles proc~add_particles->proc~init_random_seed proc~start_parallel start_parallel proc~start_parallel->proc~init_random_seed proc~one_layer_nano_tubes one_layer_nano_tubes proc~one_layer_nano_tubes->proc~init_random_seed proc~pspecies_distribute pspecies_distribute proc~pspecies_distribute->proc~init_random_seed proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~init_random_seed proc~beam_inject beam_inject proc~beam_inject->proc~init_random_seed proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~comoving_coordinate comoving_coordinate proc~env_run->proc~comoving_coordinate proc~lp_window_xshift lp_window_xshift proc~env_run->proc~lp_window_xshift proc~particles_inject particles_inject proc~particles_inject->proc~add_particles proc~part_distribute part_distribute proc~part_distribute->proc~one_layer_nano_tubes proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle proc~start Start program~aladyn->proc~start proc~lp_cycle Lp_cycle program~aladyn->proc~lp_cycle proc~comoving_coordinate->proc~particles_inject proc~init init proc~init->proc~part_distribute proc~lp_window_xshift->proc~particles_inject proc~start->proc~init proc~lp_run lp_run proc~lp_run->proc~comoving_coordinate proc~lp_run->proc~lp_window_xshift proc~lp_cycle->proc~lp_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_random_seed.html"},{"title":"gasdev – ALaDyn","text":"public subroutine gasdev(dev) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: dev Called by proc~~gasdev~~CalledByGraph proc~gasdev gasdev proc~add_particles add_particles proc~add_particles->proc~gasdev proc~bunch_gen bunch_gen proc~bunch_gen->proc~gasdev proc~one_layer_nano_tubes one_layer_nano_tubes proc~one_layer_nano_tubes->proc~gasdev proc~env_ionization_electrons_inject env_ionization_electrons_inject proc~env_ionization_electrons_inject->proc~gasdev proc~pspecies_distribute pspecies_distribute proc~pspecies_distribute->proc~gasdev proc~ionization_electrons_inject ionization_electrons_inject proc~ionization_electrons_inject->proc~gasdev proc~ionization_cycle ionization_cycle proc~ionization_cycle->proc~env_ionization_electrons_inject proc~ionization_cycle->proc~ionization_electrons_inject proc~particles_inject particles_inject proc~particles_inject->proc~add_particles proc~part_distribute part_distribute proc~part_distribute->proc~one_layer_nano_tubes proc~comoving_coordinate comoving_coordinate proc~comoving_coordinate->proc~particles_inject proc~init init proc~init->proc~part_distribute proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~particles_inject proc~env_run env_run proc~env_run->proc~comoving_coordinate proc~env_run->proc~lp_window_xshift proc~start Start proc~start->proc~init proc~lp_run lp_run proc~lp_run->proc~comoving_coordinate proc~lp_run->proc~lp_window_xshift proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run program~aladyn aladyn program~aladyn->proc~start program~aladyn->proc~lp_cycle proc~env_cycle Env_cycle program~aladyn->proc~env_cycle proc~env_cycle->proc~env_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/gasdev.html"},{"title":"sort – ALaDyn","text":"private subroutine sort(part, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: part (:) integer, intent(in) :: np Contents None","tags":"","loc":"proc/sort.html"},{"title":"vsort – ALaDyn","text":"private subroutine vsort(part, np, ndv, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: part (:,:) integer, intent(in) :: np integer, intent(in) :: ndv integer, intent(in) :: dir Contents None","tags":"","loc":"proc/vsort.html"},{"title":"bunch_gen – ALaDyn","text":"public subroutine bunch_gen(ndm, n1, n2, sx, sy, sz, gm, ey, ez, cut, dg, bunch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndm integer, intent(in) :: n1 integer, intent(in) :: n2 real(kind=dp), intent(in) :: sx real(kind=dp), intent(in) :: sy real(kind=dp), intent(in) :: sz real(kind=dp), intent(in) :: gm real(kind=dp), intent(in) :: ey real(kind=dp), intent(in) :: ez real(kind=dp), intent(in) :: cut real(kind=dp), intent(in) :: dg real(kind=dp), intent(inout) :: bunch (:,:) Calls proc~~bunch_gen~~CallsGraph proc~bunch_gen bunch_gen proc~gasdev gasdev proc~bunch_gen->proc~gasdev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bunch_gen.html"},{"title":"mpi_buffer_alloc – ALaDyn","text":"public subroutine mpi_buffer_alloc(n1_loc, n2_loc, n3_loc, nvd) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc integer, intent(in) :: nvd Called by proc~~mpi_buffer_alloc~~CalledByGraph proc~mpi_buffer_alloc mpi_buffer_alloc proc~start Start proc~start->proc~mpi_buffer_alloc program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_buffer_alloc.html"},{"title":"v_alloc – ALaDyn","text":"public subroutine v_alloc(n1, n2, n3, ncomp, njc, ndm, ifluid, lp, oder, envlp, color, comv, fsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ncomp integer, intent(in) :: njc integer, intent(in) :: ndm integer, intent(in) :: ifluid integer, intent(in) :: lp integer, intent(in) :: oder logical, intent(in) :: envlp logical, intent(in) :: color logical, intent(in) :: comv integer, intent(inout) :: fsize Called by proc~~v_alloc~~CalledByGraph proc~v_alloc v_alloc proc~start Start proc~start->proc~v_alloc program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/v_alloc.html"},{"title":"bv_alloc – ALaDyn","text":"public subroutine bv_alloc(n1, n2, n3, bcomp, ndm, ibch, fsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: bcomp integer, intent(in) :: ndm integer, intent(in) :: ibch integer, intent(inout) :: fsize Contents None","tags":"","loc":"proc/bv_alloc.html"},{"title":"fluid_alloc – ALaDyn","text":"public subroutine fluid_alloc(n1, n2, n3, fcomp, ndm, lp, fsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: fcomp integer, intent(in) :: ndm integer, intent(in) :: lp integer, intent(inout) :: fsize Called by proc~~fluid_alloc~~CalledByGraph proc~fluid_alloc fluid_alloc proc~start Start proc~start->proc~fluid_alloc program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fluid_alloc.html"},{"title":"bext_alloc – ALaDyn","text":"public subroutine bext_alloc(n1, n2, n3, bcomp, fsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: bcomp integer, intent(inout) :: fsize Contents None","tags":"","loc":"proc/bext_alloc.html"},{"title":"p_alloc – ALaDyn","text":"public subroutine p_alloc(npt_max, ncmp, np_s, ns, lp, mid, r_type, msize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npt_max integer, intent(in) :: ncmp integer, intent(in) :: np_s (:) integer, intent(in) :: ns integer, intent(in) :: lp integer, intent(in) :: mid integer, intent(in) :: r_type integer, intent(inout) :: msize Called by proc~~p_alloc~~CalledByGraph proc~p_alloc p_alloc proc~multi_layer_threesp_target multi_layer_threesp_target proc~multi_layer_threesp_target->proc~p_alloc proc~restart restart proc~restart->proc~p_alloc proc~preplasma_multisp preplasma_multisp proc~preplasma_multisp->proc~p_alloc proc~one_layer_nano_tubes one_layer_nano_tubes proc~one_layer_nano_tubes->proc~p_alloc proc~one_layer_nano_wires one_layer_nano_wires proc~one_layer_nano_wires->proc~p_alloc proc~multi_layer_gas_target multi_layer_gas_target proc~multi_layer_gas_target->proc~p_alloc proc~multi_layer_twosp_target multi_layer_twosp_target proc~multi_layer_twosp_target->proc~p_alloc proc~beam_inject beam_inject proc~beam_inject->proc~p_alloc proc~start Start proc~start->proc~restart proc~init init proc~start->proc~init proc~part_distribute part_distribute proc~part_distribute->proc~multi_layer_threesp_target proc~part_distribute->proc~preplasma_multisp proc~part_distribute->proc~one_layer_nano_tubes proc~part_distribute->proc~one_layer_nano_wires proc~part_distribute->proc~multi_layer_gas_target proc~part_distribute->proc~multi_layer_twosp_target proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject program~aladyn aladyn program~aladyn->proc~start program~aladyn->proc~env_cycle proc~init->proc~part_distribute Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/p_alloc.html"},{"title":"p_realloc – ALaDyn","text":"public subroutine p_realloc(pdata, npt_new, ndv) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: pdata integer, intent(in) :: npt_new integer, intent(in) :: ndv Contents None","tags":"","loc":"proc/p_realloc.html"},{"title":"v_realloc – ALaDyn","text":"public subroutine v_realloc(vdata, npt_new, ndv) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: vdata (:,:) integer, intent(in) :: npt_new integer, intent(in) :: ndv Called by proc~~v_realloc~~CalledByGraph proc~v_realloc v_realloc proc~ionization_cycle ionization_cycle proc~ionization_cycle->proc~v_realloc proc~reset_all_part_dist reset_all_part_dist proc~reset_all_part_dist->proc~v_realloc proc~cell_part_dist cell_part_dist proc~cell_part_dist->proc~v_realloc proc~comoving_coordinate comoving_coordinate proc~comoving_coordinate->proc~cell_part_dist proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~cell_part_dist proc~env_run env_run proc~env_run->proc~comoving_coordinate proc~env_run->proc~lp_window_xshift proc~lp_run lp_run proc~lp_run->proc~comoving_coordinate proc~lp_run->proc~lp_window_xshift proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/v_realloc.html"},{"title":"new_index_array – ALaDyn","text":"public function new_index_array(length) result(this) Constructor for the index_array type Arguments Type Intent Optional Attributes Name integer, intent(in) :: length Return Value type( index_array ) Called by proc~~new_index_array~~CalledByGraph proc~new_index_array new_index_array interface~index_array index_array interface~index_array->proc~new_index_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/new_index_array.html"},{"title":"find_index – ALaDyn","text":"public subroutine find_index(index_in, mask) Type bound procedure that finds and pack all the array indices\n according to the given mask Arguments Type Intent Optional Attributes Name class( index_array ), intent(inout) :: index_in logical, intent(in) :: mask (:) Contents None","tags":"","loc":"proc/find_index.html"},{"title":"index_array – ALaDyn","text":"public interface index_array Calls interface~~index_array~~CallsGraph interface~index_array index_array proc~new_index_array new_index_array interface~index_array->proc~new_index_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures new_index_array Module Procedures public function new_index_array (length) result(this) Constructor for the index_array type Arguments Type Intent Optional Attributes Name integer, intent(in) :: length Return Value type( index_array )","tags":"","loc":"interface/index_array.html"},{"title":"set_grid – ALaDyn","text":"public subroutine set_grid(n1, n2, n3, ib, x_stretch, y_stretch, xres, yxres, zxres) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ib integer, intent(in) :: x_stretch integer, intent(in) :: y_stretch real(kind=dp), intent(in) :: xres real(kind=dp), intent(in) :: yxres real(kind=dp), intent(in) :: zxres Called by proc~~set_grid~~CalledByGraph proc~set_grid set_grid proc~set_initial_param set_initial_param proc~set_initial_param->proc~set_grid proc~start Start proc~start->proc~set_initial_param program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_grid.html"},{"title":"mpi_loc_grid – ALaDyn","text":"public subroutine mpi_loc_grid(n1_loc, n2_loc, n3_loc, npex, npey, npez) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc integer, intent(in) :: npex integer, intent(in) :: npey integer, intent(in) :: npez Called by proc~~mpi_loc_grid~~CalledByGraph proc~mpi_loc_grid mpi_loc_grid proc~start Start proc~start->proc~mpi_loc_grid program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_loc_grid.html"},{"title":"set_output_grid – ALaDyn","text":"public subroutine set_output_grid(jmp, npex, npey, npez) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jmp integer, intent(in) :: npex integer, intent(in) :: npey integer, intent(in) :: npez Called by proc~~set_output_grid~~CalledByGraph proc~set_output_grid set_output_grid proc~start Start proc~start->proc~set_output_grid program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_output_grid.html"},{"title":"set_ftyzgrid – ALaDyn","text":"public subroutine set_ftyzgrid(npey, npez, sh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npey integer, intent(in) :: npez integer, intent(in) :: sh Called by proc~~set_ftyzgrid~~CalledByGraph proc~set_ftyzgrid set_ftyzgrid proc~set_ftgrid set_ftgrid proc~set_ftgrid->proc~set_ftyzgrid proc~start Start proc~start->proc~set_ftgrid program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_ftyzgrid.html"},{"title":"set_fyzxgrid – ALaDyn","text":"public subroutine set_fyzxgrid(npey, npez, npex, sh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npey integer, intent(in) :: npez integer, intent(in) :: npex integer, intent(in) :: sh Called by proc~~set_fyzxgrid~~CalledByGraph proc~set_fyzxgrid set_fyzxgrid proc~start Start proc~start->proc~set_fyzxgrid program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_fyzxgrid.html"},{"title":"set_fxgrid – ALaDyn","text":"public subroutine set_fxgrid(npex, sh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npex integer, intent(in) :: sh Called by proc~~set_fxgrid~~CalledByGraph proc~set_fxgrid set_fxgrid proc~start Start proc~start->proc~set_fxgrid program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_fxgrid.html"},{"title":"set_str_ind – ALaDyn","text":"public subroutine set_str_ind(npey, npez, ndm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npey integer, intent(in) :: npez integer, intent(in) :: ndm Contents None","tags":"","loc":"proc/set_str_ind.html"},{"title":"select_str_to_ft_grid – ALaDyn","text":"public subroutine select_str_to_ft_grid(npey, npez) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npey integer, intent(in) :: npez Called by proc~~select_str_to_ft_grid~~CalledByGraph proc~select_str_to_ft_grid select_str_to_ft_grid proc~set_ftgrid set_ftgrid proc~set_ftgrid->proc~select_str_to_ft_grid proc~start Start proc~start->proc~set_ftgrid program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/select_str_to_ft_grid.html"},{"title":"set_loc_grid_param – ALaDyn","text":"public subroutine set_loc_grid_param() Arguments None Called by proc~~set_loc_grid_param~~CalledByGraph proc~set_loc_grid_param set_loc_grid_param proc~start Start proc~start->proc~set_loc_grid_param program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_loc_grid_param.html"},{"title":"set_ftgrid – ALaDyn","text":"public subroutine set_ftgrid(str, npe1, npe2, npe3) Arguments Type Intent Optional Attributes Name logical, intent(in) :: str integer, intent(in) :: npe1 integer, intent(in) :: npe2 integer, intent(in) :: npe3 Calls proc~~set_ftgrid~~CallsGraph proc~set_ftgrid set_ftgrid proc~set_ftyzgrid set_ftyzgrid proc~set_ftgrid->proc~set_ftyzgrid proc~select_str_to_ft_grid select_str_to_ft_grid proc~set_ftgrid->proc~select_str_to_ft_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_ftgrid~~CalledByGraph proc~set_ftgrid set_ftgrid proc~start Start proc~start->proc~set_ftgrid program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_ftgrid.html"},{"title":"invert_stretched_grid – ALaDyn","text":"private pure function invert_stretched_grid(yp_in, params) result(stretched) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: yp_in type( str_params ), intent(in) :: params Return Value real(kind=dp) Called by proc~~invert_stretched_grid~~CalledByGraph proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind map2dy_part_sind proc~map2dy_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~set_local_2d_positions set_local_2d_positions proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~map3d_part_sind->proc~map2dy_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~set_local_2d_positions proc~set_local_3d_positions set_local_3d_positions proc~set_grid_charge_and_jx->proc~set_local_3d_positions proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~set_local_2d_positions proc~set_grid_env_den_energy->proc~set_local_3d_positions proc~set_part2d_hcell_acc set_part2d_hcell_acc proc~set_part2d_hcell_acc->proc~set_local_2d_positions proc~ncdef_2d_curr ncdef_2d_curr proc~ncdef_2d_curr->proc~set_local_2d_positions proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~set_local_2d_positions proc~set_env_grad_interp->proc~set_local_3d_positions proc~esirkepov_2d_curr esirkepov_2d_curr proc~esirkepov_2d_curr->proc~set_local_2d_positions proc~set_local_3d_positions->proc~map3d_part_sind proc~set_env_density set_env_density proc~set_env_density->proc~set_local_2d_positions proc~set_env_density->proc~set_local_3d_positions proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~set_local_2d_positions proc~set_ion_efield->proc~set_local_3d_positions proc~set_env_acc set_env_acc proc~set_env_acc->proc~set_local_2d_positions proc~set_env_acc->proc~set_local_3d_positions proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~set_local_2d_positions proc~set_grid_charge->proc~set_local_3d_positions proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~set_local_2d_positions proc~set_grid_den_energy->proc~set_local_3d_positions proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~set_local_2d_positions proc~set_ion_env_field->proc~set_local_3d_positions proc~esirkepov_3d_curr esirkepov_3d_curr proc~esirkepov_3d_curr->proc~set_local_3d_positions proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part2d_hcell_acc proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~ncdef_2d_curr proc~curr_accumulate->proc~esirkepov_2d_curr proc~curr_accumulate->proc~esirkepov_3d_curr proc~ncdef_3d_curr ncdef_3d_curr proc~curr_accumulate->proc~ncdef_3d_curr proc~ncdef_3d_curr->proc~set_local_3d_positions proc~set_part3d_hcell_acc->proc~set_local_3d_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/invert_stretched_grid.html"},{"title":"invert_uniform_grid – ALaDyn","text":"private pure function invert_uniform_grid(yp_in, params) result(uniform) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: yp_in type( str_params ), intent(in) :: params Return Value real(kind=dp) Called by proc~~invert_uniform_grid~~CalledByGraph proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind map2dy_part_sind proc~map2dy_part_sind->proc~invert_uniform_grid proc~map2dz_part_sind map2dz_part_sind proc~map2dz_part_sind->proc~invert_uniform_grid proc~set_local_2d_positions set_local_2d_positions proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~map3d_part_sind->proc~map2dy_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~set_local_2d_positions proc~set_local_3d_positions set_local_3d_positions proc~set_grid_charge_and_jx->proc~set_local_3d_positions proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~set_local_2d_positions proc~set_grid_env_den_energy->proc~set_local_3d_positions proc~set_part2d_hcell_acc set_part2d_hcell_acc proc~set_part2d_hcell_acc->proc~set_local_2d_positions proc~ncdef_2d_curr ncdef_2d_curr proc~ncdef_2d_curr->proc~set_local_2d_positions proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~set_local_2d_positions proc~set_env_grad_interp->proc~set_local_3d_positions proc~esirkepov_2d_curr esirkepov_2d_curr proc~esirkepov_2d_curr->proc~set_local_2d_positions proc~set_local_3d_positions->proc~map3d_part_sind proc~set_env_density set_env_density proc~set_env_density->proc~set_local_2d_positions proc~set_env_density->proc~set_local_3d_positions proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~set_local_2d_positions proc~set_ion_efield->proc~set_local_3d_positions proc~set_env_acc set_env_acc proc~set_env_acc->proc~set_local_2d_positions proc~set_env_acc->proc~set_local_3d_positions proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~set_local_2d_positions proc~set_grid_charge->proc~set_local_3d_positions proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~set_local_2d_positions proc~set_grid_den_energy->proc~set_local_3d_positions proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~set_local_2d_positions proc~set_ion_env_field->proc~set_local_3d_positions proc~esirkepov_3d_curr esirkepov_3d_curr proc~esirkepov_3d_curr->proc~set_local_3d_positions proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part2d_hcell_acc proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~ncdef_2d_curr proc~curr_accumulate->proc~esirkepov_2d_curr proc~curr_accumulate->proc~esirkepov_3d_curr proc~ncdef_3d_curr ncdef_3d_curr proc~curr_accumulate->proc~ncdef_3d_curr proc~ncdef_3d_curr->proc~set_local_3d_positions proc~set_part3d_hcell_acc->proc~set_local_3d_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/invert_uniform_grid.html"},{"title":"map2dy_part_sind – ALaDyn","text":"public subroutine map2dy_part_sind(np, ic1, pt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: ic1 real(kind=dp), intent(inout) :: pt (:,:) Calls proc~~map2dy_part_sind~~CallsGraph proc~map2dy_part_sind map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~map2dy_part_sind~~CalledByGraph proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions set_local_2d_positions proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~map3d_part_sind->proc~map2dy_part_sind proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~set_local_2d_positions proc~set_local_3d_positions set_local_3d_positions proc~set_grid_charge_and_jx->proc~set_local_3d_positions proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~set_local_2d_positions proc~set_grid_env_den_energy->proc~set_local_3d_positions proc~set_part2d_hcell_acc set_part2d_hcell_acc proc~set_part2d_hcell_acc->proc~set_local_2d_positions proc~ncdef_2d_curr ncdef_2d_curr proc~ncdef_2d_curr->proc~set_local_2d_positions proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~set_local_2d_positions proc~set_env_grad_interp->proc~set_local_3d_positions proc~esirkepov_2d_curr esirkepov_2d_curr proc~esirkepov_2d_curr->proc~set_local_2d_positions proc~set_local_3d_positions->proc~map3d_part_sind proc~set_env_density set_env_density proc~set_env_density->proc~set_local_2d_positions proc~set_env_density->proc~set_local_3d_positions proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~set_local_2d_positions proc~set_ion_efield->proc~set_local_3d_positions proc~set_env_acc set_env_acc proc~set_env_acc->proc~set_local_2d_positions proc~set_env_acc->proc~set_local_3d_positions proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~set_local_2d_positions proc~set_grid_charge->proc~set_local_3d_positions proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~set_local_2d_positions proc~set_grid_den_energy->proc~set_local_3d_positions proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~set_local_2d_positions proc~set_ion_env_field->proc~set_local_3d_positions proc~esirkepov_3d_curr esirkepov_3d_curr proc~esirkepov_3d_curr->proc~set_local_3d_positions proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part2d_hcell_acc proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~ncdef_2d_curr proc~curr_accumulate->proc~esirkepov_2d_curr proc~curr_accumulate->proc~esirkepov_3d_curr proc~ncdef_3d_curr ncdef_3d_curr proc~curr_accumulate->proc~ncdef_3d_curr proc~ncdef_3d_curr->proc~set_local_3d_positions proc~set_part3d_hcell_acc->proc~set_local_3d_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/map2dy_part_sind.html"},{"title":"map2dz_part_sind – ALaDyn","text":"private subroutine map2dz_part_sind(np, ic1, pt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: ic1 real(kind=dp), intent(inout) :: pt (:,:) Calls proc~~map2dz_part_sind~~CallsGraph proc~map2dz_part_sind map2dz_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dz_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~map2dz_part_sind~~CalledByGraph proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind map3d_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~set_local_3d_positions set_local_3d_positions proc~set_local_3d_positions->proc~map3d_part_sind proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~set_local_3d_positions proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~set_local_3d_positions proc~esirkepov_3d_curr esirkepov_3d_curr proc~esirkepov_3d_curr->proc~set_local_3d_positions proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~set_local_3d_positions proc~ncdef_3d_curr ncdef_3d_curr proc~ncdef_3d_curr->proc~set_local_3d_positions proc~set_env_density set_env_density proc~set_env_density->proc~set_local_3d_positions proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~set_local_3d_positions proc~set_env_acc set_env_acc proc~set_env_acc->proc~set_local_3d_positions proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~set_local_3d_positions proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_part3d_hcell_acc->proc~set_local_3d_positions proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~set_local_3d_positions proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~set_local_3d_positions proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~esirkepov_3d_curr proc~curr_accumulate->proc~ncdef_3d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/map2dz_part_sind.html"},{"title":"map3d_part_sind – ALaDyn","text":"public subroutine map3d_part_sind(pt, np, ic1, ic2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ic1 integer, intent(in) :: ic2 Calls proc~~map3d_part_sind~~CallsGraph proc~map3d_part_sind map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~map3d_part_sind~~CalledByGraph proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions set_local_3d_positions proc~set_local_3d_positions->proc~map3d_part_sind proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~set_local_3d_positions proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~set_local_3d_positions proc~esirkepov_3d_curr esirkepov_3d_curr proc~esirkepov_3d_curr->proc~set_local_3d_positions proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~set_local_3d_positions proc~ncdef_3d_curr ncdef_3d_curr proc~ncdef_3d_curr->proc~set_local_3d_positions proc~set_env_density set_env_density proc~set_env_density->proc~set_local_3d_positions proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~set_local_3d_positions proc~set_env_acc set_env_acc proc~set_env_acc->proc~set_local_3d_positions proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~set_local_3d_positions proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_part3d_hcell_acc->proc~set_local_3d_positions proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~set_local_3d_positions proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~set_local_3d_positions proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~esirkepov_3d_curr proc~curr_accumulate->proc~ncdef_3d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/map3d_part_sind.html"},{"title":"beam_data – ALaDyn","text":"public subroutine beam_data(ndm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndm Calls proc~~beam_data~~CallsGraph proc~beam_data beam_data ebfb ebfb proc~beam_data->ebfb unit_charge unit_charge proc~beam_data->unit_charge exchange_2d_grdata exchange_2d_grdata proc~beam_data->exchange_2d_grdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~beam_data~~CalledByGraph proc~beam_data beam_data proc~beam_inject beam_inject proc~beam_inject->proc~beam_data proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/beam_data.html"},{"title":"mpi_beam_ftgrid_distribute – ALaDyn","text":"public subroutine mpi_beam_ftgrid_distribute(ndm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndm Calls proc~~mpi_beam_ftgrid_distribute~~CallsGraph proc~mpi_beam_ftgrid_distribute mpi_beam_ftgrid_distribute loc_nbpart loc_nbpart proc~mpi_beam_ftgrid_distribute->loc_nbpart bunch bunch proc~mpi_beam_ftgrid_distribute->bunch ebfb ebfb proc~mpi_beam_ftgrid_distribute->ebfb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpi_beam_ftgrid_distribute~~CalledByGraph proc~mpi_beam_ftgrid_distribute mpi_beam_ftgrid_distribute proc~beam_inject beam_inject proc~beam_inject->proc~mpi_beam_ftgrid_distribute proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_beam_ftgrid_distribute.html"},{"title":"mpi_beam_distribute – ALaDyn","text":"public subroutine mpi_beam_distribute(ndm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndm Calls proc~~mpi_beam_distribute~~CallsGraph proc~mpi_beam_distribute mpi_beam_distribute loc_nbpart loc_nbpart proc~mpi_beam_distribute->loc_nbpart bunch bunch proc~mpi_beam_distribute->bunch ebfb ebfb proc~mpi_beam_distribute->ebfb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpi_beam_distribute~~CalledByGraph proc~mpi_beam_distribute mpi_beam_distribute proc~beam_inject beam_inject proc~beam_inject->proc~mpi_beam_distribute proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_beam_distribute.html"},{"title":"beam_model_pot – ALaDyn","text":"public subroutine beam_model_pot(poten, sx, sy, sz, b_am, i1, i2, j1, j2, k1, k2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: poten (:,:,:,:) real(kind=dp), intent(in) :: sx real(kind=dp), intent(in) :: sy real(kind=dp), intent(in) :: sz real(kind=dp), intent(in) :: b_am integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 Contents None","tags":"","loc":"proc/beam_model_pot.html"},{"title":"beam_inject – ALaDyn","text":"public subroutine beam_inject() Arguments None Calls proc~~beam_inject~~CallsGraph proc~beam_inject beam_inject ebf_bunch ebf_bunch proc~beam_inject->ebf_bunch proc~initial_beam_fields initial_beam_fields proc~beam_inject->proc~initial_beam_fields proc~p_alloc p_alloc proc~beam_inject->proc~p_alloc loc_nbpart loc_nbpart proc~beam_inject->loc_nbpart proc~init_random_seed init_random_seed proc~beam_inject->proc~init_random_seed pot pot proc~beam_inject->pot proc~beam_data beam_data proc~beam_inject->proc~beam_data proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~beam_inject->proc~fill_ebfield_yzxbdsdata proc~mpi_beam_ftgrid_distribute mpi_beam_ftgrid_distribute proc~beam_inject->proc~mpi_beam_ftgrid_distribute loc_npart loc_npart proc~beam_inject->loc_npart lp_end lp_end proc~beam_inject->lp_end ebf ebf proc~beam_inject->ebf proc~mpi_beam_distribute mpi_beam_distribute proc~beam_inject->proc~mpi_beam_distribute ebfp ebfp proc~beam_inject->ebfp spec spec proc~beam_inject->spec bunch bunch proc~beam_inject->bunch jc jc proc~beam_inject->jc ebfb ebfb proc~beam_inject->ebfb loc_yg loc_yg proc~initial_beam_fields->loc_yg loc_zg loc_zg proc~initial_beam_fields->loc_zg proc~beam_data->ebfb exchange_2d_grdata exchange_2d_grdata proc~beam_data->exchange_2d_grdata unit_charge unit_charge proc~beam_data->unit_charge proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~mpi_beam_ftgrid_distribute->loc_nbpart proc~mpi_beam_ftgrid_distribute->bunch proc~mpi_beam_ftgrid_distribute->ebfb proc~mpi_beam_distribute->loc_nbpart proc~mpi_beam_distribute->bunch proc~mpi_beam_distribute->ebfb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~beam_inject~~CalledByGraph proc~beam_inject beam_inject proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/beam_inject.html"},{"title":"initial_tparticles_select – ALaDyn","text":"public subroutine initial_tparticles_select(tx1, ty1) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: tx1 real(kind=dp), intent(in) :: ty1 Calls proc~~initial_tparticles_select~~CallsGraph proc~initial_tparticles_select initial_tparticles_select loc_tpart loc_tpart proc~initial_tparticles_select->loc_tpart t0_pl t0_pl proc~initial_tparticles_select->t0_pl intvec_distribute intvec_distribute proc~initial_tparticles_select->intvec_distribute loc_npart loc_npart proc~initial_tparticles_select->loc_npart loc_ygrid loc_ygrid proc~initial_tparticles_select->loc_ygrid pdata_tracking pdata_tracking proc~initial_tparticles_select->pdata_tracking ebfp ebfp proc~initial_tparticles_select->ebfp spec spec proc~initial_tparticles_select->spec track_aux track_aux proc~initial_tparticles_select->track_aux Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/initial_tparticles_select.html"},{"title":"t_particles_collect – ALaDyn","text":"public subroutine t_particles_collect(time_ind) Arguments Type Intent Optional Attributes Name integer, intent(in) :: time_ind Calls proc~~t_particles_collect~~CallsGraph proc~t_particles_collect t_particles_collect loc_tpart loc_tpart proc~t_particles_collect->loc_tpart intvec_distribute intvec_distribute proc~t_particles_collect->intvec_distribute exchange_1d_grdata exchange_1d_grdata proc~t_particles_collect->exchange_1d_grdata loc_zgrid loc_zgrid proc~t_particles_collect->loc_zgrid loc_npart loc_npart proc~t_particles_collect->loc_npart loc_ygrid loc_ygrid proc~t_particles_collect->loc_ygrid loc_xgrid loc_xgrid proc~t_particles_collect->loc_xgrid pdata_tracking pdata_tracking proc~t_particles_collect->pdata_tracking spec spec proc~t_particles_collect->spec track_aux track_aux proc~t_particles_collect->track_aux str_indx str_indx proc~t_particles_collect->str_indx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/t_particles_collect.html"},{"title":"fill_density_data – ALaDyn","text":"public subroutine fill_density_data(den, ic) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: den (:,:,:,:) integer, intent(in) :: ic Calls proc~~fill_density_data~~CallsGraph proc~fill_density_data fill_density_data loc_zgrid loc_zgrid proc~fill_density_data->loc_zgrid y y proc~fill_density_data->y x x proc~fill_density_data->x loc_ygrid loc_ygrid proc~fill_density_data->loc_ygrid z z proc~fill_density_data->z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fill_density_data~~CalledByGraph proc~fill_density_data fill_density_data proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fill_density_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fill_density_data.html"},{"title":"collect_bunch_and_plasma_density – ALaDyn","text":"public subroutine collect_bunch_and_plasma_density(this_bunch, isp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: this_bunch integer, intent(in) :: isp Calls proc~~collect_bunch_and_plasma_density~~CallsGraph proc~collect_bunch_and_plasma_density collect_bunch_and_plasma_density proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~collect_bunch_and_plasma_density->proc~fill_curr_yzxbdsdata loc_nbpart loc_nbpart proc~collect_bunch_and_plasma_density->loc_nbpart loc_yg loc_yg proc~collect_bunch_and_plasma_density->loc_yg loc_npart loc_npart proc~collect_bunch_and_plasma_density->loc_npart loc_zg loc_zg proc~collect_bunch_and_plasma_density->loc_zg spec spec proc~collect_bunch_and_plasma_density->spec bunch bunch proc~collect_bunch_and_plasma_density->bunch jc jc proc~collect_bunch_and_plasma_density->jc proc~exchange_bdx_data exchange_bdx_data proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/collect_bunch_and_plasma_density.html"},{"title":"prl_bden_energy_interp – ALaDyn","text":"public subroutine prl_bden_energy_interp(ic) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic Calls proc~~prl_bden_energy_interp~~CallsGraph proc~prl_bden_energy_interp prl_bden_energy_interp proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~prl_bden_energy_interp->proc~fill_curr_yzxbdsdata loc_nbpart loc_nbpart proc~prl_bden_energy_interp->loc_nbpart loc_yg loc_yg proc~prl_bden_energy_interp->loc_yg loc_zg loc_zg proc~prl_bden_energy_interp->loc_zg bunch bunch proc~prl_bden_energy_interp->bunch jc jc proc~prl_bden_energy_interp->jc proc~exchange_bdx_data exchange_bdx_data proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/prl_bden_energy_interp.html"},{"title":"prl_den_energy_interp – ALaDyn","text":"public subroutine prl_den_energy_interp(ic, cmp_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(in) :: cmp_out Calls proc~~prl_den_energy_interp~~CallsGraph proc~prl_den_energy_interp prl_den_energy_interp env env proc~prl_den_energy_interp->env loc_yg loc_yg proc~prl_den_energy_interp->loc_yg loc_npart loc_npart proc~prl_den_energy_interp->loc_npart proc~den_zyxbd den_zyxbd proc~prl_den_energy_interp->proc~den_zyxbd jc jc proc~prl_den_energy_interp->jc loc_zg loc_zg proc~prl_den_energy_interp->loc_zg spec spec proc~prl_den_energy_interp->spec mass mass proc~prl_den_energy_interp->mass Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~prl_den_energy_interp~~CalledByGraph proc~prl_den_energy_interp prl_den_energy_interp proc~data_out data_out proc~data_out->proc~prl_den_energy_interp proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/prl_den_energy_interp.html"},{"title":"set_wake_potential – ALaDyn","text":"public subroutine set_wake_potential() Arguments None Calls proc~~set_wake_potential~~CallsGraph proc~set_wake_potential set_wake_potential proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~set_wake_potential->proc~fill_curr_yzxbdsdata proc~fft_2d_psolv fft_2d_psolv proc~set_wake_potential->proc~fft_2d_psolv proc~fill_density_data fill_density_data proc~set_wake_potential->proc~fill_density_data loc_npart loc_npart proc~set_wake_potential->loc_npart spec spec proc~set_wake_potential->spec jc jc proc~set_wake_potential->jc proc~exchange_bdx_data exchange_bdx_data proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data proc~mpi_ftw_alloc mpi_ftw_alloc proc~fft_2d_psolv->proc~mpi_ftw_alloc all_gather_dpreal all_gather_dpreal proc~fft_2d_psolv->all_gather_dpreal proc~beam_2d_potential beam_2d_potential proc~fft_2d_psolv->proc~beam_2d_potential proc~mpi_yzft_ord mpi_yzft_ord proc~fft_2d_psolv->proc~mpi_yzft_ord proc~pftw2d pftw2d proc~fft_2d_psolv->proc~pftw2d proc~pftw2d_sc pftw2d_sc proc~fft_2d_psolv->proc~pftw2d_sc ftw_init ftw_init proc~fft_2d_psolv->ftw_init proc~mpi_ftw_dalloc mpi_ftw_dalloc proc~fft_2d_psolv->proc~mpi_ftw_dalloc proc~unif_to_str_field_interp unif_to_str_field_interp proc~fft_2d_psolv->proc~unif_to_str_field_interp ftw_end ftw_end proc~fft_2d_psolv->ftw_end proc~ft_overset_grid ft_overset_grid proc~fft_2d_psolv->proc~ft_overset_grid loc_zgrid loc_zgrid proc~fill_density_data->loc_zgrid y y proc~fill_density_data->y x x proc~fill_density_data->x loc_ygrid loc_ygrid proc~fill_density_data->loc_ygrid z z proc~fill_density_data->z proc~swap_xy_3data swap_xy_3data proc~pftw2d->proc~swap_xy_3data proc~ftw1d ftw1d proc~pftw2d->proc~ftw1d proc~swap_xy_3data_inv swap_xy_3data_inv proc~pftw2d->proc~swap_xy_3data_inv proc~swap_xz_3data swap_xz_3data proc~pftw2d->proc~swap_xz_3data proc~swap_xz_3data_inv swap_xz_3data_inv proc~pftw2d->proc~swap_xz_3data_inv proc~pftw2d_sc->proc~swap_xy_3data proc~pftw2d_sc->proc~swap_xy_3data_inv proc~ftw1d_sc ftw1d_sc proc~pftw2d_sc->proc~ftw1d_sc proc~pftw2d_sc->proc~swap_xz_3data proc~pftw2d_sc->proc~swap_xz_3data_inv yft_ind yft_ind proc~unif_to_str_field_interp->yft_ind loc_yg loc_yg proc~unif_to_str_field_interp->loc_yg loc_zft loc_zft proc~unif_to_str_field_interp->loc_zft zft_ind zft_ind proc~unif_to_str_field_interp->zft_ind loc_zg loc_zg proc~unif_to_str_field_interp->loc_zg loc_yft loc_yft proc~unif_to_str_field_interp->loc_yft zp_next zp_next proc~ft_overset_grid->zp_next zp_prev zp_prev proc~ft_overset_grid->zp_prev yp_next yp_next proc~ft_overset_grid->yp_next comm_col comm_col proc~ft_overset_grid->comm_col yp_prev yp_prev proc~ft_overset_grid->yp_prev proc~swap_xy_3data->yp_next proc~swap_xy_3data->comm_col proc~swap_xy_3data->yp_prev interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~ftw1d->interface~fftw_execute_dft_r2c interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~ftw1d->interface~fftw_execute_dft_c2r proc~swap_xy_3data_inv->yp_next proc~swap_xy_3data_inv->comm_col proc~swap_xy_3data_inv->yp_prev interface~fftw_execute_r2r fftw_execute_r2r proc~ftw1d_sc->interface~fftw_execute_r2r proc~determine_kind determine_kind proc~ftw1d_sc->proc~determine_kind proc~logical_dimension logical_dimension proc~ftw1d_sc->proc~logical_dimension proc~swap_xz_3data->zp_next proc~swap_xz_3data->zp_prev proc~swap_xz_3data->comm_col proc~swap_xz_3data_inv->zp_next proc~swap_xz_3data_inv->zp_prev proc~swap_xz_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_wake_potential.html"},{"title":"lp_pulse – ALaDyn","text":"public subroutine lp_pulse(lp_mod, part_in) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lp_mod real(kind=dp), intent(out) :: part_in Calls proc~~lp_pulse~~CallsGraph proc~lp_pulse lp_pulse proc~init_lp_inc0_fields init_lp_inc0_fields proc~lp_pulse->proc~init_lp_inc0_fields lp_in lp_in proc~lp_pulse->lp_in y0_cent y0_cent proc~lp_pulse->y0_cent lp_end lp_end proc~lp_pulse->lp_end xc_loc xc_loc proc~lp_pulse->xc_loc loc_xgrid loc_xgrid proc~lp_pulse->loc_xgrid xf_loc xf_loc proc~lp_pulse->xf_loc lp_delay lp_delay proc~lp_pulse->lp_delay z0_cent z0_cent proc~lp_pulse->z0_cent lpx lpx proc~lp_pulse->lpx loc_zgrid loc_zgrid proc~init_lp_inc0_fields->loc_zgrid proc~get_plane_wave_lp get_plane_wave_lp proc~init_lp_inc0_fields->proc~get_plane_wave_lp proc~get_laser_fields_lp get_laser_fields_lp proc~init_lp_inc0_fields->proc~get_laser_fields_lp proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_fields_lp loc_yg loc_yg proc~init_lp_inc0_fields->loc_yg loc_xg loc_xg proc~init_lp_inc0_fields->loc_xg proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_gprof_fields_lp loc_ygrid loc_ygrid proc~init_lp_inc0_fields->loc_ygrid proc~get_laser_gprof_fields_lp get_laser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_laser_gprof_fields_lp loc_zg loc_zg proc~init_lp_inc0_fields->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~lp_pulse~~CalledByGraph proc~lp_pulse lp_pulse proc~init init proc~init->proc~lp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/lp_pulse.html"},{"title":"cp_pulse – ALaDyn","text":"public subroutine cp_pulse(cp_mod, part_in) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cp_mod real(kind=dp), intent(out) :: part_in Calls proc~~cp_pulse~~CallsGraph proc~cp_pulse cp_pulse proc~init_cp_fields init_cp_fields proc~cp_pulse->proc~init_cp_fields lp_in lp_in proc~cp_pulse->lp_in lp_end lp_end proc~cp_pulse->lp_end loc_xgrid loc_xgrid proc~cp_pulse->loc_xgrid lpx lpx proc~cp_pulse->lpx loc_zgrid loc_zgrid proc~init_cp_fields->loc_zgrid proc~get_plane_wave_cp get_plane_wave_cp proc~init_cp_fields->proc~get_plane_wave_cp loc_yg loc_yg proc~init_cp_fields->loc_yg loc_xg loc_xg proc~init_cp_fields->loc_xg loc_ygrid loc_ygrid proc~init_cp_fields->loc_ygrid loc_zg loc_zg proc~init_cp_fields->loc_zg proc~get_laser_fields_cp get_laser_fields_cp proc~init_cp_fields->proc~get_laser_fields_cp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cp_pulse~~CalledByGraph proc~cp_pulse cp_pulse proc~init init proc~init->proc~cp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cp_pulse.html"},{"title":"set_envelope – ALaDyn","text":"public subroutine set_envelope(part_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: part_in Calls proc~~set_envelope~~CallsGraph proc~set_envelope set_envelope proc~init_envelope_field init_envelope_field proc~set_envelope->proc~init_envelope_field lp_in lp_in proc~set_envelope->lp_in y0_cent y0_cent proc~set_envelope->y0_cent z0_cent z0_cent proc~set_envelope->z0_cent xc_loc xc_loc proc~set_envelope->xc_loc lp_end lp_end proc~set_envelope->lp_end loc_xgrid loc_xgrid proc~set_envelope->loc_xgrid xf_loc xf_loc proc~set_envelope->xf_loc lp_delay lp_delay proc~set_envelope->lp_delay proc~init_gprof_envelope_field init_gprof_envelope_field proc~set_envelope->proc~init_gprof_envelope_field lpx lpx proc~set_envelope->lpx loc_zgrid loc_zgrid proc~init_envelope_field->loc_zgrid loc_yg loc_yg proc~init_envelope_field->loc_yg loc_xg loc_xg proc~init_envelope_field->loc_xg loc_ygrid loc_ygrid proc~init_envelope_field->loc_ygrid loc_zg loc_zg proc~init_envelope_field->loc_zg proc~init_gprof_envelope_field->loc_zgrid proc~init_gprof_envelope_field->loc_yg proc~init_gprof_envelope_field->loc_xg proc~init_gprof_envelope_field->loc_ygrid proc~init_gprof_envelope_field->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_envelope~~CalledByGraph proc~set_envelope set_envelope proc~init init proc~init->proc~set_envelope proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_envelope.html"},{"title":"init – ALaDyn","text":"public subroutine init() Arguments None Calls proc~~init~~CallsGraph proc~init init proc~lp_pulse lp_pulse proc~init->proc~lp_pulse proc~part_distribute part_distribute proc~init->proc~part_distribute proc~cp_pulse cp_pulse proc~init->proc~cp_pulse proc~set_envelope set_envelope proc~init->proc~set_envelope y0_cent y0_cent proc~lp_pulse->y0_cent lp_end lp_end proc~lp_pulse->lp_end loc_xgrid loc_xgrid proc~lp_pulse->loc_xgrid proc~init_lp_inc0_fields init_lp_inc0_fields proc~lp_pulse->proc~init_lp_inc0_fields z0_cent z0_cent proc~lp_pulse->z0_cent xc_loc xc_loc proc~lp_pulse->xc_loc lp_in lp_in proc~lp_pulse->lp_in xf_loc xf_loc proc~lp_pulse->xf_loc lp_delay lp_delay proc~lp_pulse->lp_delay lpx lpx proc~lp_pulse->lpx proc~multi_layer_threesp_target multi_layer_threesp_target proc~part_distribute->proc~multi_layer_threesp_target proc~multi_layer_gas_target multi_layer_gas_target proc~part_distribute->proc~multi_layer_gas_target proc~preplasma_multisp preplasma_multisp proc~part_distribute->proc~preplasma_multisp proc~one_layer_nano_tubes one_layer_nano_tubes proc~part_distribute->proc~one_layer_nano_tubes proc~one_layer_nano_wires one_layer_nano_wires proc~part_distribute->proc~one_layer_nano_wires proc~multi_layer_twosp_target multi_layer_twosp_target proc~part_distribute->proc~multi_layer_twosp_target proc~init_cp_fields init_cp_fields proc~cp_pulse->proc~init_cp_fields proc~cp_pulse->lp_end proc~cp_pulse->loc_xgrid proc~cp_pulse->lp_in proc~cp_pulse->lpx proc~set_envelope->y0_cent proc~set_envelope->lp_end proc~set_envelope->loc_xgrid proc~init_gprof_envelope_field init_gprof_envelope_field proc~set_envelope->proc~init_gprof_envelope_field proc~set_envelope->z0_cent proc~init_envelope_field init_envelope_field proc~set_envelope->proc~init_envelope_field proc~set_envelope->xc_loc proc~set_envelope->lp_in proc~set_envelope->xf_loc proc~set_envelope->lp_delay proc~set_envelope->lpx proc~get_plane_wave_cp get_plane_wave_cp proc~init_cp_fields->proc~get_plane_wave_cp loc_zg loc_zg proc~init_cp_fields->loc_zg proc~get_laser_fields_cp get_laser_fields_cp proc~init_cp_fields->proc~get_laser_fields_cp loc_zgrid loc_zgrid proc~init_cp_fields->loc_zgrid loc_yg loc_yg proc~init_cp_fields->loc_yg loc_xg loc_xg proc~init_cp_fields->loc_xg loc_ygrid loc_ygrid proc~init_cp_fields->loc_ygrid proc~init_gprof_envelope_field->loc_zg proc~init_gprof_envelope_field->loc_zgrid proc~init_gprof_envelope_field->loc_yg proc~init_gprof_envelope_field->loc_xg proc~init_gprof_envelope_field->loc_ygrid wghpt wghpt proc~multi_layer_threesp_target->wghpt loc_xpt loc_xpt proc~multi_layer_threesp_target->loc_xpt loc_wghx loc_wghx proc~multi_layer_threesp_target->loc_wghx proc~p_alloc p_alloc proc~multi_layer_threesp_target->proc~p_alloc proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~multi_layer_threesp_target->proc~set_uniform_yz_distrib xpt xpt proc~multi_layer_threesp_target->xpt spec spec proc~multi_layer_threesp_target->spec proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_gprof_fields_lp proc~get_laser_gprof_fields_lp get_laser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_laser_gprof_fields_lp proc~init_lp_inc0_fields->loc_zg proc~init_lp_inc0_fields->loc_zgrid proc~get_laser_fields_lp get_laser_fields_lp proc~init_lp_inc0_fields->proc~get_laser_fields_lp proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_fields_lp proc~init_lp_inc0_fields->loc_yg proc~init_lp_inc0_fields->loc_xg proc~get_plane_wave_lp get_plane_wave_lp proc~init_lp_inc0_fields->proc~get_plane_wave_lp proc~init_lp_inc0_fields->loc_ygrid proc~multi_layer_gas_target->wghpt proc~multi_layer_gas_target->loc_xpt proc~multi_layer_gas_target->loc_wghx proc~multi_layer_gas_target->proc~p_alloc proc~multi_layer_gas_target->proc~set_uniform_yz_distrib proc~mpi_x_part_distrib mpi_x_part_distrib proc~multi_layer_gas_target->proc~mpi_x_part_distrib proc~multi_layer_gas_target->xpt proc~multi_layer_gas_target->spec proc~preplasma_multisp->wghpt proc~preplasma_multisp->loc_xpt proc~preplasma_multisp->loc_wghx proc~preplasma_multisp->proc~p_alloc proc~preplasma_multisp->proc~set_uniform_yz_distrib proc~preplasma_multisp->xpt proc~preplasma_multisp->spec proc~init_envelope_field->loc_zg proc~init_envelope_field->loc_zgrid proc~init_envelope_field->loc_yg proc~init_envelope_field->loc_xg proc~init_envelope_field->loc_ygrid proc~one_layer_nano_tubes->wghpt proc~one_layer_nano_tubes->loc_xpt zpt zpt proc~one_layer_nano_tubes->zpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~one_layer_nano_tubes->proc~mpi_yz_part_distrib proc~one_layer_nano_tubes->proc~p_alloc loc_wghyz loc_wghyz proc~one_layer_nano_tubes->loc_wghyz proc~init_random_seed init_random_seed proc~one_layer_nano_tubes->proc~init_random_seed proc~one_layer_nano_tubes->xpt loc_ypt loc_ypt proc~one_layer_nano_tubes->loc_ypt loc_zpt loc_zpt proc~one_layer_nano_tubes->loc_zpt ypt ypt proc~one_layer_nano_tubes->ypt proc~one_layer_nano_tubes->spec proc~gasdev gasdev proc~one_layer_nano_tubes->proc~gasdev proc~one_layer_nano_wires->wghpt proc~one_layer_nano_wires->loc_xpt proc~one_layer_nano_wires->loc_wghx proc~set_pgrid_ind set_pgrid_ind proc~one_layer_nano_wires->proc~set_pgrid_ind proc~one_layer_nano_wires->zpt proc~one_layer_nano_wires->proc~mpi_yz_part_distrib proc~one_layer_nano_wires->proc~p_alloc proc~one_layer_nano_wires->loc_wghyz proc~one_layer_nano_wires->xpt proc~one_layer_nano_wires->loc_ypt proc~one_layer_nano_wires->loc_zpt proc~one_layer_nano_wires->ypt proc~one_layer_nano_wires->spec proc~multi_layer_twosp_target->wghpt proc~multi_layer_twosp_target->loc_xpt proc~multi_layer_twosp_target->loc_wghx proc~multi_layer_twosp_target->proc~p_alloc proc~multi_layer_twosp_target->proc~set_uniform_yz_distrib proc~multi_layer_twosp_target->xpt proc~multi_layer_twosp_target->spec proc~set_pgrid_ind->zpt proc~set_pgrid_ind->ypt proc~mpi_yz_part_distrib->zpt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->ypt proc~set_uniform_yz_distrib->proc~set_pgrid_ind proc~set_uniform_yz_distrib->zpt proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib proc~set_uniform_yz_distrib->loc_wghyz proc~set_uniform_yz_distrib->loc_ypt proc~set_uniform_yz_distrib->loc_zpt proc~set_uniform_yz_distrib->ypt proc~mpi_x_part_distrib->wghpt proc~mpi_x_part_distrib->loc_xpt proc~mpi_x_part_distrib->loc_wghx proc~mpi_x_part_distrib->xpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init~~CalledByGraph proc~init init proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init.html"},{"title":"set_pgrid_xind – ALaDyn","text":"private subroutine set_pgrid_xind(npx, ic) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npx integer, intent(in) :: ic Calls proc~~set_pgrid_xind~~CallsGraph proc~set_pgrid_xind set_pgrid_xind xpt xpt proc~set_pgrid_xind->xpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_pgrid_xind.html"},{"title":"set_pgrid_ind – ALaDyn","text":"private subroutine set_pgrid_ind(npy, npz, ic) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npy integer, intent(in) :: npz integer, intent(in) :: ic Calls proc~~set_pgrid_ind~~CallsGraph proc~set_pgrid_ind set_pgrid_ind ypt ypt proc~set_pgrid_ind->ypt zpt zpt proc~set_pgrid_ind->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_pgrid_ind~~CalledByGraph proc~set_pgrid_ind set_pgrid_ind proc~one_layer_nano_wires one_layer_nano_wires proc~one_layer_nano_wires->proc~set_pgrid_ind proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~set_uniform_yz_distrib->proc~set_pgrid_ind proc~multi_layer_threesp_target multi_layer_threesp_target proc~multi_layer_threesp_target->proc~set_uniform_yz_distrib proc~multi_layer_twosp_target multi_layer_twosp_target proc~multi_layer_twosp_target->proc~set_uniform_yz_distrib proc~multi_layer_gas_target multi_layer_gas_target proc~multi_layer_gas_target->proc~set_uniform_yz_distrib proc~preplasma_multisp preplasma_multisp proc~preplasma_multisp->proc~set_uniform_yz_distrib proc~part_distribute part_distribute proc~part_distribute->proc~one_layer_nano_wires proc~part_distribute->proc~multi_layer_threesp_target proc~part_distribute->proc~multi_layer_twosp_target proc~part_distribute->proc~multi_layer_gas_target proc~part_distribute->proc~preplasma_multisp proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_pgrid_ind.html"},{"title":"pspecies_distribute – ALaDyn","text":"private subroutine pspecies_distribute(loc_sp, t_x, ch, q, ic, i2, p) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: loc_sp real(kind=dp), intent(in) :: t_x real(kind=dp), intent(in) :: ch integer, intent(in) :: q integer, intent(in) :: ic integer, intent(in) :: i2 integer, intent(out) :: p Calls proc~~pspecies_distribute~~CallsGraph proc~pspecies_distribute pspecies_distribute loc_zpt loc_zpt proc~pspecies_distribute->loc_zpt loc_ypt loc_ypt proc~pspecies_distribute->loc_ypt loc_wghyz loc_wghyz proc~pspecies_distribute->loc_wghyz proc~init_random_seed init_random_seed proc~pspecies_distribute->proc~init_random_seed loc_wghx loc_wghx proc~pspecies_distribute->loc_wghx proc~gasdev gasdev proc~pspecies_distribute->proc~gasdev loc_xpt loc_xpt proc~pspecies_distribute->loc_xpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pspecies_distribute.html"},{"title":"mpi_x_part_distrib – ALaDyn","text":"private subroutine mpi_x_part_distrib(nc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Calls proc~~mpi_x_part_distrib~~CallsGraph proc~mpi_x_part_distrib mpi_x_part_distrib xpt xpt proc~mpi_x_part_distrib->xpt loc_wghx loc_wghx proc~mpi_x_part_distrib->loc_wghx loc_xpt loc_xpt proc~mpi_x_part_distrib->loc_xpt wghpt wghpt proc~mpi_x_part_distrib->wghpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpi_x_part_distrib~~CalledByGraph proc~mpi_x_part_distrib mpi_x_part_distrib proc~multi_layer_gas_target multi_layer_gas_target proc~multi_layer_gas_target->proc~mpi_x_part_distrib proc~part_distribute part_distribute proc~part_distribute->proc~multi_layer_gas_target proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_x_part_distrib.html"},{"title":"mpi_yz_part_distrib – ALaDyn","text":"private subroutine mpi_yz_part_distrib(nc, ky2_in, kz2_in, nyc, nzc, ymt, zmt, whyz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: ky2_in (:) integer, intent(in) :: kz2_in (:) integer, intent(in) :: nyc (:) integer, intent(in) :: nzc (:) real(kind=dp), intent(in) :: ymt real(kind=dp), intent(in) :: zmt real(kind=dp), intent(in) :: whyz (:,:,:) Calls proc~~mpi_yz_part_distrib~~CallsGraph proc~mpi_yz_part_distrib mpi_yz_part_distrib loc_ypt loc_ypt proc~mpi_yz_part_distrib->loc_ypt loc_zpt loc_zpt proc~mpi_yz_part_distrib->loc_zpt loc_wghyz loc_wghyz proc~mpi_yz_part_distrib->loc_wghyz ypt ypt proc~mpi_yz_part_distrib->ypt zpt zpt proc~mpi_yz_part_distrib->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpi_yz_part_distrib~~CalledByGraph proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~one_layer_nano_tubes one_layer_nano_tubes proc~one_layer_nano_tubes->proc~mpi_yz_part_distrib proc~one_layer_nano_wires one_layer_nano_wires proc~one_layer_nano_wires->proc~mpi_yz_part_distrib proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib proc~multi_layer_threesp_target multi_layer_threesp_target proc~multi_layer_threesp_target->proc~set_uniform_yz_distrib proc~multi_layer_twosp_target multi_layer_twosp_target proc~multi_layer_twosp_target->proc~set_uniform_yz_distrib proc~multi_layer_gas_target multi_layer_gas_target proc~multi_layer_gas_target->proc~set_uniform_yz_distrib proc~preplasma_multisp preplasma_multisp proc~preplasma_multisp->proc~set_uniform_yz_distrib proc~part_distribute part_distribute proc~part_distribute->proc~one_layer_nano_tubes proc~part_distribute->proc~one_layer_nano_wires proc~part_distribute->proc~multi_layer_threesp_target proc~part_distribute->proc~multi_layer_twosp_target proc~part_distribute->proc~multi_layer_gas_target proc~part_distribute->proc~preplasma_multisp proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_yz_part_distrib.html"},{"title":"set_uniform_yz_distrib – ALaDyn","text":"private subroutine set_uniform_yz_distrib(nyh_in, nc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in integer, intent(in) :: nc Calls proc~~set_uniform_yz_distrib~~CallsGraph proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib loc_zpt loc_zpt proc~set_uniform_yz_distrib->loc_zpt loc_ypt loc_ypt proc~set_uniform_yz_distrib->loc_ypt loc_wghyz loc_wghyz proc~set_uniform_yz_distrib->loc_wghyz proc~set_pgrid_ind set_pgrid_ind proc~set_uniform_yz_distrib->proc~set_pgrid_ind ypt ypt proc~set_uniform_yz_distrib->ypt zpt zpt proc~set_uniform_yz_distrib->zpt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->ypt proc~mpi_yz_part_distrib->zpt proc~set_pgrid_ind->ypt proc~set_pgrid_ind->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_uniform_yz_distrib~~CalledByGraph proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~preplasma_multisp preplasma_multisp proc~preplasma_multisp->proc~set_uniform_yz_distrib proc~multi_layer_twosp_target multi_layer_twosp_target proc~multi_layer_twosp_target->proc~set_uniform_yz_distrib proc~multi_layer_gas_target multi_layer_gas_target proc~multi_layer_gas_target->proc~set_uniform_yz_distrib proc~multi_layer_threesp_target multi_layer_threesp_target proc~multi_layer_threesp_target->proc~set_uniform_yz_distrib proc~part_distribute part_distribute proc~part_distribute->proc~preplasma_multisp proc~part_distribute->proc~multi_layer_twosp_target proc~part_distribute->proc~multi_layer_gas_target proc~part_distribute->proc~multi_layer_threesp_target proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_uniform_yz_distrib.html"},{"title":"multi_layer_gas_target – ALaDyn","text":"private subroutine multi_layer_gas_target(layer_mod, nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: layer_mod integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 Calls proc~~multi_layer_gas_target~~CallsGraph proc~multi_layer_gas_target multi_layer_gas_target xpt xpt proc~multi_layer_gas_target->xpt proc~p_alloc p_alloc proc~multi_layer_gas_target->proc~p_alloc loc_wghx loc_wghx proc~multi_layer_gas_target->loc_wghx proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~multi_layer_gas_target->proc~set_uniform_yz_distrib wghpt wghpt proc~multi_layer_gas_target->wghpt proc~mpi_x_part_distrib mpi_x_part_distrib proc~multi_layer_gas_target->proc~mpi_x_part_distrib spec spec proc~multi_layer_gas_target->spec loc_xpt loc_xpt proc~multi_layer_gas_target->loc_xpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib loc_zpt loc_zpt proc~set_uniform_yz_distrib->loc_zpt loc_ypt loc_ypt proc~set_uniform_yz_distrib->loc_ypt loc_wghyz loc_wghyz proc~set_uniform_yz_distrib->loc_wghyz proc~set_pgrid_ind set_pgrid_ind proc~set_uniform_yz_distrib->proc~set_pgrid_ind ypt ypt proc~set_uniform_yz_distrib->ypt zpt zpt proc~set_uniform_yz_distrib->zpt proc~mpi_x_part_distrib->xpt proc~mpi_x_part_distrib->loc_wghx proc~mpi_x_part_distrib->wghpt proc~mpi_x_part_distrib->loc_xpt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->ypt proc~mpi_yz_part_distrib->zpt proc~set_pgrid_ind->ypt proc~set_pgrid_ind->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~multi_layer_gas_target~~CalledByGraph proc~multi_layer_gas_target multi_layer_gas_target proc~part_distribute part_distribute proc~part_distribute->proc~multi_layer_gas_target proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/multi_layer_gas_target.html"},{"title":"preplasma_multisp – ALaDyn","text":"private subroutine preplasma_multisp(nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 Calls proc~~preplasma_multisp~~CallsGraph proc~preplasma_multisp preplasma_multisp xpt xpt proc~preplasma_multisp->xpt proc~p_alloc p_alloc proc~preplasma_multisp->proc~p_alloc loc_wghx loc_wghx proc~preplasma_multisp->loc_wghx proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~preplasma_multisp->proc~set_uniform_yz_distrib wghpt wghpt proc~preplasma_multisp->wghpt spec spec proc~preplasma_multisp->spec loc_xpt loc_xpt proc~preplasma_multisp->loc_xpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib loc_zpt loc_zpt proc~set_uniform_yz_distrib->loc_zpt loc_ypt loc_ypt proc~set_uniform_yz_distrib->loc_ypt loc_wghyz loc_wghyz proc~set_uniform_yz_distrib->loc_wghyz proc~set_pgrid_ind set_pgrid_ind proc~set_uniform_yz_distrib->proc~set_pgrid_ind ypt ypt proc~set_uniform_yz_distrib->ypt zpt zpt proc~set_uniform_yz_distrib->zpt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->ypt proc~mpi_yz_part_distrib->zpt proc~set_pgrid_ind->ypt proc~set_pgrid_ind->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~preplasma_multisp~~CalledByGraph proc~preplasma_multisp preplasma_multisp proc~part_distribute part_distribute proc~part_distribute->proc~preplasma_multisp proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/preplasma_multisp.html"},{"title":"multi_layer_twosp_target – ALaDyn","text":"private subroutine multi_layer_twosp_target(nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 Calls proc~~multi_layer_twosp_target~~CallsGraph proc~multi_layer_twosp_target multi_layer_twosp_target xpt xpt proc~multi_layer_twosp_target->xpt proc~p_alloc p_alloc proc~multi_layer_twosp_target->proc~p_alloc loc_wghx loc_wghx proc~multi_layer_twosp_target->loc_wghx proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~multi_layer_twosp_target->proc~set_uniform_yz_distrib wghpt wghpt proc~multi_layer_twosp_target->wghpt spec spec proc~multi_layer_twosp_target->spec loc_xpt loc_xpt proc~multi_layer_twosp_target->loc_xpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib loc_zpt loc_zpt proc~set_uniform_yz_distrib->loc_zpt loc_ypt loc_ypt proc~set_uniform_yz_distrib->loc_ypt loc_wghyz loc_wghyz proc~set_uniform_yz_distrib->loc_wghyz proc~set_pgrid_ind set_pgrid_ind proc~set_uniform_yz_distrib->proc~set_pgrid_ind ypt ypt proc~set_uniform_yz_distrib->ypt zpt zpt proc~set_uniform_yz_distrib->zpt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->ypt proc~mpi_yz_part_distrib->zpt proc~set_pgrid_ind->ypt proc~set_pgrid_ind->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~multi_layer_twosp_target~~CalledByGraph proc~multi_layer_twosp_target multi_layer_twosp_target proc~part_distribute part_distribute proc~part_distribute->proc~multi_layer_twosp_target proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/multi_layer_twosp_target.html"},{"title":"multi_layer_threesp_target – ALaDyn","text":"private subroutine multi_layer_threesp_target(nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 Calls proc~~multi_layer_threesp_target~~CallsGraph proc~multi_layer_threesp_target multi_layer_threesp_target xpt xpt proc~multi_layer_threesp_target->xpt proc~p_alloc p_alloc proc~multi_layer_threesp_target->proc~p_alloc loc_wghx loc_wghx proc~multi_layer_threesp_target->loc_wghx proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~multi_layer_threesp_target->proc~set_uniform_yz_distrib wghpt wghpt proc~multi_layer_threesp_target->wghpt spec spec proc~multi_layer_threesp_target->spec loc_xpt loc_xpt proc~multi_layer_threesp_target->loc_xpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib loc_zpt loc_zpt proc~set_uniform_yz_distrib->loc_zpt loc_ypt loc_ypt proc~set_uniform_yz_distrib->loc_ypt loc_wghyz loc_wghyz proc~set_uniform_yz_distrib->loc_wghyz proc~set_pgrid_ind set_pgrid_ind proc~set_uniform_yz_distrib->proc~set_pgrid_ind ypt ypt proc~set_uniform_yz_distrib->ypt zpt zpt proc~set_uniform_yz_distrib->zpt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->ypt proc~mpi_yz_part_distrib->zpt proc~set_pgrid_ind->ypt proc~set_pgrid_ind->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~multi_layer_threesp_target~~CalledByGraph proc~multi_layer_threesp_target multi_layer_threesp_target proc~part_distribute part_distribute proc~part_distribute->proc~multi_layer_threesp_target proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/multi_layer_threesp_target.html"},{"title":"one_layer_nano_wires – ALaDyn","text":"private subroutine one_layer_nano_wires(nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 Calls proc~~one_layer_nano_wires~~CallsGraph proc~one_layer_nano_wires one_layer_nano_wires xpt xpt proc~one_layer_nano_wires->xpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~one_layer_nano_wires->proc~mpi_yz_part_distrib loc_zpt loc_zpt proc~one_layer_nano_wires->loc_zpt loc_ypt loc_ypt proc~one_layer_nano_wires->loc_ypt loc_wghyz loc_wghyz proc~one_layer_nano_wires->loc_wghyz proc~p_alloc p_alloc proc~one_layer_nano_wires->proc~p_alloc ypt ypt proc~one_layer_nano_wires->ypt loc_wghx loc_wghx proc~one_layer_nano_wires->loc_wghx wghpt wghpt proc~one_layer_nano_wires->wghpt proc~set_pgrid_ind set_pgrid_ind proc~one_layer_nano_wires->proc~set_pgrid_ind spec spec proc~one_layer_nano_wires->spec loc_xpt loc_xpt proc~one_layer_nano_wires->loc_xpt zpt zpt proc~one_layer_nano_wires->zpt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->ypt proc~mpi_yz_part_distrib->zpt proc~set_pgrid_ind->ypt proc~set_pgrid_ind->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~one_layer_nano_wires~~CalledByGraph proc~one_layer_nano_wires one_layer_nano_wires proc~part_distribute part_distribute proc~part_distribute->proc~one_layer_nano_wires proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/one_layer_nano_wires.html"},{"title":"one_layer_nano_tubes – ALaDyn","text":"private subroutine one_layer_nano_tubes(nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 Calls proc~~one_layer_nano_tubes~~CallsGraph proc~one_layer_nano_tubes one_layer_nano_tubes xpt xpt proc~one_layer_nano_tubes->xpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~one_layer_nano_tubes->proc~mpi_yz_part_distrib loc_zpt loc_zpt proc~one_layer_nano_tubes->loc_zpt loc_ypt loc_ypt proc~one_layer_nano_tubes->loc_ypt loc_wghyz loc_wghyz proc~one_layer_nano_tubes->loc_wghyz proc~p_alloc p_alloc proc~one_layer_nano_tubes->proc~p_alloc proc~init_random_seed init_random_seed proc~one_layer_nano_tubes->proc~init_random_seed ypt ypt proc~one_layer_nano_tubes->ypt wghpt wghpt proc~one_layer_nano_tubes->wghpt spec spec proc~one_layer_nano_tubes->spec proc~gasdev gasdev proc~one_layer_nano_tubes->proc~gasdev loc_xpt loc_xpt proc~one_layer_nano_tubes->loc_xpt zpt zpt proc~one_layer_nano_tubes->zpt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->ypt proc~mpi_yz_part_distrib->zpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~one_layer_nano_tubes~~CalledByGraph proc~one_layer_nano_tubes one_layer_nano_tubes proc~part_distribute part_distribute proc~part_distribute->proc~one_layer_nano_tubes proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/one_layer_nano_tubes.html"},{"title":"part_distribute – ALaDyn","text":"public subroutine part_distribute(id, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: id real(kind=dp), intent(in) :: xf0 Calls proc~~part_distribute~~CallsGraph proc~part_distribute part_distribute proc~multi_layer_threesp_target multi_layer_threesp_target proc~part_distribute->proc~multi_layer_threesp_target proc~preplasma_multisp preplasma_multisp proc~part_distribute->proc~preplasma_multisp proc~one_layer_nano_tubes one_layer_nano_tubes proc~part_distribute->proc~one_layer_nano_tubes proc~one_layer_nano_wires one_layer_nano_wires proc~part_distribute->proc~one_layer_nano_wires proc~multi_layer_gas_target multi_layer_gas_target proc~part_distribute->proc~multi_layer_gas_target proc~multi_layer_twosp_target multi_layer_twosp_target proc~part_distribute->proc~multi_layer_twosp_target xpt xpt proc~multi_layer_threesp_target->xpt proc~p_alloc p_alloc proc~multi_layer_threesp_target->proc~p_alloc loc_wghx loc_wghx proc~multi_layer_threesp_target->loc_wghx proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~multi_layer_threesp_target->proc~set_uniform_yz_distrib wghpt wghpt proc~multi_layer_threesp_target->wghpt spec spec proc~multi_layer_threesp_target->spec loc_xpt loc_xpt proc~multi_layer_threesp_target->loc_xpt proc~preplasma_multisp->xpt proc~preplasma_multisp->proc~p_alloc proc~preplasma_multisp->loc_wghx proc~preplasma_multisp->proc~set_uniform_yz_distrib proc~preplasma_multisp->wghpt proc~preplasma_multisp->spec proc~preplasma_multisp->loc_xpt proc~one_layer_nano_tubes->xpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~one_layer_nano_tubes->proc~mpi_yz_part_distrib proc~one_layer_nano_tubes->proc~p_alloc loc_ypt loc_ypt proc~one_layer_nano_tubes->loc_ypt loc_zpt loc_zpt proc~one_layer_nano_tubes->loc_zpt loc_wghyz loc_wghyz proc~one_layer_nano_tubes->loc_wghyz proc~init_random_seed init_random_seed proc~one_layer_nano_tubes->proc~init_random_seed ypt ypt proc~one_layer_nano_tubes->ypt proc~one_layer_nano_tubes->wghpt proc~one_layer_nano_tubes->spec proc~gasdev gasdev proc~one_layer_nano_tubes->proc~gasdev proc~one_layer_nano_tubes->loc_xpt zpt zpt proc~one_layer_nano_tubes->zpt proc~one_layer_nano_wires->xpt proc~one_layer_nano_wires->proc~mpi_yz_part_distrib proc~one_layer_nano_wires->proc~p_alloc proc~one_layer_nano_wires->loc_ypt proc~one_layer_nano_wires->loc_zpt proc~one_layer_nano_wires->loc_wghyz proc~one_layer_nano_wires->ypt proc~one_layer_nano_wires->loc_wghx proc~one_layer_nano_wires->wghpt proc~set_pgrid_ind set_pgrid_ind proc~one_layer_nano_wires->proc~set_pgrid_ind proc~one_layer_nano_wires->spec proc~one_layer_nano_wires->loc_xpt proc~one_layer_nano_wires->zpt proc~multi_layer_gas_target->xpt proc~multi_layer_gas_target->proc~p_alloc proc~multi_layer_gas_target->loc_wghx proc~multi_layer_gas_target->proc~set_uniform_yz_distrib proc~multi_layer_gas_target->wghpt proc~mpi_x_part_distrib mpi_x_part_distrib proc~multi_layer_gas_target->proc~mpi_x_part_distrib proc~multi_layer_gas_target->spec proc~multi_layer_gas_target->loc_xpt proc~multi_layer_twosp_target->xpt proc~multi_layer_twosp_target->proc~p_alloc proc~multi_layer_twosp_target->loc_wghx proc~multi_layer_twosp_target->proc~set_uniform_yz_distrib proc~multi_layer_twosp_target->wghpt proc~multi_layer_twosp_target->spec proc~multi_layer_twosp_target->loc_xpt proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->ypt proc~mpi_yz_part_distrib->zpt proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib proc~set_uniform_yz_distrib->loc_ypt proc~set_uniform_yz_distrib->loc_zpt proc~set_uniform_yz_distrib->loc_wghyz proc~set_uniform_yz_distrib->ypt proc~set_uniform_yz_distrib->proc~set_pgrid_ind proc~set_uniform_yz_distrib->zpt proc~set_pgrid_ind->ypt proc~set_pgrid_ind->zpt proc~mpi_x_part_distrib->xpt proc~mpi_x_part_distrib->loc_wghx proc~mpi_x_part_distrib->wghpt proc~mpi_x_part_distrib->loc_xpt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~part_distribute~~CalledByGraph proc~part_distribute part_distribute proc~init init proc~init->proc~part_distribute proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_distribute.html"},{"title":"clean_field – ALaDyn","text":"private subroutine clean_field(ef, lp1, i1, j1, j2, k1, k2, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: lp1 integer, intent(in) :: i1 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 integer, intent(in) :: nc Contents None","tags":"","loc":"proc/clean_field.html"},{"title":"endian – ALaDyn","text":"public subroutine endian(iend) Arguments Type Intent Optional Attributes Name integer, intent(out) :: iend Called by proc~~endian~~CalledByGraph proc~endian endian proc~part_pdata_out part_pdata_out proc~part_pdata_out->proc~endian proc~bfields_out bfields_out proc~bfields_out->proc~endian proc~fluid_den_mom_out fluid_den_mom_out proc~fluid_den_mom_out->proc~endian proc~part_ionz_out part_ionz_out proc~part_ionz_out->proc~endian proc~fields_out fields_out proc~fields_out->proc~endian proc~bden_energy_out bden_energy_out proc~bden_energy_out->proc~endian proc~part_bdata_out part_bdata_out proc~part_bdata_out->proc~endian proc~fields_out_new fields_out_new proc~fields_out_new->proc~endian proc~ext_bfield_out ext_bfield_out proc~ext_bfield_out->proc~endian proc~part_high_gamma_out part_high_gamma_out proc~part_high_gamma_out->proc~endian proc~den_energy_out den_energy_out proc~den_energy_out->proc~endian proc~data_out data_out proc~data_out->proc~part_pdata_out proc~data_out->proc~fluid_den_mom_out proc~data_out->proc~fields_out proc~data_out->proc~fields_out_new proc~data_out->proc~den_energy_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/endian.html"},{"title":"fluid_den_mom_out – ALaDyn","text":"public subroutine fluid_den_mom_out(fvar, cmp, flcomp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: fvar (:,:,:,:) integer, intent(in) :: cmp integer, intent(in) :: flcomp Calls proc~~fluid_den_mom_out~~CallsGraph proc~fluid_den_mom_out fluid_den_mom_out proc~exchange_pdata exchange_pdata proc~fluid_den_mom_out->proc~exchange_pdata proc~endian endian proc~fluid_den_mom_out->proc~endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fluid_den_mom_out~~CalledByGraph proc~fluid_den_mom_out fluid_den_mom_out proc~data_out data_out proc~data_out->proc~fluid_den_mom_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fluid_den_mom_out.html"},{"title":"den_energy_out – ALaDyn","text":"public subroutine den_energy_out(ns_ind, cmp, cmp_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ns_ind integer, intent(in) :: cmp integer, intent(in) :: cmp_loc Calls proc~~den_energy_out~~CallsGraph proc~den_energy_out den_energy_out proc~exchange_pdata exchange_pdata proc~den_energy_out->proc~exchange_pdata proc~endian endian proc~den_energy_out->proc~endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~den_energy_out~~CalledByGraph proc~den_energy_out den_energy_out proc~data_out data_out proc~data_out->proc~den_energy_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/den_energy_out.html"},{"title":"bden_energy_out – ALaDyn","text":"public subroutine bden_energy_out(cmp_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cmp_loc Calls proc~~bden_energy_out~~CallsGraph proc~bden_energy_out bden_energy_out proc~exchange_pdata exchange_pdata proc~bden_energy_out->proc~exchange_pdata proc~endian endian proc~bden_energy_out->proc~endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bden_energy_out.html"},{"title":"ext_bfield_out – ALaDyn","text":"public subroutine ext_bfield_out(ef, f_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) integer, intent(in) :: f_ind Calls proc~~ext_bfield_out~~CallsGraph proc~ext_bfield_out ext_bfield_out proc~exchange_pdata exchange_pdata proc~ext_bfield_out->proc~exchange_pdata proc~endian endian proc~ext_bfield_out->proc~endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ext_bfield_out.html"},{"title":"fields_out – ALaDyn","text":"public subroutine fields_out(ef, f_ind, f_var) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) integer, intent(in) :: f_ind integer, intent(in) :: f_var Calls proc~~fields_out~~CallsGraph proc~fields_out fields_out proc~exchange_pdata exchange_pdata proc~fields_out->proc~exchange_pdata proc~endian endian proc~fields_out->proc~endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fields_out~~CalledByGraph proc~fields_out fields_out proc~data_out data_out proc~data_out->proc~fields_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fields_out.html"},{"title":"fields_out_new – ALaDyn","text":"public subroutine fields_out_new(ef, f_ind, var_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) integer, intent(in) :: f_ind integer, intent(in) :: var_ind Calls proc~~fields_out_new~~CallsGraph proc~fields_out_new fields_out_new proc~mpi_write_field mpi_write_field proc~fields_out_new->proc~mpi_write_field proc~endian endian proc~fields_out_new->proc~endian mpi_file_set_view mpi_file_set_view proc~mpi_write_field->mpi_file_set_view mpi_file_open mpi_file_open proc~mpi_write_field->mpi_file_open mpi_file_close mpi_file_close proc~mpi_write_field->mpi_file_close mpi_file_write mpi_file_write proc~mpi_write_field->mpi_file_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fields_out_new~~CalledByGraph proc~fields_out_new fields_out_new proc~data_out data_out proc~data_out->proc~fields_out_new proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fields_out_new.html"},{"title":"bfields_out – ALaDyn","text":"public subroutine bfields_out(ef, ef1, f_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ef1 (:,:,:,:) integer, intent(in) :: f_ind Calls proc~~bfields_out~~CallsGraph proc~bfields_out bfields_out proc~exchange_pdata exchange_pdata proc~bfields_out->proc~exchange_pdata proc~endian endian proc~bfields_out->proc~endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bfields_out.html"},{"title":"env_two_fields_out – ALaDyn","text":"public subroutine env_two_fields_out(ef, ef1, f_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ef1 (:,:,:,:) integer, intent(in) :: f_ind Calls proc~~env_two_fields_out~~CallsGraph proc~env_two_fields_out env_two_fields_out proc~exchange_pdata exchange_pdata proc~env_two_fields_out->proc~exchange_pdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_two_fields_out~~CalledByGraph proc~env_two_fields_out env_two_fields_out proc~data_out data_out proc~data_out->proc~env_two_fields_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_two_fields_out.html"},{"title":"env_fields_out – ALaDyn","text":"public subroutine env_fields_out(ef, f_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) integer, intent(in) :: f_ind Calls proc~~env_fields_out~~CallsGraph proc~env_fields_out env_fields_out proc~exchange_pdata exchange_pdata proc~env_fields_out->proc~exchange_pdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_fields_out~~CalledByGraph proc~env_fields_out env_fields_out proc~data_out data_out proc~data_out->proc~env_fields_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_fields_out.html"},{"title":"part_pdata_out – ALaDyn","text":"public subroutine part_pdata_out(timenow, xmin_out, xmax_out, ymax_out, pid, jmp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: timenow real(kind=dp), intent(in) :: xmin_out real(kind=dp), intent(in) :: xmax_out real(kind=dp), intent(in) :: ymax_out integer, intent(in) :: pid integer, intent(in) :: jmp Calls proc~~part_pdata_out~~CallsGraph proc~part_pdata_out part_pdata_out proc~mpi_write_part mpi_write_part proc~part_pdata_out->proc~mpi_write_part loc_npart loc_npart proc~part_pdata_out->loc_npart proc~endian endian proc~part_pdata_out->proc~endian proc~intvec_distribute intvec_distribute proc~part_pdata_out->proc~intvec_distribute mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~part_pdata_out~~CalledByGraph proc~part_pdata_out part_pdata_out proc~data_out data_out proc~data_out->proc~part_pdata_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_pdata_out.html"},{"title":"part_high_gamma_out – ALaDyn","text":"public subroutine part_high_gamma_out(gam_in, timenow) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: gam_in real(kind=dp), intent(in) :: timenow Calls proc~~part_high_gamma_out~~CallsGraph proc~part_high_gamma_out part_high_gamma_out proc~mpi_write_part mpi_write_part proc~part_high_gamma_out->proc~mpi_write_part loc_npart loc_npart proc~part_high_gamma_out->loc_npart proc~endian endian proc~part_high_gamma_out->proc~endian proc~intvec_distribute intvec_distribute proc~part_high_gamma_out->proc~intvec_distribute mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_high_gamma_out.html"},{"title":"part_bdata_out – ALaDyn","text":"public subroutine part_bdata_out(timenow, pid, jmp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: timenow integer, intent(in) :: pid integer, intent(in) :: jmp Calls proc~~part_bdata_out~~CallsGraph proc~part_bdata_out part_bdata_out proc~mpi_write_part mpi_write_part proc~part_bdata_out->proc~mpi_write_part loc_npart loc_npart proc~part_bdata_out->loc_npart proc~endian endian proc~part_bdata_out->proc~endian proc~intvec_distribute intvec_distribute proc~part_bdata_out->proc~intvec_distribute mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_bdata_out.html"},{"title":"part_ionz_out – ALaDyn","text":"public subroutine part_ionz_out(timenow) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: timenow Calls proc~~part_ionz_out~~CallsGraph proc~part_ionz_out part_ionz_out proc~mpi_write_part mpi_write_part proc~part_ionz_out->proc~mpi_write_part loc_npart loc_npart proc~part_ionz_out->loc_npart proc~endian endian proc~part_ionz_out->proc~endian proc~intvec_distribute intvec_distribute proc~part_ionz_out->proc~intvec_distribute mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_ionz_out.html"},{"title":"beam_2d_potential – ALaDyn","text":"private subroutine beam_2d_potential(poten, nxf_in, n2_loc, n3_loc, ft_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: poten (:,:,:) integer, intent(in) :: nxf_in integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc integer, intent(in) :: ft_ind Called by proc~~beam_2d_potential~~CalledByGraph proc~beam_2d_potential beam_2d_potential proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~beam_2d_potential proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/beam_2d_potential.html"},{"title":"beam_potential – ALaDyn","text":"private subroutine beam_potential(poten, gam2, nxf_in, n2_loc, n3_loc, ft_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: poten (:,:,:) real(kind=dp), intent(in) :: gam2 integer, intent(in) :: nxf_in integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc integer, intent(in) :: ft_ind Called by proc~~beam_potential~~CalledByGraph proc~beam_potential beam_potential proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~beam_potential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/beam_potential.html"},{"title":"fft_3d_psolv – ALaDyn","text":"public subroutine fft_3d_psolv(rho, pot1, g2, omp0, n1, n1_loc, n2, n2_loc, n3, n3_loc, i1, i2, j1, j2, k1, k2, ft_mod, sym, s_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: rho (:,:,:,:) real(kind=dp), intent(inout) :: pot1 (:,:,:,:) real(kind=dp), intent(in) :: g2 real(kind=dp), intent(in) :: omp0 integer, intent(in) :: n1 integer, intent(in) :: n1_loc integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 integer, intent(in) :: ft_mod integer, intent(in) :: sym integer, intent(in) :: s_ind Calls proc~~fft_3d_psolv~~CallsGraph proc~fft_3d_psolv fft_3d_psolv proc~pftw3d pftw3d proc~fft_3d_psolv->proc~pftw3d proc~beam_potential beam_potential proc~fft_3d_psolv->proc~beam_potential proc~mpi_ftw_alloc mpi_ftw_alloc proc~fft_3d_psolv->proc~mpi_ftw_alloc all_gather_dpreal all_gather_dpreal proc~fft_3d_psolv->all_gather_dpreal proc~mpi_yzft_ord mpi_yzft_ord proc~fft_3d_psolv->proc~mpi_yzft_ord proc~pftw3d_sc pftw3d_sc proc~fft_3d_psolv->proc~pftw3d_sc ftw_init ftw_init proc~fft_3d_psolv->ftw_init proc~unif_to_str_field_interp unif_to_str_field_interp proc~fft_3d_psolv->proc~unif_to_str_field_interp proc~mpi_ftw_dalloc mpi_ftw_dalloc proc~fft_3d_psolv->proc~mpi_ftw_dalloc ftw_end ftw_end proc~fft_3d_psolv->ftw_end proc~ft_overset_grid ft_overset_grid proc~fft_3d_psolv->proc~ft_overset_grid proc~ftw1d ftw1d proc~pftw3d->proc~ftw1d proc~pftw2d pftw2d proc~pftw3d->proc~pftw2d proc~ftw1d_sc ftw1d_sc proc~pftw3d_sc->proc~ftw1d_sc proc~pftw2d_sc pftw2d_sc proc~pftw3d_sc->proc~pftw2d_sc yft_ind yft_ind proc~unif_to_str_field_interp->yft_ind loc_yg loc_yg proc~unif_to_str_field_interp->loc_yg loc_zft loc_zft proc~unif_to_str_field_interp->loc_zft zft_ind zft_ind proc~unif_to_str_field_interp->zft_ind loc_zg loc_zg proc~unif_to_str_field_interp->loc_zg loc_yft loc_yft proc~unif_to_str_field_interp->loc_yft zp_next zp_next proc~ft_overset_grid->zp_next zp_prev zp_prev proc~ft_overset_grid->zp_prev yp_next yp_next proc~ft_overset_grid->yp_next comm_col comm_col proc~ft_overset_grid->comm_col yp_prev yp_prev proc~ft_overset_grid->yp_prev interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~ftw1d->interface~fftw_execute_dft_r2c interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~ftw1d->interface~fftw_execute_dft_c2r proc~pftw2d->proc~ftw1d proc~swap_xy_3data swap_xy_3data proc~pftw2d->proc~swap_xy_3data proc~swap_xy_3data_inv swap_xy_3data_inv proc~pftw2d->proc~swap_xy_3data_inv proc~swap_xz_3data swap_xz_3data proc~pftw2d->proc~swap_xz_3data proc~swap_xz_3data_inv swap_xz_3data_inv proc~pftw2d->proc~swap_xz_3data_inv interface~fftw_execute_r2r fftw_execute_r2r proc~ftw1d_sc->interface~fftw_execute_r2r proc~determine_kind determine_kind proc~ftw1d_sc->proc~determine_kind proc~logical_dimension logical_dimension proc~ftw1d_sc->proc~logical_dimension proc~pftw2d_sc->proc~ftw1d_sc proc~pftw2d_sc->proc~swap_xy_3data proc~pftw2d_sc->proc~swap_xy_3data_inv proc~pftw2d_sc->proc~swap_xz_3data proc~pftw2d_sc->proc~swap_xz_3data_inv proc~swap_xy_3data->yp_next proc~swap_xy_3data->comm_col proc~swap_xy_3data->yp_prev proc~swap_xy_3data_inv->yp_next proc~swap_xy_3data_inv->comm_col proc~swap_xy_3data_inv->yp_prev proc~swap_xz_3data->zp_next proc~swap_xz_3data->zp_prev proc~swap_xz_3data->comm_col proc~swap_xz_3data_inv->zp_next proc~swap_xz_3data_inv->zp_prev proc~swap_xz_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fft_3d_psolv.html"},{"title":"fft_2d_psolv – ALaDyn","text":"public subroutine fft_2d_psolv(rho, pot1, omp0, n1, n1_loc, n2, n2_loc, n3, n3_loc, i1, i2, j1, j2, k1, k2, ft_mod, sym, sind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: rho (:,:,:,:) real(kind=dp), intent(inout) :: pot1 (:,:,:,:) real(kind=dp), intent(in) :: omp0 integer, intent(in) :: n1 integer, intent(in) :: n1_loc integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 integer, intent(in) :: ft_mod integer, intent(in) :: sym integer, intent(in) :: sind Calls proc~~fft_2d_psolv~~CallsGraph proc~fft_2d_psolv fft_2d_psolv proc~mpi_ftw_alloc mpi_ftw_alloc proc~fft_2d_psolv->proc~mpi_ftw_alloc all_gather_dpreal all_gather_dpreal proc~fft_2d_psolv->all_gather_dpreal proc~beam_2d_potential beam_2d_potential proc~fft_2d_psolv->proc~beam_2d_potential proc~mpi_yzft_ord mpi_yzft_ord proc~fft_2d_psolv->proc~mpi_yzft_ord proc~pftw2d pftw2d proc~fft_2d_psolv->proc~pftw2d proc~pftw2d_sc pftw2d_sc proc~fft_2d_psolv->proc~pftw2d_sc ftw_init ftw_init proc~fft_2d_psolv->ftw_init proc~mpi_ftw_dalloc mpi_ftw_dalloc proc~fft_2d_psolv->proc~mpi_ftw_dalloc proc~unif_to_str_field_interp unif_to_str_field_interp proc~fft_2d_psolv->proc~unif_to_str_field_interp ftw_end ftw_end proc~fft_2d_psolv->ftw_end proc~ft_overset_grid ft_overset_grid proc~fft_2d_psolv->proc~ft_overset_grid proc~swap_xy_3data swap_xy_3data proc~pftw2d->proc~swap_xy_3data proc~ftw1d ftw1d proc~pftw2d->proc~ftw1d proc~swap_xy_3data_inv swap_xy_3data_inv proc~pftw2d->proc~swap_xy_3data_inv proc~swap_xz_3data swap_xz_3data proc~pftw2d->proc~swap_xz_3data proc~swap_xz_3data_inv swap_xz_3data_inv proc~pftw2d->proc~swap_xz_3data_inv proc~pftw2d_sc->proc~swap_xy_3data proc~pftw2d_sc->proc~swap_xy_3data_inv proc~ftw1d_sc ftw1d_sc proc~pftw2d_sc->proc~ftw1d_sc proc~pftw2d_sc->proc~swap_xz_3data proc~pftw2d_sc->proc~swap_xz_3data_inv yft_ind yft_ind proc~unif_to_str_field_interp->yft_ind loc_yg loc_yg proc~unif_to_str_field_interp->loc_yg loc_zft loc_zft proc~unif_to_str_field_interp->loc_zft zft_ind zft_ind proc~unif_to_str_field_interp->zft_ind loc_zg loc_zg proc~unif_to_str_field_interp->loc_zg loc_yft loc_yft proc~unif_to_str_field_interp->loc_yft zp_next zp_next proc~ft_overset_grid->zp_next zp_prev zp_prev proc~ft_overset_grid->zp_prev yp_next yp_next proc~ft_overset_grid->yp_next comm_col comm_col proc~ft_overset_grid->comm_col yp_prev yp_prev proc~ft_overset_grid->yp_prev proc~swap_xy_3data->yp_next proc~swap_xy_3data->comm_col proc~swap_xy_3data->yp_prev interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~ftw1d->interface~fftw_execute_dft_r2c interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~ftw1d->interface~fftw_execute_dft_c2r proc~swap_xy_3data_inv->yp_next proc~swap_xy_3data_inv->comm_col proc~swap_xy_3data_inv->yp_prev interface~fftw_execute_r2r fftw_execute_r2r proc~ftw1d_sc->interface~fftw_execute_r2r proc~determine_kind determine_kind proc~ftw1d_sc->proc~determine_kind proc~logical_dimension logical_dimension proc~ftw1d_sc->proc~logical_dimension proc~swap_xz_3data->zp_next proc~swap_xz_3data->zp_prev proc~swap_xz_3data->comm_col proc~swap_xz_3data_inv->zp_next proc~swap_xz_3data_inv->zp_prev proc~swap_xz_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fft_2d_psolv~~CalledByGraph proc~fft_2d_psolv fft_2d_psolv proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fft_2d_psolv.html"},{"title":"set_field_param – ALaDyn","text":"public subroutine set_field_param() Arguments None Calls proc~~set_field_param~~CallsGraph proc~set_field_param set_field_param float float proc~set_field_param->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_field_param.html"},{"title":"trid_der1 – ALaDyn","text":"public subroutine trid_der1(a, b, c, b1, c1, an, bn, n, ic1, ic2, ord) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b real(kind=dp), intent(in) :: c real(kind=dp), intent(in) :: b1 real(kind=dp), intent(in) :: c1 real(kind=dp), intent(in) :: an real(kind=dp), intent(in) :: bn integer, intent(in) :: n integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: ord Called by proc~~trid_der1~~CalledByGraph proc~trid_der1 trid_der1 proc~field_xadvect field_xadvect proc~field_xadvect->proc~trid_der1 proc~advance_lpf_fields advance_lpf_fields proc~advance_lpf_fields->proc~field_xadvect proc~advect_bunch_fields advect_bunch_fields proc~advect_bunch_fields->proc~field_xadvect proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~advance_lpf_fields proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/trid_der1.html"},{"title":"unif_to_str_field_interp – ALaDyn","text":"public subroutine unif_to_str_field_interp(unif_field, str_field, ic) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: unif_field (:,:,:) real(kind=dp), intent(inout) :: str_field (:,:,:,:) integer, intent(in) :: ic Calls proc~~unif_to_str_field_interp~~CallsGraph proc~unif_to_str_field_interp unif_to_str_field_interp yft_ind yft_ind proc~unif_to_str_field_interp->yft_ind loc_yg loc_yg proc~unif_to_str_field_interp->loc_yg loc_zft loc_zft proc~unif_to_str_field_interp->loc_zft zft_ind zft_ind proc~unif_to_str_field_interp->zft_ind loc_zg loc_zg proc~unif_to_str_field_interp->loc_zg loc_yft loc_yft proc~unif_to_str_field_interp->loc_yft Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~unif_to_str_field_interp~~CalledByGraph proc~unif_to_str_field_interp unif_to_str_field_interp proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~unif_to_str_field_interp proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~unif_to_str_field_interp proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/unif_to_str_field_interp.html"},{"title":"enforce_continuity – ALaDyn","text":"public subroutine enforce_continuity(curr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) Calls proc~~enforce_continuity~~CallsGraph proc~enforce_continuity enforce_continuity loc_yg loc_yg proc~enforce_continuity->loc_yg loc_zg loc_zg proc~enforce_continuity->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/enforce_continuity.html"},{"title":"field_xadvect – ALaDyn","text":"public subroutine field_xadvect(ef, dth, v_adv, ic1, ic2, isch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dth real(kind=dp), intent(in) :: v_adv integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: isch Calls proc~~field_xadvect~~CallsGraph proc~field_xadvect field_xadvect proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~field_xadvect~~CalledByGraph proc~field_xadvect field_xadvect proc~advance_lpf_fields advance_lpf_fields proc~advance_lpf_fields->proc~field_xadvect proc~advect_bunch_fields advect_bunch_fields proc~advect_bunch_fields->proc~field_xadvect proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~advance_lpf_fields proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/field_xadvect.html"},{"title":"pp_lapl – ALaDyn","text":"public subroutine pp_lapl(av, source, ic1, ic2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: av (:,:,:,:) real(kind=dp), intent(inout) :: source (:,:,:,:) integer, intent(in) :: ic1 integer, intent(in) :: ic2 Calls proc~~pp_lapl~~CallsGraph proc~pp_lapl pp_lapl loc_yg loc_yg proc~pp_lapl->loc_yg loc_zg loc_zg proc~pp_lapl->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pp_lapl~~CalledByGraph proc~pp_lapl pp_lapl proc~env_lpf_solve env_lpf_solve proc~env_lpf_solve->proc~pp_lapl proc~advance_lpf_envelope advance_lpf_envelope proc~advance_lpf_envelope->proc~env_lpf_solve proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pp_lapl.html"},{"title":"env_grad – ALaDyn","text":"public subroutine env_grad(envg) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: envg (:,:,:,:) Calls proc~~env_grad~~CallsGraph proc~env_grad env_grad loc_yg loc_yg proc~env_grad->loc_yg loc_zg loc_zg proc~env_grad->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_grad.html"},{"title":"env_maxw_solve – ALaDyn","text":"public subroutine env_maxw_solve(curr, evf, om0, dtl) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(inout) :: evf (:,:,:,:) real(kind=dp), intent(in) :: om0 real(kind=dp), intent(in) :: dtl Calls proc~~env_maxw_solve~~CallsGraph proc~env_maxw_solve env_maxw_solve proc~potential_lapl potential_lapl proc~env_maxw_solve->proc~potential_lapl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_maxw_solve~~CalledByGraph proc~env_maxw_solve env_maxw_solve proc~advance_lpf_envelope advance_lpf_envelope proc~advance_lpf_envelope->proc~env_maxw_solve proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_maxw_solve.html"},{"title":"env_lpf_solve – ALaDyn","text":"public subroutine env_lpf_solve(curr, evf, ib, om0, dtl) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(inout) :: evf (:,:,:,:) integer, intent(in) :: ib real(kind=dp), intent(in) :: om0 real(kind=dp), intent(in) :: dtl Calls proc~~env_lpf_solve~~CallsGraph proc~env_lpf_solve env_lpf_solve proc~pp_lapl pp_lapl proc~env_lpf_solve->proc~pp_lapl loc_yg loc_yg proc~pp_lapl->loc_yg loc_zg loc_zg proc~pp_lapl->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_lpf_solve~~CalledByGraph proc~env_lpf_solve env_lpf_solve proc~advance_lpf_envelope advance_lpf_envelope proc~advance_lpf_envelope->proc~env_lpf_solve proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_lpf_solve.html"},{"title":"env_bds – ALaDyn","text":"public subroutine env_bds(ef, ptrght, ptlft, init_ic, end_ic) Boundary conditions for the envelope field.\n Empirically set to be continuous with continuous first derivative. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) integer, intent(in) :: ptrght integer, intent(in) :: ptlft integer, intent(in), optional :: init_ic integer, intent(in), optional :: end_ic Calls proc~~env_bds~~CallsGraph proc~env_bds env_bds loc_yg loc_yg proc~env_bds->loc_yg loc_zg loc_zg proc~env_bds->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~env_bds~~CalledByGraph proc~env_bds env_bds proc~advance_lpf_envelope advance_lpf_envelope proc~advance_lpf_envelope->proc~env_bds proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/env_bds.html"},{"title":"bf_bds – ALaDyn","text":"public subroutine bf_bds(ef, dtl, imbd) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dtl integer, intent(in) :: imbd Calls proc~~bf_bds~~CallsGraph proc~bf_bds bf_bds loc_yg loc_yg proc~bf_bds->loc_yg loc_zg loc_zg proc~bf_bds->loc_zg loc_xg loc_xg proc~bf_bds->loc_xg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bf_bds~~CalledByGraph proc~bf_bds bf_bds proc~advance_lpf_fields advance_lpf_fields proc~advance_lpf_fields->proc~bf_bds proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~advance_lpf_fields proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bf_bds.html"},{"title":"ef_bds – ALaDyn","text":"public subroutine ef_bds(ef, dtl, imbd) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dtl integer, intent(in) :: imbd Calls proc~~ef_bds~~CallsGraph proc~ef_bds ef_bds loc_zgrid loc_zgrid proc~ef_bds->loc_zgrid loc_yg loc_yg proc~ef_bds->loc_yg loc_zg loc_zg proc~ef_bds->loc_zg loc_xg loc_xg proc~ef_bds->loc_xg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ef_bds~~CalledByGraph proc~ef_bds ef_bds proc~advance_lpf_fields advance_lpf_fields proc~advance_lpf_fields->proc~ef_bds proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~advance_lpf_fields proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ef_bds.html"},{"title":"potential_lapl – ALaDyn","text":"public subroutine potential_lapl(apf, curr, ic1, ic2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: apf (:,:,:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: ic1 integer, intent(in) :: ic2 Called by proc~~potential_lapl~~CalledByGraph proc~potential_lapl potential_lapl proc~env_maxw_solve env_maxw_solve proc~env_maxw_solve->proc~potential_lapl proc~advance_lpf_envelope advance_lpf_envelope proc~advance_lpf_envelope->proc~env_maxw_solve proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/potential_lapl.html"},{"title":"rote – ALaDyn","text":"public subroutine rote(ef, dtf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dtf Calls proc~~rote~~CallsGraph proc~rote rote loc_yg loc_yg proc~rote->loc_yg loc_zg loc_zg proc~rote->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~rote~~CalledByGraph proc~rote rote proc~advance_lpf_fields advance_lpf_fields proc~advance_lpf_fields->proc~rote proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~advance_lpf_fields proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/rote.html"},{"title":"rotb – ALaDyn","text":"public subroutine rotb(ef, dtf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dtf Calls proc~~rotb~~CallsGraph proc~rotb rotb loc_yg loc_yg proc~rotb->loc_yg loc_zg loc_zg proc~rotb->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~rotb~~CalledByGraph proc~rotb rotb proc~advance_lpf_fields advance_lpf_fields proc~advance_lpf_fields->proc~rotb proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~advance_lpf_fields proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/rotb.html"},{"title":"nc_fluid_density_momenta – ALaDyn","text":"public subroutine nc_fluid_density_momenta(flx, ef, dt_step, fcomp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: flx (:,:,:,:) real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dt_step integer, intent(in) :: fcomp Calls proc~~nc_fluid_density_momenta~~CallsGraph proc~nc_fluid_density_momenta nc_fluid_density_momenta loc_yg loc_yg proc~nc_fluid_density_momenta->loc_yg loc_zg loc_zg proc~nc_fluid_density_momenta->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~nc_fluid_density_momenta~~CalledByGraph proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~update_adam_bash_fluid_variables proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/nc_fluid_density_momenta.html"},{"title":"initial_beam_fields – ALaDyn","text":"public subroutine initial_beam_fields(poten, efb, g2, bet) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: poten (:,:,:,:) real(kind=dp), intent(out) :: efb (:,:,:,:) real(kind=dp), intent(in) :: g2 real(kind=dp), intent(in) :: bet Calls proc~~initial_beam_fields~~CallsGraph proc~initial_beam_fields initial_beam_fields loc_yg loc_yg proc~initial_beam_fields->loc_yg loc_zg loc_zg proc~initial_beam_fields->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initial_beam_fields~~CalledByGraph proc~initial_beam_fields initial_beam_fields proc~beam_inject beam_inject proc~beam_inject->proc~initial_beam_fields proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/initial_beam_fields.html"},{"title":"init_envelope_field – ALaDyn","text":"public subroutine init_envelope_field(ef, ee0, t_loc, tf, wx, wy, xf0, om0, pw, i1, i2, ycent, zcent) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 integer, intent(in) :: pw integer, intent(in) :: i1 integer, intent(in) :: i2 real(kind=dp) :: ycent real(kind=dp) :: zcent Calls proc~~init_envelope_field~~CallsGraph proc~init_envelope_field init_envelope_field loc_zgrid loc_zgrid proc~init_envelope_field->loc_zgrid loc_yg loc_yg proc~init_envelope_field->loc_yg loc_xg loc_xg proc~init_envelope_field->loc_xg loc_ygrid loc_ygrid proc~init_envelope_field->loc_ygrid loc_zg loc_zg proc~init_envelope_field->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_envelope_field~~CalledByGraph proc~init_envelope_field init_envelope_field proc~set_envelope set_envelope proc~set_envelope->proc~init_envelope_field proc~init init proc~init->proc~set_envelope proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_envelope_field.html"},{"title":"init_gprof_envelope_field – ALaDyn","text":"public subroutine init_gprof_envelope_field(ef, ee0, t_loc, tf, wx, wy, xf0, om0, pw, i1, i2, ycent, zcent) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 integer, intent(in) :: pw integer, intent(in) :: i1 integer, intent(in) :: i2 real(kind=dp) :: ycent real(kind=dp) :: zcent Calls proc~~init_gprof_envelope_field~~CallsGraph proc~init_gprof_envelope_field init_gprof_envelope_field loc_zgrid loc_zgrid proc~init_gprof_envelope_field->loc_zgrid loc_yg loc_yg proc~init_gprof_envelope_field->loc_yg loc_xg loc_xg proc~init_gprof_envelope_field->loc_xg loc_ygrid loc_ygrid proc~init_gprof_envelope_field->loc_ygrid loc_zg loc_zg proc~init_gprof_envelope_field->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_gprof_envelope_field~~CalledByGraph proc~init_gprof_envelope_field init_gprof_envelope_field proc~set_envelope set_envelope proc~set_envelope->proc~init_gprof_envelope_field proc~init init proc~init->proc~set_envelope proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_gprof_envelope_field.html"},{"title":"get_2dlaser_gprof_fields_lp – ALaDyn","text":"public subroutine get_2dlaser_gprof_fields_lp(coords, par_lp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_lp (7) real(kind=dp), intent(out) :: fields (6) Called by proc~~get_2dlaser_gprof_fields_lp~~CalledByGraph proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~inflow_lp_fields inflow_lp_fields proc~inflow_lp_fields->proc~get_2dlaser_gprof_fields_lp proc~init_lp_inc0_fields init_lp_inc0_fields proc~init_lp_inc0_fields->proc~get_2dlaser_gprof_fields_lp proc~init_lp_fields init_lp_fields proc~init_lp_fields->proc~get_2dlaser_gprof_fields_lp proc~wave_field_left_inject wave_field_left_inject proc~wave_field_left_inject->proc~inflow_lp_fields proc~lp_pulse lp_pulse proc~lp_pulse->proc~init_lp_inc0_fields proc~init init proc~init->proc~lp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_2dlaser_gprof_fields_lp.html"},{"title":"get_2dlaser_fields_lp – ALaDyn","text":"public subroutine get_2dlaser_fields_lp(coords, par_lp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_lp (7) real(kind=dp), intent(out) :: fields (6) Called by proc~~get_2dlaser_fields_lp~~CalledByGraph proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~inflow_lp_fields inflow_lp_fields proc~inflow_lp_fields->proc~get_2dlaser_fields_lp proc~init_lp_inc0_fields init_lp_inc0_fields proc~init_lp_inc0_fields->proc~get_2dlaser_fields_lp proc~init_lp_fields init_lp_fields proc~init_lp_fields->proc~get_2dlaser_fields_lp proc~wave_field_left_inject wave_field_left_inject proc~wave_field_left_inject->proc~inflow_lp_fields proc~lp_pulse lp_pulse proc~lp_pulse->proc~init_lp_inc0_fields proc~init init proc~init->proc~lp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_2dlaser_fields_lp.html"},{"title":"get_laser_fields_lp – ALaDyn","text":"public subroutine get_laser_fields_lp(coords, par_lp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_lp (7) real(kind=dp), intent(out) :: fields (6) Called by proc~~get_laser_fields_lp~~CalledByGraph proc~get_laser_fields_lp get_laser_fields_lp proc~inflow_lp_fields inflow_lp_fields proc~inflow_lp_fields->proc~get_laser_fields_lp proc~init_lp_inc0_fields init_lp_inc0_fields proc~init_lp_inc0_fields->proc~get_laser_fields_lp proc~init_lp_fields init_lp_fields proc~init_lp_fields->proc~get_laser_fields_lp proc~wave_field_left_inject wave_field_left_inject proc~wave_field_left_inject->proc~inflow_lp_fields proc~lp_pulse lp_pulse proc~lp_pulse->proc~init_lp_inc0_fields proc~init init proc~init->proc~lp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_laser_fields_lp.html"},{"title":"get_laser_gprof_fields_lp – ALaDyn","text":"public subroutine get_laser_gprof_fields_lp(coords, par_lp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_lp (7) real(kind=dp), intent(out) :: fields (6) Called by proc~~get_laser_gprof_fields_lp~~CalledByGraph proc~get_laser_gprof_fields_lp get_laser_gprof_fields_lp proc~init_lp_inc0_fields init_lp_inc0_fields proc~init_lp_inc0_fields->proc~get_laser_gprof_fields_lp proc~init_lp_fields init_lp_fields proc~init_lp_fields->proc~get_laser_gprof_fields_lp proc~lp_pulse lp_pulse proc~lp_pulse->proc~init_lp_inc0_fields proc~init init proc~init->proc~lp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_laser_gprof_fields_lp.html"},{"title":"get_plane_wave_lp – ALaDyn","text":"public subroutine get_plane_wave_lp(coords, par_pp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_pp (7) real(kind=dp), intent(out) :: fields (6) Called by proc~~get_plane_wave_lp~~CalledByGraph proc~get_plane_wave_lp get_plane_wave_lp proc~inflow_lp_fields inflow_lp_fields proc~inflow_lp_fields->proc~get_plane_wave_lp proc~init_lp_inc0_fields init_lp_inc0_fields proc~init_lp_inc0_fields->proc~get_plane_wave_lp proc~init_lp_fields init_lp_fields proc~init_lp_fields->proc~get_plane_wave_lp proc~wave_field_left_inject wave_field_left_inject proc~wave_field_left_inject->proc~inflow_lp_fields proc~lp_pulse lp_pulse proc~lp_pulse->proc~init_lp_inc0_fields proc~init init proc~init->proc~lp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_plane_wave_lp.html"},{"title":"get_plane_wave_cp – ALaDyn","text":"public subroutine get_plane_wave_cp(coords, par_pp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_pp (7) real(kind=dp), intent(out) :: fields (6) Called by proc~~get_plane_wave_cp~~CalledByGraph proc~get_plane_wave_cp get_plane_wave_cp proc~init_cp_fields init_cp_fields proc~init_cp_fields->proc~get_plane_wave_cp proc~inflow_cp_fields inflow_cp_fields proc~inflow_cp_fields->proc~get_plane_wave_cp proc~cp_pulse cp_pulse proc~cp_pulse->proc~init_cp_fields proc~init init proc~init->proc~cp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_plane_wave_cp.html"},{"title":"get_laser_fields_cp – ALaDyn","text":"public subroutine get_laser_fields_cp(coords, par_cp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_cp (7) real(kind=dp), intent(out) :: fields (6) Called by proc~~get_laser_fields_cp~~CalledByGraph proc~get_laser_fields_cp get_laser_fields_cp proc~init_cp_fields init_cp_fields proc~init_cp_fields->proc~get_laser_fields_cp proc~inflow_cp_fields inflow_cp_fields proc~inflow_cp_fields->proc~get_laser_fields_cp proc~cp_pulse cp_pulse proc~cp_pulse->proc~init_cp_fields proc~init init proc~init->proc~cp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_laser_fields_cp.html"},{"title":"inflow_lp_fields – ALaDyn","text":"public subroutine inflow_lp_fields(ef, ee0, t_loc, tf, wx, wy, xf0, om0, lp, i, j1, j2, k1, k2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 integer, intent(in) :: lp integer, intent(in) :: i integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 Calls proc~~inflow_lp_fields~~CallsGraph proc~inflow_lp_fields inflow_lp_fields proc~get_plane_wave_lp get_plane_wave_lp proc~inflow_lp_fields->proc~get_plane_wave_lp proc~get_laser_fields_lp get_laser_fields_lp proc~inflow_lp_fields->proc~get_laser_fields_lp proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~inflow_lp_fields->proc~get_2dlaser_fields_lp loc_yg loc_yg proc~inflow_lp_fields->loc_yg loc_xg loc_xg proc~inflow_lp_fields->loc_xg proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~inflow_lp_fields->proc~get_2dlaser_gprof_fields_lp loc_zg loc_zg proc~inflow_lp_fields->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inflow_lp_fields~~CalledByGraph proc~inflow_lp_fields inflow_lp_fields proc~wave_field_left_inject wave_field_left_inject proc~wave_field_left_inject->proc~inflow_lp_fields Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inflow_lp_fields.html"},{"title":"init_lp_inc0_fields – ALaDyn","text":"public subroutine init_lp_inc0_fields(ef, ee0, t_loc, tf, wx, wy, xf0, om0, lp, i1, i2, ycent, zcent) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 integer, intent(in) :: lp integer, intent(in) :: i1 integer, intent(in) :: i2 real(kind=dp) :: ycent real(kind=dp) :: zcent Calls proc~~init_lp_inc0_fields~~CallsGraph proc~init_lp_inc0_fields init_lp_inc0_fields loc_zgrid loc_zgrid proc~init_lp_inc0_fields->loc_zgrid proc~get_plane_wave_lp get_plane_wave_lp proc~init_lp_inc0_fields->proc~get_plane_wave_lp proc~get_laser_fields_lp get_laser_fields_lp proc~init_lp_inc0_fields->proc~get_laser_fields_lp proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_fields_lp loc_yg loc_yg proc~init_lp_inc0_fields->loc_yg loc_xg loc_xg proc~init_lp_inc0_fields->loc_xg proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_gprof_fields_lp loc_ygrid loc_ygrid proc~init_lp_inc0_fields->loc_ygrid proc~get_laser_gprof_fields_lp get_laser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_laser_gprof_fields_lp loc_zg loc_zg proc~init_lp_inc0_fields->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_lp_inc0_fields~~CalledByGraph proc~init_lp_inc0_fields init_lp_inc0_fields proc~lp_pulse lp_pulse proc~lp_pulse->proc~init_lp_inc0_fields proc~init init proc~init->proc~lp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_lp_inc0_fields.html"},{"title":"init_lp_fields – ALaDyn","text":"public subroutine init_lp_fields(ef, ee0, t_loc, tf, wx, wy, xf0, om0, angle, lp_shx, lp, i1, i2, ycent, zcent) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 real(kind=dp), intent(in) :: angle real(kind=dp), intent(in) :: lp_shx integer, intent(in) :: lp integer, intent(in) :: i1 integer, intent(in) :: i2 real(kind=dp) :: ycent real(kind=dp) :: zcent Calls proc~~init_lp_fields~~CallsGraph proc~init_lp_fields init_lp_fields loc_zgrid loc_zgrid proc~init_lp_fields->loc_zgrid proc~get_plane_wave_lp get_plane_wave_lp proc~init_lp_fields->proc~get_plane_wave_lp proc~get_laser_fields_lp get_laser_fields_lp proc~init_lp_fields->proc~get_laser_fields_lp proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~init_lp_fields->proc~get_2dlaser_fields_lp loc_yg loc_yg proc~init_lp_fields->loc_yg loc_xg loc_xg proc~init_lp_fields->loc_xg proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~init_lp_fields->proc~get_2dlaser_gprof_fields_lp loc_ygrid loc_ygrid proc~init_lp_fields->loc_ygrid proc~get_laser_gprof_fields_lp get_laser_gprof_fields_lp proc~init_lp_fields->proc~get_laser_gprof_fields_lp loc_zg loc_zg proc~init_lp_fields->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_lp_fields.html"},{"title":"inflow_cp_fields – ALaDyn","text":"public subroutine inflow_cp_fields(ef, ee0, t_loc, tf, wx, wy, xf0, cp, i, j1, j2, k1, k2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 integer, intent(in) :: cp integer, intent(in) :: i integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 Calls proc~~inflow_cp_fields~~CallsGraph proc~inflow_cp_fields inflow_cp_fields proc~get_plane_wave_cp get_plane_wave_cp proc~inflow_cp_fields->proc~get_plane_wave_cp loc_yg loc_yg proc~inflow_cp_fields->loc_yg loc_xg loc_xg proc~inflow_cp_fields->loc_xg loc_zg loc_zg proc~inflow_cp_fields->loc_zg proc~get_laser_fields_cp get_laser_fields_cp proc~inflow_cp_fields->proc~get_laser_fields_cp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/inflow_cp_fields.html"},{"title":"init_cp_fields – ALaDyn","text":"public subroutine init_cp_fields(ef, ee0, t_loc, tf, wx, wy, xf0, angle, lp_shx, cp, i1, i2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: angle real(kind=dp), intent(in) :: lp_shx integer, intent(in) :: cp integer, intent(in) :: i1 integer, intent(in) :: i2 Calls proc~~init_cp_fields~~CallsGraph proc~init_cp_fields init_cp_fields loc_zgrid loc_zgrid proc~init_cp_fields->loc_zgrid proc~get_plane_wave_cp get_plane_wave_cp proc~init_cp_fields->proc~get_plane_wave_cp loc_yg loc_yg proc~init_cp_fields->loc_yg loc_xg loc_xg proc~init_cp_fields->loc_xg loc_ygrid loc_ygrid proc~init_cp_fields->loc_ygrid loc_zg loc_zg proc~init_cp_fields->loc_zg proc~get_laser_fields_cp get_laser_fields_cp proc~init_cp_fields->proc~get_laser_fields_cp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_cp_fields~~CalledByGraph proc~init_cp_fields init_cp_fields proc~cp_pulse cp_pulse proc~cp_pulse->proc~init_cp_fields proc~init init proc~init->proc~cp_pulse proc~start Start proc~start->proc~init program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_cp_fields.html"},{"title":"init_fluid_density_momenta – ALaDyn","text":"public subroutine init_fluid_density_momenta(dmodel, part_in) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dmodel real(kind=dp), intent(in) :: part_in Calls proc~~init_fluid_density_momenta~~CallsGraph proc~init_fluid_density_momenta init_fluid_density_momenta loc_zgrid loc_zgrid proc~init_fluid_density_momenta->loc_zgrid loc_yg loc_yg proc~init_fluid_density_momenta->loc_yg loc_ygrid loc_ygrid proc~init_fluid_density_momenta->loc_ygrid loc_xgrid loc_xgrid proc~init_fluid_density_momenta->loc_xgrid loc_zg loc_zg proc~init_fluid_density_momenta->loc_zg lpx lpx proc~init_fluid_density_momenta->lpx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/init_fluid_density_momenta.html"},{"title":"set_poloidal_ex_fields – ALaDyn","text":"public subroutine set_poloidal_ex_fields(ef1, i1, i2, j1, j2, k1, k2, bpoloidal, rpoloidal) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef1 (:,:,:,:) integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 real(kind=dp), intent(in) :: bpoloidal real(kind=dp), intent(in) :: rpoloidal Calls proc~~set_poloidal_ex_fields~~CallsGraph proc~set_poloidal_ex_fields set_poloidal_ex_fields loc_yg loc_yg proc~set_poloidal_ex_fields->loc_yg loc_zg loc_zg proc~set_poloidal_ex_fields->loc_zg loc_xg loc_xg proc~set_poloidal_ex_fields->loc_xg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_poloidal_ex_fields.html"},{"title":"set_solenoid_fields – ALaDyn","text":"public subroutine set_solenoid_fields(ef1, i1, i2, j1, j2, k1, k2, x0, l_sol, bs) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef1 (:,:,:,:) integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 real(kind=dp), intent(in) :: x0 real(kind=dp), intent(in) :: l_sol (3,2) real(kind=dp), intent(in) :: bs (2) Calls proc~~set_solenoid_fields~~CallsGraph proc~set_solenoid_fields set_solenoid_fields loc_yg loc_yg proc~set_solenoid_fields->loc_yg loc_zg loc_zg proc~set_solenoid_fields->loc_zg loc_xg loc_xg proc~set_solenoid_fields->loc_xg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_solenoid_fields.html"},{"title":"mpi_ftw_alloc – ALaDyn","text":"public subroutine mpi_ftw_alloc(n1, n2, n2_loc, n3, n3_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc Called by proc~~mpi_ftw_alloc~~CalledByGraph proc~mpi_ftw_alloc mpi_ftw_alloc proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~mpi_ftw_alloc proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~mpi_ftw_alloc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_ftw_alloc.html"},{"title":"mpi_yzft_ord – ALaDyn","text":"public subroutine mpi_yzft_ord(ny_ft, nz_ft) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ny_ft integer, intent(in) :: nz_ft Called by proc~~mpi_yzft_ord~~CalledByGraph proc~mpi_yzft_ord mpi_yzft_ord proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~mpi_yzft_ord proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~mpi_yzft_ord proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_yzft_ord.html"},{"title":"mpi_ftw_dalloc – ALaDyn","text":"public subroutine mpi_ftw_dalloc() Arguments None Called by proc~~mpi_ftw_dalloc~~CalledByGraph proc~mpi_ftw_dalloc mpi_ftw_dalloc proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~mpi_ftw_dalloc proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~mpi_ftw_dalloc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_ftw_dalloc.html"},{"title":"ft_overset_grid – ALaDyn","text":"public subroutine ft_overset_grid(w_s, w_r, nft1, nft2, nft3) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w_s (:,:,:) real(kind=dp), intent(out) :: w_r (:,:,:) integer, intent(in) :: nft1 integer, intent(in) :: nft2 integer, intent(in) :: nft3 Calls proc~~ft_overset_grid~~CallsGraph proc~ft_overset_grid ft_overset_grid zp_next zp_next proc~ft_overset_grid->zp_next zp_prev zp_prev proc~ft_overset_grid->zp_prev yp_next yp_next proc~ft_overset_grid->yp_next comm_col comm_col proc~ft_overset_grid->comm_col yp_prev yp_prev proc~ft_overset_grid->yp_prev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ft_overset_grid~~CalledByGraph proc~ft_overset_grid ft_overset_grid proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~ft_overset_grid proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~ft_overset_grid proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ft_overset_grid.html"},{"title":"swap_yx_3data – ALaDyn","text":"public subroutine swap_yx_3data(waux, wdata, n1_loc, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: waux (:,:,:) real(kind=dp), intent(out) :: wdata (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2 integer, intent(in) :: n3 Calls proc~~swap_yx_3data~~CallsGraph proc~swap_yx_3data swap_yx_3data xp_prev xp_prev proc~swap_yx_3data->xp_prev xp_next xp_next proc~swap_yx_3data->xp_next comm_col comm_col proc~swap_yx_3data->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_yx_3data.html"},{"title":"swap_xy_3data – ALaDyn","text":"public subroutine swap_xy_3data(wp1, wp2, n1_loc, n2_loc, n3_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wp1 (:,:,:) real(kind=dp), intent(out) :: wp2 (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc Calls proc~~swap_xy_3data~~CallsGraph proc~swap_xy_3data swap_xy_3data comm_col comm_col proc~swap_xy_3data->comm_col yp_prev yp_prev proc~swap_xy_3data->yp_prev yp_next yp_next proc~swap_xy_3data->yp_next Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~swap_xy_3data~~CalledByGraph proc~swap_xy_3data swap_xy_3data proc~pftw2d pftw2d proc~pftw2d->proc~swap_xy_3data proc~pftw2d_sc pftw2d_sc proc~pftw2d_sc->proc~swap_xy_3data proc~pftw3d pftw3d proc~pftw3d->proc~pftw2d proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d proc~fft_2d_psolv->proc~pftw2d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d proc~fft_3d_psolv->proc~pftw3d_sc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_xy_3data.html"},{"title":"swap_xz_3data – ALaDyn","text":"public subroutine swap_xz_3data(wp1, wp2, n1_loc, n2_loc, n3_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wp1 (:,:,:) real(kind=dp), intent(out) :: wp2 (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc Calls proc~~swap_xz_3data~~CallsGraph proc~swap_xz_3data swap_xz_3data zp_next zp_next proc~swap_xz_3data->zp_next zp_prev zp_prev proc~swap_xz_3data->zp_prev comm_col comm_col proc~swap_xz_3data->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~swap_xz_3data~~CalledByGraph proc~swap_xz_3data swap_xz_3data proc~pftw2d pftw2d proc~pftw2d->proc~swap_xz_3data proc~pftw2d_sc pftw2d_sc proc~pftw2d_sc->proc~swap_xz_3data proc~pftw3d pftw3d proc~pftw3d->proc~pftw2d proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d proc~fft_2d_psolv->proc~pftw2d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d proc~fft_3d_psolv->proc~pftw3d_sc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_xz_3data.html"},{"title":"swap_yx_3data_inv – ALaDyn","text":"public subroutine swap_yx_3data_inv(wdata, waux, n1_loc, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wdata (:,:,:) real(kind=dp), intent(out) :: waux (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2 integer, intent(in) :: n3 Calls proc~~swap_yx_3data_inv~~CallsGraph proc~swap_yx_3data_inv swap_yx_3data_inv xp_prev xp_prev proc~swap_yx_3data_inv->xp_prev xp_next xp_next proc~swap_yx_3data_inv->xp_next comm_col comm_col proc~swap_yx_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_yx_3data_inv.html"},{"title":"swap_xy_3data_inv – ALaDyn","text":"public subroutine swap_xy_3data_inv(wp2, wp1, n1_loc, n2_loc, n3_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wp2 (:,:,:) real(kind=dp), intent(out) :: wp1 (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc Calls proc~~swap_xy_3data_inv~~CallsGraph proc~swap_xy_3data_inv swap_xy_3data_inv comm_col comm_col proc~swap_xy_3data_inv->comm_col yp_prev yp_prev proc~swap_xy_3data_inv->yp_prev yp_next yp_next proc~swap_xy_3data_inv->yp_next Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~swap_xy_3data_inv~~CalledByGraph proc~swap_xy_3data_inv swap_xy_3data_inv proc~pftw2d pftw2d proc~pftw2d->proc~swap_xy_3data_inv proc~pftw2d_sc pftw2d_sc proc~pftw2d_sc->proc~swap_xy_3data_inv proc~pftw3d pftw3d proc~pftw3d->proc~pftw2d proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d proc~fft_2d_psolv->proc~pftw2d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d proc~fft_3d_psolv->proc~pftw3d_sc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_xy_3data_inv.html"},{"title":"swap_xz_3data_inv – ALaDyn","text":"public subroutine swap_xz_3data_inv(wp2, wp1, n1_loc, n2_loc, n3_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wp2 (:,:,:) real(kind=dp), intent(out) :: wp1 (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc Calls proc~~swap_xz_3data_inv~~CallsGraph proc~swap_xz_3data_inv swap_xz_3data_inv zp_next zp_next proc~swap_xz_3data_inv->zp_next zp_prev zp_prev proc~swap_xz_3data_inv->zp_prev comm_col comm_col proc~swap_xz_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~swap_xz_3data_inv~~CalledByGraph proc~swap_xz_3data_inv swap_xz_3data_inv proc~pftw2d pftw2d proc~pftw2d->proc~swap_xz_3data_inv proc~pftw2d_sc pftw2d_sc proc~pftw2d_sc->proc~swap_xz_3data_inv proc~pftw3d pftw3d proc~pftw3d->proc~pftw2d proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d proc~fft_2d_psolv->proc~pftw2d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d proc~fft_3d_psolv->proc~pftw3d_sc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/swap_xz_3data_inv.html"},{"title":"pftw2d_sc – ALaDyn","text":"public subroutine pftw2d_sc(w, n1, n2, n2_loc, n3, n3_loc, is, sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: is integer, intent(in) :: sym Calls proc~~pftw2d_sc~~CallsGraph proc~pftw2d_sc pftw2d_sc proc~swap_xy_3data swap_xy_3data proc~pftw2d_sc->proc~swap_xy_3data proc~swap_xy_3data_inv swap_xy_3data_inv proc~pftw2d_sc->proc~swap_xy_3data_inv proc~ftw1d_sc ftw1d_sc proc~pftw2d_sc->proc~ftw1d_sc proc~swap_xz_3data swap_xz_3data proc~pftw2d_sc->proc~swap_xz_3data proc~swap_xz_3data_inv swap_xz_3data_inv proc~pftw2d_sc->proc~swap_xz_3data_inv yp_next yp_next proc~swap_xy_3data->yp_next comm_col comm_col proc~swap_xy_3data->comm_col yp_prev yp_prev proc~swap_xy_3data->yp_prev proc~swap_xy_3data_inv->yp_next proc~swap_xy_3data_inv->comm_col proc~swap_xy_3data_inv->yp_prev interface~fftw_execute_r2r fftw_execute_r2r proc~ftw1d_sc->interface~fftw_execute_r2r proc~determine_kind determine_kind proc~ftw1d_sc->proc~determine_kind proc~logical_dimension logical_dimension proc~ftw1d_sc->proc~logical_dimension zp_next zp_next proc~swap_xz_3data->zp_next zp_prev zp_prev proc~swap_xz_3data->zp_prev proc~swap_xz_3data->comm_col proc~swap_xz_3data_inv->zp_next proc~swap_xz_3data_inv->zp_prev proc~swap_xz_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pftw2d_sc~~CalledByGraph proc~pftw2d_sc pftw2d_sc proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d_sc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pftw2d_sc.html"},{"title":"pftw3d_sc – ALaDyn","text":"public subroutine pftw3d_sc(w, n1, n2, n2_loc, n3, n3_loc, is, sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: is integer, intent(in) :: sym Calls proc~~pftw3d_sc~~CallsGraph proc~pftw3d_sc pftw3d_sc proc~ftw1d_sc ftw1d_sc proc~pftw3d_sc->proc~ftw1d_sc proc~pftw2d_sc pftw2d_sc proc~pftw3d_sc->proc~pftw2d_sc interface~fftw_execute_r2r fftw_execute_r2r proc~ftw1d_sc->interface~fftw_execute_r2r proc~determine_kind determine_kind proc~ftw1d_sc->proc~determine_kind proc~logical_dimension logical_dimension proc~ftw1d_sc->proc~logical_dimension proc~pftw2d_sc->proc~ftw1d_sc proc~swap_xy_3data swap_xy_3data proc~pftw2d_sc->proc~swap_xy_3data proc~swap_xy_3data_inv swap_xy_3data_inv proc~pftw2d_sc->proc~swap_xy_3data_inv proc~swap_xz_3data swap_xz_3data proc~pftw2d_sc->proc~swap_xz_3data proc~swap_xz_3data_inv swap_xz_3data_inv proc~pftw2d_sc->proc~swap_xz_3data_inv yp_next yp_next proc~swap_xy_3data->yp_next comm_col comm_col proc~swap_xy_3data->comm_col yp_prev yp_prev proc~swap_xy_3data->yp_prev proc~swap_xy_3data_inv->yp_next proc~swap_xy_3data_inv->comm_col proc~swap_xy_3data_inv->yp_prev zp_next zp_next proc~swap_xz_3data->zp_next zp_prev zp_prev proc~swap_xz_3data->zp_prev proc~swap_xz_3data->comm_col proc~swap_xz_3data_inv->zp_next proc~swap_xz_3data_inv->zp_prev proc~swap_xz_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pftw3d_sc~~CalledByGraph proc~pftw3d_sc pftw3d_sc proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d_sc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pftw3d_sc.html"},{"title":"pftw2d – ALaDyn","text":"public subroutine pftw2d(w, n1, n2, n2_loc, n3, n3_loc, is) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: is Calls proc~~pftw2d~~CallsGraph proc~pftw2d pftw2d proc~swap_xy_3data swap_xy_3data proc~pftw2d->proc~swap_xy_3data proc~ftw1d ftw1d proc~pftw2d->proc~ftw1d proc~swap_xy_3data_inv swap_xy_3data_inv proc~pftw2d->proc~swap_xy_3data_inv proc~swap_xz_3data swap_xz_3data proc~pftw2d->proc~swap_xz_3data proc~swap_xz_3data_inv swap_xz_3data_inv proc~pftw2d->proc~swap_xz_3data_inv yp_next yp_next proc~swap_xy_3data->yp_next comm_col comm_col proc~swap_xy_3data->comm_col yp_prev yp_prev proc~swap_xy_3data->yp_prev interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~ftw1d->interface~fftw_execute_dft_r2c interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~ftw1d->interface~fftw_execute_dft_c2r proc~swap_xy_3data_inv->yp_next proc~swap_xy_3data_inv->comm_col proc~swap_xy_3data_inv->yp_prev zp_next zp_next proc~swap_xz_3data->zp_next zp_prev zp_prev proc~swap_xz_3data->zp_prev proc~swap_xz_3data->comm_col proc~swap_xz_3data_inv->zp_next proc~swap_xz_3data_inv->zp_prev proc~swap_xz_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pftw2d~~CalledByGraph proc~pftw2d pftw2d proc~pftw3d pftw3d proc~pftw3d->proc~pftw2d proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pftw2d.html"},{"title":"pftw3d – ALaDyn","text":"public subroutine pftw3d(w, n1, n2, n2_loc, n3, n3_loc, is) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: is Calls proc~~pftw3d~~CallsGraph proc~pftw3d pftw3d proc~pftw2d pftw2d proc~pftw3d->proc~pftw2d proc~ftw1d ftw1d proc~pftw3d->proc~ftw1d proc~pftw2d->proc~ftw1d proc~swap_xy_3data swap_xy_3data proc~pftw2d->proc~swap_xy_3data proc~swap_xy_3data_inv swap_xy_3data_inv proc~pftw2d->proc~swap_xy_3data_inv proc~swap_xz_3data swap_xz_3data proc~pftw2d->proc~swap_xz_3data proc~swap_xz_3data_inv swap_xz_3data_inv proc~pftw2d->proc~swap_xz_3data_inv interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~ftw1d->interface~fftw_execute_dft_r2c interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~ftw1d->interface~fftw_execute_dft_c2r yp_next yp_next proc~swap_xy_3data->yp_next comm_col comm_col proc~swap_xy_3data->comm_col yp_prev yp_prev proc~swap_xy_3data->yp_prev proc~swap_xy_3data_inv->yp_next proc~swap_xy_3data_inv->comm_col proc~swap_xy_3data_inv->yp_prev zp_next zp_next proc~swap_xz_3data->zp_next zp_prev zp_prev proc~swap_xz_3data->zp_prev proc~swap_xz_3data->comm_col proc~swap_xz_3data_inv->zp_next proc~swap_xz_3data_inv->zp_prev proc~swap_xz_3data_inv->comm_col Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pftw3d~~CalledByGraph proc~pftw3d pftw3d proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pftw3d.html"},{"title":"ftw_init – ALaDyn","text":"public subroutine ftw_init(n1, n2, n3, ind_ft) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ind_ft Calls proc~~ftw_init~~CallsGraph proc~ftw_init ftw_init dfftw_plan_dft_c2r_1d dfftw_plan_dft_c2r_1d proc~ftw_init->dfftw_plan_dft_c2r_1d dfftw_plan_dft_r2c_1d dfftw_plan_dft_r2c_1d proc~ftw_init->dfftw_plan_dft_r2c_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw_init.html"},{"title":"ftw_end – ALaDyn","text":"public subroutine ftw_end() Arguments None Contents None","tags":"","loc":"proc/ftw_end.html"},{"title":"ftw1d_st – ALaDyn","text":"public subroutine ftw1d_st(w, n1, n2, n3, is, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir Calls proc~~ftw1d_st~~CallsGraph proc~ftw1d_st ftw1d_st dfftw_execute dfftw_execute proc~ftw1d_st->dfftw_execute Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw1d_st.html"},{"title":"ftw1d – ALaDyn","text":"public subroutine ftw1d(w, n1, n2, n3, is, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir Calls proc~~ftw1d~2~~CallsGraph proc~ftw1d~2 ftw1d dfftw_execute dfftw_execute proc~ftw1d~2->dfftw_execute Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw1d~2.html"},{"title":"ft_kern – ALaDyn","text":"public subroutine ft_kern(w, n1, is) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:) integer, intent(in) :: n1 integer, intent(in) :: is Calls proc~~ft_kern~~CallsGraph proc~ft_kern ft_kern dfftw_execute dfftw_execute proc~ft_kern->dfftw_execute Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ft_kern.html"},{"title":"ftw1d_sc – ALaDyn","text":"public subroutine ftw1d_sc(w, n1, n2, n3, is, dir, sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir integer, intent(in) :: sym Calls proc~~ftw1d_sc~2~~CallsGraph proc~ftw1d_sc~2 ftw1d_sc dfftw_execute dfftw_execute proc~ftw1d_sc~2->dfftw_execute Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw1d_sc~2.html"},{"title":"fftw_plan_dft – ALaDyn","text":"interface public function fftw_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftw_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft.html"},{"title":"fftw_plan_dft_1d – ALaDyn","text":"interface public function fftw_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftw_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_1d.html"},{"title":"fftw_plan_dft_2d – ALaDyn","text":"interface public function fftw_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftw_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_2d.html"},{"title":"fftw_plan_dft_3d – ALaDyn","text":"interface public function fftw_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftw_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_3d.html"},{"title":"fftw_plan_many_dft – ALaDyn","text":"interface public function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftw_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_many_dft.html"},{"title":"fftw_plan_guru_dft – ALaDyn","text":"interface public function fftw_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_dft.html"},{"title":"fftw_plan_guru_split_dft – ALaDyn","text":"interface public function fftw_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_split_dft.html"},{"title":"fftw_plan_guru64_dft – ALaDyn","text":"interface public function fftw_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_dft.html"},{"title":"fftw_plan_guru64_split_dft – ALaDyn","text":"interface public function fftw_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_split_dft.html"},{"title":"fftw_plan_many_dft_r2c – ALaDyn","text":"interface public function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_many_dft_r2c.html"},{"title":"fftw_plan_dft_r2c – ALaDyn","text":"interface public function fftw_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_r2c.html"},{"title":"fftw_plan_dft_r2c_1d – ALaDyn","text":"interface public function fftw_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_r2c_1d.html"},{"title":"fftw_plan_dft_r2c_2d – ALaDyn","text":"interface public function fftw_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_r2c_2d.html"},{"title":"fftw_plan_dft_r2c_3d – ALaDyn","text":"interface public function fftw_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_r2c_3d.html"},{"title":"fftw_plan_many_dft_c2r – ALaDyn","text":"interface public function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_many_dft_c2r.html"},{"title":"fftw_plan_dft_c2r – ALaDyn","text":"interface public function fftw_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_c2r.html"},{"title":"fftw_plan_dft_c2r_1d – ALaDyn","text":"interface public function fftw_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_c2r_1d.html"},{"title":"fftw_plan_dft_c2r_2d – ALaDyn","text":"interface public function fftw_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_c2r_2d.html"},{"title":"fftw_plan_dft_c2r_3d – ALaDyn","text":"interface public function fftw_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_c2r_3d.html"},{"title":"fftw_plan_guru_dft_r2c – ALaDyn","text":"interface public function fftw_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_dft_r2c.html"},{"title":"fftw_plan_guru_dft_c2r – ALaDyn","text":"interface public function fftw_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_dft_c2r.html"},{"title":"fftw_plan_guru_split_dft_r2c – ALaDyn","text":"interface public function fftw_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_split_dft_r2c.html"},{"title":"fftw_plan_guru_split_dft_c2r – ALaDyn","text":"interface public function fftw_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_split_dft_c2r.html"},{"title":"fftw_plan_guru64_dft_r2c – ALaDyn","text":"interface public function fftw_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_dft_r2c.html"},{"title":"fftw_plan_guru64_dft_c2r – ALaDyn","text":"interface public function fftw_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_dft_c2r.html"},{"title":"fftw_plan_guru64_split_dft_r2c – ALaDyn","text":"interface public function fftw_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_split_dft_r2c.html"},{"title":"fftw_plan_guru64_split_dft_c2r – ALaDyn","text":"interface public function fftw_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_split_dft_c2r.html"},{"title":"fftw_plan_many_r2r – ALaDyn","text":"interface public function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftw_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_many_r2r.html"},{"title":"fftw_plan_r2r – ALaDyn","text":"interface public function fftw_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftw_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_r2r.html"},{"title":"fftw_plan_r2r_1d – ALaDyn","text":"interface public function fftw_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftw_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_r2r_1d.html"},{"title":"fftw_plan_r2r_2d – ALaDyn","text":"interface public function fftw_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftw_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_r2r_2d.html"},{"title":"fftw_plan_r2r_3d – ALaDyn","text":"interface public function fftw_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftw_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_r2r_3d.html"},{"title":"fftw_plan_guru_r2r – ALaDyn","text":"interface public function fftw_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_r2r.html"},{"title":"fftw_plan_guru64_r2r – ALaDyn","text":"interface public function fftw_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_r2r.html"},{"title":"fftw_init_threads – ALaDyn","text":"interface public function fftw_init_threads() bind(C, name='fftw_init_threads') Arguments None Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_init_threads.html"},{"title":"fftw_export_wisdom_to_filename – ALaDyn","text":"interface public function fftw_export_wisdom_to_filename(filename) bind(C, name='fftw_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_export_wisdom_to_filename.html"},{"title":"fftw_export_wisdom_to_string – ALaDyn","text":"interface public function fftw_export_wisdom_to_string() bind(C, name='fftw_export_wisdom_to_string') Arguments None Return Value type(C_PTR)","tags":"","loc":"interface/fftw_export_wisdom_to_string.html"},{"title":"fftw_import_system_wisdom – ALaDyn","text":"interface public function fftw_import_system_wisdom() bind(C, name='fftw_import_system_wisdom') Arguments None Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_system_wisdom.html"},{"title":"fftw_import_wisdom_from_filename – ALaDyn","text":"interface public function fftw_import_wisdom_from_filename(filename) bind(C, name='fftw_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_wisdom_from_filename.html"},{"title":"fftw_import_wisdom_from_file – ALaDyn","text":"interface public function fftw_import_wisdom_from_file(input_file) bind(C, name='fftw_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_wisdom_from_file.html"},{"title":"fftw_import_wisdom_from_string – ALaDyn","text":"interface public function fftw_import_wisdom_from_string(input_string) bind(C, name='fftw_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_wisdom_from_string.html"},{"title":"fftw_import_wisdom – ALaDyn","text":"interface public function fftw_import_wisdom(read_char, data) bind(C, name='fftw_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_wisdom.html"},{"title":"fftw_sprint_plan – ALaDyn","text":"interface public function fftw_sprint_plan(p) bind(C, name='fftw_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(C_PTR)","tags":"","loc":"interface/fftw_sprint_plan.html"},{"title":"fftw_malloc – ALaDyn","text":"interface public function fftw_malloc(n) bind(C, name='fftw_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftw_malloc.html"},{"title":"fftw_alloc_real – ALaDyn","text":"interface public function fftw_alloc_real(n) bind(C, name='fftw_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftw_alloc_real.html"},{"title":"fftw_alloc_complex – ALaDyn","text":"interface public function fftw_alloc_complex(n) bind(C, name='fftw_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftw_alloc_complex.html"},{"title":"fftw_estimate_cost – ALaDyn","text":"interface public function fftw_estimate_cost(p) bind(C, name='fftw_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/fftw_estimate_cost.html"},{"title":"fftw_cost – ALaDyn","text":"interface public function fftw_cost(p) bind(C, name='fftw_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/fftw_cost.html"},{"title":"fftw_alignment_of – ALaDyn","text":"interface public function fftw_alignment_of(p) bind(C, name='fftw_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), intent(out), dimension(*) :: p Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_alignment_of.html"},{"title":"fftw_execute_dft – ALaDyn","text":"interface public subroutine fftw_execute_dft(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft.html"},{"title":"fftw_execute_split_dft – ALaDyn","text":"interface public subroutine fftw_execute_split_dft(p, ri, ii, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftw_execute_split_dft.html"},{"title":"fftw_execute_dft_r2c – ALaDyn","text":"interface public subroutine fftw_execute_dft_r2c(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft_r2c~2.html"},{"title":"fftw_execute_dft_c2r – ALaDyn","text":"interface public subroutine fftw_execute_dft_c2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft_c2r~2.html"},{"title":"fftw_execute_split_dft_r2c – ALaDyn","text":"interface public subroutine fftw_execute_split_dft_r2c(p, in, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftw_execute_split_dft_r2c.html"},{"title":"fftw_execute_split_dft_c2r – ALaDyn","text":"interface public subroutine fftw_execute_split_dft_c2r(p, ri, ii, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_split_dft_c2r.html"},{"title":"fftw_execute_r2r – ALaDyn","text":"interface public subroutine fftw_execute_r2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_r2r~2.html"},{"title":"fftw_destroy_plan – ALaDyn","text":"interface public subroutine fftw_destroy_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_destroy_plan.html"},{"title":"fftw_forget_wisdom – ALaDyn","text":"interface public subroutine fftw_forget_wisdom() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftw_forget_wisdom.html"},{"title":"fftw_cleanup – ALaDyn","text":"interface public subroutine fftw_cleanup() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftw_cleanup.html"},{"title":"fftw_set_timelimit – ALaDyn","text":"interface public subroutine fftw_set_timelimit(t) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t","tags":"","loc":"interface/fftw_set_timelimit.html"},{"title":"fftw_plan_with_nthreads – ALaDyn","text":"interface public subroutine fftw_plan_with_nthreads(nthreads) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads","tags":"","loc":"interface/fftw_plan_with_nthreads.html"},{"title":"fftw_cleanup_threads – ALaDyn","text":"interface public subroutine fftw_cleanup_threads() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftw_cleanup_threads.html"},{"title":"fftw_make_planner_thread_safe – ALaDyn","text":"interface public subroutine fftw_make_planner_thread_safe() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftw_make_planner_thread_safe.html"},{"title":"fftw_export_wisdom_to_file – ALaDyn","text":"interface public subroutine fftw_export_wisdom_to_file(output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file","tags":"","loc":"interface/fftw_export_wisdom_to_file.html"},{"title":"fftw_export_wisdom – ALaDyn","text":"interface public subroutine fftw_export_wisdom(write_char, data) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data","tags":"","loc":"interface/fftw_export_wisdom.html"},{"title":"fftw_fprint_plan – ALaDyn","text":"interface public subroutine fftw_fprint_plan(p, output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file","tags":"","loc":"interface/fftw_fprint_plan.html"},{"title":"fftw_print_plan – ALaDyn","text":"interface public subroutine fftw_print_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_print_plan.html"},{"title":"fftw_free – ALaDyn","text":"interface public subroutine fftw_free(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_free.html"},{"title":"fftw_flops – ALaDyn","text":"interface public subroutine fftw_flops(p, add, mul, fmas) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas","tags":"","loc":"interface/fftw_flops.html"},{"title":"fftwf_plan_dft – ALaDyn","text":"interface public function fftwf_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftwf_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft.html"},{"title":"fftwf_plan_dft_1d – ALaDyn","text":"interface public function fftwf_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftwf_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_1d.html"},{"title":"fftwf_plan_dft_2d – ALaDyn","text":"interface public function fftwf_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftwf_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_2d.html"},{"title":"fftwf_plan_dft_3d – ALaDyn","text":"interface public function fftwf_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftwf_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_3d.html"},{"title":"fftwf_plan_many_dft – ALaDyn","text":"interface public function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftwf_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_many_dft.html"},{"title":"fftwf_plan_guru_dft – ALaDyn","text":"interface public function fftwf_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_dft.html"},{"title":"fftwf_plan_guru_split_dft – ALaDyn","text":"interface public function fftwf_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_split_dft.html"},{"title":"fftwf_plan_guru64_dft – ALaDyn","text":"interface public function fftwf_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_dft.html"},{"title":"fftwf_plan_guru64_split_dft – ALaDyn","text":"interface public function fftwf_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft.html"},{"title":"fftwf_plan_many_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_many_dft_r2c.html"},{"title":"fftwf_plan_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_r2c.html"},{"title":"fftwf_plan_dft_r2c_1d – ALaDyn","text":"interface public function fftwf_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_r2c_1d.html"},{"title":"fftwf_plan_dft_r2c_2d – ALaDyn","text":"interface public function fftwf_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_r2c_2d.html"},{"title":"fftwf_plan_dft_r2c_3d – ALaDyn","text":"interface public function fftwf_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_r2c_3d.html"},{"title":"fftwf_plan_many_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_many_dft_c2r.html"},{"title":"fftwf_plan_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_c2r.html"},{"title":"fftwf_plan_dft_c2r_1d – ALaDyn","text":"interface public function fftwf_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_c2r_1d.html"},{"title":"fftwf_plan_dft_c2r_2d – ALaDyn","text":"interface public function fftwf_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_c2r_2d.html"},{"title":"fftwf_plan_dft_c2r_3d – ALaDyn","text":"interface public function fftwf_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_c2r_3d.html"},{"title":"fftwf_plan_guru_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_dft_r2c.html"},{"title":"fftwf_plan_guru_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_dft_c2r.html"},{"title":"fftwf_plan_guru_split_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_split_dft_r2c.html"},{"title":"fftwf_plan_guru_split_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_split_dft_c2r.html"},{"title":"fftwf_plan_guru64_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_dft_r2c.html"},{"title":"fftwf_plan_guru64_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_dft_c2r.html"},{"title":"fftwf_plan_guru64_split_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft_r2c.html"},{"title":"fftwf_plan_guru64_split_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft_c2r.html"},{"title":"fftwf_plan_many_r2r – ALaDyn","text":"interface public function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftwf_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_many_r2r.html"},{"title":"fftwf_plan_r2r – ALaDyn","text":"interface public function fftwf_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_r2r.html"},{"title":"fftwf_plan_r2r_1d – ALaDyn","text":"interface public function fftwf_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_r2r_1d.html"},{"title":"fftwf_plan_r2r_2d – ALaDyn","text":"interface public function fftwf_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftwf_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_r2r_2d.html"},{"title":"fftwf_plan_r2r_3d – ALaDyn","text":"interface public function fftwf_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftwf_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_r2r_3d.html"},{"title":"fftwf_plan_guru_r2r – ALaDyn","text":"interface public function fftwf_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_r2r.html"},{"title":"fftwf_plan_guru64_r2r – ALaDyn","text":"interface public function fftwf_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_r2r.html"},{"title":"fftwf_init_threads – ALaDyn","text":"interface public function fftwf_init_threads() bind(C, name='fftwf_init_threads') Arguments None Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_init_threads.html"},{"title":"fftwf_export_wisdom_to_filename – ALaDyn","text":"interface public function fftwf_export_wisdom_to_filename(filename) bind(C, name='fftwf_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_export_wisdom_to_filename.html"},{"title":"fftwf_export_wisdom_to_string – ALaDyn","text":"interface public function fftwf_export_wisdom_to_string() bind(C, name='fftwf_export_wisdom_to_string') Arguments None Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_export_wisdom_to_string.html"},{"title":"fftwf_import_system_wisdom – ALaDyn","text":"interface public function fftwf_import_system_wisdom() bind(C, name='fftwf_import_system_wisdom') Arguments None Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_system_wisdom.html"},{"title":"fftwf_import_wisdom_from_filename – ALaDyn","text":"interface public function fftwf_import_wisdom_from_filename(filename) bind(C, name='fftwf_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_wisdom_from_filename.html"},{"title":"fftwf_import_wisdom_from_file – ALaDyn","text":"interface public function fftwf_import_wisdom_from_file(input_file) bind(C, name='fftwf_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_wisdom_from_file.html"},{"title":"fftwf_import_wisdom_from_string – ALaDyn","text":"interface public function fftwf_import_wisdom_from_string(input_string) bind(C, name='fftwf_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_wisdom_from_string.html"},{"title":"fftwf_import_wisdom – ALaDyn","text":"interface public function fftwf_import_wisdom(read_char, data) bind(C, name='fftwf_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_wisdom.html"},{"title":"fftwf_sprint_plan – ALaDyn","text":"interface public function fftwf_sprint_plan(p) bind(C, name='fftwf_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_sprint_plan.html"},{"title":"fftwf_malloc – ALaDyn","text":"interface public function fftwf_malloc(n) bind(C, name='fftwf_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_malloc.html"},{"title":"fftwf_alloc_real – ALaDyn","text":"interface public function fftwf_alloc_real(n) bind(C, name='fftwf_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_alloc_real.html"},{"title":"fftwf_alloc_complex – ALaDyn","text":"interface public function fftwf_alloc_complex(n) bind(C, name='fftwf_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_alloc_complex.html"},{"title":"fftwf_estimate_cost – ALaDyn","text":"interface public function fftwf_estimate_cost(p) bind(C, name='fftwf_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/fftwf_estimate_cost.html"},{"title":"fftwf_cost – ALaDyn","text":"interface public function fftwf_cost(p) bind(C, name='fftwf_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/fftwf_cost.html"},{"title":"fftwf_alignment_of – ALaDyn","text":"interface public function fftwf_alignment_of(p) bind(C, name='fftwf_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_FLOAT), intent(out), dimension(*) :: p Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_alignment_of.html"},{"title":"fftwf_execute_dft – ALaDyn","text":"interface public subroutine fftwf_execute_dft(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft.html"},{"title":"fftwf_execute_split_dft – ALaDyn","text":"interface public subroutine fftwf_execute_split_dft(p, ri, ii, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftwf_execute_split_dft.html"},{"title":"fftwf_execute_dft_r2c – ALaDyn","text":"interface public subroutine fftwf_execute_dft_r2c(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft_r2c.html"},{"title":"fftwf_execute_dft_c2r – ALaDyn","text":"interface public subroutine fftwf_execute_dft_c2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft_c2r.html"},{"title":"fftwf_execute_split_dft_r2c – ALaDyn","text":"interface public subroutine fftwf_execute_split_dft_r2c(p, in, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftwf_execute_split_dft_r2c.html"},{"title":"fftwf_execute_split_dft_c2r – ALaDyn","text":"interface public subroutine fftwf_execute_split_dft_c2r(p, ri, ii, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_split_dft_c2r.html"},{"title":"fftwf_execute_r2r – ALaDyn","text":"interface public subroutine fftwf_execute_r2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_r2r.html"},{"title":"fftwf_destroy_plan – ALaDyn","text":"interface public subroutine fftwf_destroy_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_destroy_plan.html"},{"title":"fftwf_forget_wisdom – ALaDyn","text":"interface public subroutine fftwf_forget_wisdom() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftwf_forget_wisdom.html"},{"title":"fftwf_cleanup – ALaDyn","text":"interface public subroutine fftwf_cleanup() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftwf_cleanup.html"},{"title":"fftwf_set_timelimit – ALaDyn","text":"interface public subroutine fftwf_set_timelimit(t) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t","tags":"","loc":"interface/fftwf_set_timelimit.html"},{"title":"fftwf_plan_with_nthreads – ALaDyn","text":"interface public subroutine fftwf_plan_with_nthreads(nthreads) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads","tags":"","loc":"interface/fftwf_plan_with_nthreads.html"},{"title":"fftwf_cleanup_threads – ALaDyn","text":"interface public subroutine fftwf_cleanup_threads() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftwf_cleanup_threads.html"},{"title":"fftwf_make_planner_thread_safe – ALaDyn","text":"interface public subroutine fftwf_make_planner_thread_safe() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftwf_make_planner_thread_safe.html"},{"title":"fftwf_export_wisdom_to_file – ALaDyn","text":"interface public subroutine fftwf_export_wisdom_to_file(output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file","tags":"","loc":"interface/fftwf_export_wisdom_to_file.html"},{"title":"fftwf_export_wisdom – ALaDyn","text":"interface public subroutine fftwf_export_wisdom(write_char, data) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data","tags":"","loc":"interface/fftwf_export_wisdom.html"},{"title":"fftwf_fprint_plan – ALaDyn","text":"interface public subroutine fftwf_fprint_plan(p, output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file","tags":"","loc":"interface/fftwf_fprint_plan.html"},{"title":"fftwf_print_plan – ALaDyn","text":"interface public subroutine fftwf_print_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_print_plan.html"},{"title":"fftwf_free – ALaDyn","text":"interface public subroutine fftwf_free(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_free.html"},{"title":"fftwf_flops – ALaDyn","text":"interface public subroutine fftwf_flops(p, add, mul, fmas) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas","tags":"","loc":"interface/fftwf_flops.html"},{"title":"logical_dimension – ALaDyn","text":"public pure function logical_dimension(kind_flag, N) result(log_dim) Returns the logical dimension given the FFT Kind.\n To be generalized for other applications than\n FFTW_RODFT00 and FFTW_REDFT00 Arguments Type Intent Optional Attributes Name integer(kind=C_INTPTR_T), intent(in) :: kind_flag integer, intent(in) :: N Return Value integer Called by proc~~logical_dimension~~CalledByGraph proc~logical_dimension logical_dimension proc~ftw1d_sc ftw1d_sc proc~ftw1d_sc->proc~logical_dimension proc~pftw2d_sc pftw2d_sc proc~pftw2d_sc->proc~ftw1d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~ftw1d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d_sc proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/logical_dimension.html"},{"title":"determine_kind – ALaDyn","text":"public pure function determine_kind(sym_index) result(kind) Converts the integer flag sym into the proper FFT kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: sym_index Return Value integer(kind=C_INTPTR_T) Called by proc~~determine_kind~~CalledByGraph proc~determine_kind determine_kind proc~ftw1d_sc ftw1d_sc proc~ftw1d_sc->proc~determine_kind proc~pftw2d_sc pftw2d_sc proc~pftw2d_sc->proc~ftw1d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~ftw1d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d_sc proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/determine_kind.html"},{"title":"ftw_init – ALaDyn","text":"public subroutine ftw_init(n1, n2, n3, ind_ft) Initialization of all the FFT variables and plans Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ind_ft Calls proc~~ftw_init~2~~CallsGraph proc~ftw_init~2 ftw_init interface~fftw_alloc_complex~2 fftw_alloc_complex proc~ftw_init~2->interface~fftw_alloc_complex~2 interface~fftw_plan_dft_c2r_1d~2 fftw_plan_dft_c2r_1d proc~ftw_init~2->interface~fftw_plan_dft_c2r_1d~2 interface~fftw_plan_dft_r2c_1d~2 fftw_plan_dft_r2c_1d proc~ftw_init~2->interface~fftw_plan_dft_r2c_1d~2 interface~fftw_plan_r2r_1d~2 fftw_plan_r2r_1d proc~ftw_init~2->interface~fftw_plan_r2r_1d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw_init~2.html"},{"title":"ftw_end – ALaDyn","text":"public subroutine ftw_end() Routines that ends all the FFTs. It destroys the existing plans\n and deallocates the arrays. Arguments None Calls proc~~ftw_end~2~~CallsGraph proc~ftw_end~2 ftw_end interface~fftw_destroy_plan~2 fftw_destroy_plan proc~ftw_end~2->interface~fftw_destroy_plan~2 interface~fftw_free~2 fftw_free proc~ftw_end~2->interface~fftw_free~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw_end~2.html"},{"title":"ftw1d_st – ALaDyn","text":"public subroutine ftw1d_st(w, n1, n2, n3, is, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) WARNING: Not used in the code, need to be checked integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir Calls proc~~ftw1d_st~2~~CallsGraph proc~ftw1d_st~2 ftw1d_st interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~ftw1d_st~2->interface~fftw_execute_dft_r2c interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~ftw1d_st~2->interface~fftw_execute_dft_c2r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw1d_st~2.html"},{"title":"ftw1d – ALaDyn","text":"public subroutine ftw1d(w, n1, n2, n3, is, dir) WARNING: Still to be checked Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir Calls proc~~ftw1d~~CallsGraph proc~ftw1d ftw1d interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~ftw1d->interface~fftw_execute_dft_r2c interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~ftw1d->interface~fftw_execute_dft_c2r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ftw1d~~CalledByGraph proc~ftw1d ftw1d proc~pftw2d pftw2d proc~pftw2d->proc~ftw1d proc~pftw3d pftw3d proc~pftw3d->proc~ftw1d proc~pftw3d->proc~pftw2d proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw1d.html"},{"title":"ftw1d_sc – ALaDyn","text":"public subroutine ftw1d_sc(w, n1, n2, n3, is, dir, sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir integer, intent(in) :: sym Calls proc~~ftw1d_sc~~CallsGraph proc~ftw1d_sc ftw1d_sc proc~determine_kind determine_kind proc~ftw1d_sc->proc~determine_kind proc~logical_dimension logical_dimension proc~ftw1d_sc->proc~logical_dimension interface~fftw_execute_r2r fftw_execute_r2r proc~ftw1d_sc->interface~fftw_execute_r2r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ftw1d_sc~~CalledByGraph proc~ftw1d_sc ftw1d_sc proc~pftw2d_sc pftw2d_sc proc~pftw2d_sc->proc~ftw1d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~ftw1d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d_sc proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ftw1d_sc.html"},{"title":"fftw_plan_dft – ALaDyn","text":"interface public function fftw_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftw_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft~2.html"},{"title":"fftw_plan_dft_1d – ALaDyn","text":"interface public function fftw_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftw_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_1d~2.html"},{"title":"fftw_plan_dft_2d – ALaDyn","text":"interface public function fftw_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftw_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_2d~2.html"},{"title":"fftw_plan_dft_3d – ALaDyn","text":"interface public function fftw_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftw_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_3d~2.html"},{"title":"fftw_plan_many_dft – ALaDyn","text":"interface public function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftw_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_many_dft~2.html"},{"title":"fftw_plan_guru_dft – ALaDyn","text":"interface public function fftw_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_dft~2.html"},{"title":"fftw_plan_guru_split_dft – ALaDyn","text":"interface public function fftw_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_split_dft~2.html"},{"title":"fftw_plan_guru64_dft – ALaDyn","text":"interface public function fftw_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_dft~2.html"},{"title":"fftw_plan_guru64_split_dft – ALaDyn","text":"interface public function fftw_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_split_dft~2.html"},{"title":"fftw_plan_many_dft_r2c – ALaDyn","text":"interface public function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_many_dft_r2c~2.html"},{"title":"fftw_plan_dft_r2c – ALaDyn","text":"interface public function fftw_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_r2c~2.html"},{"title":"fftw_plan_dft_r2c_1d – ALaDyn","text":"interface Called by interface~~fftw_plan_dft_r2c_1d~2~~CalledByGraph interface~fftw_plan_dft_r2c_1d~2 fftw_plan_dft_r2c_1d proc~ftw_init~2 ftw_init proc~ftw_init~2->interface~fftw_plan_dft_r2c_1d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function fftw_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_r2c_1d~2.html"},{"title":"fftw_plan_dft_r2c_2d – ALaDyn","text":"interface public function fftw_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_r2c_2d~2.html"},{"title":"fftw_plan_dft_r2c_3d – ALaDyn","text":"interface public function fftw_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_r2c_3d~2.html"},{"title":"fftw_plan_many_dft_c2r – ALaDyn","text":"interface public function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_many_dft_c2r~2.html"},{"title":"fftw_plan_dft_c2r – ALaDyn","text":"interface public function fftw_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_c2r~2.html"},{"title":"fftw_plan_dft_c2r_1d – ALaDyn","text":"interface Called by interface~~fftw_plan_dft_c2r_1d~2~~CalledByGraph interface~fftw_plan_dft_c2r_1d~2 fftw_plan_dft_c2r_1d proc~ftw_init~2 ftw_init proc~ftw_init~2->interface~fftw_plan_dft_c2r_1d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function fftw_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_c2r_1d~2.html"},{"title":"fftw_plan_dft_c2r_2d – ALaDyn","text":"interface public function fftw_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_c2r_2d~2.html"},{"title":"fftw_plan_dft_c2r_3d – ALaDyn","text":"interface public function fftw_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_dft_c2r_3d~2.html"},{"title":"fftw_plan_guru_dft_r2c – ALaDyn","text":"interface public function fftw_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_dft_r2c~2.html"},{"title":"fftw_plan_guru_dft_c2r – ALaDyn","text":"interface public function fftw_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_dft_c2r~2.html"},{"title":"fftw_plan_guru_split_dft_r2c – ALaDyn","text":"interface public function fftw_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_split_dft_r2c~2.html"},{"title":"fftw_plan_guru_split_dft_c2r – ALaDyn","text":"interface public function fftw_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_split_dft_c2r~2.html"},{"title":"fftw_plan_guru64_dft_r2c – ALaDyn","text":"interface public function fftw_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_dft_r2c~2.html"},{"title":"fftw_plan_guru64_dft_c2r – ALaDyn","text":"interface public function fftw_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_dft_c2r~2.html"},{"title":"fftw_plan_guru64_split_dft_r2c – ALaDyn","text":"interface public function fftw_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_split_dft_r2c~2.html"},{"title":"fftw_plan_guru64_split_dft_c2r – ALaDyn","text":"interface public function fftw_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_split_dft_c2r~2.html"},{"title":"fftw_plan_many_r2r – ALaDyn","text":"interface public function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftw_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_many_r2r~2.html"},{"title":"fftw_plan_r2r – ALaDyn","text":"interface public function fftw_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftw_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_r2r~2.html"},{"title":"fftw_plan_r2r_1d – ALaDyn","text":"interface Called by interface~~fftw_plan_r2r_1d~2~~CalledByGraph interface~fftw_plan_r2r_1d~2 fftw_plan_r2r_1d proc~ftw_init~2 ftw_init proc~ftw_init~2->interface~fftw_plan_r2r_1d~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function fftw_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftw_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_r2r_1d~2.html"},{"title":"fftw_plan_r2r_2d – ALaDyn","text":"interface public function fftw_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftw_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_r2r_2d~2.html"},{"title":"fftw_plan_r2r_3d – ALaDyn","text":"interface public function fftw_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftw_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_r2r_3d~2.html"},{"title":"fftw_plan_guru_r2r – ALaDyn","text":"interface public function fftw_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru_r2r~2.html"},{"title":"fftw_plan_guru64_r2r – ALaDyn","text":"interface public function fftw_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftw_plan_guru64_r2r~2.html"},{"title":"fftw_init_threads – ALaDyn","text":"interface public function fftw_init_threads() bind(C, name='fftw_init_threads') Arguments None Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_init_threads~2.html"},{"title":"fftw_export_wisdom_to_filename – ALaDyn","text":"interface public function fftw_export_wisdom_to_filename(filename) bind(C, name='fftw_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_export_wisdom_to_filename~2.html"},{"title":"fftw_export_wisdom_to_string – ALaDyn","text":"interface public function fftw_export_wisdom_to_string() bind(C, name='fftw_export_wisdom_to_string') Arguments None Return Value type(C_PTR)","tags":"","loc":"interface/fftw_export_wisdom_to_string~2.html"},{"title":"fftw_import_system_wisdom – ALaDyn","text":"interface public function fftw_import_system_wisdom() bind(C, name='fftw_import_system_wisdom') Arguments None Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_system_wisdom~2.html"},{"title":"fftw_import_wisdom_from_filename – ALaDyn","text":"interface public function fftw_import_wisdom_from_filename(filename) bind(C, name='fftw_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_wisdom_from_filename~2.html"},{"title":"fftw_import_wisdom_from_file – ALaDyn","text":"interface public function fftw_import_wisdom_from_file(input_file) bind(C, name='fftw_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_wisdom_from_file~2.html"},{"title":"fftw_import_wisdom_from_string – ALaDyn","text":"interface public function fftw_import_wisdom_from_string(input_string) bind(C, name='fftw_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_wisdom_from_string~2.html"},{"title":"fftw_import_wisdom – ALaDyn","text":"interface public function fftw_import_wisdom(read_char, data) bind(C, name='fftw_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_import_wisdom~2.html"},{"title":"fftw_sprint_plan – ALaDyn","text":"interface public function fftw_sprint_plan(p) bind(C, name='fftw_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(C_PTR)","tags":"","loc":"interface/fftw_sprint_plan~2.html"},{"title":"fftw_malloc – ALaDyn","text":"interface public function fftw_malloc(n) bind(C, name='fftw_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftw_malloc~2.html"},{"title":"fftw_alloc_real – ALaDyn","text":"interface public function fftw_alloc_real(n) bind(C, name='fftw_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftw_alloc_real~2.html"},{"title":"fftw_alloc_complex – ALaDyn","text":"interface Called by interface~~fftw_alloc_complex~2~~CalledByGraph interface~fftw_alloc_complex~2 fftw_alloc_complex proc~ftw_init~2 ftw_init proc~ftw_init~2->interface~fftw_alloc_complex~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public function fftw_alloc_complex(n) bind(C, name='fftw_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftw_alloc_complex~2.html"},{"title":"fftw_estimate_cost – ALaDyn","text":"interface public function fftw_estimate_cost(p) bind(C, name='fftw_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/fftw_estimate_cost~2.html"},{"title":"fftw_cost – ALaDyn","text":"interface public function fftw_cost(p) bind(C, name='fftw_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/fftw_cost~2.html"},{"title":"fftw_alignment_of – ALaDyn","text":"interface public function fftw_alignment_of(p) bind(C, name='fftw_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), intent(out), dimension(*) :: p Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftw_alignment_of~2.html"},{"title":"fftw_execute_dft – ALaDyn","text":"interface public subroutine fftw_execute_dft(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft~2.html"},{"title":"fftw_execute_split_dft – ALaDyn","text":"interface public subroutine fftw_execute_split_dft(p, ri, ii, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftw_execute_split_dft~2.html"},{"title":"fftw_execute_dft_r2c – ALaDyn","text":"interface Called by interface~~fftw_execute_dft_r2c~~CalledByGraph interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~ftw1d ftw1d proc~ftw1d->interface~fftw_execute_dft_r2c proc~ftw1d_st~2 ftw1d_st proc~ftw1d_st~2->interface~fftw_execute_dft_r2c proc~pftw2d pftw2d proc~pftw2d->proc~ftw1d proc~pftw3d pftw3d proc~pftw3d->proc~ftw1d proc~pftw3d->proc~pftw2d proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine fftw_execute_dft_r2c(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft_r2c.html"},{"title":"fftw_execute_dft_c2r – ALaDyn","text":"interface Called by interface~~fftw_execute_dft_c2r~~CalledByGraph interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~ftw1d ftw1d proc~ftw1d->interface~fftw_execute_dft_c2r proc~ftw1d_st~2 ftw1d_st proc~ftw1d_st~2->interface~fftw_execute_dft_c2r proc~pftw2d pftw2d proc~pftw2d->proc~ftw1d proc~pftw3d pftw3d proc~pftw3d->proc~ftw1d proc~pftw3d->proc~pftw2d proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine fftw_execute_dft_c2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft_c2r.html"},{"title":"fftw_execute_split_dft_r2c – ALaDyn","text":"interface public subroutine fftw_execute_split_dft_r2c(p, in, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftw_execute_split_dft_r2c~2.html"},{"title":"fftw_execute_split_dft_c2r – ALaDyn","text":"interface public subroutine fftw_execute_split_dft_c2r(p, ri, ii, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_split_dft_c2r~2.html"},{"title":"fftw_execute_r2r – ALaDyn","text":"interface Called by interface~~fftw_execute_r2r~~CalledByGraph interface~fftw_execute_r2r fftw_execute_r2r proc~ftw1d_sc ftw1d_sc proc~ftw1d_sc->interface~fftw_execute_r2r proc~pftw2d_sc pftw2d_sc proc~pftw2d_sc->proc~ftw1d_sc proc~pftw3d_sc pftw3d_sc proc~pftw3d_sc->proc~ftw1d_sc proc~pftw3d_sc->proc~pftw2d_sc proc~fft_2d_psolv fft_2d_psolv proc~fft_2d_psolv->proc~pftw2d_sc proc~fft_3d_psolv fft_3d_psolv proc~fft_3d_psolv->proc~pftw3d_sc proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fft_2d_psolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine fftw_execute_r2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_r2r.html"},{"title":"fftw_destroy_plan – ALaDyn","text":"interface Called by interface~~fftw_destroy_plan~2~~CalledByGraph interface~fftw_destroy_plan~2 fftw_destroy_plan proc~ftw_end~2 ftw_end proc~ftw_end~2->interface~fftw_destroy_plan~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine fftw_destroy_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_destroy_plan~2.html"},{"title":"fftw_forget_wisdom – ALaDyn","text":"interface public subroutine fftw_forget_wisdom() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftw_forget_wisdom~2.html"},{"title":"fftw_cleanup – ALaDyn","text":"interface public subroutine fftw_cleanup() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftw_cleanup~2.html"},{"title":"fftw_set_timelimit – ALaDyn","text":"interface public subroutine fftw_set_timelimit(t) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t","tags":"","loc":"interface/fftw_set_timelimit~2.html"},{"title":"fftw_plan_with_nthreads – ALaDyn","text":"interface public subroutine fftw_plan_with_nthreads(nthreads) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads","tags":"","loc":"interface/fftw_plan_with_nthreads~2.html"},{"title":"fftw_cleanup_threads – ALaDyn","text":"interface public subroutine fftw_cleanup_threads() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftw_cleanup_threads~2.html"},{"title":"fftw_make_planner_thread_safe – ALaDyn","text":"interface public subroutine fftw_make_planner_thread_safe() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftw_make_planner_thread_safe~2.html"},{"title":"fftw_export_wisdom_to_file – ALaDyn","text":"interface public subroutine fftw_export_wisdom_to_file(output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file","tags":"","loc":"interface/fftw_export_wisdom_to_file~2.html"},{"title":"fftw_export_wisdom – ALaDyn","text":"interface public subroutine fftw_export_wisdom(write_char, data) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data","tags":"","loc":"interface/fftw_export_wisdom~2.html"},{"title":"fftw_fprint_plan – ALaDyn","text":"interface public subroutine fftw_fprint_plan(p, output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file","tags":"","loc":"interface/fftw_fprint_plan~2.html"},{"title":"fftw_print_plan – ALaDyn","text":"interface public subroutine fftw_print_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_print_plan~2.html"},{"title":"fftw_free – ALaDyn","text":"interface Called by interface~~fftw_free~2~~CalledByGraph interface~fftw_free~2 fftw_free proc~ftw_end~2 ftw_end proc~ftw_end~2->interface~fftw_free~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine fftw_free(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_free~2.html"},{"title":"fftw_flops – ALaDyn","text":"interface public subroutine fftw_flops(p, add, mul, fmas) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas","tags":"","loc":"interface/fftw_flops~2.html"},{"title":"fftwf_plan_dft – ALaDyn","text":"interface public function fftwf_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftwf_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft~2.html"},{"title":"fftwf_plan_dft_1d – ALaDyn","text":"interface public function fftwf_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftwf_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_1d~2.html"},{"title":"fftwf_plan_dft_2d – ALaDyn","text":"interface public function fftwf_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftwf_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_2d~2.html"},{"title":"fftwf_plan_dft_3d – ALaDyn","text":"interface public function fftwf_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftwf_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_3d~2.html"},{"title":"fftwf_plan_many_dft – ALaDyn","text":"interface public function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftwf_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_many_dft~2.html"},{"title":"fftwf_plan_guru_dft – ALaDyn","text":"interface public function fftwf_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_dft~2.html"},{"title":"fftwf_plan_guru_split_dft – ALaDyn","text":"interface public function fftwf_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_split_dft~2.html"},{"title":"fftwf_plan_guru64_dft – ALaDyn","text":"interface public function fftwf_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_dft~2.html"},{"title":"fftwf_plan_guru64_split_dft – ALaDyn","text":"interface public function fftwf_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft~2.html"},{"title":"fftwf_plan_many_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_many_dft_r2c~2.html"},{"title":"fftwf_plan_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_r2c~2.html"},{"title":"fftwf_plan_dft_r2c_1d – ALaDyn","text":"interface public function fftwf_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_r2c_1d~2.html"},{"title":"fftwf_plan_dft_r2c_2d – ALaDyn","text":"interface public function fftwf_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_r2c_2d~2.html"},{"title":"fftwf_plan_dft_r2c_3d – ALaDyn","text":"interface public function fftwf_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_r2c_3d~2.html"},{"title":"fftwf_plan_many_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_many_dft_c2r~2.html"},{"title":"fftwf_plan_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_c2r~2.html"},{"title":"fftwf_plan_dft_c2r_1d – ALaDyn","text":"interface public function fftwf_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_c2r_1d~2.html"},{"title":"fftwf_plan_dft_c2r_2d – ALaDyn","text":"interface public function fftwf_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_c2r_2d~2.html"},{"title":"fftwf_plan_dft_c2r_3d – ALaDyn","text":"interface public function fftwf_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_dft_c2r_3d~2.html"},{"title":"fftwf_plan_guru_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_dft_r2c~2.html"},{"title":"fftwf_plan_guru_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_dft_c2r~2.html"},{"title":"fftwf_plan_guru_split_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_split_dft_r2c~2.html"},{"title":"fftwf_plan_guru_split_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_split_dft_c2r~2.html"},{"title":"fftwf_plan_guru64_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_dft_r2c~2.html"},{"title":"fftwf_plan_guru64_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_dft_c2r~2.html"},{"title":"fftwf_plan_guru64_split_dft_r2c – ALaDyn","text":"interface public function fftwf_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft_r2c~2.html"},{"title":"fftwf_plan_guru64_split_dft_c2r – ALaDyn","text":"interface public function fftwf_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft_c2r~2.html"},{"title":"fftwf_plan_many_r2r – ALaDyn","text":"interface public function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftwf_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_many_r2r~2.html"},{"title":"fftwf_plan_r2r – ALaDyn","text":"interface public function fftwf_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_r2r~2.html"},{"title":"fftwf_plan_r2r_1d – ALaDyn","text":"interface public function fftwf_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_r2r_1d~2.html"},{"title":"fftwf_plan_r2r_2d – ALaDyn","text":"interface public function fftwf_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftwf_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_r2r_2d~2.html"},{"title":"fftwf_plan_r2r_3d – ALaDyn","text":"interface public function fftwf_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftwf_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_r2r_3d~2.html"},{"title":"fftwf_plan_guru_r2r – ALaDyn","text":"interface public function fftwf_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru_r2r~2.html"},{"title":"fftwf_plan_guru64_r2r – ALaDyn","text":"interface public function fftwf_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_plan_guru64_r2r~2.html"},{"title":"fftwf_init_threads – ALaDyn","text":"interface public function fftwf_init_threads() bind(C, name='fftwf_init_threads') Arguments None Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_init_threads~2.html"},{"title":"fftwf_export_wisdom_to_filename – ALaDyn","text":"interface public function fftwf_export_wisdom_to_filename(filename) bind(C, name='fftwf_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_export_wisdom_to_filename~2.html"},{"title":"fftwf_export_wisdom_to_string – ALaDyn","text":"interface public function fftwf_export_wisdom_to_string() bind(C, name='fftwf_export_wisdom_to_string') Arguments None Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_export_wisdom_to_string~2.html"},{"title":"fftwf_import_system_wisdom – ALaDyn","text":"interface public function fftwf_import_system_wisdom() bind(C, name='fftwf_import_system_wisdom') Arguments None Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_system_wisdom~2.html"},{"title":"fftwf_import_wisdom_from_filename – ALaDyn","text":"interface public function fftwf_import_wisdom_from_filename(filename) bind(C, name='fftwf_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_wisdom_from_filename~2.html"},{"title":"fftwf_import_wisdom_from_file – ALaDyn","text":"interface public function fftwf_import_wisdom_from_file(input_file) bind(C, name='fftwf_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_wisdom_from_file~2.html"},{"title":"fftwf_import_wisdom_from_string – ALaDyn","text":"interface public function fftwf_import_wisdom_from_string(input_string) bind(C, name='fftwf_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_wisdom_from_string~2.html"},{"title":"fftwf_import_wisdom – ALaDyn","text":"interface public function fftwf_import_wisdom(read_char, data) bind(C, name='fftwf_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_import_wisdom~2.html"},{"title":"fftwf_sprint_plan – ALaDyn","text":"interface public function fftwf_sprint_plan(p) bind(C, name='fftwf_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_sprint_plan~2.html"},{"title":"fftwf_malloc – ALaDyn","text":"interface public function fftwf_malloc(n) bind(C, name='fftwf_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_malloc~2.html"},{"title":"fftwf_alloc_real – ALaDyn","text":"interface public function fftwf_alloc_real(n) bind(C, name='fftwf_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_alloc_real~2.html"},{"title":"fftwf_alloc_complex – ALaDyn","text":"interface public function fftwf_alloc_complex(n) bind(C, name='fftwf_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR)","tags":"","loc":"interface/fftwf_alloc_complex~2.html"},{"title":"fftwf_estimate_cost – ALaDyn","text":"interface public function fftwf_estimate_cost(p) bind(C, name='fftwf_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/fftwf_estimate_cost~2.html"},{"title":"fftwf_cost – ALaDyn","text":"interface public function fftwf_cost(p) bind(C, name='fftwf_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/fftwf_cost~2.html"},{"title":"fftwf_alignment_of – ALaDyn","text":"interface public function fftwf_alignment_of(p) bind(C, name='fftwf_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_FLOAT), intent(out), dimension(*) :: p Return Value integer(kind=C_INT)","tags":"","loc":"interface/fftwf_alignment_of~2.html"},{"title":"fftwf_execute_dft – ALaDyn","text":"interface public subroutine fftwf_execute_dft(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft~2.html"},{"title":"fftwf_execute_split_dft – ALaDyn","text":"interface public subroutine fftwf_execute_split_dft(p, ri, ii, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftwf_execute_split_dft~2.html"},{"title":"fftwf_execute_dft_r2c – ALaDyn","text":"interface public subroutine fftwf_execute_dft_r2c(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft_r2c~2.html"},{"title":"fftwf_execute_dft_c2r – ALaDyn","text":"interface public subroutine fftwf_execute_dft_c2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft_c2r~2.html"},{"title":"fftwf_execute_split_dft_r2c – ALaDyn","text":"interface public subroutine fftwf_execute_split_dft_r2c(p, in, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftwf_execute_split_dft_r2c~2.html"},{"title":"fftwf_execute_split_dft_c2r – ALaDyn","text":"interface public subroutine fftwf_execute_split_dft_c2r(p, ri, ii, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_split_dft_c2r~2.html"},{"title":"fftwf_execute_r2r – ALaDyn","text":"interface public subroutine fftwf_execute_r2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_r2r~2.html"},{"title":"fftwf_destroy_plan – ALaDyn","text":"interface public subroutine fftwf_destroy_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_destroy_plan~2.html"},{"title":"fftwf_forget_wisdom – ALaDyn","text":"interface public subroutine fftwf_forget_wisdom() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftwf_forget_wisdom~2.html"},{"title":"fftwf_cleanup – ALaDyn","text":"interface public subroutine fftwf_cleanup() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftwf_cleanup~2.html"},{"title":"fftwf_set_timelimit – ALaDyn","text":"interface public subroutine fftwf_set_timelimit(t) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t","tags":"","loc":"interface/fftwf_set_timelimit~2.html"},{"title":"fftwf_plan_with_nthreads – ALaDyn","text":"interface public subroutine fftwf_plan_with_nthreads(nthreads) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads","tags":"","loc":"interface/fftwf_plan_with_nthreads~2.html"},{"title":"fftwf_cleanup_threads – ALaDyn","text":"interface public subroutine fftwf_cleanup_threads() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftwf_cleanup_threads~2.html"},{"title":"fftwf_make_planner_thread_safe – ALaDyn","text":"interface public subroutine fftwf_make_planner_thread_safe() bind(C, name=\"0\") Arguments None","tags":"","loc":"interface/fftwf_make_planner_thread_safe~2.html"},{"title":"fftwf_export_wisdom_to_file – ALaDyn","text":"interface public subroutine fftwf_export_wisdom_to_file(output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file","tags":"","loc":"interface/fftwf_export_wisdom_to_file~2.html"},{"title":"fftwf_export_wisdom – ALaDyn","text":"interface public subroutine fftwf_export_wisdom(write_char, data) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data","tags":"","loc":"interface/fftwf_export_wisdom~2.html"},{"title":"fftwf_fprint_plan – ALaDyn","text":"interface public subroutine fftwf_fprint_plan(p, output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file","tags":"","loc":"interface/fftwf_fprint_plan~2.html"},{"title":"fftwf_print_plan – ALaDyn","text":"interface public subroutine fftwf_print_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_print_plan~2.html"},{"title":"fftwf_free – ALaDyn","text":"interface public subroutine fftwf_free(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_free~2.html"},{"title":"fftwf_flops – ALaDyn","text":"interface public subroutine fftwf_flops(p, add, mul, fmas) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas","tags":"","loc":"interface/fftwf_flops~2.html"},{"title":"set_int_pshape – ALaDyn","text":"public subroutine set_int_pshape(spl, xx, ax, ind) Arguments Type Intent Optional Attributes Name integer, intent(in) :: spl real(kind=dp), intent(in) :: xx real(kind=dp), intent(out) :: ax (0:3) integer, intent(out) :: ind Contents None","tags":"","loc":"proc/set_int_pshape.html"},{"title":"set_hint_pshape – ALaDyn","text":"public subroutine set_hint_pshape(spl, xx, ax, ind) Arguments Type Intent Optional Attributes Name integer, intent(in) :: spl real(kind=dp), intent(in) :: xx real(kind=dp), intent(out) :: ax (0:3) integer, intent(out) :: ind Contents None","tags":"","loc":"proc/set_hint_pshape.html"},{"title":"qlh_2d_spline – ALaDyn","text":"public subroutine qlh_2d_spline(xp, ax, axh, ay, ayh, ix, ihx, iy, ihy) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:1) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: ayh (0:1) integer, intent(inout) :: ix integer, intent(inout) :: ihx integer, intent(inout) :: iy integer, intent(inout) :: ihy Called by proc~~qlh_2d_spline~~CalledByGraph proc~qlh_2d_spline qlh_2d_spline proc~set_part2d_hcell_acc set_part2d_hcell_acc proc~set_part2d_hcell_acc->proc~qlh_2d_spline proc~ncdef_2d_curr ncdef_2d_curr proc~ncdef_2d_curr->proc~qlh_2d_spline proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part2d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~ncdef_2d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/qlh_2d_spline.html"},{"title":"qqh_1d_spline – ALaDyn","text":"public subroutine qqh_1d_spline(xp, ax, axh, ix, ihx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:2) integer, intent(inout) :: ix integer, intent(inout) :: ihx Called by proc~~qqh_1d_spline~~CalledByGraph proc~qqh_1d_spline qqh_1d_spline proc~set_part1d_acc set_part1d_acc proc~set_part1d_acc->proc~qqh_1d_spline proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part1d_acc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/qqh_1d_spline.html"},{"title":"qqh_2d_spline – ALaDyn","text":"public subroutine qqh_2d_spline(xp, ax, axh, ay, ayh, ix, ihx, iy, ihy) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:2) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: ayh (0:2) integer, intent(inout) :: ix integer, intent(inout) :: ihx integer, intent(inout) :: iy integer, intent(inout) :: ihy Called by proc~~qqh_2d_spline~~CalledByGraph proc~qqh_2d_spline qqh_2d_spline proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~qqh_2d_spline proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~qqh_2d_spline proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~qqh_2d_spline proc~set_env_acc set_env_acc proc~set_env_acc->proc~qqh_2d_spline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/qqh_2d_spline.html"},{"title":"qlh_3d_spline – ALaDyn","text":"public subroutine qlh_3d_spline(xp, ax, axh, ay, ayh, az, azh, ix, ihx, iy, ihy, iz, ihz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:1) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: ayh (0:1) real(kind=dp), intent(inout) :: az (0:2) real(kind=dp), intent(inout) :: azh (0:1) integer, intent(inout) :: ix integer, intent(inout) :: ihx integer, intent(inout) :: iy integer, intent(inout) :: ihy integer, intent(inout) :: iz integer, intent(inout) :: ihz Called by proc~~qlh_3d_spline~~CalledByGraph proc~qlh_3d_spline qlh_3d_spline proc~ncdef_3d_curr ncdef_3d_curr proc~ncdef_3d_curr->proc~qlh_3d_spline proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_part3d_hcell_acc->proc~qlh_3d_spline proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~ncdef_3d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/qlh_3d_spline.html"},{"title":"qqh_3d_spline – ALaDyn","text":"public subroutine qqh_3d_spline(xp, ax, axh, ay, ayh, az, azh, ix, ihx, iy, ihy, iz, ihz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:2) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: ayh (0:2) real(kind=dp), intent(inout) :: az (0:2) real(kind=dp), intent(inout) :: azh (0:2) integer, intent(inout) :: ix integer, intent(inout) :: ihx integer, intent(inout) :: iy integer, intent(inout) :: ihy integer, intent(inout) :: iz integer, intent(inout) :: ihz Called by proc~~qqh_3d_spline~~CalledByGraph proc~qqh_3d_spline qqh_3d_spline proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~qqh_3d_spline proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~qqh_3d_spline proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~qqh_3d_spline proc~set_env_acc set_env_acc proc~set_env_acc->proc~qqh_3d_spline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/qqh_3d_spline.html"},{"title":"qden_1d_wgh – ALaDyn","text":"public subroutine qden_1d_wgh(xp, ax, ix) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) integer, intent(inout) :: ix Called by proc~~qden_1d_wgh~~CalledByGraph proc~qden_1d_wgh qden_1d_wgh proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~qden_1d_wgh proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~qden_1d_wgh proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~qden_1d_wgh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/qden_1d_wgh.html"},{"title":"qden_2d_wgh – ALaDyn","text":"public subroutine qden_2d_wgh(xp, ax, ay, ix, iy) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: ay (0:2) integer, intent(inout) :: ix integer, intent(inout) :: iy Called by proc~~qden_2d_wgh~~CalledByGraph proc~qden_2d_wgh qden_2d_wgh proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~qden_2d_wgh proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~qden_2d_wgh proc~set_charge_on_ftgrid set_charge_on_ftgrid proc~set_charge_on_ftgrid->proc~qden_2d_wgh proc~esirkepov_2d_curr esirkepov_2d_curr proc~esirkepov_2d_curr->proc~qden_2d_wgh proc~set_env_density set_env_density proc~set_env_density->proc~qden_2d_wgh proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~qden_2d_wgh proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~qden_2d_wgh proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~esirkepov_2d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/qden_2d_wgh.html"},{"title":"cden_2d_wgh – ALaDyn","text":"public subroutine cden_2d_wgh(xp, ax, ay, ix, iy) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:3) real(kind=dp), intent(inout) :: ay (0:3) integer, intent(inout) :: ix integer, intent(inout) :: iy Called by proc~~cden_2d_wgh~~CalledByGraph proc~cden_2d_wgh cden_2d_wgh proc~set_ho_grid_charge set_ho_grid_charge proc~set_ho_grid_charge->proc~cden_2d_wgh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cden_2d_wgh.html"},{"title":"qden_3d_wgh – ALaDyn","text":"public subroutine qden_3d_wgh(xp, ax, ay, az, ix, iy, iz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: az (0:2) integer, intent(inout) :: ix integer, intent(inout) :: iy integer, intent(inout) :: iz Called by proc~~qden_3d_wgh~~CalledByGraph proc~qden_3d_wgh qden_3d_wgh proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~qden_3d_wgh proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~qden_3d_wgh proc~esirkepov_3d_curr esirkepov_3d_curr proc~esirkepov_3d_curr->proc~qden_3d_wgh proc~set_charge_on_ftgrid set_charge_on_ftgrid proc~set_charge_on_ftgrid->proc~qden_3d_wgh proc~set_env_density set_env_density proc~set_env_density->proc~qden_3d_wgh proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~qden_3d_wgh proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~qden_3d_wgh proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~esirkepov_3d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/qden_3d_wgh.html"},{"title":"cden_3d_wgh – ALaDyn","text":"public subroutine cden_3d_wgh(xp, ax, ay, az, ix, iy, iz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:3) real(kind=dp), intent(inout) :: ay (0:3) real(kind=dp), intent(inout) :: az (0:3) integer, intent(inout) :: ix integer, intent(inout) :: iy integer, intent(inout) :: iz Called by proc~~cden_3d_wgh~~CalledByGraph proc~cden_3d_wgh cden_3d_wgh proc~set_ho_grid_charge set_ho_grid_charge proc~set_ho_grid_charge->proc~cden_3d_wgh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cden_3d_wgh.html"},{"title":"set_local_2d_positions – ALaDyn","text":"public subroutine set_local_2d_positions(pt_loc, n1, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt_loc (:,:) integer, intent(in) :: n1 integer, intent(in) :: np Calls proc~~set_local_2d_positions~~CallsGraph proc~set_local_2d_positions set_local_2d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_local_2d_positions~~CalledByGraph proc~set_local_2d_positions set_local_2d_positions proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~set_local_2d_positions proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~set_local_2d_positions proc~set_part2d_hcell_acc set_part2d_hcell_acc proc~set_part2d_hcell_acc->proc~set_local_2d_positions proc~ncdef_2d_curr ncdef_2d_curr proc~ncdef_2d_curr->proc~set_local_2d_positions proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~set_local_2d_positions proc~esirkepov_2d_curr esirkepov_2d_curr proc~esirkepov_2d_curr->proc~set_local_2d_positions proc~set_env_density set_env_density proc~set_env_density->proc~set_local_2d_positions proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~set_local_2d_positions proc~set_env_acc set_env_acc proc~set_env_acc->proc~set_local_2d_positions proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~set_local_2d_positions proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~set_local_2d_positions proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~set_local_2d_positions proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part2d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~ncdef_2d_curr proc~curr_accumulate->proc~esirkepov_2d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_local_2d_positions.html"},{"title":"set_local_3d_positions – ALaDyn","text":"public subroutine set_local_3d_positions(pt_loc, n1, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt_loc (:,:) integer, intent(in) :: n1 integer, intent(in) :: np Calls proc~~set_local_3d_positions~~CallsGraph proc~set_local_3d_positions set_local_3d_positions proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_local_3d_positions~~CalledByGraph proc~set_local_3d_positions set_local_3d_positions proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_grid_charge_and_jx->proc~set_local_3d_positions proc~set_grid_env_den_energy set_grid_env_den_energy proc~set_grid_env_den_energy->proc~set_local_3d_positions proc~esirkepov_3d_curr esirkepov_3d_curr proc~esirkepov_3d_curr->proc~set_local_3d_positions proc~set_env_grad_interp set_env_grad_interp proc~set_env_grad_interp->proc~set_local_3d_positions proc~ncdef_3d_curr ncdef_3d_curr proc~ncdef_3d_curr->proc~set_local_3d_positions proc~set_env_density set_env_density proc~set_env_density->proc~set_local_3d_positions proc~set_ion_efield set_ion_efield proc~set_ion_efield->proc~set_local_3d_positions proc~set_env_acc set_env_acc proc~set_env_acc->proc~set_local_3d_positions proc~set_grid_charge set_grid_charge proc~set_grid_charge->proc~set_local_3d_positions proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_part3d_hcell_acc->proc~set_local_3d_positions proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~set_local_3d_positions proc~set_ion_env_field set_ion_env_field proc~set_ion_env_field->proc~set_local_3d_positions proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~esirkepov_3d_curr proc~curr_accumulate->proc~ncdef_3d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_local_3d_positions.html"},{"title":"set_part_gamma – ALaDyn","text":"public subroutine set_part_gamma(pt_loc, np, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt_loc (:,:) integer, intent(in) :: np integer, intent(in) :: nc Called by proc~~set_part_gamma~~CalledByGraph proc~set_part_gamma set_part_gamma proc~set_grid_den_energy set_grid_den_energy proc~set_grid_den_energy->proc~set_part_gamma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_part_gamma.html"},{"title":"set_part_velocities – ALaDyn","text":"public subroutine set_part_velocities(pt_loc, np, njc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt_loc (:,:) integer, intent(in) :: np integer, intent(in) :: njc Contents None","tags":"","loc":"proc/set_part_velocities.html"},{"title":"set_ho_grid_charge – ALaDyn","text":"public subroutine set_ho_grid_charge(sp_loc, pt, den, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: den (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: ic Calls proc~~set_ho_grid_charge~~CallsGraph proc~set_ho_grid_charge set_ho_grid_charge proc~cden_2d_wgh cden_2d_wgh proc~set_ho_grid_charge->proc~cden_2d_wgh proc~cden_3d_wgh cden_3d_wgh proc~set_ho_grid_charge->proc~cden_3d_wgh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_ho_grid_charge.html"},{"title":"set_charge_on_ftgrid – ALaDyn","text":"public subroutine set_charge_on_ftgrid(sp_loc, pt, den, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: den (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: ic Calls proc~~set_charge_on_ftgrid~~CallsGraph proc~set_charge_on_ftgrid set_charge_on_ftgrid proc~qden_3d_wgh qden_3d_wgh proc~set_charge_on_ftgrid->proc~qden_3d_wgh proc~qden_2d_wgh qden_2d_wgh proc~set_charge_on_ftgrid->proc~qden_2d_wgh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_charge_on_ftgrid.html"},{"title":"set_grid_charge – ALaDyn","text":"public subroutine set_grid_charge(sp_loc, pt, den, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: den (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: ic Calls proc~~set_grid_charge~~CallsGraph proc~set_grid_charge set_grid_charge proc~qden_1d_wgh qden_1d_wgh proc~set_grid_charge->proc~qden_1d_wgh proc~qden_3d_wgh qden_3d_wgh proc~set_grid_charge->proc~qden_3d_wgh proc~qden_2d_wgh qden_2d_wgh proc~set_grid_charge->proc~qden_2d_wgh proc~set_local_3d_positions set_local_3d_positions proc~set_grid_charge->proc~set_local_3d_positions proc~set_local_2d_positions set_local_2d_positions proc~set_grid_charge->proc~set_local_2d_positions proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_grid_charge.html"},{"title":"set_grid_env_den_energy – ALaDyn","text":"public subroutine set_grid_env_den_energy(sp_loc, pt, eden, np, icp) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: eden (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: icp Calls proc~~set_grid_env_den_energy~~CallsGraph proc~set_grid_env_den_energy set_grid_env_den_energy proc~qden_1d_wgh qden_1d_wgh proc~set_grid_env_den_energy->proc~qden_1d_wgh proc~qden_3d_wgh qden_3d_wgh proc~set_grid_env_den_energy->proc~qden_3d_wgh proc~qden_2d_wgh qden_2d_wgh proc~set_grid_env_den_energy->proc~qden_2d_wgh proc~set_local_3d_positions set_local_3d_positions proc~set_grid_env_den_energy->proc~set_local_3d_positions proc~set_local_2d_positions set_local_2d_positions proc~set_grid_env_den_energy->proc~set_local_2d_positions proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_grid_env_den_energy.html"},{"title":"set_grid_den_energy – ALaDyn","text":"public subroutine set_grid_den_energy(sp_loc, pt, eden, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: eden (:,:,:,:) integer, intent(in) :: np Calls proc~~set_grid_den_energy~~CallsGraph proc~set_grid_den_energy set_grid_den_energy proc~qden_1d_wgh qden_1d_wgh proc~set_grid_den_energy->proc~qden_1d_wgh proc~set_part_gamma set_part_gamma proc~set_grid_den_energy->proc~set_part_gamma proc~qden_3d_wgh qden_3d_wgh proc~set_grid_den_energy->proc~qden_3d_wgh proc~qden_2d_wgh qden_2d_wgh proc~set_grid_den_energy->proc~qden_2d_wgh proc~set_local_3d_positions set_local_3d_positions proc~set_grid_den_energy->proc~set_local_3d_positions proc~set_local_2d_positions set_local_2d_positions proc~set_grid_den_energy->proc~set_local_2d_positions proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_grid_den_energy.html"},{"title":"set_grid_charge_and_jx – ALaDyn","text":"public subroutine set_grid_charge_and_jx(sp_loc, pt, eden, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: eden (:,:,:,:) integer, intent(in) :: np Calls proc~~set_grid_charge_and_jx~~CallsGraph proc~set_grid_charge_and_jx set_grid_charge_and_jx proc~set_local_2d_positions set_local_2d_positions proc~set_grid_charge_and_jx->proc~set_local_2d_positions proc~qden_3d_wgh qden_3d_wgh proc~set_grid_charge_and_jx->proc~qden_3d_wgh proc~qden_2d_wgh qden_2d_wgh proc~set_grid_charge_and_jx->proc~qden_2d_wgh proc~set_local_3d_positions set_local_3d_positions proc~set_grid_charge_and_jx->proc~set_local_3d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_grid_charge_and_jx.html"},{"title":"set_part1d_acc – ALaDyn","text":"public subroutine set_part1d_acc(ef, sp_loc, pt, np, ndf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ndf Calls proc~~set_part1d_acc~~CallsGraph proc~set_part1d_acc set_part1d_acc proc~qqh_1d_spline qqh_1d_spline proc~set_part1d_acc->proc~qqh_1d_spline Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_part1d_acc~~CalledByGraph proc~set_part1d_acc set_part1d_acc proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part1d_acc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_part1d_acc.html"},{"title":"set_part2d_hcell_acc – ALaDyn","text":"public subroutine set_part2d_hcell_acc(ef, sp_loc, pt, np, ndf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ndf Calls proc~~set_part2d_hcell_acc~~CallsGraph proc~set_part2d_hcell_acc set_part2d_hcell_acc proc~qlh_2d_spline qlh_2d_spline proc~set_part2d_hcell_acc->proc~qlh_2d_spline proc~set_local_2d_positions set_local_2d_positions proc~set_part2d_hcell_acc->proc~set_local_2d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_part2d_hcell_acc~~CalledByGraph proc~set_part2d_hcell_acc set_part2d_hcell_acc proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part2d_hcell_acc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_part2d_hcell_acc.html"},{"title":"set_part3d_hcell_acc – ALaDyn","text":"public subroutine set_part3d_hcell_acc(ef, sp_loc, pt, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np Calls proc~~set_part3d_hcell_acc~~CallsGraph proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~qlh_3d_spline qlh_3d_spline proc~set_part3d_hcell_acc->proc~qlh_3d_spline proc~set_local_3d_positions set_local_3d_positions proc~set_part3d_hcell_acc->proc~set_local_3d_positions proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_part3d_hcell_acc~~CalledByGraph proc~set_part3d_hcell_acc set_part3d_hcell_acc proc~set_lpf_acc set_lpf_acc proc~set_lpf_acc->proc~set_part3d_hcell_acc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_part3d_hcell_acc.html"},{"title":"set_ion_efield – ALaDyn","text":"public subroutine set_ion_efield(ef, sp_loc, pt, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np Calls proc~~set_ion_efield~~CallsGraph proc~set_ion_efield set_ion_efield proc~qqh_3d_spline qqh_3d_spline proc~set_ion_efield->proc~qqh_3d_spline proc~set_local_2d_positions set_local_2d_positions proc~set_ion_efield->proc~set_local_2d_positions proc~qqh_2d_spline qqh_2d_spline proc~set_ion_efield->proc~qqh_2d_spline proc~set_local_3d_positions set_local_3d_positions proc~set_ion_efield->proc~set_local_3d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_ion_efield.html"},{"title":"set_env_acc – ALaDyn","text":"public subroutine set_env_acc(ef, av, sp_loc, pt, np, dt_step) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) real(kind=dp), intent(in) :: av (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np real(kind=dp), intent(in) :: dt_step Calls proc~~set_env_acc~~CallsGraph proc~set_env_acc set_env_acc proc~qqh_3d_spline qqh_3d_spline proc~set_env_acc->proc~qqh_3d_spline proc~set_local_2d_positions set_local_2d_positions proc~set_env_acc->proc~set_local_2d_positions proc~qqh_2d_spline qqh_2d_spline proc~set_env_acc->proc~qqh_2d_spline proc~set_local_3d_positions set_local_3d_positions proc~set_env_acc->proc~set_local_3d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_env_acc.html"},{"title":"set_ion_env_field – ALaDyn","text":"public subroutine set_ion_env_field(ef, sp_loc, pt, np, om0) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np real(kind=dp), intent(in) :: om0 Calls proc~~set_ion_env_field~~CallsGraph proc~set_ion_env_field set_ion_env_field proc~qqh_3d_spline qqh_3d_spline proc~set_ion_env_field->proc~qqh_3d_spline proc~set_local_2d_positions set_local_2d_positions proc~set_ion_env_field->proc~set_local_2d_positions proc~qqh_2d_spline qqh_2d_spline proc~set_ion_env_field->proc~qqh_2d_spline proc~set_local_3d_positions set_local_3d_positions proc~set_ion_env_field->proc~set_local_3d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_ion_env_field.html"},{"title":"set_env_grad_interp – ALaDyn","text":"public subroutine set_env_grad_interp(av, sp_loc, pt, np, ndm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: av (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ndm Calls proc~~set_env_grad_interp~~CallsGraph proc~set_env_grad_interp set_env_grad_interp proc~qqh_3d_spline qqh_3d_spline proc~set_env_grad_interp->proc~qqh_3d_spline proc~set_local_2d_positions set_local_2d_positions proc~set_env_grad_interp->proc~set_local_2d_positions proc~qqh_2d_spline qqh_2d_spline proc~set_env_grad_interp->proc~qqh_2d_spline proc~set_local_3d_positions set_local_3d_positions proc~set_env_grad_interp->proc~set_local_3d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_env_grad_interp.html"},{"title":"set_env_density – ALaDyn","text":"public subroutine set_env_density(efp, av, np, ic) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: efp (:,:) real(kind=dp), intent(inout) :: av (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: ic Calls proc~~set_env_density~~CallsGraph proc~set_env_density set_env_density proc~set_local_2d_positions set_local_2d_positions proc~set_env_density->proc~set_local_2d_positions proc~qden_3d_wgh qden_3d_wgh proc~set_env_density->proc~qden_3d_wgh proc~qden_2d_wgh qden_2d_wgh proc~set_env_density->proc~qden_2d_wgh proc~set_local_3d_positions set_local_3d_positions proc~set_env_density->proc~set_local_3d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_env_density.html"},{"title":"esirkepov_2d_curr – ALaDyn","text":"public subroutine esirkepov_2d_curr(sp_loc, pt, jcurr, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: jcurr (:,:,:,:) integer, intent(in) :: np Calls proc~~esirkepov_2d_curr~~CallsGraph proc~esirkepov_2d_curr esirkepov_2d_curr proc~set_local_2d_positions set_local_2d_positions proc~esirkepov_2d_curr->proc~set_local_2d_positions proc~qden_2d_wgh qden_2d_wgh proc~esirkepov_2d_curr->proc~qden_2d_wgh proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~esirkepov_2d_curr~~CalledByGraph proc~esirkepov_2d_curr esirkepov_2d_curr proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~esirkepov_2d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/esirkepov_2d_curr.html"},{"title":"esirkepov_3d_curr – ALaDyn","text":"public subroutine esirkepov_3d_curr(sp_loc, pt, jcurr, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: jcurr (:,:,:,:) integer, intent(in) :: np Calls proc~~esirkepov_3d_curr~~CallsGraph proc~esirkepov_3d_curr esirkepov_3d_curr proc~qden_3d_wgh qden_3d_wgh proc~esirkepov_3d_curr->proc~qden_3d_wgh proc~set_local_3d_positions set_local_3d_positions proc~esirkepov_3d_curr->proc~set_local_3d_positions proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~esirkepov_3d_curr~~CalledByGraph proc~esirkepov_3d_curr esirkepov_3d_curr proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~esirkepov_3d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/esirkepov_3d_curr.html"},{"title":"ncdef_2d_curr – ALaDyn","text":"public subroutine ncdef_2d_curr(sp_loc, pt, jcurr, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: jcurr (:,:,:,:) integer, intent(in) :: np Calls proc~~ncdef_2d_curr~~CallsGraph proc~ncdef_2d_curr ncdef_2d_curr proc~qlh_2d_spline qlh_2d_spline proc~ncdef_2d_curr->proc~qlh_2d_spline proc~set_local_2d_positions set_local_2d_positions proc~ncdef_2d_curr->proc~set_local_2d_positions proc~map2dy_part_sind map2dy_part_sind proc~set_local_2d_positions->proc~map2dy_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ncdef_2d_curr~~CalledByGraph proc~ncdef_2d_curr ncdef_2d_curr proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~ncdef_2d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ncdef_2d_curr.html"},{"title":"ncdef_3d_curr – ALaDyn","text":"public subroutine ncdef_3d_curr(sp_loc, pt, jcurr, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: jcurr (:,:,:,:) integer, intent(in) :: np Calls proc~~ncdef_3d_curr~~CallsGraph proc~ncdef_3d_curr ncdef_3d_curr proc~qlh_3d_spline qlh_3d_spline proc~ncdef_3d_curr->proc~qlh_3d_spline proc~set_local_3d_positions set_local_3d_positions proc~ncdef_3d_curr->proc~set_local_3d_positions proc~map3d_part_sind map3d_part_sind proc~set_local_3d_positions->proc~map3d_part_sind proc~map2dy_part_sind map2dy_part_sind proc~map3d_part_sind->proc~map2dy_part_sind proc~map2dz_part_sind map2dz_part_sind proc~map3d_part_sind->proc~map2dz_part_sind proc~invert_stretched_grid invert_stretched_grid proc~map2dy_part_sind->proc~invert_stretched_grid proc~invert_uniform_grid invert_uniform_grid proc~map2dy_part_sind->proc~invert_uniform_grid proc~map2dz_part_sind->proc~invert_stretched_grid proc~map2dz_part_sind->proc~invert_uniform_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ncdef_3d_curr~~CalledByGraph proc~ncdef_3d_curr ncdef_3d_curr proc~curr_accumulate curr_accumulate proc~curr_accumulate->proc~ncdef_3d_curr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ncdef_3d_curr.html"},{"title":"fill_curr_yzxbdsdata – ALaDyn","text":"public subroutine fill_curr_yzxbdsdata(curr, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: nc Calls proc~~fill_curr_yzxbdsdata~~CallsGraph proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~exchange_bdx_data exchange_bdx_data proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fill_curr_yzxbdsdata~~CalledByGraph proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fill_curr_yzxbdsdata proc~prl_bden_energy_interp prl_bden_energy_interp proc~prl_bden_energy_interp->proc~fill_curr_yzxbdsdata proc~curr_mpi_collect curr_mpi_collect proc~curr_mpi_collect->proc~fill_curr_yzxbdsdata proc~collect_bunch_and_plasma_density collect_bunch_and_plasma_density proc~collect_bunch_and_plasma_density->proc~fill_curr_yzxbdsdata proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~curr_mpi_collect proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fill_curr_yzxbdsdata.html"},{"title":"fill_ftcurr_yzbdsdata – ALaDyn","text":"public subroutine fill_ftcurr_yzbdsdata(curr, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: nc Calls proc~~fill_ftcurr_yzbdsdata~~CallsGraph proc~fill_ftcurr_yzbdsdata fill_ftcurr_yzbdsdata proc~exchange_bdx_data exchange_bdx_data proc~fill_ftcurr_yzbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fill_ftcurr_yzbdsdata.html"},{"title":"jc_xyzbd – ALaDyn","text":"public subroutine jc_xyzbd(curr, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: nc Called by proc~~jc_xyzbd~~CalledByGraph proc~jc_xyzbd jc_xyzbd proc~curr_mpi_collect curr_mpi_collect proc~curr_mpi_collect->proc~jc_xyzbd proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~curr_mpi_collect proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/jc_xyzbd.html"},{"title":"den_zyxbd – ALaDyn","text":"public subroutine den_zyxbd(rho, ik) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: rho (:,:,:,:) integer, intent(in) :: ik Called by proc~~den_zyxbd~~CalledByGraph proc~den_zyxbd den_zyxbd proc~prl_den_energy_interp prl_den_energy_interp proc~prl_den_energy_interp->proc~den_zyxbd proc~data_out data_out proc~data_out->proc~prl_den_energy_interp proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/den_zyxbd.html"},{"title":"check_decomposition – ALaDyn","text":"public subroutine check_decomposition() Arguments None Called by proc~~check_decomposition~~CalledByGraph proc~check_decomposition check_decomposition proc~start_parallel start_parallel proc~start_parallel->proc~check_decomposition Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/check_decomposition.html"},{"title":"start_parallel – ALaDyn","text":"public subroutine start_parallel(ncmp, p_ind, b_ind) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncmp integer, intent(in) :: p_ind integer, intent(in) :: b_ind Calls proc~~start_parallel~~CallsGraph proc~start_parallel start_parallel mpi_comm_size mpi_comm_size proc~start_parallel->mpi_comm_size mpi_type_contiguous mpi_type_contiguous proc~start_parallel->mpi_type_contiguous proc~init_random_seed init_random_seed proc~start_parallel->proc~init_random_seed mpi_comm_rank mpi_comm_rank proc~start_parallel->mpi_comm_rank mpi_init mpi_init proc~start_parallel->mpi_init mpi_type_commit mpi_type_commit proc~start_parallel->mpi_type_commit proc~check_decomposition check_decomposition proc~start_parallel->proc~check_decomposition Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/start_parallel.html"},{"title":"mpi_write_dp – ALaDyn","text":"public subroutine mpi_write_dp(buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_write_dp~~CallsGraph proc~mpi_write_dp mpi_write_dp mpi_file_close mpi_file_close proc~mpi_write_dp->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_dp->mpi_file_open mpi_file_write_at mpi_file_write_at proc~mpi_write_dp->mpi_file_write_at Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_write_dp.html"},{"title":"mpi_write_row_dp – ALaDyn","text":"public subroutine mpi_write_row_dp(buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_write_row_dp~~CallsGraph proc~mpi_write_row_dp mpi_write_row_dp mpi_file_close mpi_file_close proc~mpi_write_row_dp->mpi_file_close mpi_file_write_at mpi_file_write_at proc~mpi_write_row_dp->mpi_file_write_at Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_write_row_dp.html"},{"title":"mpi_write_col_dp – ALaDyn","text":"public subroutine mpi_write_col_dp(buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_write_col_dp~~CallsGraph proc~mpi_write_col_dp mpi_write_col_dp mpi_file_close mpi_file_close proc~mpi_write_col_dp->mpi_file_close mpi_file_write_at mpi_file_write_at proc~mpi_write_col_dp->mpi_file_write_at Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_write_col_dp.html"},{"title":"mpi_read_col_dp – ALaDyn","text":"public subroutine mpi_read_col_dp(buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_read_col_dp~~CallsGraph proc~mpi_read_col_dp mpi_read_col_dp mpi_file_close mpi_file_close proc~mpi_read_col_dp->mpi_file_close mpi_file_read_at mpi_file_read_at proc~mpi_read_col_dp->mpi_file_read_at Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_read_col_dp.html"},{"title":"mpi_read_dp – ALaDyn","text":"public subroutine mpi_read_dp(buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_read_dp~~CallsGraph proc~mpi_read_dp mpi_read_dp mpi_file_close mpi_file_close proc~mpi_read_dp->mpi_file_close mpi_file_open mpi_file_open proc~mpi_read_dp->mpi_file_open mpi_file_read_at mpi_file_read_at proc~mpi_read_dp->mpi_file_read_at Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_read_dp.html"},{"title":"mpi_write_part – ALaDyn","text":"public subroutine mpi_write_part(buf, bufsize, loc_np, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer, intent(in) :: loc_np integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_write_part~~CallsGraph proc~mpi_write_part mpi_write_part mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpi_write_part~~CalledByGraph proc~mpi_write_part mpi_write_part proc~part_pdata_out part_pdata_out proc~part_pdata_out->proc~mpi_write_part proc~part_high_gamma_out part_high_gamma_out proc~part_high_gamma_out->proc~mpi_write_part proc~part_ionz_out part_ionz_out proc~part_ionz_out->proc~mpi_write_part proc~part_bdata_out part_bdata_out proc~part_bdata_out->proc~mpi_write_part proc~data_out data_out proc~data_out->proc~part_pdata_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_write_part.html"},{"title":"mpi_write_part_col – ALaDyn","text":"public subroutine mpi_write_part_col(buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_write_part_col~~CallsGraph proc~mpi_write_part_col mpi_write_part_col mpi_file_set_view mpi_file_set_view proc~mpi_write_part_col->mpi_file_set_view mpi_file_close mpi_file_close proc~mpi_write_part_col->mpi_file_close mpi_file_write mpi_file_write proc~mpi_write_part_col->mpi_file_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_write_part_col.html"},{"title":"mpi_write_field – ALaDyn","text":"public subroutine mpi_write_field(buf, bufsize, header, header_size, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer, intent(in) :: header (:) integer, intent(in) :: header_size integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_write_field~~CallsGraph proc~mpi_write_field mpi_write_field mpi_file_set_view mpi_file_set_view proc~mpi_write_field->mpi_file_set_view mpi_file_open mpi_file_open proc~mpi_write_field->mpi_file_open mpi_file_close mpi_file_close proc~mpi_write_field->mpi_file_close mpi_file_write mpi_file_write proc~mpi_write_field->mpi_file_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~mpi_write_field~~CalledByGraph proc~mpi_write_field mpi_write_field proc~fields_out_new fields_out_new proc~fields_out_new->proc~mpi_write_field proc~data_out data_out proc~data_out->proc~fields_out_new proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_write_field.html"},{"title":"mpi_write_field_col – ALaDyn","text":"public subroutine mpi_write_field_col(buf, bufsize, header, header_size, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer, intent(in) :: header (:) integer, intent(in) :: header_size integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout Calls proc~~mpi_write_field_col~~CallsGraph proc~mpi_write_field_col mpi_write_field_col mpi_file_set_view mpi_file_set_view proc~mpi_write_field_col->mpi_file_set_view mpi_file_close mpi_file_close proc~mpi_write_field_col->mpi_file_close mpi_file_write mpi_file_write proc~mpi_write_field_col->mpi_file_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/mpi_write_field_col.html"},{"title":"End_parallel – ALaDyn","text":"public subroutine End_parallel() Arguments None Calls proc~~end_parallel~~CallsGraph proc~end_parallel End_parallel mpi_finalize mpi_finalize proc~end_parallel->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/end_parallel.html"},{"title":"exchange_idata – ALaDyn","text":"public subroutine exchange_idata(sr, idat, lenw, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr integer, intent(inout) :: idat (:) integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: tag Contents None","tags":"","loc":"proc/exchange_idata.html"},{"title":"exchange_2d_idata – ALaDyn","text":"public subroutine exchange_2d_idata(sr, idat, n1, n2, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr integer, intent(inout) :: idat (:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: ipe integer, intent(in) :: tag Contents None","tags":"","loc":"proc/exchange_2d_idata.html"},{"title":"exchange_3d_sp_data – ALaDyn","text":"public subroutine exchange_3d_sp_data(sr, dat0, n1, n2, n3, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=sp), intent(inout) :: dat0 (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ipe integer, intent(in) :: tag Contents None","tags":"","loc":"proc/exchange_3d_sp_data.html"},{"title":"exchange_1d_grdata – ALaDyn","text":"public subroutine exchange_1d_grdata(sr, dat0, lenw, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=dp), intent(inout) :: dat0 (:) integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: tag Called by proc~~exchange_1d_grdata~~CalledByGraph proc~exchange_1d_grdata exchange_1d_grdata proc~restart restart proc~restart->proc~exchange_1d_grdata proc~start Start proc~start->proc~restart program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/exchange_1d_grdata.html"},{"title":"exchange_2d_grdata – ALaDyn","text":"public subroutine exchange_2d_grdata(sr, dat0, n1, n2, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=dp), intent(inout) :: dat0 (:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: ipe integer, intent(in) :: tag Called by proc~~exchange_2d_grdata~~CalledByGraph proc~exchange_2d_grdata exchange_2d_grdata proc~restart restart proc~restart->proc~exchange_2d_grdata proc~start Start proc~start->proc~restart program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/exchange_2d_grdata.html"},{"title":"exchange_3d_grdata – ALaDyn","text":"public subroutine exchange_3d_grdata(sr, dat0, lenw, dir, ipe) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=dp), intent(inout) :: dat0 (:,:,:) integer, intent(in) :: lenw integer, intent(in) :: dir integer, intent(in) :: ipe Contents None","tags":"","loc":"proc/exchange_3d_grdata.html"},{"title":"exchange_grdata – ALaDyn","text":"public subroutine exchange_grdata(sr, dat0, lenw, dir, ipe) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=dp), intent(inout) :: dat0 (:,:,:,:) integer, intent(in) :: lenw integer, intent(in) :: dir integer, intent(in) :: ipe Contents None","tags":"","loc":"proc/exchange_grdata.html"},{"title":"realvec_distribute – ALaDyn","text":"public subroutine realvec_distribute(rs, rv, nproc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: rs real(kind=dp) :: rv (:) integer, intent(in) :: nproc Calls proc~~realvec_distribute~~CallsGraph proc~realvec_distribute realvec_distribute mpi_send mpi_send proc~realvec_distribute->mpi_send mpi_recv mpi_recv proc~realvec_distribute->mpi_recv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/realvec_distribute.html"},{"title":"intvec_distribute – ALaDyn","text":"public subroutine intvec_distribute(ns, nc, nproc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ns integer, intent(inout) :: nc (:) integer, intent(in) :: nproc Calls proc~~intvec_distribute~~CallsGraph proc~intvec_distribute intvec_distribute mpi_send mpi_send proc~intvec_distribute->mpi_send mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~intvec_distribute~~CalledByGraph proc~intvec_distribute intvec_distribute proc~part_pdata_out part_pdata_out proc~part_pdata_out->proc~intvec_distribute proc~restart restart proc~restart->proc~intvec_distribute proc~dump_data dump_data proc~dump_data->proc~intvec_distribute proc~part_numbers Part_numbers proc~part_numbers->proc~intvec_distribute proc~part_ionz_out part_ionz_out proc~part_ionz_out->proc~intvec_distribute proc~part_bdata_out part_bdata_out proc~part_bdata_out->proc~intvec_distribute proc~part_high_gamma_out part_high_gamma_out proc~part_high_gamma_out->proc~intvec_distribute program~aladyn aladyn program~aladyn->proc~part_numbers proc~env_cycle Env_cycle program~aladyn->proc~env_cycle proc~start Start program~aladyn->proc~start proc~lp_cycle Lp_cycle program~aladyn->proc~lp_cycle proc~timing timing proc~timing->proc~part_numbers proc~env_cycle->proc~part_numbers proc~env_cycle->proc~timing proc~data_out data_out proc~env_cycle->proc~data_out proc~env_run env_run proc~env_cycle->proc~env_run proc~start->proc~restart proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~part_numbers proc~data_out->proc~part_pdata_out proc~env_run->proc~lp_window_xshift proc~lp_cycle->proc~timing proc~lp_cycle->proc~data_out proc~lp_run lp_run proc~lp_cycle->proc~lp_run proc~lp_run->proc~lp_window_xshift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/intvec_distribute.html"},{"title":"sr_idata – ALaDyn","text":"public subroutine sr_idata(ns, nr, dir, side) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ns integer, intent(out) :: nr integer, intent(in) :: dir integer, intent(in) :: side Called by proc~~sr_idata~~CalledByGraph proc~sr_idata sr_idata proc~traffic_size_eval traffic_size_eval proc~traffic_size_eval->proc~sr_idata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/sr_idata.html"},{"title":"sr_pdata – ALaDyn","text":"public subroutine sr_pdata(sdata, rdata, ns, nr, dir, side) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sdata (:) real(kind=dp), intent(out) :: rdata (:) integer, intent(in) :: ns integer, intent(in) :: nr integer, intent(in) :: dir integer, intent(in) :: side Contents None","tags":"","loc":"proc/sr_pdata.html"},{"title":"sr_vidata – ALaDyn","text":"public subroutine sr_vidata(sidat, ridat, n2, n3, dir, side) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sidat (n2,n3) integer, intent(out) :: ridat (n2,n3) integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: dir integer, intent(in) :: side Contents None","tags":"","loc":"proc/sr_vidata.html"},{"title":"exchange_pdata – ALaDyn","text":"public subroutine exchange_pdata(sr, pdata, lenw, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=sp), intent(inout) :: pdata (:) integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: tag Called by proc~~exchange_pdata~~CalledByGraph proc~exchange_pdata exchange_pdata proc~bfields_out bfields_out proc~bfields_out->proc~exchange_pdata proc~env_two_fields_out env_two_fields_out proc~env_two_fields_out->proc~exchange_pdata proc~fields_out fields_out proc~fields_out->proc~exchange_pdata proc~bden_energy_out bden_energy_out proc~bden_energy_out->proc~exchange_pdata proc~env_fields_out env_fields_out proc~env_fields_out->proc~exchange_pdata proc~ext_bfield_out ext_bfield_out proc~ext_bfield_out->proc~exchange_pdata proc~fluid_den_mom_out fluid_den_mom_out proc~fluid_den_mom_out->proc~exchange_pdata proc~den_energy_out den_energy_out proc~den_energy_out->proc~exchange_pdata proc~data_out data_out proc~data_out->proc~env_two_fields_out proc~data_out->proc~fields_out proc~data_out->proc~env_fields_out proc~data_out->proc~fluid_den_mom_out proc~data_out->proc~den_energy_out proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/exchange_pdata.html"},{"title":"exchange_rdata – ALaDyn","text":"public subroutine exchange_rdata(buff, sr, lenw, ipe, dir, tag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: buff (:) logical, intent(in) :: sr integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: dir integer, intent(in) :: tag Contents None","tags":"","loc":"proc/exchange_rdata.html"},{"title":"exchange_rdata_int – ALaDyn","text":"public subroutine exchange_rdata_int(buff, sr, lenw, ipe, dir, tag) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: buff (:) logical, intent(in) :: sr integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: dir integer, intent(in) :: tag Called by proc~~exchange_rdata_int~~CalledByGraph proc~exchange_rdata_int exchange_rdata_int proc~dump_data dump_data proc~dump_data->proc~exchange_rdata_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/exchange_rdata_int.html"},{"title":"vint_2d_bcast – ALaDyn","text":"public subroutine vint_2d_bcast(mydat, n1, n2) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: mydat integer, intent(in) :: n1 integer, intent(in) :: n2 Called by proc~~vint_2d_bcast~~CalledByGraph proc~vint_2d_bcast vint_2d_bcast proc~restart restart proc~restart->proc~vint_2d_bcast proc~start Start proc~start->proc~restart program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/vint_2d_bcast.html"},{"title":"vint_bcast – ALaDyn","text":"public subroutine vint_bcast(mydat, nt) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: mydat (nt) integer, intent(in) :: nt Calls proc~~vint_bcast~~CallsGraph proc~vint_bcast vint_bcast mpi_bcast mpi_bcast proc~vint_bcast->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vint_bcast~~CalledByGraph proc~vint_bcast vint_bcast proc~restart restart proc~restart->proc~vint_bcast proc~start Start proc~start->proc~restart program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/vint_bcast.html"},{"title":"int_bcast – ALaDyn","text":"public subroutine int_bcast(mydat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mydat Calls proc~~int_bcast~~CallsGraph proc~int_bcast int_bcast mpi_bcast mpi_bcast proc~int_bcast->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/int_bcast.html"},{"title":"all_gather_dpreal – ALaDyn","text":"public subroutine all_gather_dpreal(rv_send, rv_recv, dir, nt) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: rv_send (:) real(kind=dp), intent(inout) :: rv_recv (:) integer, intent(in) :: dir integer, intent(in) :: nt Contents None","tags":"","loc":"proc/all_gather_dpreal.html"},{"title":"allreduce_dpreal – ALaDyn","text":"public subroutine allreduce_dpreal(ib, rv_loc, rv, nt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ib real(kind=dp), intent(in) :: rv_loc (:) real(kind=dp), intent(out) :: rv (:) integer, intent(in) :: nt Calls proc~~allreduce_dpreal~~CallsGraph proc~allreduce_dpreal allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allreduce_dpreal~~CalledByGraph proc~allreduce_dpreal allreduce_dpreal proc~bunch_corr bunch_corr proc~bunch_corr->proc~allreduce_dpreal proc~fields_on_target fields_on_target proc~fields_on_target->proc~allreduce_dpreal proc~enb_hgam enb_hgam proc~enb_hgam->proc~allreduce_dpreal proc~enb_hgam->proc~bunch_corr proc~laser_struct_data laser_struct_data proc~laser_struct_data->proc~allreduce_dpreal proc~envar Envar proc~envar->proc~allreduce_dpreal proc~enb_bunch enb_bunch proc~envar->proc~enb_bunch proc~envelope_struct_data envelope_struct_data proc~envar->proc~envelope_struct_data proc~max_pmemory_check Max_pmemory_check proc~max_pmemory_check->proc~allreduce_dpreal proc~enb_ionz enb_ionz proc~enb_ionz->proc~allreduce_dpreal proc~enb_ionz->proc~bunch_corr proc~enb_bunch->proc~allreduce_dpreal proc~enb_bunch->proc~bunch_corr proc~envelope_struct_data->proc~allreduce_dpreal program~aladyn aladyn program~aladyn->proc~max_pmemory_check proc~lp_cycle Lp_cycle program~aladyn->proc~lp_cycle proc~env_cycle Env_cycle program~aladyn->proc~env_cycle proc~data_out data_out proc~data_out->proc~envar proc~timing timing proc~timing->proc~max_pmemory_check proc~lp_cycle->proc~data_out proc~lp_cycle->proc~timing proc~env_cycle->proc~data_out proc~env_cycle->proc~timing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allreduce_dpreal.html"},{"title":"allreduce_big_int – ALaDyn","text":"public subroutine allreduce_big_int(n0, n1) Arguments Type Intent Optional Attributes Name integer(kind=dp), intent(in) :: n0 integer(kind=dp), intent(out) :: n1 Calls proc~~allreduce_big_int~~CallsGraph proc~allreduce_big_int allreduce_big_int mpi_allreduce mpi_allreduce proc~allreduce_big_int->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allreduce_big_int.html"},{"title":"allreduce_sint – ALaDyn","text":"public subroutine allreduce_sint(ib, dt0, dt_tot) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ib integer, intent(in) :: dt0 integer, intent(out) :: dt_tot Calls proc~~allreduce_sint~~CallsGraph proc~allreduce_sint allreduce_sint mpi_bcast mpi_bcast proc~allreduce_sint->mpi_bcast mpi_reduce mpi_reduce proc~allreduce_sint->mpi_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allreduce_sint.html"},{"title":"allreduce_vint – ALaDyn","text":"public subroutine allreduce_vint(ib, dt0, dt_tot, nt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ib integer, intent(in) :: dt0 (nt) integer, intent(out) :: dt_tot (nt) integer, intent(in) :: nt Calls proc~~allreduce_vint~~CallsGraph proc~allreduce_vint allreduce_vint mpi_bcast mpi_bcast proc~allreduce_vint->mpi_bcast mpi_reduce mpi_reduce proc~allreduce_vint->mpi_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/allreduce_vint.html"},{"title":"bcast_grdata – ALaDyn","text":"public subroutine bcast_grdata(dat0, n1, n2, n3, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dat0 (:,:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: nc Contents None","tags":"","loc":"proc/bcast_grdata.html"},{"title":"bcast_realv_sum – ALaDyn","text":"public subroutine bcast_realv_sum(ib, dt_prl, dt_tot, nt) Arguments Type Intent Optional Attributes Name logical, intent(in) :: ib real(kind=dp), intent(in) :: dt_prl (nt) real(kind=dp), intent(out) :: dt_tot (nt) integer, intent(in) :: nt Calls proc~~bcast_realv_sum~~CallsGraph proc~bcast_realv_sum bcast_realv_sum mpi_reduce mpi_reduce proc~bcast_realv_sum->mpi_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bcast_realv_sum.html"},{"title":"bcast_int_sum – ALaDyn","text":"public subroutine bcast_int_sum(dt_prl, dt_tot) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dt_prl integer, intent(out) :: dt_tot Calls proc~~bcast_int_sum~~CallsGraph proc~bcast_int_sum bcast_int_sum mpi_bcast mpi_bcast proc~bcast_int_sum->mpi_bcast mpi_reduce mpi_reduce proc~bcast_int_sum->mpi_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bcast_int_sum.html"},{"title":"real_bcast – ALaDyn","text":"public subroutine real_bcast(dt_tot, ndt) Arguments Type Intent Optional Attributes Name real(kind=dp) :: dt_tot (ndt) integer, intent(in) :: ndt Calls proc~~real_bcast~~CallsGraph proc~real_bcast real_bcast mpi_bcast mpi_bcast proc~real_bcast->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~real_bcast~~CalledByGraph proc~real_bcast real_bcast proc~restart restart proc~restart->proc~real_bcast proc~start Start proc~start->proc~restart program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/real_bcast.html"},{"title":"local_to_global_grdata – ALaDyn","text":"public subroutine local_to_global_grdata(buff1, buff2, lenws, ip, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buff1 (:) real(kind=dp), intent(out) :: buff2 (:) integer, intent(in) :: lenws integer, intent(in) :: ip integer, intent(in) :: dir Contents None","tags":"","loc":"proc/local_to_global_grdata.html"},{"title":"exchange_bd_3d_data – ALaDyn","text":"public subroutine exchange_bd_3d_data(buff1, lenws, buff2, lenwr, dir, side) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buff1 (:,:,:) integer, intent(in) :: lenws real(kind=dp), intent(out) :: buff2 (:,:,:) integer, intent(in) :: lenwr integer, intent(in) :: dir integer(kind=hp_int), intent(in) :: side Contents None","tags":"","loc":"proc/exchange_bd_3d_data.html"},{"title":"exchange_bdx_data – ALaDyn","text":"public subroutine exchange_bdx_data(buff1, buff2, lenws, lenwr, dir, side) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buff1 (:) real(kind=dp), intent(out) :: buff2 (:) integer, intent(in) :: lenws integer, intent(in) :: lenwr integer, intent(in) :: dir integer(kind=hp_int), intent(in) :: side Called by proc~~exchange_bdx_data~~CalledByGraph proc~exchange_bdx_data exchange_bdx_data proc~fluid_left_xshift fluid_left_xshift proc~fluid_left_xshift->proc~exchange_bdx_data proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data proc~fields_left_xshift fields_left_xshift proc~fields_left_xshift->proc~exchange_bdx_data proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~fill_ebfield_xbdsdata fill_ebfield_xbdsdata proc~fill_ebfield_xbdsdata->proc~exchange_bdx_data proc~fill_ftcurr_yzbdsdata fill_ftcurr_yzbdsdata proc~fill_ftcurr_yzbdsdata->proc~exchange_bdx_data proc~fluid_curr_accumulate fluid_curr_accumulate proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata proc~pfields_prepare pfields_prepare proc~pfields_prepare->proc~fill_ebfield_yzxbdsdata proc~advance_lpf_envelope advance_lpf_envelope proc~advance_lpf_envelope->proc~fill_ebfield_yzxbdsdata proc~curr_mpi_collect curr_mpi_collect proc~curr_mpi_collect->proc~fill_curr_yzxbdsdata proc~collect_bunch_and_plasma_density collect_bunch_and_plasma_density proc~collect_bunch_and_plasma_density->proc~fill_curr_yzxbdsdata proc~set_wake_potential set_wake_potential proc~set_wake_potential->proc~fill_curr_yzxbdsdata proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata proc~prl_bden_energy_interp prl_bden_energy_interp proc~prl_bden_energy_interp->proc~fill_curr_yzxbdsdata proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~fluid_left_xshift proc~lp_window_xshift->proc~fields_left_xshift proc~advect_bunch_fields advect_bunch_fields proc~advect_bunch_fields->proc~fill_ebfield_xbdsdata proc~advance_lpf_fields advance_lpf_fields proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~beam_inject beam_inject proc~beam_inject->proc~fill_ebfield_yzxbdsdata proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~fluid_curr_accumulate proc~lpf2_evolve->proc~pfields_prepare proc~lpf2_evolve->proc~update_adam_bash_fluid_variables proc~lpf2_evolve->proc~advance_lpf_fields proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject proc~env_run env_run proc~env_cycle->proc~env_run proc~lp_run lp_run proc~lp_run->proc~lp_window_xshift proc~lp_run->proc~lpf2_evolve proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~fluid_curr_accumulate proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_lpf2_evolve->proc~curr_mpi_collect proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run->proc~lp_window_xshift proc~env_run->proc~env_lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run program~aladyn aladyn program~aladyn->proc~env_cycle program~aladyn->proc~lp_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/exchange_bdx_data.html"},{"title":"processor_grid_diag – ALaDyn","text":"public subroutine processor_grid_diag() Arguments None Contents None","tags":"","loc":"proc/processor_grid_diag.html"},{"title":"field_xyzbd – ALaDyn","text":"public subroutine field_xyzbd(ef, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) integer, intent(in) :: nc Called by proc~~field_xyzbd~~CalledByGraph proc~field_xyzbd field_xyzbd proc~pfields_prepare pfields_prepare proc~pfields_prepare->proc~field_xyzbd proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~update_adam_bash_fluid_variables->proc~field_xyzbd proc~fluid_curr_accumulate fluid_curr_accumulate proc~fluid_curr_accumulate->proc~field_xyzbd proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~pfields_prepare proc~lpf2_evolve->proc~update_adam_bash_fluid_variables proc~lpf2_evolve->proc~fluid_curr_accumulate proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables proc~env_lpf2_evolve->proc~fluid_curr_accumulate proc~env_run env_run proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/field_xyzbd.html"},{"title":"fluid_left_xshift – ALaDyn","text":"public subroutine fluid_left_xshift(fld, den_x, den_yz, i1, i2, ic1, ic2, xsh) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: fld (:,:,:,:) real(kind=dp), intent(in) :: den_x (:) real(kind=dp), intent(in) :: den_yz (:,:) integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: xsh Calls proc~~fluid_left_xshift~~CallsGraph proc~fluid_left_xshift fluid_left_xshift proc~exchange_bdx_data exchange_bdx_data proc~fluid_left_xshift->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fluid_left_xshift~~CalledByGraph proc~fluid_left_xshift fluid_left_xshift proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~fluid_left_xshift proc~env_run env_run proc~env_run->proc~lp_window_xshift proc~lp_run lp_run proc~lp_run->proc~lp_window_xshift proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fluid_left_xshift.html"},{"title":"fields_left_xshift – ALaDyn","text":"public subroutine fields_left_xshift(fld, i1, i2, ic1, ic2, xsh) Arguments Type Intent Optional Attributes Name real(kind=dp) :: fld (:,:,:,:) integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: xsh Calls proc~~fields_left_xshift~~CallsGraph proc~fields_left_xshift fields_left_xshift proc~exchange_bdx_data exchange_bdx_data proc~fields_left_xshift->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fields_left_xshift~~CalledByGraph proc~fields_left_xshift fields_left_xshift proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~fields_left_xshift proc~env_run env_run proc~env_run->proc~lp_window_xshift proc~lp_run lp_run proc~lp_run->proc~lp_window_xshift proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fields_left_xshift.html"},{"title":"fill_ebfield_yzxbdsdata – ALaDyn","text":"public subroutine fill_ebfield_yzxbdsdata(fld, ic1, ic2, str, stl) Arguments Type Intent Optional Attributes Name real(kind=dp) :: fld (:,:,:,:) integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: str integer, intent(in) :: stl Calls proc~~fill_ebfield_yzxbdsdata~~CallsGraph proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fill_ebfield_yzxbdsdata~~CalledByGraph proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate fluid_curr_accumulate proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata proc~pfields_prepare pfields_prepare proc~pfields_prepare->proc~fill_ebfield_yzxbdsdata proc~advance_lpf_envelope advance_lpf_envelope proc~advance_lpf_envelope->proc~fill_ebfield_yzxbdsdata proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata proc~advance_lpf_fields advance_lpf_fields proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~beam_inject beam_inject proc~beam_inject->proc~fill_ebfield_yzxbdsdata proc~env_cycle Env_cycle proc~env_cycle->proc~beam_inject proc~env_run env_run proc~env_cycle->proc~env_run proc~lpf2_evolve lpf2_evolve proc~lpf2_evolve->proc~fluid_curr_accumulate proc~lpf2_evolve->proc~pfields_prepare proc~lpf2_evolve->proc~update_adam_bash_fluid_variables proc~lpf2_evolve->proc~advance_lpf_fields proc~env_lpf2_evolve env_lpf2_evolve proc~env_lpf2_evolve->proc~fluid_curr_accumulate proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables proc~env_lpf2_evolve->proc~advance_lpf_fields proc~env_run->proc~env_lpf2_evolve proc~lp_run lp_run proc~lp_run->proc~lpf2_evolve program~aladyn aladyn program~aladyn->proc~env_cycle proc~lp_cycle Lp_cycle program~aladyn->proc~lp_cycle proc~lp_cycle->proc~lp_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fill_ebfield_yzxbdsdata.html"},{"title":"fill_ebfield_xbdsdata – ALaDyn","text":"public subroutine fill_ebfield_xbdsdata(fld, ic1, ic2, str, stl) Arguments Type Intent Optional Attributes Name real(kind=dp) :: fld (:,:,:,:) integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: str integer, intent(in) :: stl Calls proc~~fill_ebfield_xbdsdata~~CallsGraph proc~fill_ebfield_xbdsdata fill_ebfield_xbdsdata proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_xbdsdata->proc~exchange_bdx_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fill_ebfield_xbdsdata~~CalledByGraph proc~fill_ebfield_xbdsdata fill_ebfield_xbdsdata proc~advect_bunch_fields advect_bunch_fields proc~advect_bunch_fields->proc~fill_ebfield_xbdsdata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fill_ebfield_xbdsdata.html"},{"title":"traffic_size_eval – ALaDyn","text":"public subroutine traffic_size_eval(sp_loc, xl, xr, pel, per, ibd, ind, npold, nsr, npnew) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr logical, intent(in) :: pel logical, intent(in) :: per integer, intent(in) :: ibd integer, intent(in) :: ind integer, intent(in) :: npold integer, intent(inout) :: nsr (4) integer, intent(inout) :: npnew Calls proc~~traffic_size_eval~~CallsGraph proc~traffic_size_eval traffic_size_eval proc~sr_idata sr_idata proc~traffic_size_eval->proc~sr_idata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/traffic_size_eval.html"},{"title":"part_prl_wexchange – ALaDyn","text":"public subroutine part_prl_wexchange(sp_loc, xl, xr, xlmin, xrmax, pel, per, ibd, dir, ndv, old_np, n_sr, npt) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr real(kind=dp), intent(in) :: xlmin real(kind=dp), intent(in) :: xrmax logical, intent(in) :: pel logical, intent(in) :: per integer, intent(in) :: ibd integer, intent(in) :: dir integer, intent(in) :: ndv integer, intent(in) :: old_np integer, intent(in) :: n_sr (4) integer, intent(out) :: npt Calls proc~~part_prl_wexchange~~CallsGraph proc~part_prl_wexchange part_prl_wexchange index_array index_array proc~part_prl_wexchange->index_array aux1 aux1 proc~part_prl_wexchange->aux1 aux2 aux2 proc~part_prl_wexchange->aux2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_prl_wexchange.html"},{"title":"part_prl_exchange – ALaDyn","text":"public subroutine part_prl_exchange(sp_loc, vstore, xl, xr, xlmin, xrmax, pel, per, ibd, dir, ndv, old_np, n_sr, npt) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(in) :: vstore (:,:) real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr real(kind=dp), intent(in) :: xlmin real(kind=dp), intent(in) :: xrmax logical, intent(in) :: pel logical, intent(in) :: per integer, intent(in) :: ibd integer, intent(in) :: dir integer, intent(in) :: ndv integer, intent(in) :: old_np integer, intent(in) :: n_sr (4) integer, intent(out) :: npt Calls proc~~part_prl_exchange~~CallsGraph proc~part_prl_exchange part_prl_exchange index_array index_array proc~part_prl_exchange->index_array aux1 aux1 proc~part_prl_exchange->aux1 aux2 aux2 proc~part_prl_exchange->aux2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_prl_exchange.html"},{"title":"reset_all_part_dist – ALaDyn","text":"public subroutine reset_all_part_dist(loc_sp, pstore, xl, xr, ib, np, ndv, cin, np_new, mwin) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: loc_sp real(kind=dp), intent(inout) :: pstore (:,:) real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr integer, intent(in) :: ib integer, intent(in) :: np integer, intent(in) :: ndv integer, intent(in) :: cin integer, intent(out) :: np_new logical, intent(in) :: mwin Calls proc~~reset_all_part_dist~~CallsGraph proc~reset_all_part_dist reset_all_part_dist proc~v_realloc v_realloc proc~reset_all_part_dist->proc~v_realloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/reset_all_part_dist.html"},{"title":"cell_part_dist – ALaDyn","text":"public subroutine cell_part_dist(moving_wind) Arguments Type Intent Optional Attributes Name logical, intent(in) :: moving_wind Calls proc~~cell_part_dist~~CallsGraph proc~cell_part_dist cell_part_dist ebfp ebfp proc~cell_part_dist->ebfp loc_npart loc_npart proc~cell_part_dist->loc_npart proc~v_realloc v_realloc proc~cell_part_dist->proc~v_realloc spec spec proc~cell_part_dist->spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~cell_part_dist~~CalledByGraph proc~cell_part_dist cell_part_dist proc~comoving_coordinate comoving_coordinate proc~comoving_coordinate->proc~cell_part_dist proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~cell_part_dist proc~env_run env_run proc~env_run->proc~comoving_coordinate proc~env_run->proc~lp_window_xshift proc~lp_run lp_run proc~lp_run->proc~comoving_coordinate proc~lp_run->proc~lp_window_xshift proc~lp_cycle Lp_cycle proc~lp_cycle->proc~lp_run proc~env_cycle Env_cycle proc~env_cycle->proc~env_run program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/cell_part_dist.html"},{"title":"timing – ALaDyn","text":"public subroutine timing() Arguments None Calls proc~~timing~~CallsGraph proc~timing timing proc~part_numbers Part_numbers proc~timing->proc~part_numbers proc~tot_num_part tot_num_part proc~timing->proc~tot_num_part proc~max_pmemory_check Max_pmemory_check proc~timing->proc~max_pmemory_check loc_npart loc_npart proc~part_numbers->loc_npart proc~intvec_distribute intvec_distribute proc~part_numbers->proc~intvec_distribute proc~tot_num_part->loc_npart proc~allreduce_dpreal allreduce_dpreal proc~max_pmemory_check->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce mpi_send mpi_send proc~intvec_distribute->mpi_send mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~timing~~CalledByGraph proc~timing timing proc~lp_cycle Lp_cycle proc~lp_cycle->proc~timing proc~env_cycle Env_cycle proc~env_cycle->proc~timing program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/timing.html"},{"title":"error_message – ALaDyn","text":"public subroutine error_message() Arguments None Called by proc~~error_message~~CalledByGraph proc~error_message error_message proc~lp_cycle Lp_cycle proc~lp_cycle->proc~error_message proc~env_cycle Env_cycle proc~env_cycle->proc~error_message program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/error_message.html"},{"title":"Part_numbers – ALaDyn","text":"public subroutine Part_numbers() Arguments None Calls proc~~part_numbers~~CallsGraph proc~part_numbers Part_numbers loc_npart loc_npart proc~part_numbers->loc_npart proc~intvec_distribute intvec_distribute proc~part_numbers->proc~intvec_distribute mpi_send mpi_send proc~intvec_distribute->mpi_send mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~part_numbers~~CalledByGraph proc~part_numbers Part_numbers program~aladyn aladyn program~aladyn->proc~part_numbers proc~env_cycle Env_cycle program~aladyn->proc~env_cycle proc~lp_cycle Lp_cycle program~aladyn->proc~lp_cycle proc~env_cycle->proc~part_numbers proc~timing timing proc~env_cycle->proc~timing proc~env_run env_run proc~env_cycle->proc~env_run proc~lp_window_xshift lp_window_xshift proc~lp_window_xshift->proc~part_numbers proc~timing->proc~part_numbers proc~env_run->proc~lp_window_xshift proc~lp_cycle->proc~timing proc~lp_run lp_run proc~lp_cycle->proc~lp_run proc~lp_run->proc~lp_window_xshift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/part_numbers.html"},{"title":"tot_num_part – ALaDyn","text":"public subroutine tot_num_part() Arguments None Calls proc~~tot_num_part~~CallsGraph proc~tot_num_part tot_num_part loc_npart loc_npart proc~tot_num_part->loc_npart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~tot_num_part~~CalledByGraph proc~tot_num_part tot_num_part proc~timing timing proc~timing->proc~tot_num_part proc~lp_cycle Lp_cycle proc~lp_cycle->proc~timing proc~env_cycle Env_cycle proc~env_cycle->proc~timing program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/tot_num_part.html"},{"title":"initial_run_info – ALaDyn","text":"public subroutine initial_run_info(nw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nw Called by proc~~initial_run_info~~CalledByGraph proc~initial_run_info initial_run_info program~aladyn aladyn program~aladyn->proc~initial_run_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/initial_run_info.html"},{"title":"ioniz_data – ALaDyn","text":"public subroutine ioniz_data(ef_max, z0, an, zlev, zmod) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef_max integer, intent(in) :: z0 (:) integer, intent(in) :: an (:) integer, intent(in) :: zlev integer, intent(in) :: zmod Contents None","tags":"","loc":"proc/ioniz_data.html"},{"title":"Final_run_info – ALaDyn","text":"public subroutine Final_run_info() Arguments None Called by proc~~final_run_info~~CalledByGraph proc~final_run_info Final_run_info program~aladyn aladyn program~aladyn->proc~final_run_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/final_run_info.html"},{"title":"submem – ALaDyn","text":"public subroutine submem(rmem) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: rmem Calls proc~~submem~~CallsGraph proc~submem submem memaddr memaddr proc~submem->memaddr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/submem.html"},{"title":"Max_pmemory_check – ALaDyn","text":"public subroutine Max_pmemory_check() Arguments None Calls proc~~max_pmemory_check~~CallsGraph proc~max_pmemory_check Max_pmemory_check proc~allreduce_dpreal allreduce_dpreal proc~max_pmemory_check->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~max_pmemory_check~~CalledByGraph proc~max_pmemory_check Max_pmemory_check program~aladyn aladyn program~aladyn->proc~max_pmemory_check proc~lp_cycle Lp_cycle program~aladyn->proc~lp_cycle proc~env_cycle Env_cycle program~aladyn->proc~env_cycle proc~timing timing proc~timing->proc~max_pmemory_check proc~lp_cycle->proc~timing proc~env_cycle->proc~timing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/max_pmemory_check.html"},{"title":"track_part_pdata_out – ALaDyn","text":"public subroutine track_part_pdata_out(tk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tk Calls proc~~track_part_pdata_out~~CallsGraph proc~track_part_pdata_out track_part_pdata_out loc_tpart loc_tpart proc~track_part_pdata_out->loc_tpart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/track_part_pdata_out.html"},{"title":"energy_spect – ALaDyn","text":"public subroutine energy_spect(np, ekem, gfield) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=dp), intent(in) :: ekem real(kind=dp), intent(in) :: gfield (:,:) Contents None","tags":"","loc":"proc/energy_spect.html"},{"title":"select_energy_spect – ALaDyn","text":"public subroutine select_energy_spect(np, ekem, xl, xr, gfield) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=dp), intent(in) :: ekem real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr real(kind=dp), intent(in) :: gfield (:,:) Contents None","tags":"","loc":"proc/select_energy_spect.html"},{"title":"energy_momenta – ALaDyn","text":"public subroutine energy_momenta(sp_loc, gfield, np, ek, ekmax) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: gfield (:,:) integer, intent(in) :: np real(kind=dp), intent(out) :: ek (:) real(kind=dp), intent(out) :: ekmax Contents None","tags":"","loc":"proc/energy_momenta.html"},{"title":"laser_struct_data – ALaDyn","text":"public subroutine laser_struct_data(nst) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst Calls proc~~laser_struct_data~~CallsGraph proc~laser_struct_data laser_struct_data lp_in lp_in proc~laser_struct_data->lp_in lp_end lp_end proc~laser_struct_data->lp_end proc~allreduce_dpreal allreduce_dpreal proc~laser_struct_data->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/laser_struct_data.html"},{"title":"envelope_struct_data – ALaDyn","text":"public subroutine envelope_struct_data(nst) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst Calls proc~~envelope_struct_data~~CallsGraph proc~envelope_struct_data envelope_struct_data proc~allreduce_dpreal allreduce_dpreal proc~envelope_struct_data->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~envelope_struct_data~~CalledByGraph proc~envelope_struct_data envelope_struct_data proc~envar Envar proc~envar->proc~envelope_struct_data proc~data_out data_out proc~data_out->proc~envar proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/envelope_struct_data.html"},{"title":"fields_on_target – ALaDyn","text":"public subroutine fields_on_target(nst) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst Calls proc~~fields_on_target~~CallsGraph proc~fields_on_target fields_on_target proc~allreduce_dpreal allreduce_dpreal proc~fields_on_target->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/fields_on_target.html"},{"title":"Envar – ALaDyn","text":"public subroutine Envar(nst) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst Calls proc~~envar~~CallsGraph proc~envar Envar proc~allreduce_dpreal allreduce_dpreal proc~envar->proc~allreduce_dpreal loc_npart loc_npart proc~envar->loc_npart proc~envelope_struct_data envelope_struct_data proc~envar->proc~envelope_struct_data proc~enb_bunch enb_bunch proc~envar->proc~enb_bunch mass mass proc~envar->mass mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce proc~envelope_struct_data->proc~allreduce_dpreal proc~enb_bunch->proc~allreduce_dpreal proc~enb_bunch->loc_npart proc~bunch_corr bunch_corr proc~enb_bunch->proc~bunch_corr proc~bunch_corr->proc~allreduce_dpreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~envar~~CalledByGraph proc~envar Envar proc~data_out data_out proc~data_out->proc~envar proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/envar.html"},{"title":"bunch_corr – ALaDyn","text":"public subroutine bunch_corr(bch, np_loc, np_norm, bcorr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bch (:,:) integer, intent(in) :: np_loc real(kind=dp), intent(in) :: np_norm real(kind=dp), intent(out) :: bcorr (16) Calls proc~~bunch_corr~~CallsGraph proc~bunch_corr bunch_corr proc~allreduce_dpreal allreduce_dpreal proc~bunch_corr->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~bunch_corr~~CalledByGraph proc~bunch_corr bunch_corr proc~enb_hgam enb_hgam proc~enb_hgam->proc~bunch_corr proc~enb_bunch enb_bunch proc~enb_bunch->proc~bunch_corr proc~enb_ionz enb_ionz proc~enb_ionz->proc~bunch_corr proc~envar Envar proc~envar->proc~enb_bunch proc~data_out data_out proc~data_out->proc~envar proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bunch_corr.html"},{"title":"enb_bunch – ALaDyn","text":"public subroutine enb_bunch(nst, ib) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: ib Calls proc~~enb_bunch~~CallsGraph proc~enb_bunch enb_bunch proc~bunch_corr bunch_corr proc~enb_bunch->proc~bunch_corr loc_npart loc_npart proc~enb_bunch->loc_npart proc~allreduce_dpreal allreduce_dpreal proc~enb_bunch->proc~allreduce_dpreal proc~bunch_corr->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~enb_bunch~~CalledByGraph proc~enb_bunch enb_bunch proc~envar Envar proc~envar->proc~enb_bunch proc~data_out data_out proc~data_out->proc~envar proc~lp_cycle Lp_cycle proc~lp_cycle->proc~data_out proc~env_cycle Env_cycle proc~env_cycle->proc~data_out program~aladyn aladyn program~aladyn->proc~lp_cycle program~aladyn->proc~env_cycle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/enb_bunch.html"},{"title":"enb_ionz – ALaDyn","text":"public subroutine enb_ionz(nst, t_loc, gmm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: gmm Calls proc~~enb_ionz~~CallsGraph proc~enb_ionz enb_ionz proc~bunch_corr bunch_corr proc~enb_ionz->proc~bunch_corr loc_npart loc_npart proc~enb_ionz->loc_npart proc~allreduce_dpreal allreduce_dpreal proc~enb_ionz->proc~allreduce_dpreal proc~bunch_corr->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/enb_ionz.html"},{"title":"enb_hgam – ALaDyn","text":"public subroutine enb_hgam(nst, t_loc, gmm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: gmm Calls proc~~enb_hgam~~CallsGraph proc~enb_hgam enb_hgam proc~bunch_corr bunch_corr proc~enb_hgam->proc~bunch_corr loc_npart loc_npart proc~enb_hgam->loc_npart proc~allreduce_dpreal allreduce_dpreal proc~enb_hgam->proc~allreduce_dpreal proc~bunch_corr->proc~allreduce_dpreal mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/enb_hgam.html"},{"title":"en_data – ALaDyn","text":"public subroutine en_data(nst, itr, idata) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: itr integer, intent(in) :: idata Calls proc~~en_data~~CallsGraph proc~en_data en_data proc~general_en_data general_en_data proc~en_data->proc~general_en_data mp_per_cell mp_per_cell proc~general_en_data->mp_per_cell ion_min ion_min proc~general_en_data->ion_min lpy lpy proc~general_en_data->lpy atomic_number atomic_number proc~general_en_data->atomic_number lpx lpx proc~general_en_data->lpx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/en_data.html"},{"title":"general_en_data – ALaDyn","text":"public subroutine general_en_data(nst, itr, idata) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: itr integer, intent(in) :: idata Calls proc~~general_en_data~~CallsGraph proc~general_en_data general_en_data mp_per_cell mp_per_cell proc~general_en_data->mp_per_cell ion_min ion_min proc~general_en_data->ion_min lpy lpy proc~general_en_data->lpy atomic_number atomic_number proc~general_en_data->atomic_number lpx lpx proc~general_en_data->lpx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~general_en_data~~CalledByGraph proc~general_en_data general_en_data proc~en_data en_data proc~en_data->proc~general_en_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/general_en_data.html"},{"title":"en_bdata – ALaDyn","text":"public subroutine en_bdata(nst, it, idata) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: it integer, intent(in) :: idata Calls proc~~en_bdata~~CallsGraph proc~en_bdata en_bdata ion_min ion_min proc~en_bdata->ion_min mp_per_cell mp_per_cell proc~en_bdata->mp_per_cell atomic_number atomic_number proc~en_bdata->atomic_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/en_bdata.html"},{"title":"en_ionz_data – ALaDyn","text":"public subroutine en_ionz_data(nst, itrz, data_id) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: itrz integer, intent(in) :: data_id Calls proc~~en_ionz_data~~CallsGraph proc~en_ionz_data en_ionz_data ion_min ion_min proc~en_ionz_data->ion_min mp_per_cell mp_per_cell proc~en_ionz_data->mp_per_cell atomic_number atomic_number proc~en_ionz_data->atomic_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/en_ionz_data.html"},{"title":"en_high_gamma_data – ALaDyn","text":"public subroutine en_high_gamma_data(nst, itrz, data_id) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: itrz integer, intent(in) :: data_id Calls proc~~en_high_gamma_data~~CallsGraph proc~en_high_gamma_data en_high_gamma_data ion_min ion_min proc~en_high_gamma_data->ion_min mp_per_cell mp_per_cell proc~en_high_gamma_data->mp_per_cell atomic_number atomic_number proc~en_high_gamma_data->atomic_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/en_high_gamma_data.html"},{"title":"isprime – ALaDyn","text":"private function isprime(num) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num Return Value logical Called by proc~~isprime~~CalledByGraph proc~isprime isprime proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~from_ppc_to_npx_npy_npz->proc~isprime proc~consistency_check_number_of_particles consistency_check_number_of_particles proc~consistency_check_number_of_particles->proc~from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles_comp consistency_check_number_of_particles_comp proc~consistency_check_number_of_particles_comp->proc~from_ppc_to_npx_npy_npz proc~read_input_nml read_input_nml proc~read_input_nml->proc~consistency_check_number_of_particles_comp proc~read_main_input read_main_input proc~read_main_input->proc~read_input_nml proc~start Start proc~start->proc~read_main_input program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/isprime.html"},{"title":"read_main_input – ALaDyn","text":"public subroutine read_main_input() Arguments None Calls proc~~read_main_input~~CallsGraph proc~read_main_input read_main_input proc~read_input_nml read_input_nml proc~read_main_input->proc~read_input_nml proc~consistency_check_number_of_particles_comp consistency_check_number_of_particles_comp proc~read_input_nml->proc~consistency_check_number_of_particles_comp proc~consistency_check_grid consistency_check_grid proc~read_input_nml->proc~consistency_check_grid proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles_comp->proc~from_ppc_to_npx_npy_npz proc~isprime isprime proc~from_ppc_to_npx_npy_npz->proc~isprime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_main_input~~CalledByGraph proc~read_main_input read_main_input proc~start Start proc~start->proc~read_main_input program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_main_input.html"},{"title":"read_input_nml – ALaDyn","text":"private subroutine read_input_nml() Arguments None Calls proc~~read_input_nml~~CallsGraph proc~read_input_nml read_input_nml proc~consistency_check_number_of_particles_comp consistency_check_number_of_particles_comp proc~read_input_nml->proc~consistency_check_number_of_particles_comp proc~consistency_check_grid consistency_check_grid proc~read_input_nml->proc~consistency_check_grid proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles_comp->proc~from_ppc_to_npx_npy_npz proc~isprime isprime proc~from_ppc_to_npx_npy_npz->proc~isprime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_input_nml~~CalledByGraph proc~read_input_nml read_input_nml proc~read_main_input read_main_input proc~read_main_input->proc~read_input_nml proc~start Start proc~start->proc~read_main_input program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/read_input_nml.html"},{"title":"write_read_nml – ALaDyn","text":"public subroutine write_read_nml() Arguments None Called by proc~~write_read_nml~~CalledByGraph proc~write_read_nml write_read_nml proc~start Start proc~start->proc~write_read_nml program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/write_read_nml.html"},{"title":"consistency_check_number_of_particles_comp – ALaDyn","text":"private subroutine consistency_check_number_of_particles_comp() Arguments None Calls proc~~consistency_check_number_of_particles_comp~~CallsGraph proc~consistency_check_number_of_particles_comp consistency_check_number_of_particles_comp proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles_comp->proc~from_ppc_to_npx_npy_npz proc~isprime isprime proc~from_ppc_to_npx_npy_npz->proc~isprime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~consistency_check_number_of_particles_comp~~CalledByGraph proc~consistency_check_number_of_particles_comp consistency_check_number_of_particles_comp proc~read_input_nml read_input_nml proc~read_input_nml->proc~consistency_check_number_of_particles_comp proc~read_main_input read_main_input proc~read_main_input->proc~read_input_nml proc~start Start proc~start->proc~read_main_input program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/consistency_check_number_of_particles_comp.html"},{"title":"consistency_check_grid – ALaDyn","text":"private subroutine consistency_check_grid() Arguments None Called by proc~~consistency_check_grid~~CalledByGraph proc~consistency_check_grid consistency_check_grid proc~read_input_nml read_input_nml proc~read_input_nml->proc~consistency_check_grid proc~read_main_input read_main_input proc~read_main_input->proc~read_input_nml proc~start Start proc~start->proc~read_main_input program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/consistency_check_grid.html"},{"title":"consistency_check_number_of_particles – ALaDyn","text":"private subroutine consistency_check_number_of_particles() Arguments None Calls proc~~consistency_check_number_of_particles~~CallsGraph proc~consistency_check_number_of_particles consistency_check_number_of_particles proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles->proc~from_ppc_to_npx_npy_npz proc~isprime isprime proc~from_ppc_to_npx_npy_npz->proc~isprime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/consistency_check_number_of_particles.html"},{"title":"from_ppc_to_npx_npy_npz – ALaDyn","text":"private subroutine from_ppc_to_npx_npy_npz() Arguments None Calls proc~~from_ppc_to_npx_npy_npz~~CallsGraph proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~isprime isprime proc~from_ppc_to_npx_npy_npz->proc~isprime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~from_ppc_to_npx_npy_npz~~CalledByGraph proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles consistency_check_number_of_particles proc~consistency_check_number_of_particles->proc~from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles_comp consistency_check_number_of_particles_comp proc~consistency_check_number_of_particles_comp->proc~from_ppc_to_npx_npy_npz proc~read_input_nml read_input_nml proc~read_input_nml->proc~consistency_check_number_of_particles_comp proc~read_main_input read_main_input proc~read_main_input->proc~read_input_nml proc~start Start proc~start->proc~read_main_input program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/from_ppc_to_npx_npy_npz.html"},{"title":"primefactors – ALaDyn","text":"private subroutine primefactors(num, factors, number_factors) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num integer, intent(out), dimension((num/2)) :: factors integer, intent(inout) :: number_factors Contents None","tags":"","loc":"proc/primefactors.html"},{"title":"print_at_screen_nml_error – ALaDyn","text":"private subroutine print_at_screen_nml_error() Arguments None Contents None","tags":"","loc":"proc/print_at_screen_nml_error.html"},{"title":"select_number_of_bunch_particles – ALaDyn","text":"private subroutine select_number_of_bunch_particles() Arguments None Contents None","tags":"","loc":"proc/select_number_of_bunch_particles.html"},{"title":"dump_data – ALaDyn","text":"public subroutine dump_data(it_loc, tloc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it_loc real(kind=dp), intent(in) :: tloc Calls proc~~dump_data~~CallsGraph proc~dump_data dump_data xpt xpt proc~dump_data->xpt loc_zpt loc_zpt proc~dump_data->loc_zpt loc_ypt loc_ypt proc~dump_data->loc_ypt loc_wghyz loc_wghyz proc~dump_data->loc_wghyz fluid_x_profile fluid_x_profile proc~dump_data->fluid_x_profile env env proc~dump_data->env wghpt wghpt proc~dump_data->wghpt loc_npart loc_npart proc~dump_data->loc_npart ebf ebf proc~dump_data->ebf up up proc~dump_data->up proc~intvec_distribute intvec_distribute proc~dump_data->proc~intvec_distribute up0 up0 proc~dump_data->up0 proc~exchange_rdata_int exchange_rdata_int proc~dump_data->proc~exchange_rdata_int spec spec proc~dump_data->spec env1 env1 proc~dump_data->env1 fluid_yz_profile fluid_yz_profile proc~dump_data->fluid_yz_profile mpi_send mpi_send proc~intvec_distribute->mpi_send mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dump_data.html"},{"title":"restart – ALaDyn","text":"public subroutine restart(it_loc, tloc) Arguments Type Intent Optional Attributes Name integer, intent(out) :: it_loc real(kind=dp), intent(out) :: tloc Calls proc~~restart~~CallsGraph proc~restart restart proc~vint_2d_bcast vint_2d_bcast proc~restart->proc~vint_2d_bcast wghpt wghpt proc~restart->wghpt proc~vint_bcast vint_bcast proc~restart->proc~vint_bcast proc~exchange_2d_grdata exchange_2d_grdata proc~restart->proc~exchange_2d_grdata loc_npart loc_npart proc~restart->loc_npart up up proc~restart->up up0 up0 proc~restart->up0 proc~intvec_distribute intvec_distribute proc~restart->proc~intvec_distribute ebf ebf proc~restart->ebf env env proc~restart->env env1 env1 proc~restart->env1 proc~p_alloc p_alloc proc~restart->proc~p_alloc loc_wghyz loc_wghyz proc~restart->loc_wghyz proc~exchange_1d_grdata exchange_1d_grdata proc~restart->proc~exchange_1d_grdata xpt xpt proc~restart->xpt loc_ypt loc_ypt proc~restart->loc_ypt loc_zpt loc_zpt proc~restart->loc_zpt fluid_x_profile fluid_x_profile proc~restart->fluid_x_profile proc~real_bcast real_bcast proc~restart->proc~real_bcast spec spec proc~restart->spec fluid_yz_profile fluid_yz_profile proc~restart->fluid_yz_profile mpi_bcast mpi_bcast proc~vint_bcast->mpi_bcast proc~intvec_distribute->mpi_bcast mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_send mpi_send proc~intvec_distribute->mpi_send proc~real_bcast->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~restart~~CalledByGraph proc~restart restart proc~start Start proc~start->proc~restart program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/restart.html"},{"title":"create_timestep_folder – ALaDyn","text":"public subroutine create_timestep_folder(iout) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iout Contents None","tags":"","loc":"proc/create_timestep_folder.html"},{"title":"create_initial_folders – ALaDyn","text":"public subroutine create_initial_folders() Arguments None Called by proc~~create_initial_folders~~CalledByGraph proc~create_initial_folders create_initial_folders proc~start Start proc~start->proc~create_initial_folders program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/create_initial_folders.html"},{"title":"set_initial_param – ALaDyn","text":"public subroutine set_initial_param() Arguments None Calls proc~~set_initial_param~~CallsGraph proc~set_initial_param set_initial_param proc~set_grid set_grid proc~set_initial_param->proc~set_grid y y proc~set_initial_param->y z z proc~set_initial_param->z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_initial_param~~CalledByGraph proc~set_initial_param set_initial_param proc~start Start proc~start->proc~set_initial_param program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/set_initial_param.html"},{"title":"Start – ALaDyn","text":"public subroutine Start() Start subroutine. It reads the input file, initializes\n the variables and allocates the needed arrays before to start the\n simulation. Arguments None Calls proc~~start~~CallsGraph proc~start Start ion_min ion_min proc~start->ion_min proc~set_ftgrid set_ftgrid proc~start->proc~set_ftgrid proc~set_fxgrid set_fxgrid proc~start->proc~set_fxgrid proc~set_loc_grid_param set_loc_grid_param proc~start->proc~set_loc_grid_param proc~create_initial_folders create_initial_folders proc~start->proc~create_initial_folders end_parallel end_parallel proc~start->end_parallel yft_ind yft_ind proc~start->yft_ind proc~read_main_input read_main_input proc~start->proc~read_main_input mpi_barrier mpi_barrier proc~start->mpi_barrier proc~init init proc~start->proc~init proc~v_alloc v_alloc proc~start->proc~v_alloc set_field_param set_field_param proc~start->set_field_param proc~restart restart proc~start->proc~restart loc_yg loc_yg proc~start->loc_yg proc~set_fyzxgrid set_fyzxgrid proc~start->proc~set_fyzxgrid atomic_number atomic_number proc~start->atomic_number loc_yft loc_yft proc~start->loc_yft proc~fluid_alloc fluid_alloc proc~start->proc~fluid_alloc proc~set_output_grid set_output_grid proc~start->proc~set_output_grid proc~mpi_loc_grid mpi_loc_grid proc~start->proc~mpi_loc_grid proc~set_initial_param set_initial_param proc~start->proc~set_initial_param float float proc~start->float proc~write_read_nml write_read_nml proc~start->proc~write_read_nml loc_yftgrid loc_yftgrid proc~start->loc_yftgrid loc_ygrid loc_ygrid proc~start->loc_ygrid proc~mpi_buffer_alloc mpi_buffer_alloc proc~start->proc~mpi_buffer_alloc start_parallel start_parallel proc~start->start_parallel proc~select_str_to_ft_grid select_str_to_ft_grid proc~set_ftgrid->proc~select_str_to_ft_grid proc~set_ftyzgrid set_ftyzgrid proc~set_ftgrid->proc~set_ftyzgrid proc~read_input_nml read_input_nml proc~read_main_input->proc~read_input_nml proc~lp_pulse lp_pulse proc~init->proc~lp_pulse proc~set_envelope set_envelope proc~init->proc~set_envelope proc~cp_pulse cp_pulse proc~init->proc~cp_pulse proc~part_distribute part_distribute proc~init->proc~part_distribute proc~vint_2d_bcast vint_2d_bcast proc~restart->proc~vint_2d_bcast wghpt wghpt proc~restart->wghpt proc~vint_bcast vint_bcast proc~restart->proc~vint_bcast proc~exchange_2d_grdata exchange_2d_grdata proc~restart->proc~exchange_2d_grdata loc_npart loc_npart proc~restart->loc_npart up up proc~restart->up up0 up0 proc~restart->up0 proc~intvec_distribute intvec_distribute proc~restart->proc~intvec_distribute ebf ebf proc~restart->ebf env env proc~restart->env env1 env1 proc~restart->env1 proc~p_alloc p_alloc proc~restart->proc~p_alloc loc_wghyz loc_wghyz proc~restart->loc_wghyz proc~exchange_1d_grdata exchange_1d_grdata proc~restart->proc~exchange_1d_grdata xpt xpt proc~restart->xpt loc_ypt loc_ypt proc~restart->loc_ypt loc_zpt loc_zpt proc~restart->loc_zpt fluid_x_profile fluid_x_profile proc~restart->fluid_x_profile proc~real_bcast real_bcast proc~restart->proc~real_bcast spec spec proc~restart->spec fluid_yz_profile fluid_yz_profile proc~restart->fluid_yz_profile z z proc~set_initial_param->z proc~set_grid set_grid proc~set_initial_param->proc~set_grid y y proc~set_initial_param->y y0_cent y0_cent proc~lp_pulse->y0_cent lp_end lp_end proc~lp_pulse->lp_end loc_xgrid loc_xgrid proc~lp_pulse->loc_xgrid proc~init_lp_inc0_fields init_lp_inc0_fields proc~lp_pulse->proc~init_lp_inc0_fields z0_cent z0_cent proc~lp_pulse->z0_cent xc_loc xc_loc proc~lp_pulse->xc_loc lp_in lp_in proc~lp_pulse->lp_in xf_loc xf_loc proc~lp_pulse->xf_loc lp_delay lp_delay proc~lp_pulse->lp_delay lpx lpx proc~lp_pulse->lpx mpi_bcast mpi_bcast proc~vint_bcast->mpi_bcast mpi_send mpi_send proc~intvec_distribute->mpi_send mpi_recv mpi_recv proc~intvec_distribute->mpi_recv proc~intvec_distribute->mpi_bcast proc~set_envelope->y0_cent proc~set_envelope->lp_end proc~set_envelope->loc_xgrid proc~init_gprof_envelope_field init_gprof_envelope_field proc~set_envelope->proc~init_gprof_envelope_field proc~set_envelope->z0_cent proc~init_envelope_field init_envelope_field proc~set_envelope->proc~init_envelope_field proc~set_envelope->xc_loc proc~set_envelope->lp_in proc~set_envelope->xf_loc proc~set_envelope->lp_delay proc~set_envelope->lpx proc~init_cp_fields init_cp_fields proc~cp_pulse->proc~init_cp_fields proc~cp_pulse->lp_end proc~cp_pulse->loc_xgrid proc~cp_pulse->lp_in proc~cp_pulse->lpx proc~consistency_check_grid consistency_check_grid proc~read_input_nml->proc~consistency_check_grid proc~consistency_check_number_of_particles_comp consistency_check_number_of_particles_comp proc~read_input_nml->proc~consistency_check_number_of_particles_comp proc~multi_layer_threesp_target multi_layer_threesp_target proc~part_distribute->proc~multi_layer_threesp_target proc~multi_layer_gas_target multi_layer_gas_target proc~part_distribute->proc~multi_layer_gas_target proc~preplasma_multisp preplasma_multisp proc~part_distribute->proc~preplasma_multisp proc~one_layer_nano_tubes one_layer_nano_tubes proc~part_distribute->proc~one_layer_nano_tubes proc~one_layer_nano_wires one_layer_nano_wires proc~part_distribute->proc~one_layer_nano_wires proc~multi_layer_twosp_target multi_layer_twosp_target proc~part_distribute->proc~multi_layer_twosp_target proc~real_bcast->mpi_bcast proc~init_cp_fields->loc_yg proc~init_cp_fields->loc_ygrid proc~get_plane_wave_cp get_plane_wave_cp proc~init_cp_fields->proc~get_plane_wave_cp loc_zg loc_zg proc~init_cp_fields->loc_zg proc~get_laser_fields_cp get_laser_fields_cp proc~init_cp_fields->proc~get_laser_fields_cp loc_zgrid loc_zgrid proc~init_cp_fields->loc_zgrid loc_xg loc_xg proc~init_cp_fields->loc_xg proc~init_gprof_envelope_field->loc_yg proc~init_gprof_envelope_field->loc_ygrid proc~init_gprof_envelope_field->loc_zg proc~init_gprof_envelope_field->loc_zgrid proc~init_gprof_envelope_field->loc_xg proc~multi_layer_threesp_target->wghpt proc~multi_layer_threesp_target->proc~p_alloc proc~multi_layer_threesp_target->xpt proc~multi_layer_threesp_target->spec loc_xpt loc_xpt proc~multi_layer_threesp_target->loc_xpt loc_wghx loc_wghx proc~multi_layer_threesp_target->loc_wghx proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~multi_layer_threesp_target->proc~set_uniform_yz_distrib proc~init_lp_inc0_fields->loc_yg proc~init_lp_inc0_fields->loc_ygrid proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_gprof_fields_lp proc~get_laser_gprof_fields_lp get_laser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_laser_gprof_fields_lp proc~init_lp_inc0_fields->loc_zg proc~init_lp_inc0_fields->loc_zgrid proc~get_laser_fields_lp get_laser_fields_lp proc~init_lp_inc0_fields->proc~get_laser_fields_lp proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_fields_lp proc~init_lp_inc0_fields->loc_xg proc~get_plane_wave_lp get_plane_wave_lp proc~init_lp_inc0_fields->proc~get_plane_wave_lp proc~multi_layer_gas_target->wghpt proc~multi_layer_gas_target->proc~p_alloc proc~multi_layer_gas_target->xpt proc~multi_layer_gas_target->spec proc~multi_layer_gas_target->loc_xpt proc~multi_layer_gas_target->loc_wghx proc~multi_layer_gas_target->proc~set_uniform_yz_distrib proc~mpi_x_part_distrib mpi_x_part_distrib proc~multi_layer_gas_target->proc~mpi_x_part_distrib proc~preplasma_multisp->wghpt proc~preplasma_multisp->proc~p_alloc proc~preplasma_multisp->xpt proc~preplasma_multisp->spec proc~preplasma_multisp->loc_xpt proc~preplasma_multisp->loc_wghx proc~preplasma_multisp->proc~set_uniform_yz_distrib proc~init_envelope_field->loc_yg proc~init_envelope_field->loc_ygrid proc~init_envelope_field->loc_zg proc~init_envelope_field->loc_zgrid proc~init_envelope_field->loc_xg proc~one_layer_nano_tubes->wghpt proc~one_layer_nano_tubes->proc~p_alloc proc~one_layer_nano_tubes->loc_wghyz proc~one_layer_nano_tubes->xpt proc~one_layer_nano_tubes->loc_ypt proc~one_layer_nano_tubes->loc_zpt proc~one_layer_nano_tubes->spec proc~one_layer_nano_tubes->loc_xpt zpt zpt proc~one_layer_nano_tubes->zpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~one_layer_nano_tubes->proc~mpi_yz_part_distrib proc~init_random_seed init_random_seed proc~one_layer_nano_tubes->proc~init_random_seed ypt ypt proc~one_layer_nano_tubes->ypt proc~gasdev gasdev proc~one_layer_nano_tubes->proc~gasdev proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles_comp->proc~from_ppc_to_npx_npy_npz proc~one_layer_nano_wires->wghpt proc~one_layer_nano_wires->proc~p_alloc proc~one_layer_nano_wires->loc_wghyz proc~one_layer_nano_wires->xpt proc~one_layer_nano_wires->loc_ypt proc~one_layer_nano_wires->loc_zpt proc~one_layer_nano_wires->spec proc~one_layer_nano_wires->loc_xpt proc~one_layer_nano_wires->loc_wghx proc~set_pgrid_ind set_pgrid_ind proc~one_layer_nano_wires->proc~set_pgrid_ind proc~one_layer_nano_wires->zpt proc~one_layer_nano_wires->proc~mpi_yz_part_distrib proc~one_layer_nano_wires->ypt proc~multi_layer_twosp_target->wghpt proc~multi_layer_twosp_target->proc~p_alloc proc~multi_layer_twosp_target->xpt proc~multi_layer_twosp_target->spec proc~multi_layer_twosp_target->loc_xpt proc~multi_layer_twosp_target->loc_wghx proc~multi_layer_twosp_target->proc~set_uniform_yz_distrib proc~isprime isprime proc~from_ppc_to_npx_npy_npz->proc~isprime proc~set_pgrid_ind->zpt proc~set_pgrid_ind->ypt proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->zpt proc~mpi_yz_part_distrib->ypt proc~set_uniform_yz_distrib->loc_wghyz proc~set_uniform_yz_distrib->loc_ypt proc~set_uniform_yz_distrib->loc_zpt proc~set_uniform_yz_distrib->proc~set_pgrid_ind proc~set_uniform_yz_distrib->zpt proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib proc~set_uniform_yz_distrib->ypt proc~mpi_x_part_distrib->wghpt proc~mpi_x_part_distrib->xpt proc~mpi_x_part_distrib->loc_xpt proc~mpi_x_part_distrib->loc_wghx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~start~~CalledByGraph proc~start Start program~aladyn aladyn program~aladyn->proc~start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/start.html"},{"title":"ionize – ALaDyn","text":"Uses ionz_data common_param array_alloc mpi_var util module~~ionize~~UsesGraph module~ionize ionize module~ionz_data ionz_data module~ionize->module~ionz_data module~array_alloc array_alloc module~ionize->module~array_alloc module~mpi_var mpi_var module~ionize->module~mpi_var module~util util module~ionize->module~util module~common_param common_param module~ionize->module~common_param module~precision_def precision_def module~ionz_data->module~precision_def module~pstruct_data pstruct_data module~array_alloc->module~pstruct_data module~fstruct_data fstruct_data module~array_alloc->module~fstruct_data module~mpi_var->module~precision_def module~code_util code_util module~util->module~code_util module~util->module~precision_def module~common_param->module~precision_def module~pstruct_data->module~precision_def module~struct_def struct_def module~pstruct_data->module~struct_def module~code_util->module~precision_def module~fstruct_data->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ionize~~UsedByGraph module~ionize ionize module~pic_evolve pic_evolve module~pic_evolve->module~ionize module~start_all start_all module~start_all->module~ionize module~env_evolve env_evolve module~env_evolve->module~ionize program~aladyn aladyn program~aladyn->module~pic_evolve program~aladyn->module~start_all program~aladyn->module~env_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables el_ionz_count efp_aux Subroutines set_field_ioniz_wfunction ionization_electrons_inject env_ionization_electrons_inject part_ionize ionization_cycle Variables Type Visibility Attributes Name Initial integer, private, allocatable :: el_ionz_count (:) real(kind=dp), private, allocatable :: efp_aux (:,:) Subroutines public subroutine set_field_ioniz_wfunction (z0, zm, loc_ion, nz_lev, nz_model, e_max, dt_in) Arguments Type Intent Optional Attributes Name integer, intent(in) :: z0 integer, intent(in) :: zm integer, intent(in) :: loc_ion integer, intent(in) :: nz_lev integer, intent(in) :: nz_model real(kind=dp), intent(in) :: e_max real(kind=dp), optional :: dt_in private subroutine ionization_electrons_inject (ion_ch_inc, ic, np, np_el, new_np_el) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ion_ch_inc (:) integer, intent(in) :: ic integer, intent(in) :: np integer, intent(inout) :: np_el integer, intent(in) :: new_np_el private subroutine env_ionization_electrons_inject (sp_field, ion_ch_inc, ic, np, np_el, new_np_el) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sp_field (:,:) integer, intent(in) :: ion_ch_inc (:) integer, intent(in) :: ic integer, intent(in) :: np integer, intent(inout) :: np_el integer, intent(in) :: new_np_el private subroutine part_ionize (sp_loc, amp_aux, np, ic, new_np_el, ion_ch_inc) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: amp_aux (:,:) integer, intent(in) :: np integer, intent(in) :: ic integer, intent(inout) :: new_np_el integer, intent(inout) :: ion_ch_inc (:) public subroutine ionization_cycle (sp_loc, sp_aux, np, ic, itloc, mom_id, def_inv) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: sp_aux (:,:) integer, intent(in) :: np integer, intent(in) :: ic integer, intent(in) :: itloc integer, intent(in) :: mom_id real(kind=dp), intent(in) :: def_inv","tags":"","loc":"module/ionize.html"},{"title":"ionz_data – ALaDyn","text":"Uses precision_def module~~ionz_data~~UsesGraph module~ionz_data ionz_data module~precision_def precision_def module~ionz_data->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ionz_data~~UsedByGraph module~ionz_data ionz_data module~set_init_param set_init_param module~set_init_param->module~ionz_data module~ionize ionize module~ionize->module~ionz_data module~run_data_info run_data_info module~run_data_info->module~ionz_data program~aladyn aladyn program~aladyn->module~run_data_info module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_evolve->module~ionize module~window window module~pic_evolve->module~window module~start_all->module~set_init_param module~start_all->module~ionize module~start_all->module~run_data_info module~env_evolve->module~ionize module~env_evolve->module~window module~window->module~run_data_info Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables species_name an_max v vfact nstar c_nstar e_c e_b e_m v_norm nl_fact nl_indx ne_shell l_fact z1_coll be p_nl wi wsp w_one_lev sigma_coll e_coll v_h e_unit omega_a c_au euler omega_l pig tiny n_ge nec lstar dge d2ge de_inv deb_inv dt_fs dgi d2gi dei_inv Subroutines set_atomic_weight set_atoms_per_molecule set_ionization_coeff set_impact_ioniz_wfunction Variables Type Visibility Attributes Name Initial character(len=10), public, parameter, dimension(0:28) :: species_name = [' Electron ', ' Hydrogen ', '  Helium  ', ' Lithium  ', 'Berillium ', ' Boron    ', '  Carbon  ', ' Nitrogen ', ' Oxygen   ', ' Florine  ', '   Neon   ', ' Sodium   ', 'Magnesium ', ' Aluminium', ' Silicon  ', 'Phosphorus', ' Solfur   ', ' Chlorine ', ' Argon    ', 'Potassium ', ' Calcium  ', ' Scandium ', ' Titanium ', '          ', ' Chromium ', 'Manganese ', '  Iron    ', '          ', '  Nickel  '] integer, public, parameter :: an_max = 40 real(kind=dp), public :: v (an_max) real(kind=dp), public :: vfact (an_max,3) real(kind=dp), public :: nstar (an_max,3) real(kind=dp), public :: c_nstar (an_max,3) real(kind=dp), public :: e_c (an_max,3) real(kind=dp), public :: e_b (an_max,3) real(kind=dp), public :: e_m (an_max,3) real(kind=dp), public :: v_norm (an_max,3) integer, public :: nl_fact (0:an_max) integer, public :: nl_indx (0:an_max) integer, public :: ne_shell (1:6,0:an_max) integer, public :: l_fact (an_max) integer, public :: z1_coll real(kind=dp), public :: be (10,0:an_max) real(kind=dp), public :: p_nl (10,0:an_max) real(kind=dp), public, allocatable :: wi (:,:,:) real(kind=dp), public, allocatable :: wsp (:,:,:,:) real(kind=dp), public, allocatable :: w_one_lev (:,:,:) real(kind=dp), public, allocatable :: sigma_coll (:,:,:) real(kind=dp), public, allocatable :: e_coll (:,:) real(kind=dp), public, parameter :: v_h = 13.5984 real(kind=dp), public, parameter :: e_unit = 0.511*1.e+06 real(kind=dp), public, parameter :: omega_a = 41.3 real(kind=dp), public, parameter :: c_au = 137.0 real(kind=dp), public, parameter :: euler = 2.71828 real(kind=dp), public, parameter :: omega_l = 0.057 real(kind=dp), public, parameter :: pig = 3.141592653589793 real(kind=dp), public, parameter :: tiny = 1.e-10 integer, public, parameter :: n_ge = 10000 integer, public, parameter :: nec = 1000 real(kind=dp), public :: lstar real(kind=dp), public :: dge real(kind=dp), public :: d2ge real(kind=dp), public :: de_inv real(kind=dp), public :: deb_inv real(kind=dp), public :: dt_fs real(kind=dp), public :: dgi real(kind=dp), public :: d2gi real(kind=dp), public :: dei_inv Subroutines public subroutine set_atomic_weight (at_number, w_number) Arguments Type Intent Optional Attributes Name integer, intent(in) :: at_number real(kind=dp), intent(out) :: w_number public subroutine set_atoms_per_molecule (at_number, n_mol_atoms) Arguments Type Intent Optional Attributes Name integer, intent(in) :: at_number integer, intent(inout) :: n_mol_atoms public subroutine set_ionization_coeff (an, sp_ionz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: an (:) integer, intent(in) :: sp_ionz public subroutine set_impact_ioniz_wfunction (zm, imod) Arguments Type Intent Optional Attributes Name integer, intent(in) :: zm integer, intent(in) :: imod","tags":"","loc":"module/ionz_data.html"},{"title":"window – ALaDyn","text":"Uses util pstruct_data fstruct_data common_param grid_param mpi_field_interface mpi_part_interface run_data_info module~~window~~UsesGraph module~window window module~grid_param grid_param module~window->module~grid_param module~fstruct_data fstruct_data module~window->module~fstruct_data module~run_data_info run_data_info module~window->module~run_data_info module~pstruct_data pstruct_data module~window->module~pstruct_data module~mpi_field_interface mpi_field_interface module~window->module~mpi_field_interface module~util util module~window->module~util module~common_param common_param module~window->module~common_param module~mpi_part_interface mpi_part_interface module~window->module~mpi_part_interface module~precision_def precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~run_data_info->module~grid_param module~run_data_info->module~fstruct_data module~run_data_info->module~pstruct_data module~run_data_info->module~common_param module~ionz_data ionz_data module~run_data_info->module~ionz_data module~control_bunch_input control_bunch_input module~run_data_info->module~control_bunch_input module~parallel parallel module~run_data_info->module~parallel module~code_util code_util module~run_data_info->module~code_util module~phys_param phys_param module~run_data_info->module~phys_param module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_field_interface->module~grid_param module~mpi_field_interface->module~fstruct_data module~mpi_field_interface->module~pstruct_data module~mpi_field_interface->module~parallel module~util->module~precision_def module~util->module~code_util module~common_param->module~precision_def module~mpi_part_interface->module~grid_param module~mpi_part_interface->module~parallel module~array_alloc array_alloc module~mpi_part_interface->module~array_alloc module~mpi_part_interface->module~code_util module~ionz_data->module~precision_def module~control_bunch_input->module~precision_def module~parallel->module~util module~parallel->module~common_param module~mpi_var mpi_var module~parallel->module~mpi_var mpi mpi module~parallel->mpi module~array_alloc->module~fstruct_data module~array_alloc->module~pstruct_data module~code_util->module~precision_def module~struct_def->module~precision_def module~phys_param->module~precision_def module~mpi_var->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~window~~UsedByGraph module~window window module~pic_evolve pic_evolve module~pic_evolve->module~window module~env_evolve env_evolve module~env_evolve->module~window program~aladyn aladyn program~aladyn->module~pic_evolve program~aladyn->module~env_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines add_particles particles_inject reset_loc_xgrid comoving_coordinate lp_window_xshift Subroutines public subroutine add_particles (np, i1, i2, ic) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: ic public subroutine particles_inject (xmx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xmx public subroutine reset_loc_xgrid () Arguments None public subroutine comoving_coordinate (vb, w_nst, loc_it) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vb integer, intent(in) :: w_nst integer, intent(in) :: loc_it public subroutine lp_window_xshift (witr, init_iter) Arguments Type Intent Optional Attributes Name integer, intent(in) :: witr integer, intent(in) :: init_iter","tags":"","loc":"module/window.html"},{"title":"fluid_density_momenta – ALaDyn","text":"Uses mpi_field_interface grid_fields module~~fluid_density_momenta~~UsesGraph module~fluid_density_momenta fluid_density_momenta module~mpi_field_interface mpi_field_interface module~fluid_density_momenta->module~mpi_field_interface module~grid_fields grid_fields module~fluid_density_momenta->module~grid_fields module~grid_param grid_param module~mpi_field_interface->module~grid_param module~fstruct_data fstruct_data module~mpi_field_interface->module~fstruct_data module~parallel parallel module~mpi_field_interface->module~parallel module~pstruct_data pstruct_data module~mpi_field_interface->module~pstruct_data module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param module~precision_def precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~common_param common_param module~parallel->module~common_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~grid_field_param->module~grid_param module~grid_field_param->module~common_param module~grid_field_param->module~mpi_var module~common_param->module~precision_def module~mpi_var->module~precision_def module~util->module~precision_def module~code_util code_util module~util->module~code_util module~struct_def->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~fluid_density_momenta~~UsedByGraph module~fluid_density_momenta fluid_density_momenta module~pic_evolve pic_evolve module~pic_evolve->module~fluid_density_momenta module~env_evolve env_evolve module~env_evolve->module~fluid_density_momenta program~aladyn aladyn program~aladyn->module~pic_evolve program~aladyn->module~env_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines fluid_curr_accumulate set_env_momentum_density_flux set_momentum_density_flux update_adam_bash_fluid_variables Subroutines public subroutine fluid_curr_accumulate (flx, curr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: flx (:,:,:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) public subroutine set_env_momentum_density_flux (uv, ef, curr, eb_tot, flx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: uv (:,:,:,:) real(kind=dp), intent(in) :: ef (:,:,:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(out) :: eb_tot (:,:,:,:) real(kind=dp), intent(out) :: flx (:,:,:,:) public subroutine set_momentum_density_flux (uv, flx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: uv (:,:,:,:) real(kind=dp), intent(inout) :: flx (:,:,:,:) public subroutine update_adam_bash_fluid_variables (u, u0, flx, ef) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: u (:,:,:,:) real(kind=dp), intent(inout) :: u0 (:,:,:,:) real(kind=dp), intent(inout) :: flx (:,:,:,:) real(kind=dp), intent(inout) :: ef (:,:,:,:)","tags":"","loc":"module/fluid_density_momenta.html"},{"title":"curr_and_fields_util – ALaDyn","text":"Uses pstruct_data fstruct_data grid_param mpi_curr_interface mpi_field_interface grid_part_connect grid_fields init_grid_field module~~curr_and_fields_util~~UsesGraph module~curr_and_fields_util curr_and_fields_util module~grid_fields grid_fields module~curr_and_fields_util->module~grid_fields module~grid_param grid_param module~curr_and_fields_util->module~grid_param module~fstruct_data fstruct_data module~curr_and_fields_util->module~fstruct_data module~grid_part_connect grid_part_connect module~curr_and_fields_util->module~grid_part_connect module~pstruct_data pstruct_data module~curr_and_fields_util->module~pstruct_data module~mpi_field_interface mpi_field_interface module~curr_and_fields_util->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~curr_and_fields_util->module~mpi_curr_interface module~init_grid_field init_grid_field module~curr_and_fields_util->module~init_grid_field module~parallel parallel module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param module~precision_def precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~grid_part_connect->module~fstruct_data module~grid_part_connect->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_connect->module~grid_part_lib module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_field_interface->module~grid_param module~mpi_field_interface->module~fstruct_data module~mpi_field_interface->module~pstruct_data module~mpi_field_interface->module~parallel module~mpi_curr_interface->module~grid_param module~mpi_curr_interface->module~fstruct_data module~mpi_curr_interface->module~pstruct_data module~mpi_curr_interface->module~parallel module~init_grid_field->module~fstruct_data module~init_grid_field->module~pstruct_data module~init_grid_field->module~grid_field_param module~phys_param phys_param module~init_grid_field->module~phys_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~common_param common_param module~parallel->module~common_param module~struct_def->module~precision_def module~grid_field_param->module~grid_param module~grid_field_param->module~mpi_var module~grid_field_param->module~common_param module~grid_part_lib->module~grid_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~phys_param->module~precision_def module~mpi_var->module~precision_def module~util->module~precision_def module~code_util code_util module~util->module~code_util module~common_param->module~precision_def module~stretched_grid->module~grid_param module~stretched_grid->module~mpi_var module~stretched_grid->module~common_param module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~curr_and_fields_util~~UsedByGraph module~curr_and_fields_util curr_and_fields_util module~pic_evolve pic_evolve module~pic_evolve->module~curr_and_fields_util module~env_evolve env_evolve module~env_evolve->module~curr_and_fields_util program~aladyn aladyn program~aladyn->module~pic_evolve program~aladyn->module~env_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines set_lpf_acc field_charge_multiply curr_accumulate curr_mpi_collect pfields_prepare advance_lpf_fields advance_lpf_envelope wave_field_left_inject advect_bunch_fields Subroutines public subroutine set_lpf_acc (ef, sp_loc, apt, np, nf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: apt (:,:) integer, intent(in) :: np integer, intent(in) :: nf public subroutine field_charge_multiply (sp_loc, apt, np, ncmp) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: apt (:,:) integer, intent(in) :: np integer, intent(in) :: ncmp public subroutine curr_accumulate (sp_loc, pdata, curr, npt) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pdata (:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: npt public subroutine curr_mpi_collect (curr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) public subroutine pfields_prepare (ef, nc, spr, spl) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) integer, intent(in) :: nc integer, intent(in) :: spr integer, intent(in) :: spl public subroutine advance_lpf_fields (ef, curr, ibd) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: curr (:,:,:,:) integer, intent(in) :: ibd public subroutine advance_lpf_envelope (curr, evf, omg) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(inout) :: evf (:,:,:,:) real(kind=dp), intent(in) :: omg public subroutine wave_field_left_inject (ef, x_left) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: x_left public subroutine advect_bunch_fields (fb, curr, v_b) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: fb (:,:,:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(in) :: v_b","tags":"","loc":"module/curr_and_fields_util.html"},{"title":"boris_push – ALaDyn","text":"Uses pstruct_data fstruct_data common_param module~~boris_push~~UsesGraph module~boris_push boris_push module~pstruct_data pstruct_data module~boris_push->module~pstruct_data module~common_param common_param module~boris_push->module~common_param module~fstruct_data fstruct_data module~boris_push->module~fstruct_data module~struct_def struct_def module~pstruct_data->module~struct_def module~precision_def precision_def module~pstruct_data->module~precision_def module~common_param->module~precision_def module~fstruct_data->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~boris_push~~UsedByGraph module~boris_push boris_push module~pic_evolve pic_evolve module~pic_evolve->module~boris_push module~env_evolve env_evolve module~env_evolve->module~boris_push program~aladyn aladyn program~aladyn->module~pic_evolve program~aladyn->module~env_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines init_lpf_momenta lpf_momenta_and_positions lpf_env_momenta lpf_env_positions Subroutines public subroutine init_lpf_momenta (sp_loc, pt, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ic public subroutine lpf_momenta_and_positions (sp_loc, pt, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ic public subroutine lpf_env_momenta (sp_loc, f_pt, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: f_pt (:,:) integer, intent(in) :: np integer, intent(in) :: ic public subroutine lpf_env_positions (sp_loc, f_pt, np) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(inout) :: f_pt (:,:) integer, intent(in) :: np","tags":"","loc":"module/boris_push.html"},{"title":"pic_evolve – ALaDyn","text":"Uses window boris_push curr_and_fields_util mpi_part_interface init_grid_field ionize fluid_density_momenta module~~pic_evolve~~UsesGraph module~pic_evolve pic_evolve module~curr_and_fields_util curr_and_fields_util module~pic_evolve->module~curr_and_fields_util module~boris_push boris_push module~pic_evolve->module~boris_push module~ionize ionize module~pic_evolve->module~ionize module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~init_grid_field init_grid_field module~pic_evolve->module~init_grid_field module~window window module~pic_evolve->module~window module~mpi_part_interface mpi_part_interface module~pic_evolve->module~mpi_part_interface module~curr_and_fields_util->module~init_grid_field module~grid_fields grid_fields module~curr_and_fields_util->module~grid_fields module~grid_param grid_param module~curr_and_fields_util->module~grid_param module~fstruct_data fstruct_data module~curr_and_fields_util->module~fstruct_data module~grid_part_connect grid_part_connect module~curr_and_fields_util->module~grid_part_connect module~pstruct_data pstruct_data module~curr_and_fields_util->module~pstruct_data module~mpi_field_interface mpi_field_interface module~curr_and_fields_util->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~curr_and_fields_util->module~mpi_curr_interface module~boris_push->module~fstruct_data module~boris_push->module~pstruct_data module~common_param common_param module~boris_push->module~common_param module~ionz_data ionz_data module~ionize->module~ionz_data module~array_alloc array_alloc module~ionize->module~array_alloc module~mpi_var mpi_var module~ionize->module~mpi_var module~util util module~ionize->module~util module~ionize->module~common_param module~fluid_density_momenta->module~grid_fields module~fluid_density_momenta->module~mpi_field_interface module~init_grid_field->module~fstruct_data module~init_grid_field->module~pstruct_data module~grid_field_param grid_field_param module~init_grid_field->module~grid_field_param module~phys_param phys_param module~init_grid_field->module~phys_param module~window->module~mpi_part_interface module~window->module~grid_param module~window->module~fstruct_data module~run_data_info run_data_info module~window->module~run_data_info module~window->module~pstruct_data module~window->module~mpi_field_interface module~window->module~util module~window->module~common_param module~mpi_part_interface->module~grid_param module~mpi_part_interface->module~array_alloc module~parallel parallel module~mpi_part_interface->module~parallel module~code_util code_util module~mpi_part_interface->module~code_util module~grid_fields->module~parallel module~grid_fields->module~grid_field_param module~precision_def precision_def module~ionz_data->module~precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~grid_part_connect->module~fstruct_data module~grid_part_connect->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_connect->module~grid_part_lib module~array_alloc->module~fstruct_data module~array_alloc->module~pstruct_data module~parallel->module~mpi_var module~parallel->module~util module~parallel->module~common_param mpi mpi module~parallel->mpi module~code_util->module~precision_def module~run_data_info->module~ionz_data module~run_data_info->module~grid_param module~run_data_info->module~fstruct_data module~run_data_info->module~parallel module~run_data_info->module~code_util module~run_data_info->module~pstruct_data module~run_data_info->module~common_param module~run_data_info->module~phys_param module~control_bunch_input control_bunch_input module~run_data_info->module~control_bunch_input module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_field_interface->module~grid_param module~mpi_field_interface->module~fstruct_data module~mpi_field_interface->module~parallel module~mpi_field_interface->module~pstruct_data module~mpi_var->module~precision_def module~mpi_curr_interface->module~grid_param module~mpi_curr_interface->module~fstruct_data module~mpi_curr_interface->module~parallel module~mpi_curr_interface->module~pstruct_data module~grid_field_param->module~grid_param module~grid_field_param->module~mpi_var module~grid_field_param->module~common_param module~util->module~code_util module~util->module~precision_def module~common_param->module~precision_def module~phys_param->module~precision_def module~control_bunch_input->module~precision_def module~struct_def->module~precision_def module~grid_part_lib->module~grid_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~stretched_grid->module~grid_param module~stretched_grid->module~mpi_var module~stretched_grid->module~common_param Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pic_evolve~~UsedByGraph module~pic_evolve pic_evolve program~aladyn aladyn program~aladyn->module~pic_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines lpf2_evolve lp_run Subroutines public subroutine lpf2_evolve (iter_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter_loc public subroutine lp_run (t_loc, iter_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: t_loc integer, intent(in) :: iter_loc","tags":"","loc":"module/pic_evolve.html"},{"title":"env_evolve – ALaDyn","text":"Uses window boris_push curr_and_fields_util mpi_part_interface ionize fluid_density_momenta util module~~env_evolve~~UsesGraph module~env_evolve env_evolve module~curr_and_fields_util curr_and_fields_util module~env_evolve->module~curr_and_fields_util module~boris_push boris_push module~env_evolve->module~boris_push module~ionize ionize module~env_evolve->module~ionize module~fluid_density_momenta fluid_density_momenta module~env_evolve->module~fluid_density_momenta module~window window module~env_evolve->module~window module~util util module~env_evolve->module~util module~mpi_part_interface mpi_part_interface module~env_evolve->module~mpi_part_interface module~grid_fields grid_fields module~curr_and_fields_util->module~grid_fields module~grid_param grid_param module~curr_and_fields_util->module~grid_param module~fstruct_data fstruct_data module~curr_and_fields_util->module~fstruct_data module~grid_part_connect grid_part_connect module~curr_and_fields_util->module~grid_part_connect module~pstruct_data pstruct_data module~curr_and_fields_util->module~pstruct_data module~mpi_field_interface mpi_field_interface module~curr_and_fields_util->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~curr_and_fields_util->module~mpi_curr_interface module~init_grid_field init_grid_field module~curr_and_fields_util->module~init_grid_field module~boris_push->module~fstruct_data module~boris_push->module~pstruct_data module~common_param common_param module~boris_push->module~common_param module~ionize->module~util module~ionz_data ionz_data module~ionize->module~ionz_data module~array_alloc array_alloc module~ionize->module~array_alloc module~mpi_var mpi_var module~ionize->module~mpi_var module~ionize->module~common_param module~fluid_density_momenta->module~grid_fields module~fluid_density_momenta->module~mpi_field_interface module~window->module~util module~window->module~mpi_part_interface module~window->module~grid_param module~window->module~fstruct_data module~run_data_info run_data_info module~window->module~run_data_info module~window->module~pstruct_data module~window->module~mpi_field_interface module~window->module~common_param module~code_util code_util module~util->module~code_util module~precision_def precision_def module~util->module~precision_def module~mpi_part_interface->module~grid_param module~mpi_part_interface->module~array_alloc module~mpi_part_interface->module~code_util module~parallel parallel module~mpi_part_interface->module~parallel module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param module~ionz_data->module~precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~grid_part_connect->module~fstruct_data module~grid_part_connect->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_connect->module~grid_part_lib module~array_alloc->module~fstruct_data module~array_alloc->module~pstruct_data module~code_util->module~precision_def module~parallel->module~util module~parallel->module~mpi_var module~parallel->module~common_param mpi mpi module~parallel->mpi module~run_data_info->module~ionz_data module~run_data_info->module~grid_param module~run_data_info->module~fstruct_data module~run_data_info->module~code_util module~run_data_info->module~parallel module~run_data_info->module~pstruct_data module~run_data_info->module~common_param module~control_bunch_input control_bunch_input module~run_data_info->module~control_bunch_input module~phys_param phys_param module~run_data_info->module~phys_param module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_field_interface->module~grid_param module~mpi_field_interface->module~fstruct_data module~mpi_field_interface->module~parallel module~mpi_field_interface->module~pstruct_data module~mpi_var->module~precision_def module~mpi_curr_interface->module~grid_param module~mpi_curr_interface->module~fstruct_data module~mpi_curr_interface->module~parallel module~mpi_curr_interface->module~pstruct_data module~init_grid_field->module~fstruct_data module~init_grid_field->module~pstruct_data module~init_grid_field->module~grid_field_param module~init_grid_field->module~phys_param module~common_param->module~precision_def module~control_bunch_input->module~precision_def module~grid_field_param->module~grid_param module~grid_field_param->module~mpi_var module~grid_field_param->module~common_param module~phys_param->module~precision_def module~struct_def->module~precision_def module~grid_part_lib->module~grid_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~stretched_grid->module~grid_param module~stretched_grid->module~mpi_var module~stretched_grid->module~common_param Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~env_evolve~~UsedByGraph module~env_evolve env_evolve program~aladyn aladyn program~aladyn->module~env_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines env_den_collect env_two_fields_average env_fields_average env_amp_prepare env_amp_two_fields_prepare env_lpf2_evolve env_run Subroutines public subroutine env_den_collect (source_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: source_in (:,:,:,:) public subroutine env_two_fields_average (evf, ev1f, av, spl_in, spr_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: evf (:,:,:,:) real(kind=dp), intent(in) :: ev1f (:,:,:,:) real(kind=dp), intent(out) :: av (:,:,:,:) integer, intent(in) :: spl_in integer, intent(in) :: spr_in public subroutine env_fields_average (evf, av, spl_in, spr_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: evf (:,:,:,:) real(kind=dp), intent(out) :: av (:,:,:,:) integer, intent(in) :: spl_in integer, intent(in) :: spr_in public subroutine env_amp_prepare (envf, av, ord, spl_in, spr_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: envf (:,:,:,:) real(kind=dp), intent(out) :: av (:,:,:,:) integer, intent(in) :: ord integer, intent(in) :: spl_in integer, intent(in) :: spr_in public subroutine env_amp_two_fields_prepare (envf, env1f, av, ord, spl_in, spr_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: envf (:,:,:,:) real(kind=dp), intent(in) :: env1f (:,:,:,:) real(kind=dp), intent(out) :: av (:,:,:,:) integer, intent(in) :: ord integer, intent(in) :: spl_in integer, intent(in) :: spr_in public subroutine env_lpf2_evolve (it_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it_loc public subroutine env_run (t_loc, iter_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: t_loc integer, intent(in) :: iter_loc","tags":"","loc":"module/env_evolve.html"},{"title":"pstruct_data – ALaDyn","text":"Uses precision_def struct_def module~~pstruct_data~~UsesGraph module~pstruct_data pstruct_data module~struct_def struct_def module~pstruct_data->module~struct_def module~precision_def precision_def module~pstruct_data->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pstruct_data~~UsedByGraph module~pstruct_data pstruct_data module~psolve psolve module~psolve->module~pstruct_data module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~pstruct_data module~grid_part_connect grid_part_connect module~curr_and_fields_util->module~grid_part_connect module~mpi_field_interface mpi_field_interface module~curr_and_fields_util->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~curr_and_fields_util->module~mpi_curr_interface module~init_grid_field init_grid_field module~curr_and_fields_util->module~init_grid_field module~boris_push boris_push module~boris_push->module~pstruct_data module~array_alloc array_alloc module~array_alloc->module~pstruct_data module~grid_part_connect->module~pstruct_data module~grid_part_util grid_part_util module~grid_part_util->module~pstruct_data module~run_data_info run_data_info module~run_data_info->module~pstruct_data module~mpi_field_interface->module~pstruct_data module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~pstruct_data module~pic_out pic_out module~pic_out->module~pstruct_data module~window window module~window->module~pstruct_data module~window->module~run_data_info module~window->module~mpi_field_interface module~mpi_part_interface mpi_part_interface module~window->module~mpi_part_interface module~mpi_curr_interface->module~pstruct_data module~init_grid_field->module~pstruct_data module~init_laser_field init_laser_field module~init_laser_field->module~pstruct_data module~init_laser_field->module~init_grid_field module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~psolve module~init_beam_part_distrib->module~array_alloc module~init_beam_part_distrib->module~grid_part_util module~init_beam_part_distrib->module~mpi_field_interface module~init_beam_part_distrib->module~mpi_curr_interface module~init_beam_part_distrib->module~init_grid_field program~aladyn aladyn program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields program~aladyn->module~pic_out program~aladyn->module~init_beam_part_distrib module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~start_all start_all program~aladyn->module~start_all module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~pic_evolve->module~curr_and_fields_util module~pic_evolve->module~boris_push module~pic_evolve->module~window module~pic_evolve->module~init_grid_field module~ionize ionize module~pic_evolve->module~ionize module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~pic_evolve->module~mpi_part_interface module~ionize->module~array_alloc module~env_evolve->module~curr_and_fields_util module~env_evolve->module~boris_push module~env_evolve->module~window module~env_evolve->module~ionize module~env_evolve->module~fluid_density_momenta module~env_evolve->module~mpi_part_interface module~start_all->module~array_alloc module~start_all->module~run_data_info module~start_all->module~ionize module~pic_in pic_in module~start_all->module~pic_in module~pic_dump pic_dump module~start_all->module~pic_dump module~pic_out_util->module~psolve module~pic_out_util->module~grid_part_util module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~init_part_distrib init_part_distrib module~init_part_distrib->module~array_alloc module~fluid_density_momenta->module~mpi_field_interface module~pic_in->module~init_laser_field module~pic_in->module~init_part_distrib module~pic_dump->module~array_alloc module~mpi_part_interface->module~array_alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ebfp ebfb ebfp0 ebfp1 pdata_tracking track_aux xpt ypt zpt wghpt loc_ypt loc_zpt loc_wghyz loc_xpt loc_wghx spec bunch ihx Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: ebfp (:,:) real(kind=dp), public, allocatable :: ebfb (:,:) real(kind=dp), public, allocatable :: ebfp0 (:,:) real(kind=dp), public, allocatable :: ebfp1 (:,:) real(kind=dp), public, allocatable :: pdata_tracking (:,:,:) real(kind=dp), public, allocatable :: track_aux (:) real(kind=dp), public, allocatable :: xpt (:,:) real(kind=dp), public, allocatable :: ypt (:,:) real(kind=dp), public, allocatable :: zpt (:,:) real(kind=dp), public, allocatable :: wghpt (:,:) real(kind=dp), public, allocatable :: loc_ypt (:,:) real(kind=dp), public, allocatable :: loc_zpt (:,:) real(kind=dp), public, allocatable :: loc_wghyz (:,:,:) real(kind=dp), public, allocatable :: loc_xpt (:,:) real(kind=dp), public, allocatable :: loc_wghx (:,:) type( species ), public :: spec (4) type( species ), public :: bunch (5) integer(kind=hp_int), public, parameter :: ihx = 3","tags":"","loc":"module/pstruct_data.html"},{"title":"control_bunch_input – ALaDyn","text":"Uses precision_def module~~control_bunch_input~~UsesGraph module~control_bunch_input control_bunch_input module~precision_def precision_def module~control_bunch_input->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~control_bunch_input~~UsedByGraph module~control_bunch_input control_bunch_input module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~control_bunch_input module~set_init_param set_init_param module~set_init_param->module~control_bunch_input module~read_input read_input module~read_input->module~control_bunch_input module~run_data_info run_data_info module~run_data_info->module~control_bunch_input module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~control_bunch_input module~window window module~window->module~run_data_info program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields module~start_all start_all program~aladyn->module~start_all module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~start_all->module~set_init_param module~start_all->module~read_input module~start_all->module~run_data_info module~pic_evolve->module~window module~env_evolve->module~window Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n_bunches bunch_type nb_tot number_of_slices bunch_shape nb_per_cell np_1 np_2 np_3 np_4 np_5 bunch_type_1 bunch_type_2 bunch_type_3 bunch_type_4 bunch_type_5 bunch_shape_1 bunch_shape_2 bunch_shape_3 bunch_shape_4 bunch_shape_5 bunch_charge bunch_volume jb_norm reduced_charge lorentz_bfact charge_right charge_left gam rhob particle_charge xc_bunch yc_bunch zc_bunch sxb syb epsy epsz dg sigma_cut_bunch alpha_twiss beta_twiss b_ex_poloidal radius_poloidal ppc_x_bunch ppc_y_bunch ppc_z_bunch ppc_bunch l_particles l_twiss l_bpoloidal l_embunchevolution Variables Type Visibility Attributes Name Initial integer, public :: n_bunches integer, public :: bunch_type (5) integer, public :: nb_tot (5) integer, public :: number_of_slices (4) integer, public :: bunch_shape (5) integer, public :: nb_per_cell (5) integer, public :: np_1 integer, public :: np_2 integer, public :: np_3 integer, public :: np_4 integer, public :: np_5 integer, public :: bunch_type_1 integer, public :: bunch_type_2 integer, public :: bunch_type_3 integer, public :: bunch_type_4 integer, public :: bunch_type_5 integer, public :: bunch_shape_1 integer, public :: bunch_shape_2 integer, public :: bunch_shape_3 integer, public :: bunch_shape_4 integer, public :: bunch_shape_5 real(kind=dp), public :: bunch_charge (5) real(kind=dp), public :: bunch_volume (5) real(kind=dp), public :: jb_norm (5) real(kind=dp), public :: reduced_charge (5) real(kind=dp), public :: lorentz_bfact (5) real(kind=dp), public :: charge_right (5) real(kind=dp), public :: charge_left (5) real(kind=dp), public :: gam (5) real(kind=dp), public :: rhob (5) real(kind=dp), public :: particle_charge (5) real(kind=dp), public :: xc_bunch (5) real(kind=dp), public :: yc_bunch (5) real(kind=dp), public :: zc_bunch (5) real(kind=dp), public :: sxb (5) real(kind=dp), public :: syb (5) real(kind=dp), public :: epsy (5) real(kind=dp), public :: epsz (5) real(kind=dp), public :: dg (5) real(kind=dp), public :: sigma_cut_bunch (5) real(kind=dp), public :: alpha_twiss (5) real(kind=dp), public :: beta_twiss (5) real(kind=dp), public :: b_ex_poloidal real(kind=dp), public :: radius_poloidal integer, public :: ppc_x_bunch (5) integer, public :: ppc_y_bunch (5) integer, public :: ppc_z_bunch (5) integer, public :: ppc_bunch (5,3) logical, public :: l_particles logical, public :: l_twiss (5) logical, public :: l_bpoloidal logical, public :: l_embunchevolution","tags":"","loc":"module/control_bunch_input.html"},{"title":"common_param – ALaDyn","text":"Uses precision_def module~~common_param~~UsesGraph module~common_param common_param module~precision_def precision_def module~common_param->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~common_param~~UsedByGraph module~common_param common_param module~psolve psolve module~psolve->module~common_param module~grid_fields grid_fields module~psolve->module~grid_fields module~prl_fft prl_fft module~psolve->module~prl_fft module~boris_push boris_push module~boris_push->module~common_param module~set_init_param set_init_param module~set_init_param->module~common_param module~set_grid_param set_grid_param module~set_init_param->module~set_grid_param module~ionize ionize module~ionize->module~common_param module~parallel parallel module~parallel->module~common_param module~init_part_distrib init_part_distrib module~init_part_distrib->module~common_param module~set_grid_param->module~common_param module~read_input read_input module~read_input->module~common_param module~run_data_info run_data_info module~run_data_info->module~common_param module~run_data_info->module~parallel module~pic_out pic_out module~pic_out->module~common_param module~pic_out->module~parallel module~grid_field_param grid_field_param module~grid_field_param->module~common_param module~window window module~window->module~common_param module~window->module~run_data_info module~mpi_field_interface mpi_field_interface module~window->module~mpi_field_interface module~mpi_part_interface mpi_part_interface module~window->module~mpi_part_interface module~grid_part_lib grid_part_lib module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~pic_dump pic_dump module~pic_dump->module~common_param module~pic_dump->module~parallel module~stretched_grid->module~common_param module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~psolve module~grid_part_util grid_part_util module~init_beam_part_distrib->module~grid_part_util module~init_beam_part_distrib->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib->module~mpi_curr_interface module~init_grid_field init_grid_field module~init_beam_part_distrib->module~init_grid_field module~grid_fields->module~parallel module~grid_fields->module~grid_field_param module~pic_evolve pic_evolve module~pic_evolve->module~boris_push module~pic_evolve->module~ionize module~pic_evolve->module~window module~pic_evolve->module~init_grid_field module~pic_evolve->module~mpi_part_interface module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~curr_and_fields_util curr_and_fields_util module~pic_evolve->module~curr_and_fields_util module~start_all start_all module~start_all->module~set_init_param module~start_all->module~ionize module~start_all->module~set_grid_param module~start_all->module~read_input module~start_all->module~run_data_info module~start_all->module~pic_dump module~pic_in pic_in module~start_all->module~pic_in module~env_evolve env_evolve module~env_evolve->module~boris_push module~env_evolve->module~ionize module~env_evolve->module~window module~env_evolve->module~mpi_part_interface module~env_evolve->module~fluid_density_momenta module~env_evolve->module~curr_and_fields_util program~aladyn aladyn program~aladyn->module~run_data_info program~aladyn->module~pic_out program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_evolve program~aladyn->module~start_all program~aladyn->module~env_evolve module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~diag_part_and_fields diag_part_and_fields program~aladyn->module~diag_part_and_fields module~pic_out_util->module~psolve module~pic_out_util->module~grid_part_util module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~grid_part_connect grid_part_connect module~grid_part_connect->module~grid_part_lib module~grid_part_util->module~grid_part_lib module~prl_fft->module~parallel module~mpi_field_interface->module~parallel module~diag_part_and_fields->module~parallel module~mpi_curr_interface->module~parallel module~init_grid_field->module~grid_field_param module~mpi_part_interface->module~parallel module~fluid_density_momenta->module~grid_fields module~fluid_density_momenta->module~mpi_field_interface module~init_laser_field->module~grid_fields module~init_laser_field->module~init_grid_field module~curr_and_fields_util->module~grid_fields module~curr_and_fields_util->module~grid_part_connect module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~mpi_curr_interface module~curr_and_fields_util->module~init_grid_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ref_nlayer ref_nlas ref_nspec nx ny nz ny_targ n1ft n2ft n3ft n1ft_loc n2ft_loc n3ft_loc k0 yx_rat zx_rat ibx iby ibz ibeam lpf_ord der_ord str_flag iform model_id dmodel_id nsp nsb ionz_lev ionz_model ion_min ion_max atomic_number n_mol_atoms nb_laser nb_1 np_per_xc np_per_yc mass_number t0_pl lpx lpy n_over_nc np1 np2 r_c t0_lp xc_lp tau_fwhm w0_y a0 lam0 lp_delay lp_offset t1_lp tau1_fwhm w1_y a1 lam1 a_symm_rat xc_1 gam_1 sxb_1 syb_1 epsy_1 epsz_1 dg_1 charge_1 ap1_twiss bt1_twiss t_inject nouts iene nvout nden npout nbout jump pjump new_sim id_new dump gam_min xp0_out xp1_out yp_out w_speed wi_time wf_time tnow tmax tscale dt_loc dt cfl initial_time tkjump nkjump track_tot_nstep txmin txmax tymin tymax tzmin tzmax t_in t_out nprocx nprocy nprocz g_prof p_tracking comoving beam hybrid wake envelope solid_target ionization ions part stretch channel inject_beam lp_active lp_inject plane_wave lin_lp circ_lp relativistic Two_color enable_ionization symmetrization_pulse charge_cons high_gamma test nx_loc ny_loc nz_loc npty nptz nptx_max ncmp_max nx_alloc loc_npty loc_nptz nptx loc_nptx sptx_max nxf npt_buffer sh_targ mp_per_cell nref np_per_zc ppc loc_nyc_max loc_nzc_max loc_nxc_max ndim_max djc ratio_mpc pavg_npart wgh_ion concentration mass mass_rat charge_to_mass unit_charge lorentz_fact n0_ref pmass ompe vbeam curr_max j0_norm ratio_mpfluid chann_fact n_plasma gam0 bet0 u0_b nb_over_np b_charge oml e0 lp_pow zr lp_intensity lp_xsize p_c w0_x lp_amp xf lp_max eb_max lp_energy lp_rad xc1_lp xf1 zr1 lp1_rad lp1_amp om1 w1_x t0_b el_lp el_d lambda_p omega_p lpvol nc0 ncrit n1_over_n n2_over_n np_per_cell np_per_nmacro nmacro targ_in targ_end lx_fwhm lp_in lp_end lp_ionz_in lp_ionz_end xf_loc xc_loc y0_cent z0_cent y1_cent z1_cent incid_angle ymin_t ymax_t zmin_t zmax_t rmin_t rmax_t track_tot_part pot_ndim nb_max pe_nbmax nb_min pe_nbmin tsc_ord t_ord spl_ord nsp_run nsp_ionz ndim curr_ndim nj_dim nd2 nfield nbfield nfcomp mod_ord w_sh macro_charge energy_in_targ nptot_global Variables Type Visibility Attributes Name Initial integer, public, parameter :: ref_nlayer = 6 integer, public, parameter :: ref_nlas = 8 integer, public, parameter :: ref_nspec = 8 integer, public :: nx integer, public :: ny integer, public :: nz integer, public :: ny_targ integer, public :: n1ft integer, public :: n2ft integer, public :: n3ft integer, public :: n1ft_loc integer, public :: n2ft_loc integer, public :: n3ft_loc real(kind=dp), public :: k0 real(kind=dp), public :: yx_rat real(kind=dp), public :: zx_rat integer, public :: ibx integer, public :: iby integer, public :: ibz integer, public :: ibeam integer, public :: lpf_ord integer, public :: der_ord integer, public :: str_flag integer, public :: iform integer, public :: model_id integer, public :: dmodel_id integer, public :: nsp integer, public :: nsb integer, public :: ionz_lev integer, public :: ionz_model integer, public :: ion_min (ref_nlayer) integer, public :: ion_max (ref_nlayer) integer, public :: atomic_number (ref_nlayer) integer, public :: n_mol_atoms (ref_nlayer) integer, public :: nb_laser integer, public :: nb_1 integer, public :: np_per_xc (ref_nlayer) integer, public :: np_per_yc (ref_nlayer) real(kind=dp), public :: mass_number (3) real(kind=dp), public :: t0_pl (4) real(kind=dp), public :: lpx (7) real(kind=dp), public :: lpy (2) real(kind=dp), public :: n_over_nc real(kind=dp), public :: np1 real(kind=dp), public :: np2 real(kind=dp), public :: r_c real(kind=dp), public :: t0_lp real(kind=dp), public :: xc_lp real(kind=dp), public :: tau_fwhm real(kind=dp), public :: w0_y real(kind=dp), public :: a0 real(kind=dp), public :: lam0 real(kind=dp), public :: lp_delay (ref_nlas) real(kind=dp), public :: lp_offset real(kind=dp), public :: t1_lp real(kind=dp), public :: tau1_fwhm real(kind=dp), public :: w1_y real(kind=dp), public :: a1 real(kind=dp), public :: lam1 real(kind=dp), public :: a_symm_rat real(kind=dp), public :: xc_1 real(kind=dp), public :: gam_1 real(kind=dp), public :: sxb_1 real(kind=dp), public :: syb_1 real(kind=dp), public :: epsy_1 real(kind=dp), public :: epsz_1 real(kind=dp), public :: dg_1 real(kind=dp), public :: charge_1 real(kind=dp), public :: ap1_twiss real(kind=dp), public :: bt1_twiss real(kind=dp), public :: t_inject integer, public :: nouts integer, public :: iene integer, public :: nvout integer, public :: nden integer, public :: npout integer, public :: nbout integer, public :: jump integer, public :: pjump integer, public :: new_sim integer, public :: id_new integer, public :: dump real(kind=dp), public :: gam_min real(kind=dp), public :: xp0_out real(kind=dp), public :: xp1_out real(kind=dp), public :: yp_out real(kind=dp), public :: w_speed real(kind=dp), public :: wi_time real(kind=dp), public :: wf_time real(kind=dp), public :: tnow real(kind=dp), public :: tmax real(kind=dp), public :: tscale real(kind=dp), public :: dt_loc real(kind=dp), public :: dt real(kind=dp), public :: cfl logical, public :: initial_time integer, public :: tkjump integer, public :: nkjump integer, public :: track_tot_nstep real(kind=dp), public :: txmin real(kind=dp), public :: txmax real(kind=dp), public :: tymin real(kind=dp), public :: tymax real(kind=dp), public :: tzmin real(kind=dp), public :: tzmax real(kind=dp), public :: t_in real(kind=dp), public :: t_out integer, public :: nprocx integer, public :: nprocy integer, public :: nprocz logical, public :: g_prof logical, public :: p_tracking logical, public :: comoving logical, public :: beam logical, public :: hybrid logical, public :: wake logical, public :: envelope logical, public :: solid_target logical, public :: ionization logical, public :: ions logical, public :: part logical, public :: stretch logical, public :: channel logical, public :: inject_beam logical, public :: lp_active logical, public :: lp_inject logical, public :: plane_wave logical, public :: lin_lp logical, public :: circ_lp logical, public :: relativistic logical, public :: Two_color logical, public :: enable_ionization (2) logical, public :: symmetrization_pulse logical, public :: charge_cons logical, public :: high_gamma logical, public :: test integer, public :: nx_loc integer, public :: ny_loc integer, public :: nz_loc integer, public :: npty integer, public :: nptz integer, public :: nptx_max integer, public :: ncmp_max integer, public :: nx_alloc integer, public :: loc_npty (ref_nspec) integer, public :: loc_nptz (ref_nspec) integer, public :: nptx (ref_nspec) integer, public :: loc_nptx (ref_nspec) integer, public :: sptx_max (ref_nspec) integer, public :: nxf integer, public :: npt_buffer (ref_nspec) integer, public :: sh_targ integer, public :: mp_per_cell (ref_nlayer) integer, public :: nref integer, public :: np_per_zc (ref_nlayer) integer, public :: ppc (ref_nlayer) integer, public :: loc_nyc_max integer, public :: loc_nzc_max integer, public :: loc_nxc_max integer, public :: ndim_max real(kind=dp), public :: djc (3) real(kind=dp), public :: ratio_mpc (ref_nlayer) real(kind=dp), public :: pavg_npart (4) real(kind=dp), public :: wgh_ion real(kind=dp), public :: concentration (ref_nlayer) real(kind=dp), public :: mass (4) real(kind=dp), public :: mass_rat (4) real(kind=dp), public :: charge_to_mass (4) real(kind=dp), public :: unit_charge (4) real(kind=dp), public :: lorentz_fact (4) real(kind=dp), public :: n0_ref real(kind=dp), public :: pmass real(kind=dp), public :: ompe real(kind=dp), public :: vbeam real(kind=dp), public :: curr_max (3) real(kind=dp), public :: j0_norm real(kind=dp), public :: ratio_mpfluid real(kind=dp), public :: chann_fact real(kind=dp), public :: n_plasma real(kind=dp), public :: gam0 real(kind=dp), public :: bet0 real(kind=dp), public :: u0_b real(kind=dp), public :: nb_over_np real(kind=dp), public :: b_charge real(kind=dp), public :: oml real(kind=dp), public :: e0 real(kind=dp), public :: lp_pow real(kind=dp), public :: zr real(kind=dp), public :: lp_intensity real(kind=dp), public :: lp_xsize real(kind=dp), public :: p_c real(kind=dp), public :: w0_x real(kind=dp), public :: lp_amp real(kind=dp), public :: xf real(kind=dp), public :: lp_max real(kind=dp), public :: eb_max real(kind=dp), public :: lp_energy real(kind=dp), public :: lp_rad real(kind=dp), public :: xc1_lp real(kind=dp), public :: xf1 real(kind=dp), public :: zr1 real(kind=dp), public :: lp1_rad real(kind=dp), public :: lp1_amp real(kind=dp), public :: om1 real(kind=dp), public :: w1_x real(kind=dp), public :: t0_b real(kind=dp), public :: el_lp real(kind=dp), public :: el_d real(kind=dp), public :: lambda_p real(kind=dp), public :: omega_p real(kind=dp), public :: lpvol real(kind=dp), public :: nc0 real(kind=dp), public :: ncrit real(kind=dp), public :: n1_over_n real(kind=dp), public :: n2_over_n real(kind=dp), public :: np_per_cell real(kind=dp), public :: np_per_nmacro real(kind=dp), public :: nmacro real(kind=dp), public :: targ_in real(kind=dp), public :: targ_end real(kind=dp), public :: lx_fwhm real(kind=dp), public :: lp_in (ref_nlas) real(kind=dp), public :: lp_end (ref_nlas) real(kind=dp), public :: lp_ionz_in real(kind=dp), public :: lp_ionz_end real(kind=dp), public :: xf_loc (ref_nlas) real(kind=dp), public :: xc_loc (ref_nlas) real(kind=dp), public :: y0_cent (ref_nlas) real(kind=dp), public :: z0_cent (ref_nlas) real(kind=dp), public :: y1_cent real(kind=dp), public :: z1_cent real(kind=dp), public :: incid_angle real(kind=dp), public :: ymin_t real(kind=dp), public :: ymax_t real(kind=dp), public :: zmin_t real(kind=dp), public :: zmax_t real(kind=dp), public :: rmin_t real(kind=dp), public :: rmax_t integer, public :: track_tot_part integer, public :: pot_ndim integer, public :: nb_max integer, public :: pe_nbmax integer, public :: nb_min integer, public :: pe_nbmin integer, public :: tsc_ord integer, public :: t_ord integer, public :: spl_ord integer, public :: nsp_run integer, public :: nsp_ionz integer, public :: ndim integer, public :: curr_ndim integer, public :: nj_dim integer, public :: nd2 integer, public :: nfield integer, public :: nbfield integer, public :: nfcomp integer, public :: mod_ord integer, public :: w_sh real(kind=dp), public :: macro_charge real(kind=dp), public :: energy_in_targ integer(kind=8), public :: nptot_global","tags":"","loc":"module/common_param.html"},{"title":"precision_def – ALaDyn","text":"Used by module~~precision_def~~UsedByGraph module~precision_def precision_def module~legacy_fft_lib legacy_fft_lib module~legacy_fft_lib->module~precision_def module~ionz_data ionz_data module~ionz_data->module~precision_def module~grid_param grid_param module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data fstruct_data module~fstruct_data->module~precision_def module~control_bunch_input control_bunch_input module~control_bunch_input->module~precision_def module~code_util code_util module~code_util->module~precision_def module~common_param common_param module~common_param->module~precision_def module~pstruct_data pstruct_data module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_var mpi_var module~mpi_var->module~precision_def module~phys_param phys_param module~phys_param->module~precision_def module~util util module~util->module~precision_def module~util->module~code_util module~struct_def->module~precision_def module~modern_fft_lib modern_fft_lib module~modern_fft_lib->module~precision_def module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~grid_param module~init_beam_part_distrib->module~control_bunch_input module~init_beam_part_distrib->module~code_util module~init_beam_part_distrib->module~phys_param module~init_beam_part_distrib->module~util module~array_alloc array_alloc module~init_beam_part_distrib->module~array_alloc module~psolve psolve module~init_beam_part_distrib->module~psolve module~grid_part_util grid_part_util module~init_beam_part_distrib->module~grid_part_util module~mpi_field_interface mpi_field_interface module~init_beam_part_distrib->module~mpi_field_interface module~init_grid_field init_grid_field module~init_beam_part_distrib->module~init_grid_field module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib->module~mpi_curr_interface module~set_init_param set_init_param module~set_init_param->module~ionz_data module~set_init_param->module~grid_param module~set_init_param->module~control_bunch_input module~set_init_param->module~code_util module~set_init_param->module~common_param module~set_init_param->module~phys_param module~set_grid_param set_grid_param module~set_init_param->module~set_grid_param module~array_alloc->module~fstruct_data module~array_alloc->module~pstruct_data module~env_evolve env_evolve module~env_evolve->module~util module~window window module~env_evolve->module~window module~mpi_part_interface mpi_part_interface module~env_evolve->module~mpi_part_interface module~ionize ionize module~env_evolve->module~ionize module~curr_and_fields_util curr_and_fields_util module~env_evolve->module~curr_and_fields_util module~boris_push boris_push module~env_evolve->module~boris_push module~fluid_density_momenta fluid_density_momenta module~env_evolve->module~fluid_density_momenta module~init_part_distrib init_part_distrib module~init_part_distrib->module~grid_param module~init_part_distrib->module~code_util module~init_part_distrib->module~common_param module~init_part_distrib->module~mpi_var module~init_part_distrib->module~phys_param module~init_part_distrib->module~util module~init_part_distrib->module~array_alloc module~set_grid_param->module~grid_param module~set_grid_param->module~common_param module~set_grid_param->module~mpi_var module~system_utilities system_utilities module~system_utilities->module~mpi_var module~window->module~grid_param module~window->module~fstruct_data module~window->module~common_param module~window->module~pstruct_data module~window->module~util module~run_data_info run_data_info module~window->module~run_data_info module~window->module~mpi_part_interface module~window->module~mpi_field_interface module~init_laser_field init_laser_field module~init_laser_field->module~fstruct_data module~init_laser_field->module~pstruct_data module~init_laser_field->module~init_grid_field module~grid_fields grid_fields module~init_laser_field->module~grid_fields module~pic_dump pic_dump module~pic_dump->module~grid_param module~pic_dump->module~code_util module~pic_dump->module~common_param module~pic_dump->module~array_alloc module~parallel parallel module~pic_dump->module~parallel module~psolve->module~grid_param module~psolve->module~fstruct_data module~psolve->module~common_param module~psolve->module~pstruct_data module~prl_fft prl_fft module~psolve->module~prl_fft module~psolve->module~grid_fields module~pic_out_util pic_out_util module~pic_out_util->module~phys_param module~pic_out_util->module~psolve module~pic_out_util->module~grid_part_util module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~grid_part_util->module~fstruct_data module~grid_part_util->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_util->module~grid_part_lib module~run_data_info->module~ionz_data module~run_data_info->module~grid_param module~run_data_info->module~fstruct_data module~run_data_info->module~control_bunch_input module~run_data_info->module~code_util module~run_data_info->module~common_param module~run_data_info->module~pstruct_data module~run_data_info->module~phys_param module~run_data_info->module~parallel module~prl_fft->module~modern_fft_lib module~prl_fft->module~parallel module~grid_part_lib->module~grid_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~mpi_part_interface->module~grid_param module~mpi_part_interface->module~code_util module~mpi_part_interface->module~array_alloc module~mpi_part_interface->module~parallel module~ionize->module~ionz_data module~ionize->module~common_param module~ionize->module~mpi_var module~ionize->module~util module~ionize->module~array_alloc module~grid_part_connect grid_part_connect module~grid_part_connect->module~fstruct_data module~grid_part_connect->module~pstruct_data module~grid_part_connect->module~grid_part_lib module~read_input read_input module~read_input->module~control_bunch_input module~read_input->module~code_util module~read_input->module~common_param module~read_input->module~mpi_var module~mpi_field_interface->module~grid_param module~mpi_field_interface->module~fstruct_data module~mpi_field_interface->module~pstruct_data module~mpi_field_interface->module~parallel module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~grid_param module~diag_part_and_fields->module~fstruct_data module~diag_part_and_fields->module~control_bunch_input module~diag_part_and_fields->module~code_util module~diag_part_and_fields->module~pstruct_data module~diag_part_and_fields->module~phys_param module~diag_part_and_fields->module~parallel module~pic_out pic_out module~pic_out->module~grid_param module~pic_out->module~fstruct_data module~pic_out->module~code_util module~pic_out->module~common_param module~pic_out->module~pstruct_data module~pic_out->module~parallel module~init_grid_field->module~fstruct_data module~init_grid_field->module~pstruct_data module~init_grid_field->module~phys_param module~grid_field_param grid_field_param module~init_grid_field->module~grid_field_param module~curr_and_fields_util->module~grid_param module~curr_and_fields_util->module~fstruct_data module~curr_and_fields_util->module~pstruct_data module~curr_and_fields_util->module~grid_part_connect module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~init_grid_field module~curr_and_fields_util->module~mpi_curr_interface module~curr_and_fields_util->module~grid_fields module~boris_push->module~fstruct_data module~boris_push->module~common_param module~boris_push->module~pstruct_data module~parallel->module~common_param module~parallel->module~mpi_var module~parallel->module~util module~grid_field_param->module~grid_param module~grid_field_param->module~common_param module~grid_field_param->module~mpi_var module~mpi_curr_interface->module~grid_param module~mpi_curr_interface->module~fstruct_data module~mpi_curr_interface->module~pstruct_data module~mpi_curr_interface->module~parallel module~stretched_grid->module~grid_param module~stretched_grid->module~common_param module~stretched_grid->module~mpi_var program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~env_evolve program~aladyn->module~pic_out_util program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields program~aladyn->module~pic_out module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all module~pic_evolve->module~window module~pic_evolve->module~mpi_part_interface module~pic_evolve->module~ionize module~pic_evolve->module~init_grid_field module~pic_evolve->module~curr_and_fields_util module~pic_evolve->module~boris_push module~pic_evolve->module~fluid_density_momenta module~start_all->module~set_init_param module~start_all->module~array_alloc module~start_all->module~set_grid_param module~start_all->module~system_utilities module~start_all->module~pic_dump module~start_all->module~run_data_info module~start_all->module~ionize module~start_all->module~read_input module~pic_in pic_in module~start_all->module~pic_in module~grid_fields->module~parallel module~grid_fields->module~grid_field_param module~fluid_density_momenta->module~mpi_field_interface module~fluid_density_momenta->module~grid_fields module~pic_in->module~init_part_distrib module~pic_in->module~init_laser_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables sp dp dp_int hp_int qp res_string wgh_cmp wgh charge part_ind zero_dp zero_sp one_dp one_sp zero one one_int_hp Functions is_zero Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = selected_real_kind(6, 37) integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: dp_int = selected_int_kind(16) integer, public, parameter :: hp_int = selected_int_kind(4) integer, public, parameter :: qp = selected_real_kind(33, 4931) logical(kind=1), public, dimension(8) :: res_string real(kind=dp), public :: wgh_cmp real(kind=sp), public :: wgh integer(kind=hp_int), public :: charge integer(kind=hp_int), public :: part_ind real(kind=dp), public, parameter :: zero_dp = 0.0 real(kind=sp), public, parameter :: zero_sp = real(0.0, sp) real(kind=dp), public, parameter :: one_dp = 1.0 real(kind=sp), public, parameter :: one_sp = real(1.0, sp) integer, public, parameter :: zero = 0 integer, public, parameter :: one = 1 integer(kind=hp_int), public, parameter :: one_int_hp = int(1, hp_int) Functions public function is_zero (value) result(check) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: value Return Value logical","tags":"","loc":"module/precision_def.html"},{"title":"phys_param – ALaDyn","text":"Uses precision_def module~~phys_param~~UsesGraph module~phys_param phys_param module~precision_def precision_def module~phys_param->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~phys_param~~UsedByGraph module~phys_param phys_param module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~phys_param module~init_grid_field init_grid_field module~init_beam_part_distrib->module~init_grid_field module~set_init_param set_init_param module~set_init_param->module~phys_param module~init_part_distrib init_part_distrib module~init_part_distrib->module~phys_param module~pic_out_util pic_out_util module~pic_out_util->module~phys_param module~run_data_info run_data_info module~run_data_info->module~phys_param module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~phys_param module~init_grid_field->module~phys_param module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~init_grid_field program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_evolve->module~init_grid_field module~pic_evolve->module~curr_and_fields_util module~window window module~pic_evolve->module~window module~start_all->module~set_init_param module~start_all->module~run_data_info module~pic_in pic_in module~start_all->module~pic_in module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~window->module~run_data_info module~init_laser_field->module~init_grid_field module~env_evolve->module~curr_and_fields_util module~env_evolve->module~window Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables epsilon pi pi2 giant_field electron_charge_norm electron_mass_norm proton_charge_norm proton_mass_norm size_of_stretch_along_x size_of_stretch_along_y e_charge electron_mass rc0 speed_of_light energy_unit t_unit mg_unit fe_unit reference_density Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: epsilon = 1.0e-8 Small parameter real(kind=dp), public, parameter :: pi = 3.141592653589793 real(kind=dp), public, parameter :: pi2 = 6.283185307179586 real(kind=dp), public, parameter :: giant_field = 1.0e4 Large control parameter for fields real(kind=dp), public, parameter :: electron_charge_norm = -1.0 Normalized electron charge real(kind=dp), public, parameter :: electron_mass_norm = 1.0 Normalized electron mass real(kind=dp), public, parameter :: proton_charge_norm = 1.0 Normalized proton charge real(kind=dp), public, parameter :: proton_mass_norm = 1836.1527706 Normalized proton mass real(kind=dp), public, parameter :: size_of_stretch_along_x = 1./4. Stretch parameter along the x direction\n (1/4 of the cells are stretched) real(kind=dp), public, parameter :: size_of_stretch_along_y = 1./6. Stretch parameter along the y and z direction\n (1/6 of the cells are stretched per side) real(kind=dp), public, parameter :: e_charge = 1.6021766*1.e-7 Electron charge in pC real(kind=dp), public, parameter :: electron_mass = 0.510998928 Electron charge in MeV real(kind=dp), public, parameter :: rc0 = 2.81794033 classical electron radius in units 10&#94;{-13} cm real(kind=dp), public, parameter :: speed_of_light = 0.299792458 Speed of light in units \\mu m/fs real(kind=dp), public, parameter :: energy_unit = electron_mass*1.e+06 real(kind=dp), public, parameter :: t_unit = 0.299792458/0.510998928 real(kind=dp), public, parameter :: mg_unit = 0.299792458/5.10998928 real(kind=dp), public, parameter :: fe_unit = 0.514 real(kind=dp), public, parameter :: reference_density = 1.e6","tags":"","loc":"module/phys_param.html"},{"title":"util – ALaDyn","text":"Uses precision_def code_util module~~util~~UsesGraph module~util util module~code_util code_util module~util->module~code_util module~precision_def precision_def module~util->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~util~~UsedByGraph module~util util module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~util module~mpi_field_interface mpi_field_interface module~init_beam_part_distrib->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib->module~mpi_curr_interface module~psolve psolve module~init_beam_part_distrib->module~psolve module~ionize ionize module~ionize->module~util module~env_evolve env_evolve module~env_evolve->module~util module~env_evolve->module~ionize module~window window module~env_evolve->module~window module~mpi_part_interface mpi_part_interface module~env_evolve->module~mpi_part_interface module~curr_and_fields_util curr_and_fields_util module~env_evolve->module~curr_and_fields_util module~fluid_density_momenta fluid_density_momenta module~env_evolve->module~fluid_density_momenta module~parallel parallel module~parallel->module~util module~init_part_distrib init_part_distrib module~init_part_distrib->module~util module~window->module~util module~run_data_info run_data_info module~window->module~run_data_info module~window->module~mpi_field_interface module~window->module~mpi_part_interface program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~env_evolve module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all program~aladyn->module~run_data_info module~diag_part_and_fields diag_part_and_fields program~aladyn->module~diag_part_and_fields module~pic_out pic_out program~aladyn->module~pic_out module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~pic_evolve->module~ionize module~pic_evolve->module~window module~pic_evolve->module~mpi_part_interface module~pic_evolve->module~curr_and_fields_util module~pic_evolve->module~fluid_density_momenta module~start_all->module~ionize module~pic_in pic_in module~start_all->module~pic_in module~start_all->module~run_data_info module~pic_dump pic_dump module~start_all->module~pic_dump module~grid_fields grid_fields module~grid_fields->module~parallel module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~run_data_info->module~parallel module~prl_fft prl_fft module~prl_fft->module~parallel module~mpi_field_interface->module~parallel module~diag_part_and_fields->module~parallel module~pic_out->module~parallel module~mpi_curr_interface->module~parallel module~pic_dump->module~parallel module~mpi_part_interface->module~parallel module~psolve->module~grid_fields module~psolve->module~prl_fft module~curr_and_fields_util->module~grid_fields module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~mpi_curr_interface module~fluid_density_momenta->module~grid_fields module~fluid_density_momenta->module~mpi_field_interface module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~pic_out_util->module~psolve module~init_laser_field->module~grid_fields Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines init_random_seed gasdev sort vsort bunch_gen Subroutines public subroutine init_random_seed (myrank) Arguments Type Intent Optional Attributes Name integer, intent(in) :: myrank public subroutine gasdev (dev) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: dev private subroutine sort (part, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: part (:) integer, intent(in) :: np private subroutine vsort (part, np, ndv, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: part (:,:) integer, intent(in) :: np integer, intent(in) :: ndv integer, intent(in) :: dir public subroutine bunch_gen (ndm, n1, n2, sx, sy, sz, gm, ey, ez, cut, dg, bunch) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndm integer, intent(in) :: n1 integer, intent(in) :: n2 real(kind=dp), intent(in) :: sx real(kind=dp), intent(in) :: sy real(kind=dp), intent(in) :: sz real(kind=dp), intent(in) :: gm real(kind=dp), intent(in) :: ey real(kind=dp), intent(in) :: ez real(kind=dp), intent(in) :: cut real(kind=dp), intent(in) :: dg real(kind=dp), intent(inout) :: bunch (:,:)","tags":"","loc":"module/util.html"},{"title":"code_util – ALaDyn","text":"Uses precision_def module~~code_util~~UsesGraph module~code_util code_util module~precision_def precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~code_util~~UsedByGraph module~code_util code_util module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~code_util module~util util module~init_beam_part_distrib->module~util module~mpi_field_interface mpi_field_interface module~init_beam_part_distrib->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib->module~mpi_curr_interface module~psolve psolve module~init_beam_part_distrib->module~psolve module~set_init_param set_init_param module~set_init_param->module~code_util module~init_part_distrib init_part_distrib module~init_part_distrib->module~code_util module~init_part_distrib->module~util module~read_input read_input module~read_input->module~code_util module~run_data_info run_data_info module~run_data_info->module~code_util module~parallel parallel module~run_data_info->module~parallel module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~code_util module~diag_part_and_fields->module~parallel module~pic_out pic_out module~pic_out->module~code_util module~pic_out->module~parallel module~util->module~code_util module~pic_dump pic_dump module~pic_dump->module~code_util module~pic_dump->module~parallel module~mpi_part_interface mpi_part_interface module~mpi_part_interface->module~code_util module~mpi_part_interface->module~parallel program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields program~aladyn->module~pic_out module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~pic_evolve->module~mpi_part_interface module~ionize ionize module~pic_evolve->module~ionize module~window window module~pic_evolve->module~window module~curr_and_fields_util curr_and_fields_util module~pic_evolve->module~curr_and_fields_util module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~ionize->module~util module~start_all->module~set_init_param module~start_all->module~read_input module~start_all->module~run_data_info module~start_all->module~pic_dump module~start_all->module~ionize module~pic_in pic_in module~start_all->module~pic_in module~env_evolve->module~util module~env_evolve->module~mpi_part_interface module~env_evolve->module~ionize module~env_evolve->module~window module~env_evolve->module~curr_and_fields_util module~env_evolve->module~fluid_density_momenta module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~parallel->module~util module~window->module~run_data_info module~window->module~util module~window->module~mpi_part_interface module~window->module~mpi_field_interface module~prl_fft prl_fft module~prl_fft->module~parallel module~mpi_field_interface->module~parallel module~grid_fields grid_fields module~grid_fields->module~parallel module~mpi_curr_interface->module~parallel module~psolve->module~prl_fft module~psolve->module~grid_fields module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~grid_fields module~curr_and_fields_util->module~mpi_curr_interface module~fluid_density_momenta->module~mpi_field_interface module~fluid_density_momenta->module~grid_fields module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~pic_out_util->module~psolve module~init_laser_field->module~grid_fields Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables major_version minor_version sw_name input_namelist_filename input_data_filename maxv sumv minv left right field curr sh_ix time2dump mem_size mem_psize last_iter iter_max write_every t_ind inject_ind tk_ind ienout iout iter ier mem_psize_max dump_t0 dump_t1 unix_time_begin unix_time_now time_interval_dumps unix_time_last_dump gamma_cut_min weights_cut_min weights_cut_max tdia dtdia tout dtout tstart mem_max_addr diag tpart l_intdiagnostics_pwfa l_intdiagnostics_classic l_force_singlefile_output l_print_j_on_grid l_first_output_on_restart l_use_unique_dumps l_disable_rng_seed l_intdiagnostics_background l_env_modulus Variables Type Visibility Attributes Name Initial integer, public, parameter :: major_version = 8 integer, public, parameter :: minor_version = 2 character(len=6), public :: sw_name = 'ALaDyn' character(len=9), public :: input_namelist_filename = 'input.nml' character(len=10), public :: input_data_filename = 'input.data' integer, public, parameter :: maxv = 1 integer, public, parameter :: sumv = 0 integer, public, parameter :: minv = -1 integer, public, parameter :: left = -1 integer, public, parameter :: right = 1 integer, public, parameter :: field = 0 integer, public, parameter :: curr = 1 integer, public, parameter :: sh_ix = 3 integer, public :: time2dump (1) = 0 integer, public :: mem_size integer, public :: mem_psize integer, public :: last_iter integer, public :: iter_max integer, public :: write_every integer, public :: t_ind integer, public :: inject_ind integer, public :: tk_ind integer, public :: ienout integer, public :: iout integer, public :: iter integer, public :: ier real(kind=dp), public :: mem_psize_max real(kind=dp), public :: dump_t0 real(kind=dp), public :: dump_t1 real(kind=dp), public :: unix_time_begin real(kind=dp), public :: unix_time_now real(kind=dp), public :: time_interval_dumps real(kind=dp), public :: unix_time_last_dump real(kind=dp), public :: gamma_cut_min real(kind=dp), public :: weights_cut_min real(kind=dp), public :: weights_cut_max real(kind=dp), public :: tdia real(kind=dp), public :: dtdia real(kind=dp), public :: tout real(kind=dp), public :: dtout real(kind=dp), public :: tstart real(kind=dp), public :: mem_max_addr logical, public :: diag logical, public :: tpart logical, public :: l_intdiagnostics_pwfa logical, public :: l_intdiagnostics_classic logical, public :: l_force_singlefile_output logical, public :: l_print_j_on_grid logical, public :: l_first_output_on_restart logical, public :: l_use_unique_dumps logical, public :: l_disable_rng_seed logical, public :: l_intdiagnostics_background logical, public :: l_env_modulus","tags":"","loc":"module/code_util.html"},{"title":"array_alloc – ALaDyn","text":"Uses pstruct_data fstruct_data module~~array_alloc~~UsesGraph module~array_alloc array_alloc module~pstruct_data pstruct_data module~array_alloc->module~pstruct_data module~fstruct_data fstruct_data module~array_alloc->module~fstruct_data module~struct_def struct_def module~pstruct_data->module~struct_def module~precision_def precision_def module~pstruct_data->module~precision_def module~fstruct_data->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~array_alloc~~UsedByGraph module~array_alloc array_alloc module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~array_alloc module~ionize ionize module~ionize->module~array_alloc module~start_all start_all module~start_all->module~array_alloc module~start_all->module~ionize module~pic_dump pic_dump module~start_all->module~pic_dump module~pic_in pic_in module~start_all->module~pic_in module~init_part_distrib init_part_distrib module~init_part_distrib->module~array_alloc module~pic_dump->module~array_alloc module~mpi_part_interface mpi_part_interface module~mpi_part_interface->module~array_alloc program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~start_all module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_evolve->module~ionize module~pic_evolve->module~mpi_part_interface module~window window module~pic_evolve->module~window module~env_evolve->module~ionize module~env_evolve->module~mpi_part_interface module~env_evolve->module~window module~pic_in->module~init_part_distrib module~window->module~mpi_part_interface Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines mpi_buffer_alloc v_alloc bv_alloc fluid_alloc bext_alloc p_alloc p_realloc v_realloc Subroutines public subroutine mpi_buffer_alloc (n1_loc, n2_loc, n3_loc, nvd) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc integer, intent(in) :: nvd public subroutine v_alloc (n1, n2, n3, ncomp, njc, ndm, ifluid, lp, oder, envlp, color, comv, fsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ncomp integer, intent(in) :: njc integer, intent(in) :: ndm integer, intent(in) :: ifluid integer, intent(in) :: lp integer, intent(in) :: oder logical, intent(in) :: envlp logical, intent(in) :: color logical, intent(in) :: comv integer, intent(inout) :: fsize public subroutine bv_alloc (n1, n2, n3, bcomp, ndm, ibch, fsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: bcomp integer, intent(in) :: ndm integer, intent(in) :: ibch integer, intent(inout) :: fsize public subroutine fluid_alloc (n1, n2, n3, fcomp, ndm, lp, fsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: fcomp integer, intent(in) :: ndm integer, intent(in) :: lp integer, intent(inout) :: fsize public subroutine bext_alloc (n1, n2, n3, bcomp, fsize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: bcomp integer, intent(inout) :: fsize public subroutine p_alloc (npt_max, ncmp, np_s, ns, lp, mid, r_type, msize) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npt_max integer, intent(in) :: ncmp integer, intent(in) :: np_s (:) integer, intent(in) :: ns integer, intent(in) :: lp integer, intent(in) :: mid integer, intent(in) :: r_type integer, intent(inout) :: msize public subroutine p_realloc (pdata, npt_new, ndv) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: pdata integer, intent(in) :: npt_new integer, intent(in) :: ndv public subroutine v_realloc (vdata, npt_new, ndv) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), allocatable :: vdata (:,:) integer, intent(in) :: npt_new integer, intent(in) :: ndv","tags":"","loc":"module/array_alloc.html"},{"title":"struct_def – ALaDyn","text":"Uses precision_def module~~struct_def~~UsesGraph module~struct_def struct_def module~precision_def precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~struct_def~~UsedByGraph module~struct_def struct_def module~pstruct_data pstruct_data module~pstruct_data->module~struct_def module~grid_param grid_param module~grid_param->module~struct_def module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~grid_param module~array_alloc array_alloc module~init_beam_part_distrib->module~array_alloc module~psolve psolve module~init_beam_part_distrib->module~psolve module~grid_part_util grid_part_util module~init_beam_part_distrib->module~grid_part_util module~mpi_field_interface mpi_field_interface module~init_beam_part_distrib->module~mpi_field_interface module~init_grid_field init_grid_field module~init_beam_part_distrib->module~init_grid_field module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib->module~mpi_curr_interface module~set_init_param set_init_param module~set_init_param->module~grid_param module~set_grid_param set_grid_param module~set_init_param->module~set_grid_param module~array_alloc->module~pstruct_data module~init_part_distrib init_part_distrib module~init_part_distrib->module~grid_param module~init_part_distrib->module~array_alloc module~set_grid_param->module~grid_param module~window window module~window->module~pstruct_data module~window->module~grid_param module~run_data_info run_data_info module~window->module~run_data_info module~mpi_part_interface mpi_part_interface module~window->module~mpi_part_interface module~window->module~mpi_field_interface module~init_laser_field init_laser_field module~init_laser_field->module~pstruct_data module~init_laser_field->module~init_grid_field module~grid_fields grid_fields module~init_laser_field->module~grid_fields module~pic_dump pic_dump module~pic_dump->module~grid_param module~pic_dump->module~array_alloc module~psolve->module~pstruct_data module~psolve->module~grid_param module~psolve->module~grid_fields module~grid_part_util->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_util->module~grid_part_lib module~run_data_info->module~pstruct_data module~run_data_info->module~grid_param module~grid_part_lib->module~grid_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~mpi_part_interface->module~grid_param module~mpi_part_interface->module~array_alloc module~grid_part_connect grid_part_connect module~grid_part_connect->module~pstruct_data module~grid_part_connect->module~grid_part_lib module~mpi_field_interface->module~pstruct_data module~mpi_field_interface->module~grid_param module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~pstruct_data module~diag_part_and_fields->module~grid_param module~pic_out pic_out module~pic_out->module~pstruct_data module~pic_out->module~grid_param module~init_grid_field->module~pstruct_data module~grid_field_param grid_field_param module~init_grid_field->module~grid_field_param module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~pstruct_data module~curr_and_fields_util->module~grid_param module~curr_and_fields_util->module~grid_part_connect module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~init_grid_field module~curr_and_fields_util->module~mpi_curr_interface module~curr_and_fields_util->module~grid_fields module~boris_push boris_push module~boris_push->module~pstruct_data module~mpi_curr_interface->module~pstruct_data module~mpi_curr_interface->module~grid_param module~grid_field_param->module~grid_param module~stretched_grid->module~grid_param program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields program~aladyn->module~pic_out module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~pic_evolve->module~window module~pic_evolve->module~mpi_part_interface module~pic_evolve->module~init_grid_field module~pic_evolve->module~curr_and_fields_util module~pic_evolve->module~boris_push module~ionize ionize module~pic_evolve->module~ionize module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~ionize->module~array_alloc module~start_all->module~set_init_param module~start_all->module~array_alloc module~start_all->module~set_grid_param module~start_all->module~pic_dump module~start_all->module~run_data_info module~start_all->module~ionize module~pic_in pic_in module~start_all->module~pic_in module~env_evolve->module~window module~env_evolve->module~mpi_part_interface module~env_evolve->module~curr_and_fields_util module~env_evolve->module~boris_push module~env_evolve->module~ionize module~env_evolve->module~fluid_density_momenta module~pic_in->module~init_part_distrib module~pic_in->module~init_laser_field module~pic_out_util->module~psolve module~pic_out_util->module~grid_part_util module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~fluid_density_momenta->module~mpi_field_interface module~fluid_density_momenta->module~grid_fields module~grid_fields->module~grid_field_param Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces index_array Derived Types species grid sgrid index_array Functions new_index_array Subroutines find_index Interfaces public interface index_array public function new_index_array (length) result(this) Constructor for the index_array type Arguments Type Intent Optional Attributes Name integer, intent(in) :: length Return Value type( index_array ) Derived Types type, public :: species Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: part (:,:) type, public :: grid Components Type Visibility Attributes Name Initial integer, public :: ng Number of cells in a given direction of the grid integer, public :: p_ind (2) Minimum and maximum cell number of the grid real(kind=dp), public :: gmin Value of the corresponding axis at the minimum cell real(kind=dp), public :: gmax Value of the corresponding axis at the maximum cell integer, public :: min_cell Initial cell of the grid in absolute units (i.e. respect to the total grid) integer, public :: max_cell Final cell of the grid in absolute units (i.e. respect to the total grid) type, public :: sgrid Components Type Visibility Attributes Name Initial integer, public :: sind (2) Initial and final stretched cell (sind(1) also coincides with the number of\nstretched cells) real(kind=dp), public :: smin Axis value on the boundary between stretched and unstretched grid (left side of the box) real(kind=dp), public :: smax Axis value on the boundary between stretched and unstretched grid (right side of the box) type, public :: index_array Type defining an array of consecutive integer numbers, useful as\n indices in arrays. Components Type Visibility Attributes Name Initial integer, public, allocatable :: indices (:) Constructor public  function new_index_array (length) Constructor for the index_array type Type-Bound Procedures procedure, public :: find_index Functions public function new_index_array (length) result(this) Constructor for the index_array type Arguments Type Intent Optional Attributes Name integer, intent(in) :: length Return Value type( index_array ) Subroutines public subroutine find_index (index_in, mask) Type bound procedure that finds and pack all the array indices\n according to the given mask Arguments Type Intent Optional Attributes Name class( index_array ), intent(inout) :: index_in logical, intent(in) :: mask (:)","tags":"","loc":"module/struct_def.html"},{"title":"fstruct_data – ALaDyn","text":"Uses precision_def module~~fstruct_data~~UsesGraph module~fstruct_data fstruct_data module~precision_def precision_def module~fstruct_data->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~fstruct_data~~UsedByGraph module~fstruct_data fstruct_data module~psolve psolve module~psolve->module~fstruct_data module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~fstruct_data module~grid_part_connect grid_part_connect module~curr_and_fields_util->module~grid_part_connect module~mpi_field_interface mpi_field_interface module~curr_and_fields_util->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~curr_and_fields_util->module~mpi_curr_interface module~init_grid_field init_grid_field module~curr_and_fields_util->module~init_grid_field module~boris_push boris_push module~boris_push->module~fstruct_data module~array_alloc array_alloc module~array_alloc->module~fstruct_data module~grid_part_connect->module~fstruct_data module~grid_part_util grid_part_util module~grid_part_util->module~fstruct_data module~run_data_info run_data_info module~run_data_info->module~fstruct_data module~mpi_field_interface->module~fstruct_data module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~fstruct_data module~pic_out pic_out module~pic_out->module~fstruct_data module~window window module~window->module~fstruct_data module~window->module~run_data_info module~window->module~mpi_field_interface module~mpi_part_interface mpi_part_interface module~window->module~mpi_part_interface module~mpi_curr_interface->module~fstruct_data module~init_grid_field->module~fstruct_data module~init_laser_field init_laser_field module~init_laser_field->module~fstruct_data module~init_laser_field->module~init_grid_field module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~psolve module~init_beam_part_distrib->module~array_alloc module~init_beam_part_distrib->module~grid_part_util module~init_beam_part_distrib->module~mpi_field_interface module~init_beam_part_distrib->module~mpi_curr_interface module~init_beam_part_distrib->module~init_grid_field program~aladyn aladyn program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields program~aladyn->module~pic_out program~aladyn->module~init_beam_part_distrib module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~start_all start_all program~aladyn->module~start_all module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~pic_evolve->module~curr_and_fields_util module~pic_evolve->module~boris_push module~pic_evolve->module~window module~pic_evolve->module~init_grid_field module~ionize ionize module~pic_evolve->module~ionize module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~pic_evolve->module~mpi_part_interface module~ionize->module~array_alloc module~env_evolve->module~curr_and_fields_util module~env_evolve->module~boris_push module~env_evolve->module~window module~env_evolve->module~ionize module~env_evolve->module~fluid_density_momenta module~env_evolve->module~mpi_part_interface module~start_all->module~array_alloc module~start_all->module~run_data_info module~start_all->module~ionize module~pic_in pic_in module~start_all->module~pic_in module~pic_dump pic_dump module~start_all->module~pic_dump module~pic_out_util->module~psolve module~pic_out_util->module~grid_part_util module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~init_part_distrib init_part_distrib module~init_part_distrib->module~array_alloc module~fluid_density_momenta->module~mpi_field_interface module~pic_in->module~init_laser_field module~pic_in->module~init_part_distrib module~pic_dump->module~array_alloc module~mpi_part_interface->module~array_alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ebf ebf_bunch jc ebf0 ebf1 ebf0_bunch ebf1_bunch jb env env0 env1 up up0 up1 flux pot fluid_x_profile fluid_yz_profile aux1 aux2 Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: ebf (:,:,:,:) real(kind=dp), public, allocatable :: ebf_bunch (:,:,:,:) real(kind=dp), public, allocatable :: jc (:,:,:,:) real(kind=dp), public, allocatable :: ebf0 (:,:,:,:) real(kind=dp), public, allocatable :: ebf1 (:,:,:,:) real(kind=dp), public, allocatable :: ebf0_bunch (:,:,:,:) real(kind=dp), public, allocatable :: ebf1_bunch (:,:,:,:) real(kind=dp), public, allocatable :: jb (:,:,:,:) real(kind=dp), public, allocatable :: env (:,:,:,:) real(kind=dp), public, allocatable :: env0 (:,:,:,:) real(kind=dp), public, allocatable :: env1 (:,:,:,:) real(kind=dp), public, allocatable :: up (:,:,:,:) real(kind=dp), public, allocatable :: up0 (:,:,:,:) real(kind=dp), public, allocatable :: up1 (:,:,:,:) real(kind=dp), public, allocatable :: flux (:,:,:,:) real(kind=dp), public, allocatable :: pot (:,:,:,:) real(kind=dp), public, allocatable :: fluid_x_profile (:) real(kind=dp), public, allocatable :: fluid_yz_profile (:,:) real(kind=dp), public, allocatable :: aux1 (:) real(kind=dp), public, allocatable :: aux2 (:)","tags":"","loc":"module/fstruct_data.html"},{"title":"set_grid_param – ALaDyn","text":"Uses common_param grid_param mpi_var module~~set_grid_param~~UsesGraph module~set_grid_param set_grid_param module~common_param common_param module~set_grid_param->module~common_param module~mpi_var mpi_var module~set_grid_param->module~mpi_var module~grid_param grid_param module~set_grid_param->module~grid_param module~precision_def precision_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~grid_param->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~set_grid_param~~UsedByGraph module~set_grid_param set_grid_param module~set_init_param set_init_param module~set_init_param->module~set_grid_param module~start_all start_all module~start_all->module~set_grid_param module~start_all->module~set_init_param program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines set_grid mpi_loc_grid set_output_grid set_ftyzgrid set_fyzxgrid set_fxgrid set_str_ind select_str_to_ft_grid set_loc_grid_param set_ftgrid Subroutines public subroutine set_grid (n1, n2, n3, ib, x_stretch, y_stretch, xres, yxres, zxres) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ib integer, intent(in) :: x_stretch integer, intent(in) :: y_stretch real(kind=dp), intent(in) :: xres real(kind=dp), intent(in) :: yxres real(kind=dp), intent(in) :: zxres public subroutine mpi_loc_grid (n1_loc, n2_loc, n3_loc, npex, npey, npez) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc integer, intent(in) :: npex integer, intent(in) :: npey integer, intent(in) :: npez public subroutine set_output_grid (jmp, npex, npey, npez) Arguments Type Intent Optional Attributes Name integer, intent(in) :: jmp integer, intent(in) :: npex integer, intent(in) :: npey integer, intent(in) :: npez public subroutine set_ftyzgrid (npey, npez, sh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npey integer, intent(in) :: npez integer, intent(in) :: sh public subroutine set_fyzxgrid (npey, npez, npex, sh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npey integer, intent(in) :: npez integer, intent(in) :: npex integer, intent(in) :: sh public subroutine set_fxgrid (npex, sh) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npex integer, intent(in) :: sh public subroutine set_str_ind (npey, npez, ndm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npey integer, intent(in) :: npez integer, intent(in) :: ndm public subroutine select_str_to_ft_grid (npey, npez) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npey integer, intent(in) :: npez public subroutine set_loc_grid_param () Arguments None public subroutine set_ftgrid (str, npe1, npe2, npe3) Arguments Type Intent Optional Attributes Name logical, intent(in) :: str integer, intent(in) :: npe1 integer, intent(in) :: npe2 integer, intent(in) :: npe3","tags":"","loc":"module/set_grid_param.html"},{"title":"stretched_grid – ALaDyn","text":"Uses common_param grid_param mpi_var module~~stretched_grid~~UsesGraph module~stretched_grid stretched_grid module~common_param common_param module~stretched_grid->module~common_param module~mpi_var mpi_var module~stretched_grid->module~mpi_var module~grid_param grid_param module~stretched_grid->module~grid_param module~precision_def precision_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~grid_param->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stretched_grid~~UsedByGraph module~stretched_grid stretched_grid module~grid_part_lib grid_part_lib module~grid_part_lib->module~stretched_grid module~grid_part_connect grid_part_connect module~grid_part_connect->module~grid_part_lib module~grid_part_util grid_part_util module~grid_part_util->module~grid_part_lib module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~grid_part_util module~pic_out_util pic_out_util module~pic_out_util->module~grid_part_util module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~grid_part_connect program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_evolve->module~curr_and_fields_util module~env_evolve->module~curr_and_fields_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables y_params z_params SYMM_CENTER Derived Types str_params Functions invert_stretched_grid invert_uniform_grid Subroutines map2dy_part_sind map2dz_part_sind map3d_part_sind Variables Type Visibility Attributes Name Initial type( str_params ), private :: y_params type( str_params ), private :: z_params real(kind=dp), private, parameter :: SYMM_CENTER = zero_dp Derived Types type, private :: str_params Components Type Visibility Attributes Name Initial real(kind=dp), public :: const real(kind=dp), public :: smin real(kind=dp), public :: smax real(kind=dp), public :: nl_stretch real(kind=dp), public :: xs real(kind=dp), public :: dli_inv real(kind=dp), public :: ratio real(kind=dp), public :: dl_inv real(kind=dp), public :: init_cell Functions private pure function invert_stretched_grid (yp_in, params) result(stretched) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: yp_in type( str_params ), intent(in) :: params Return Value real(kind=dp) private pure function invert_uniform_grid (yp_in, params) result(uniform) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: yp_in type( str_params ), intent(in) :: params Return Value real(kind=dp) Subroutines public subroutine map2dy_part_sind (np, ic1, pt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: ic1 real(kind=dp), intent(inout) :: pt (:,:) private subroutine map2dz_part_sind (np, ic1, pt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np integer, intent(in) :: ic1 real(kind=dp), intent(inout) :: pt (:,:) public subroutine map3d_part_sind (pt, np, ic1, ic2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ic1 integer, intent(in) :: ic2","tags":"","loc":"module/stretched_grid.html"},{"title":"grid_param – ALaDyn","text":"Uses precision_def struct_def module~~grid_param~~UsesGraph module~grid_param grid_param module~struct_def struct_def module~grid_param->module~struct_def module~precision_def precision_def module~grid_param->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid_param~~UsedByGraph module~grid_param grid_param module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~grid_param module~psolve psolve module~init_beam_part_distrib->module~psolve module~mpi_field_interface mpi_field_interface module~init_beam_part_distrib->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib->module~mpi_curr_interface module~grid_part_util grid_part_util module~init_beam_part_distrib->module~grid_part_util module~init_grid_field init_grid_field module~init_beam_part_distrib->module~init_grid_field module~psolve->module~grid_param module~grid_fields grid_fields module~psolve->module~grid_fields module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~grid_param module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~mpi_curr_interface module~curr_and_fields_util->module~grid_fields module~grid_part_connect grid_part_connect module~curr_and_fields_util->module~grid_part_connect module~curr_and_fields_util->module~init_grid_field module~set_init_param set_init_param module~set_init_param->module~grid_param module~set_grid_param set_grid_param module~set_init_param->module~set_grid_param module~init_part_distrib init_part_distrib module~init_part_distrib->module~grid_param module~set_grid_param->module~grid_param module~run_data_info run_data_info module~run_data_info->module~grid_param module~mpi_field_interface->module~grid_param module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~grid_param module~pic_out pic_out module~pic_out->module~grid_param module~grid_field_param grid_field_param module~grid_field_param->module~grid_param module~window window module~window->module~grid_param module~window->module~run_data_info module~window->module~mpi_field_interface module~mpi_part_interface mpi_part_interface module~window->module~mpi_part_interface module~mpi_curr_interface->module~grid_param module~grid_part_lib grid_part_lib module~grid_part_lib->module~grid_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~pic_dump pic_dump module~pic_dump->module~grid_param module~stretched_grid->module~grid_param module~mpi_part_interface->module~grid_param program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields program~aladyn->module~pic_out module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~pic_evolve->module~curr_and_fields_util module~pic_evolve->module~window module~pic_evolve->module~mpi_part_interface module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~pic_evolve->module~init_grid_field module~start_all->module~set_init_param module~start_all->module~set_grid_param module~start_all->module~run_data_info module~start_all->module~pic_dump module~pic_in pic_in module~start_all->module~pic_in module~env_evolve->module~curr_and_fields_util module~env_evolve->module~window module~env_evolve->module~mpi_part_interface module~env_evolve->module~fluid_density_momenta module~fluid_density_momenta->module~mpi_field_interface module~fluid_density_momenta->module~grid_fields module~pic_out_util->module~psolve module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~pic_out_util->module~grid_part_util module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~grid_fields->module~grid_field_param module~grid_part_connect->module~grid_part_lib module~grid_part_util->module~grid_part_lib module~init_grid_field->module~grid_field_param module~init_laser_field->module~grid_fields module~init_laser_field->module~init_grid_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables loc_ygrid loc_zgrid loc_xgrid str_xgrid str_ygrid str_zgrid wdata gwdata nxh nyh nzh loc_yftgrid loc_zftgrid yft zft loc_yft loc_zft akx aky akz sty ak2x ak2y ak2z kern kern2 skx sky skz loc_yg loc_zg loc_xg x xw y z dx1 dy1 dz1 xh yh zh dx1h dy1h dz1h str_indx yft_ind zft_ind rpt wgp xtot xmax xmin ymax ymin zmax zmin xw_min xw_max lx_box ly_box lz_box dx dx_inv dxi_inv dy dz dy_inv dyi_inv dz_inv dzi_inv aph l_s lx_s dxi dyi dzi sy_rat sz_rat sx_rat xmn ymn zmn yft_min zft_min nxp nyp nzp loc_ygr_max loc_zgr_max loc_xgr_max ix1 ix2 jy1 jy2 kz1 kz2 n_str nx_stretch ny_stretch nz_stretch Variables Type Visibility Attributes Name Initial type( grid ), public, allocatable :: loc_ygrid (:) Contains the local (to the MPI process) y grid informations type( grid ), public, allocatable :: loc_zgrid (:) Contains the local (to the MPI process) x grid informations type( grid ), public, allocatable :: loc_xgrid (:) Contains the local (to the MPI process) x grid informations type( sgrid ), public :: str_xgrid type( sgrid ), public :: str_ygrid type( sgrid ), public :: str_zgrid real(kind=sp), public, allocatable :: wdata (:) real(kind=sp), public, allocatable :: gwdata (:) integer, public, allocatable :: nxh (:) integer, public, allocatable :: nyh (:) integer, public, allocatable :: nzh (:) type( grid ), public, allocatable :: loc_yftgrid (:) type( grid ), public, allocatable :: loc_zftgrid (:) real(kind=dp), public, allocatable :: yft (:) real(kind=dp), public, allocatable :: zft (:) real(kind=dp), public, allocatable :: loc_yft (:,:) real(kind=dp), public, allocatable :: loc_zft (:,:) real(kind=dp), public, allocatable :: akx (:,:) real(kind=dp), public, allocatable :: aky (:,:) real(kind=dp), public, allocatable :: akz (:,:) real(kind=dp), public, allocatable :: sty (:,:) real(kind=dp), public, allocatable :: ak2x (:,:) real(kind=dp), public, allocatable :: ak2y (:,:) real(kind=dp), public, allocatable :: ak2z (:,:) real(kind=dp), public, allocatable :: kern (:) real(kind=dp), public, allocatable :: kern2 (:,:) real(kind=dp), public, allocatable :: skx (:,:) real(kind=dp), public, allocatable :: sky (:,:) real(kind=dp), public, allocatable :: skz (:,:) real(kind=dp), public, allocatable :: loc_yg (:,:,:) real(kind=dp), public, allocatable :: loc_zg (:,:,:) real(kind=dp), public, allocatable :: loc_xg (:,:,:) real(kind=dp), public, allocatable :: x (:) real(kind=dp), public, allocatable :: xw (:) real(kind=dp), public, allocatable :: y (:) real(kind=dp), public, allocatable :: z (:) real(kind=dp), public, allocatable :: dx1 (:) real(kind=dp), public, allocatable :: dy1 (:) real(kind=dp), public, allocatable :: dz1 (:) real(kind=dp), public, allocatable :: xh (:) real(kind=dp), public, allocatable :: yh (:) real(kind=dp), public, allocatable :: zh (:) real(kind=dp), public, allocatable :: dx1h (:) real(kind=dp), public, allocatable :: dy1h (:) real(kind=dp), public, allocatable :: dz1h (:) integer, public, allocatable :: str_indx (:,:) integer, public, allocatable :: yft_ind (:,:) integer, public, allocatable :: zft_ind (:,:) real(kind=dp), public, allocatable :: rpt (:) real(kind=dp), public, allocatable :: wgp (:) real(kind=dp), public :: xtot real(kind=dp), public :: xmax real(kind=dp), public :: xmin real(kind=dp), public :: ymax real(kind=dp), public :: ymin real(kind=dp), public :: zmax real(kind=dp), public :: zmin real(kind=dp), public :: xw_min real(kind=dp), public :: xw_max real(kind=dp), public :: lx_box real(kind=dp), public :: ly_box real(kind=dp), public :: lz_box real(kind=dp), public :: dx real(kind=dp), public :: dx_inv real(kind=dp), public :: dxi_inv real(kind=dp), public :: dy real(kind=dp), public :: dz real(kind=dp), public :: dy_inv real(kind=dp), public :: dyi_inv real(kind=dp), public :: dz_inv real(kind=dp), public :: dzi_inv real(kind=dp), public :: aph real(kind=dp), public :: l_s real(kind=dp), public :: lx_s real(kind=dp), public :: dxi real(kind=dp), public :: dyi real(kind=dp), public :: dzi real(kind=dp), public :: sy_rat real(kind=dp), public :: sz_rat real(kind=dp), public :: sx_rat real(kind=dp), public :: xmn real(kind=dp), public :: ymn real(kind=dp), public :: zmn real(kind=dp), public :: yft_min real(kind=dp), public :: zft_min integer, public :: nxp integer, public :: nyp integer, public :: nzp integer, public :: loc_ygr_max integer, public :: loc_zgr_max integer, public :: loc_xgr_max integer, public :: ix1 integer, public :: ix2 integer, public :: jy1 integer, public :: jy2 integer, public :: kz1 integer, public :: kz2 integer, public :: n_str integer, public :: nx_stretch integer, public :: ny_stretch integer, public :: nz_stretch","tags":"","loc":"module/grid_param.html"},{"title":"init_beam_part_distrib – ALaDyn","text":"Uses util psolve array_alloc grid_param mpi_field_interface mpi_curr_interface init_grid_field grid_part_util code_util control_bunch_input phys_param module~~init_beam_part_distrib~~UsesGraph module~init_beam_part_distrib init_beam_part_distrib module~psolve psolve module~init_beam_part_distrib->module~psolve module~control_bunch_input control_bunch_input module~init_beam_part_distrib->module~control_bunch_input module~array_alloc array_alloc module~init_beam_part_distrib->module~array_alloc module~grid_param grid_param module~init_beam_part_distrib->module~grid_param module~code_util code_util module~init_beam_part_distrib->module~code_util module~grid_part_util grid_part_util module~init_beam_part_distrib->module~grid_part_util module~mpi_field_interface mpi_field_interface module~init_beam_part_distrib->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib->module~mpi_curr_interface module~init_grid_field init_grid_field module~init_beam_part_distrib->module~init_grid_field module~util util module~init_beam_part_distrib->module~util module~phys_param phys_param module~init_beam_part_distrib->module~phys_param module~psolve->module~grid_param module~grid_fields grid_fields module~psolve->module~grid_fields module~fstruct_data fstruct_data module~psolve->module~fstruct_data module~pstruct_data pstruct_data module~psolve->module~pstruct_data module~prl_fft prl_fft module~psolve->module~prl_fft module~common_param common_param module~psolve->module~common_param module~precision_def precision_def module~control_bunch_input->module~precision_def module~array_alloc->module~fstruct_data module~array_alloc->module~pstruct_data module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~code_util->module~precision_def module~grid_part_util->module~fstruct_data module~grid_part_util->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_util->module~grid_part_lib module~mpi_field_interface->module~grid_param module~mpi_field_interface->module~fstruct_data module~parallel parallel module~mpi_field_interface->module~parallel module~mpi_field_interface->module~pstruct_data module~mpi_curr_interface->module~grid_param module~mpi_curr_interface->module~fstruct_data module~mpi_curr_interface->module~parallel module~mpi_curr_interface->module~pstruct_data module~init_grid_field->module~phys_param module~init_grid_field->module~fstruct_data module~init_grid_field->module~pstruct_data module~grid_field_param grid_field_param module~init_grid_field->module~grid_field_param module~util->module~code_util module~util->module~precision_def module~phys_param->module~precision_def module~grid_fields->module~parallel module~grid_fields->module~grid_field_param module~fstruct_data->module~precision_def module~parallel->module~util module~parallel->module~common_param module~mpi_var mpi_var module~parallel->module~mpi_var mpi mpi module~parallel->mpi module~struct_def->module~precision_def module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~prl_fft->module~parallel module~modern_fft_lib modern_fft_lib module~prl_fft->module~modern_fft_lib module~grid_field_param->module~grid_param module~grid_field_param->module~common_param module~grid_field_param->module~mpi_var module~common_param->module~precision_def module~grid_part_lib->module~grid_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~mpi_var->module~precision_def module~modern_fft_lib->module~precision_def iso_c_binding iso_c_binding module~modern_fft_lib->iso_c_binding module~stretched_grid->module~grid_param module~stretched_grid->module~common_param module~stretched_grid->module~mpi_var Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~init_beam_part_distrib~~UsedByGraph module~init_beam_part_distrib init_beam_part_distrib program~aladyn aladyn program~aladyn->module~init_beam_part_distrib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables bpart Subroutines beam_data mpi_beam_ftgrid_distribute mpi_beam_distribute beam_model_pot beam_inject Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: bpart (:,:) Subroutines public subroutine beam_data (ndm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndm public subroutine mpi_beam_ftgrid_distribute (ndm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndm public subroutine mpi_beam_distribute (ndm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndm public subroutine beam_model_pot (poten, sx, sy, sz, b_am, i1, i2, j1, j2, k1, k2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: poten (:,:,:,:) real(kind=dp), intent(in) :: sx real(kind=dp), intent(in) :: sy real(kind=dp), intent(in) :: sz real(kind=dp), intent(in) :: b_am integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 public subroutine beam_inject () Arguments None","tags":"","loc":"module/init_beam_part_distrib.html"},{"title":"pic_out_util – ALaDyn","text":"Uses grid_part_util mpi_curr_interface mpi_field_interface psolve phys_param module~~pic_out_util~~UsesGraph module~pic_out_util pic_out_util module~psolve psolve module~pic_out_util->module~psolve module~grid_part_util grid_part_util module~pic_out_util->module~grid_part_util module~mpi_field_interface mpi_field_interface module~pic_out_util->module~mpi_field_interface module~mpi_curr_interface mpi_curr_interface module~pic_out_util->module~mpi_curr_interface module~phys_param phys_param module~pic_out_util->module~phys_param module~grid_fields grid_fields module~psolve->module~grid_fields module~grid_param grid_param module~psolve->module~grid_param module~fstruct_data fstruct_data module~psolve->module~fstruct_data module~pstruct_data pstruct_data module~psolve->module~pstruct_data module~prl_fft prl_fft module~psolve->module~prl_fft module~common_param common_param module~psolve->module~common_param module~grid_part_util->module~fstruct_data module~grid_part_util->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_util->module~grid_part_lib module~mpi_field_interface->module~grid_param module~mpi_field_interface->module~fstruct_data module~parallel parallel module~mpi_field_interface->module~parallel module~mpi_field_interface->module~pstruct_data module~mpi_curr_interface->module~grid_param module~mpi_curr_interface->module~fstruct_data module~mpi_curr_interface->module~parallel module~mpi_curr_interface->module~pstruct_data module~precision_def precision_def module~phys_param->module~precision_def module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~parallel->module~common_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~prl_fft->module~parallel module~modern_fft_lib modern_fft_lib module~prl_fft->module~modern_fft_lib module~common_param->module~precision_def module~grid_part_lib->module~grid_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~mpi_var->module~precision_def module~grid_field_param->module~grid_param module~grid_field_param->module~common_param module~grid_field_param->module~mpi_var module~util->module~precision_def module~code_util code_util module~util->module~code_util module~struct_def->module~precision_def module~modern_fft_lib->module~precision_def iso_c_binding iso_c_binding module~modern_fft_lib->iso_c_binding module~stretched_grid->module~grid_param module~stretched_grid->module~common_param module~stretched_grid->module~mpi_var module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pic_out_util~~UsedByGraph module~pic_out_util pic_out_util program~aladyn aladyn program~aladyn->module~pic_out_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines initial_tparticles_select t_particles_collect fill_density_data collect_bunch_and_plasma_density prl_bden_energy_interp prl_den_energy_interp set_wake_potential Subroutines public subroutine initial_tparticles_select (tx1, ty1) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: tx1 real(kind=dp), intent(in) :: ty1 public subroutine t_particles_collect (time_ind) Arguments Type Intent Optional Attributes Name integer, intent(in) :: time_ind public subroutine fill_density_data (den, ic) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: den (:,:,:,:) integer, intent(in) :: ic public subroutine collect_bunch_and_plasma_density (this_bunch, isp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: this_bunch integer, intent(in) :: isp public subroutine prl_bden_energy_interp (ic) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic public subroutine prl_den_energy_interp (ic, cmp_out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ic integer, intent(in) :: cmp_out public subroutine set_wake_potential () Arguments None","tags":"","loc":"module/pic_out_util.html"},{"title":"init_laser_field – ALaDyn","text":"Uses pstruct_data fstruct_data init_grid_field grid_fields module~~init_laser_field~~UsesGraph module~init_laser_field init_laser_field module~pstruct_data pstruct_data module~init_laser_field->module~pstruct_data module~grid_fields grid_fields module~init_laser_field->module~grid_fields module~init_grid_field init_grid_field module~init_laser_field->module~init_grid_field module~fstruct_data fstruct_data module~init_laser_field->module~fstruct_data module~precision_def precision_def module~pstruct_data->module~precision_def module~struct_def struct_def module~pstruct_data->module~struct_def module~parallel parallel module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param module~init_grid_field->module~pstruct_data module~init_grid_field->module~fstruct_data module~init_grid_field->module~grid_field_param module~phys_param phys_param module~init_grid_field->module~phys_param module~fstruct_data->module~precision_def mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~common_param common_param module~parallel->module~common_param module~grid_param grid_param module~grid_field_param->module~grid_param module~grid_field_param->module~mpi_var module~grid_field_param->module~common_param module~struct_def->module~precision_def module~phys_param->module~precision_def module~grid_param->module~precision_def module~grid_param->module~struct_def module~mpi_var->module~precision_def module~util->module~precision_def module~code_util code_util module~util->module~code_util module~common_param->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~init_laser_field~~UsedByGraph module~init_laser_field init_laser_field module~pic_in pic_in module~pic_in->module~init_laser_field module~start_all start_all module~start_all->module~pic_in program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines lp_pulse cp_pulse set_envelope Subroutines public subroutine lp_pulse (lp_mod, part_in) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lp_mod real(kind=dp), intent(out) :: part_in public subroutine cp_pulse (cp_mod, part_in) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cp_mod real(kind=dp), intent(out) :: part_in public subroutine set_envelope (part_in) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: part_in","tags":"","loc":"module/init_laser_field.html"},{"title":"pic_in – ALaDyn","text":"Uses init_laser_field init_part_distrib module~~pic_in~~UsesGraph module~pic_in pic_in module~init_part_distrib init_part_distrib module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~grid_param grid_param module~init_part_distrib->module~grid_param module~array_alloc array_alloc module~init_part_distrib->module~array_alloc module~code_util code_util module~init_part_distrib->module~code_util module~mpi_var mpi_var module~init_part_distrib->module~mpi_var module~util util module~init_part_distrib->module~util module~common_param common_param module~init_part_distrib->module~common_param module~phys_param phys_param module~init_part_distrib->module~phys_param module~grid_fields grid_fields module~init_laser_field->module~grid_fields module~fstruct_data fstruct_data module~init_laser_field->module~fstruct_data module~pstruct_data pstruct_data module~init_laser_field->module~pstruct_data module~init_grid_field init_grid_field module~init_laser_field->module~init_grid_field module~parallel parallel module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param module~precision_def precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~array_alloc->module~fstruct_data module~array_alloc->module~pstruct_data module~fstruct_data->module~precision_def module~code_util->module~precision_def module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_var->module~precision_def module~init_grid_field->module~fstruct_data module~init_grid_field->module~pstruct_data module~init_grid_field->module~phys_param module~init_grid_field->module~grid_field_param module~util->module~code_util module~util->module~precision_def module~common_param->module~precision_def module~phys_param->module~precision_def module~parallel->module~mpi_var module~parallel->module~util module~parallel->module~common_param mpi mpi module~parallel->mpi module~grid_field_param->module~grid_param module~grid_field_param->module~mpi_var module~grid_field_param->module~common_param module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pic_in~~UsedByGraph module~pic_in pic_in module~start_all start_all module~start_all->module~pic_in program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables xf0 Subroutines init Variables Type Visibility Attributes Name Initial real(kind=dp), public :: xf0 Subroutines public subroutine init () Arguments None","tags":"","loc":"module/pic_in.html"},{"title":"init_part_distrib – ALaDyn","text":"Uses common_param util grid_param array_alloc mpi_var code_util phys_param module~~init_part_distrib~~UsesGraph module~init_part_distrib init_part_distrib module~grid_param grid_param module~init_part_distrib->module~grid_param module~array_alloc array_alloc module~init_part_distrib->module~array_alloc module~code_util code_util module~init_part_distrib->module~code_util module~mpi_var mpi_var module~init_part_distrib->module~mpi_var module~util util module~init_part_distrib->module~util module~common_param common_param module~init_part_distrib->module~common_param module~phys_param phys_param module~init_part_distrib->module~phys_param module~struct_def struct_def module~grid_param->module~struct_def module~precision_def precision_def module~grid_param->module~precision_def module~pstruct_data pstruct_data module~array_alloc->module~pstruct_data module~fstruct_data fstruct_data module~array_alloc->module~fstruct_data module~code_util->module~precision_def module~mpi_var->module~precision_def module~util->module~code_util module~util->module~precision_def module~common_param->module~precision_def module~phys_param->module~precision_def module~pstruct_data->module~struct_def module~pstruct_data->module~precision_def module~struct_def->module~precision_def module~fstruct_data->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~init_part_distrib~~UsedByGraph module~init_part_distrib init_part_distrib module~pic_in pic_in module~pic_in->module~init_part_distrib module~start_all start_all module~start_all->module~pic_in program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables loc_imax loc_jmax loc_kmax Subroutines set_pgrid_xind set_pgrid_ind pspecies_distribute mpi_x_part_distrib mpi_yz_part_distrib set_uniform_yz_distrib multi_layer_gas_target preplasma_multisp multi_layer_twosp_target multi_layer_threesp_target one_layer_nano_wires one_layer_nano_tubes part_distribute clean_field Variables Type Visibility Attributes Name Initial integer, private, allocatable :: loc_imax (:,:) integer, private, allocatable :: loc_jmax (:,:) integer, private, allocatable :: loc_kmax (:,:) Subroutines private subroutine set_pgrid_xind (npx, ic) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npx integer, intent(in) :: ic private subroutine set_pgrid_ind (npy, npz, ic) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npy integer, intent(in) :: npz integer, intent(in) :: ic private subroutine pspecies_distribute (loc_sp, t_x, ch, q, ic, i2, p) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: loc_sp real(kind=dp), intent(in) :: t_x real(kind=dp), intent(in) :: ch integer, intent(in) :: q integer, intent(in) :: ic integer, intent(in) :: i2 integer, intent(out) :: p private subroutine mpi_x_part_distrib (nc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc private subroutine mpi_yz_part_distrib (nc, ky2_in, kz2_in, nyc, nzc, ymt, zmt, whyz) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc integer, intent(in) :: ky2_in (:) integer, intent(in) :: kz2_in (:) integer, intent(in) :: nyc (:) integer, intent(in) :: nzc (:) real(kind=dp), intent(in) :: ymt real(kind=dp), intent(in) :: zmt real(kind=dp), intent(in) :: whyz (:,:,:) private subroutine set_uniform_yz_distrib (nyh_in, nc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in integer, intent(in) :: nc private subroutine multi_layer_gas_target (layer_mod, nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: layer_mod integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 private subroutine preplasma_multisp (nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 private subroutine multi_layer_twosp_target (nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 private subroutine multi_layer_threesp_target (nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 private subroutine one_layer_nano_wires (nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 private subroutine one_layer_nano_tubes (nyh_in, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nyh_in real(kind=dp), intent(in) :: xf0 public subroutine part_distribute (id, xf0) Arguments Type Intent Optional Attributes Name integer, intent(in) :: id real(kind=dp), intent(in) :: xf0 private subroutine clean_field (ef, lp1, i1, j1, j2, k1, k2, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: lp1 integer, intent(in) :: i1 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 integer, intent(in) :: nc","tags":"","loc":"module/init_part_distrib.html"},{"title":"pic_out – ALaDyn","text":"Uses pstruct_data fstruct_data code_util common_param grid_param parallel module~~pic_out~~UsesGraph module~pic_out pic_out module~grid_param grid_param module~pic_out->module~grid_param module~fstruct_data fstruct_data module~pic_out->module~fstruct_data module~parallel parallel module~pic_out->module~parallel module~code_util code_util module~pic_out->module~code_util module~pstruct_data pstruct_data module~pic_out->module~pstruct_data module~common_param common_param module~pic_out->module~common_param module~precision_def precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~parallel->module~common_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~code_util->module~precision_def module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~util->module~code_util module~util->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pic_out~~UsedByGraph module~pic_out pic_out program~aladyn aladyn program~aladyn->module~pic_out Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables par_dim int_par part_int_par real_par part_real_par rpar ipar Subroutines endian fluid_den_mom_out den_energy_out bden_energy_out ext_bfield_out fields_out fields_out_new bfields_out env_two_fields_out env_fields_out part_pdata_out part_high_gamma_out part_bdata_out part_ionz_out Variables Type Visibility Attributes Name Initial integer, private, parameter :: par_dim = 20 integer, private :: int_par (par_dim) integer, private :: part_int_par (par_dim) real(kind=sp), private :: real_par (par_dim) real(kind=sp), private :: part_real_par (par_dim) character(len=13), private, parameter, dimension(20) :: rpar = [' time =      ', ' xmin =      ', ' xmax =      ', ' ymin =      ', ' ymax =      ', ' zmin =      ', ' zmax =      ', ' w0_x =      ', ' w0_y =      ', ' a0 =        ', ' lam0 =      ', ' mc2(MeV) =  ', ' n0(e18) =   ', ' np/cell =   ', ' weight =    ', ' mass =      ', ' xmin_out =  ', ' xmax_out =  ', ' ymax_out =  ', ' gam_min =   '] character(len=12), private, parameter, dimension(20) :: ipar = [' npe =      ', ' nx =       ', ' ny =       ', ' nz =       ', ' model =    ', ' dmodel =   ', ' nsp =      ', ' curr_ndim =', ' mp/cell =  ', ' ion_ch =   ', ' tsch_ord = ', ' der_ord =  ', ' iform =    ', ' ph_sp_nc = ', ' f_version =', ' i_end =    ', ' nx_loc =   ', ' ny_loc =   ', ' nz_loc =   ', ' pjump  =   '] Subroutines public subroutine endian (iend) Arguments Type Intent Optional Attributes Name integer, intent(out) :: iend public subroutine fluid_den_mom_out (fvar, cmp, flcomp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: fvar (:,:,:,:) integer, intent(in) :: cmp integer, intent(in) :: flcomp public subroutine den_energy_out (ns_ind, cmp, cmp_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ns_ind integer, intent(in) :: cmp integer, intent(in) :: cmp_loc public subroutine bden_energy_out (cmp_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cmp_loc public subroutine ext_bfield_out (ef, f_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) integer, intent(in) :: f_ind public subroutine fields_out (ef, f_ind, f_var) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) integer, intent(in) :: f_ind integer, intent(in) :: f_var public subroutine fields_out_new (ef, f_ind, var_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) integer, intent(in) :: f_ind integer, intent(in) :: var_ind public subroutine bfields_out (ef, ef1, f_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ef1 (:,:,:,:) integer, intent(in) :: f_ind public subroutine env_two_fields_out (ef, ef1, f_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ef1 (:,:,:,:) integer, intent(in) :: f_ind public subroutine env_fields_out (ef, f_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) integer, intent(in) :: f_ind public subroutine part_pdata_out (timenow, xmin_out, xmax_out, ymax_out, pid, jmp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: timenow real(kind=dp), intent(in) :: xmin_out real(kind=dp), intent(in) :: xmax_out real(kind=dp), intent(in) :: ymax_out integer, intent(in) :: pid integer, intent(in) :: jmp public subroutine part_high_gamma_out (gam_in, timenow) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: gam_in real(kind=dp), intent(in) :: timenow public subroutine part_bdata_out (timenow, pid, jmp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: timenow integer, intent(in) :: pid integer, intent(in) :: jmp public subroutine part_ionz_out (timenow) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: timenow","tags":"","loc":"module/pic_out.html"},{"title":"psolve – ALaDyn","text":"Uses pstruct_data fstruct_data common_param grid_param prl_fft grid_fields module~~psolve~~UsesGraph module~psolve psolve module~grid_fields grid_fields module~psolve->module~grid_fields module~grid_param grid_param module~psolve->module~grid_param module~fstruct_data fstruct_data module~psolve->module~fstruct_data module~pstruct_data pstruct_data module~psolve->module~pstruct_data module~prl_fft prl_fft module~psolve->module~prl_fft module~common_param common_param module~psolve->module~common_param module~parallel parallel module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param module~precision_def precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~prl_fft->module~parallel module~modern_fft_lib modern_fft_lib module~prl_fft->module~modern_fft_lib module~common_param->module~precision_def module~parallel->module~common_param module~util util module~parallel->module~util module~mpi_var mpi_var module~parallel->module~mpi_var mpi mpi module~parallel->mpi module~grid_field_param->module~grid_param module~grid_field_param->module~common_param module~grid_field_param->module~mpi_var module~struct_def->module~precision_def module~modern_fft_lib->module~precision_def iso_c_binding iso_c_binding module~modern_fft_lib->iso_c_binding module~util->module~precision_def module~code_util code_util module~util->module~code_util module~mpi_var->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~psolve~~UsedByGraph module~psolve psolve module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~psolve module~pic_out_util pic_out_util module~pic_out_util->module~psolve program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables wb wa Subroutines beam_2d_potential beam_potential fft_3d_psolv fft_2d_psolv Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: wb (:,:,:) real(kind=dp), private, allocatable :: wa (:,:,:) Subroutines private subroutine beam_2d_potential (poten, nxf_in, n2_loc, n3_loc, ft_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: poten (:,:,:) integer, intent(in) :: nxf_in integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc integer, intent(in) :: ft_ind private subroutine beam_potential (poten, gam2, nxf_in, n2_loc, n3_loc, ft_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: poten (:,:,:) real(kind=dp), intent(in) :: gam2 integer, intent(in) :: nxf_in integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc integer, intent(in) :: ft_ind public subroutine fft_3d_psolv (rho, pot1, g2, omp0, n1, n1_loc, n2, n2_loc, n3, n3_loc, i1, i2, j1, j2, k1, k2, ft_mod, sym, s_ind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: rho (:,:,:,:) real(kind=dp), intent(inout) :: pot1 (:,:,:,:) real(kind=dp), intent(in) :: g2 real(kind=dp), intent(in) :: omp0 integer, intent(in) :: n1 integer, intent(in) :: n1_loc integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 integer, intent(in) :: ft_mod integer, intent(in) :: sym integer, intent(in) :: s_ind public subroutine fft_2d_psolv (rho, pot1, omp0, n1, n1_loc, n2, n2_loc, n3, n3_loc, i1, i2, j1, j2, k1, k2, ft_mod, sym, sind) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: rho (:,:,:,:) real(kind=dp), intent(inout) :: pot1 (:,:,:,:) real(kind=dp), intent(in) :: omp0 integer, intent(in) :: n1 integer, intent(in) :: n1_loc integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 integer, intent(in) :: ft_mod integer, intent(in) :: sym integer, intent(in) :: sind","tags":"","loc":"module/psolve.html"},{"title":"grid_field_param – ALaDyn","text":"Uses common_param mpi_var grid_param module~~grid_field_param~~UsesGraph module~grid_field_param grid_field_param module~common_param common_param module~grid_field_param->module~common_param module~mpi_var mpi_var module~grid_field_param->module~mpi_var module~grid_param grid_param module~grid_field_param->module~grid_param module~precision_def precision_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~grid_param->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid_field_param~~UsedByGraph module~grid_field_param grid_field_param module~grid_fields grid_fields module~grid_fields->module~grid_field_param module~init_grid_field init_grid_field module~init_grid_field->module~grid_field_param module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~init_grid_field module~psolve psolve module~init_beam_part_distrib->module~psolve module~psolve->module~grid_fields module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~grid_fields module~curr_and_fields_util->module~init_grid_field module~pic_evolve pic_evolve module~pic_evolve->module~init_grid_field module~pic_evolve->module~curr_and_fields_util module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~fluid_density_momenta->module~grid_fields module~init_laser_field init_laser_field module~init_laser_field->module~grid_fields module~init_laser_field->module~init_grid_field module~pic_out_util pic_out_util module~pic_out_util->module~psolve module~pic_in pic_in module~pic_in->module~init_laser_field program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_evolve program~aladyn->module~pic_out_util module~env_evolve env_evolve program~aladyn->module~env_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve->module~curr_and_fields_util module~env_evolve->module~fluid_density_momenta module~start_all->module~pic_in Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ww1 ww2 ww0 wr wl var hord_der2 opt_der2 opt_der1 aph_der avg_cmp cmp_coeff se_coeff se4_coeff upw Subroutines set_field_param Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: ww1 (:) real(kind=dp), public, allocatable :: ww2 (:) real(kind=dp), public, allocatable :: ww0 (:,:) real(kind=dp), public, allocatable :: wr (:,:) real(kind=dp), public, allocatable :: wl (:,:) real(kind=dp), public, allocatable :: var (:,:) real(kind=dp), public :: hord_der2 real(kind=dp), public :: opt_der2 real(kind=dp), public :: opt_der1 real(kind=dp), public :: aph_der real(kind=dp), public :: avg_cmp real(kind=dp), public :: cmp_coeff (2) real(kind=dp), public :: se_coeff (2) real(kind=dp), public :: se4_coeff (2) real(kind=dp), public :: upw (4) Subroutines public subroutine set_field_param () Arguments None","tags":"","loc":"module/grid_field_param.html"},{"title":"grid_fields – ALaDyn","text":"Uses grid_field_param parallel module~~grid_fields~~UsesGraph module~grid_fields grid_fields module~parallel parallel module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~common_param common_param module~parallel->module~common_param module~grid_param grid_param module~grid_field_param->module~grid_param module~grid_field_param->module~mpi_var module~grid_field_param->module~common_param module~struct_def struct_def module~grid_param->module~struct_def module~precision_def precision_def module~grid_param->module~precision_def module~mpi_var->module~precision_def module~code_util code_util module~util->module~code_util module~util->module~precision_def module~common_param->module~precision_def module~struct_def->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid_fields~~UsedByGraph module~grid_fields grid_fields module~fluid_density_momenta fluid_density_momenta module~fluid_density_momenta->module~grid_fields module~psolve psolve module~psolve->module~grid_fields module~init_laser_field init_laser_field module~init_laser_field->module~grid_fields module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~grid_fields module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~psolve module~pic_evolve pic_evolve module~pic_evolve->module~fluid_density_momenta module~pic_evolve->module~curr_and_fields_util module~env_evolve env_evolve module~env_evolve->module~fluid_density_momenta module~env_evolve->module~curr_and_fields_util module~pic_out_util pic_out_util module~pic_out_util->module~psolve module~pic_in pic_in module~pic_in->module~init_laser_field program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_evolve program~aladyn->module~env_evolve program~aladyn->module~pic_out_util module~start_all start_all program~aladyn->module~start_all module~start_all->module~pic_in Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x_parity y_parity z_parity COEFF_2 COEFF_1 COEFF_0 Subroutines trid_der1 unif_to_str_field_interp enforce_continuity field_xadvect pp_lapl env_grad env_maxw_solve env_lpf_solve env_bds bf_bds ef_bds potential_lapl rote rotb nc_fluid_density_momenta Variables Type Visibility Attributes Name Initial integer, private, parameter :: x_parity (6) = [-1, 1, 1, -1, 1, 1] integer, private, parameter :: y_parity (6) = [1, -1, 1, 1, -1, 1] integer, private, parameter :: z_parity (6) = [1, 1, -1, 1, 1, -1] integer, private, dimension(2, 3) :: COEFF_2 integer, private, dimension(2, 2) :: COEFF_1 integer, private, dimension(2, 1) :: COEFF_0 Subroutines public subroutine trid_der1 (a, b, c, b1, c1, an, bn, n, ic1, ic2, ord) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b real(kind=dp), intent(in) :: c real(kind=dp), intent(in) :: b1 real(kind=dp), intent(in) :: c1 real(kind=dp), intent(in) :: an real(kind=dp), intent(in) :: bn integer, intent(in) :: n integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: ord public subroutine unif_to_str_field_interp (unif_field, str_field, ic) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: unif_field (:,:,:) real(kind=dp), intent(inout) :: str_field (:,:,:,:) integer, intent(in) :: ic public subroutine enforce_continuity (curr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) public subroutine field_xadvect (ef, dth, v_adv, ic1, ic2, isch) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dth real(kind=dp), intent(in) :: v_adv integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: isch public subroutine pp_lapl (av, source, ic1, ic2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: av (:,:,:,:) real(kind=dp), intent(inout) :: source (:,:,:,:) integer, intent(in) :: ic1 integer, intent(in) :: ic2 public subroutine env_grad (envg) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: envg (:,:,:,:) public subroutine env_maxw_solve (curr, evf, om0, dtl) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(inout) :: evf (:,:,:,:) real(kind=dp), intent(in) :: om0 real(kind=dp), intent(in) :: dtl public subroutine env_lpf_solve (curr, evf, ib, om0, dtl) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) real(kind=dp), intent(inout) :: evf (:,:,:,:) integer, intent(in) :: ib real(kind=dp), intent(in) :: om0 real(kind=dp), intent(in) :: dtl public subroutine env_bds (ef, ptrght, ptlft, init_ic, end_ic) Boundary conditions for the envelope field.\n Empirically set to be continuous with continuous first derivative. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) integer, intent(in) :: ptrght integer, intent(in) :: ptlft integer, intent(in), optional :: init_ic integer, intent(in), optional :: end_ic public subroutine bf_bds (ef, dtl, imbd) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dtl integer, intent(in) :: imbd public subroutine ef_bds (ef, dtl, imbd) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dtl integer, intent(in) :: imbd public subroutine potential_lapl (apf, curr, ic1, ic2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: apf (:,:,:,:) real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: ic1 integer, intent(in) :: ic2 public subroutine rote (ef, dtf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dtf public subroutine rotb (ef, dtf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dtf public subroutine nc_fluid_density_momenta (flx, ef, dt_step, fcomp) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: flx (:,:,:,:) real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: dt_step integer, intent(in) :: fcomp","tags":"","loc":"module/grid_fields.html"},{"title":"init_grid_field – ALaDyn","text":"Uses grid_field_param pstruct_data fstruct_data phys_param module~~init_grid_field~~UsesGraph module~init_grid_field init_grid_field module~pstruct_data pstruct_data module~init_grid_field->module~pstruct_data module~phys_param phys_param module~init_grid_field->module~phys_param module~grid_field_param grid_field_param module~init_grid_field->module~grid_field_param module~fstruct_data fstruct_data module~init_grid_field->module~fstruct_data module~precision_def precision_def module~pstruct_data->module~precision_def module~struct_def struct_def module~pstruct_data->module~struct_def module~phys_param->module~precision_def module~grid_param grid_param module~grid_field_param->module~grid_param module~common_param common_param module~grid_field_param->module~common_param module~mpi_var mpi_var module~grid_field_param->module~mpi_var module~fstruct_data->module~precision_def module~grid_param->module~precision_def module~grid_param->module~struct_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~init_grid_field~~UsedByGraph module~init_grid_field init_grid_field module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~init_grid_field module~init_laser_field init_laser_field module~init_laser_field->module~init_grid_field module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~init_grid_field module~pic_evolve pic_evolve module~pic_evolve->module~init_grid_field module~pic_evolve->module~curr_and_fields_util module~pic_in pic_in module~pic_in->module~init_laser_field program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve->module~curr_and_fields_util module~start_all->module~pic_in Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines initial_beam_fields init_envelope_field init_gprof_envelope_field get_2dlaser_gprof_fields_lp get_2dlaser_fields_lp get_laser_fields_lp get_laser_gprof_fields_lp get_plane_wave_lp get_plane_wave_cp get_laser_fields_cp inflow_lp_fields init_lp_inc0_fields init_lp_fields inflow_cp_fields init_cp_fields init_fluid_density_momenta set_poloidal_ex_fields set_solenoid_fields Subroutines public subroutine initial_beam_fields (poten, efb, g2, bet) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: poten (:,:,:,:) real(kind=dp), intent(out) :: efb (:,:,:,:) real(kind=dp), intent(in) :: g2 real(kind=dp), intent(in) :: bet public subroutine init_envelope_field (ef, ee0, t_loc, tf, wx, wy, xf0, om0, pw, i1, i2, ycent, zcent) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 integer, intent(in) :: pw integer, intent(in) :: i1 integer, intent(in) :: i2 real(kind=dp) :: ycent real(kind=dp) :: zcent public subroutine init_gprof_envelope_field (ef, ee0, t_loc, tf, wx, wy, xf0, om0, pw, i1, i2, ycent, zcent) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 integer, intent(in) :: pw integer, intent(in) :: i1 integer, intent(in) :: i2 real(kind=dp) :: ycent real(kind=dp) :: zcent public subroutine get_2dlaser_gprof_fields_lp (coords, par_lp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_lp (7) real(kind=dp), intent(out) :: fields (6) public subroutine get_2dlaser_fields_lp (coords, par_lp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_lp (7) real(kind=dp), intent(out) :: fields (6) public subroutine get_laser_fields_lp (coords, par_lp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_lp (7) real(kind=dp), intent(out) :: fields (6) public subroutine get_laser_gprof_fields_lp (coords, par_lp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_lp (7) real(kind=dp), intent(out) :: fields (6) public subroutine get_plane_wave_lp (coords, par_pp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_pp (7) real(kind=dp), intent(out) :: fields (6) public subroutine get_plane_wave_cp (coords, par_pp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_pp (7) real(kind=dp), intent(out) :: fields (6) public subroutine get_laser_fields_cp (coords, par_cp, fields) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (4) real(kind=dp), intent(in) :: par_cp (7) real(kind=dp), intent(out) :: fields (6) public subroutine inflow_lp_fields (ef, ee0, t_loc, tf, wx, wy, xf0, om0, lp, i, j1, j2, k1, k2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 integer, intent(in) :: lp integer, intent(in) :: i integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 public subroutine init_lp_inc0_fields (ef, ee0, t_loc, tf, wx, wy, xf0, om0, lp, i1, i2, ycent, zcent) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 integer, intent(in) :: lp integer, intent(in) :: i1 integer, intent(in) :: i2 real(kind=dp) :: ycent real(kind=dp) :: zcent public subroutine init_lp_fields (ef, ee0, t_loc, tf, wx, wy, xf0, om0, angle, lp_shx, lp, i1, i2, ycent, zcent) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: om0 real(kind=dp), intent(in) :: angle real(kind=dp), intent(in) :: lp_shx integer, intent(in) :: lp integer, intent(in) :: i1 integer, intent(in) :: i2 real(kind=dp) :: ycent real(kind=dp) :: zcent public subroutine inflow_cp_fields (ef, ee0, t_loc, tf, wx, wy, xf0, cp, i, j1, j2, k1, k2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 integer, intent(in) :: cp integer, intent(in) :: i integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 public subroutine init_cp_fields (ef, ee0, t_loc, tf, wx, wy, xf0, angle, lp_shx, cp, i1, i2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) real(kind=dp), intent(in) :: ee0 real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: tf real(kind=dp), intent(in) :: wx real(kind=dp), intent(in) :: wy real(kind=dp), intent(in) :: xf0 real(kind=dp), intent(in) :: angle real(kind=dp), intent(in) :: lp_shx integer, intent(in) :: cp integer, intent(in) :: i1 integer, intent(in) :: i2 public subroutine init_fluid_density_momenta (dmodel, part_in) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dmodel real(kind=dp), intent(in) :: part_in public subroutine set_poloidal_ex_fields (ef1, i1, i2, j1, j2, k1, k2, bpoloidal, rpoloidal) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef1 (:,:,:,:) integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 real(kind=dp), intent(in) :: bpoloidal real(kind=dp), intent(in) :: rpoloidal public subroutine set_solenoid_fields (ef1, i1, i2, j1, j2, k1, k2, x0, l_sol, bs) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef1 (:,:,:,:) integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: j1 integer, intent(in) :: j2 integer, intent(in) :: k1 integer, intent(in) :: k2 real(kind=dp), intent(in) :: x0 real(kind=dp), intent(in) :: l_sol (3,2) real(kind=dp), intent(in) :: bs (2)","tags":"","loc":"module/init_grid_field.html"},{"title":"prl_fft – ALaDyn","text":"Uses parallel modern_fft_lib module~~prl_fft~~UsesGraph module~prl_fft prl_fft module~parallel parallel module~prl_fft->module~parallel module~modern_fft_lib modern_fft_lib module~prl_fft->module~modern_fft_lib mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~common_param common_param module~parallel->module~common_param module~precision_def precision_def module~modern_fft_lib->module~precision_def iso_c_binding iso_c_binding module~modern_fft_lib->iso_c_binding module~mpi_var->module~precision_def module~util->module~precision_def module~code_util code_util module~util->module~code_util module~common_param->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~prl_fft~~UsedByGraph module~prl_fft prl_fft module~psolve psolve module~psolve->module~prl_fft module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~psolve module~pic_out_util pic_out_util module~pic_out_util->module~psolve program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables fp1 fp2 faux1 faux2 loc_yft_ord loc_zft_ord Subroutines mpi_ftw_alloc mpi_yzft_ord mpi_ftw_dalloc ft_overset_grid swap_yx_3data swap_xy_3data swap_xz_3data swap_yx_3data_inv swap_xy_3data_inv swap_xz_3data_inv pftw2d_sc pftw3d_sc pftw2d pftw3d Variables Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: fp1 (:,:,:) real(kind=dp), public, allocatable :: fp2 (:,:,:) real(kind=dp), public, allocatable :: faux1 (:) real(kind=dp), public, allocatable :: faux2 (:) integer, public, allocatable :: loc_yft_ord (:) integer, public, allocatable :: loc_zft_ord (:) Subroutines public subroutine mpi_ftw_alloc (n1, n2, n2_loc, n3, n3_loc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc public subroutine mpi_yzft_ord (ny_ft, nz_ft) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ny_ft integer, intent(in) :: nz_ft public subroutine mpi_ftw_dalloc () Arguments None public subroutine ft_overset_grid (w_s, w_r, nft1, nft2, nft3) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w_s (:,:,:) real(kind=dp), intent(out) :: w_r (:,:,:) integer, intent(in) :: nft1 integer, intent(in) :: nft2 integer, intent(in) :: nft3 public subroutine swap_yx_3data (waux, wdata, n1_loc, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: waux (:,:,:) real(kind=dp), intent(out) :: wdata (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2 integer, intent(in) :: n3 public subroutine swap_xy_3data (wp1, wp2, n1_loc, n2_loc, n3_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wp1 (:,:,:) real(kind=dp), intent(out) :: wp2 (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc public subroutine swap_xz_3data (wp1, wp2, n1_loc, n2_loc, n3_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wp1 (:,:,:) real(kind=dp), intent(out) :: wp2 (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc public subroutine swap_yx_3data_inv (wdata, waux, n1_loc, n2, n3) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wdata (:,:,:) real(kind=dp), intent(out) :: waux (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2 integer, intent(in) :: n3 public subroutine swap_xy_3data_inv (wp2, wp1, n1_loc, n2_loc, n3_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wp2 (:,:,:) real(kind=dp), intent(out) :: wp1 (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc public subroutine swap_xz_3data_inv (wp2, wp1, n1_loc, n2_loc, n3_loc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: wp2 (:,:,:) real(kind=dp), intent(out) :: wp1 (:,:,:) integer, intent(in) :: n1_loc integer, intent(in) :: n2_loc integer, intent(in) :: n3_loc public subroutine pftw2d_sc (w, n1, n2, n2_loc, n3, n3_loc, is, sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: is integer, intent(in) :: sym public subroutine pftw3d_sc (w, n1, n2, n2_loc, n3, n3_loc, is, sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: is integer, intent(in) :: sym public subroutine pftw2d (w, n1, n2, n2_loc, n3, n3_loc, is) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: is public subroutine pftw3d (w, n1, n2, n2_loc, n3, n3_loc, is) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n2_loc integer, intent(in) :: n3 integer, intent(in) :: n3_loc integer, intent(in) :: is","tags":"","loc":"module/prl_fft.html"},{"title":"legacy_fft_lib – ALaDyn","text":"Uses precision_def iso_c_binding module~~legacy_fft_lib~~UsesGraph module~legacy_fft_lib legacy_fft_lib iso_c_binding iso_c_binding module~legacy_fft_lib->iso_c_binding module~precision_def precision_def module~legacy_fft_lib->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables C_FFTW_R2R_KIND FFTW_R2HC FFTW_HC2R FFTW_DHT FFTW_REDFT00 FFTW_REDFT01 FFTW_REDFT10 FFTW_REDFT11 FFTW_RODFT00 FFTW_RODFT01 FFTW_RODFT10 FFTW_RODFT11 FFTW_FORWARD FFTW_BACKWARD FFTW_MEASURE FFTW_DESTROY_INPUT FFTW_UNALIGNED FFTW_CONSERVE_MEMORY FFTW_EXHAUSTIVE FFTW_PRESERVE_INPUT FFTW_PATIENT FFTW_ESTIMATE FFTW_WISDOM_ONLY FFTW_ESTIMATE_PATIENT FFTW_BELIEVE_PCOST FFTW_NO_DFT_R2HC FFTW_NO_NONTHREADED FFTW_NO_BUFFERING FFTW_NO_INDIRECT_OP FFTW_ALLOW_LARGE_GENERIC FFTW_NO_RANK_SPLITS FFTW_NO_VRANK_SPLITS FFTW_NO_VRECURSE FFTW_NO_SIMD FFTW_NO_SLOW FFTW_NO_FIXED_RADIX_LARGE_N FFTW_ALLOW_PRUNING plan1 iplan1 plan2 iplan2 plan3 iplan3 cw w1 w1_st w2 w3 cfhx sfhx cfhy sfhy cfhz sfhz Interfaces fftw_plan_dft fftw_plan_dft_1d fftw_plan_dft_2d fftw_plan_dft_3d fftw_plan_many_dft fftw_plan_guru_dft fftw_plan_guru_split_dft fftw_plan_guru64_dft fftw_plan_guru64_split_dft fftw_plan_many_dft_r2c fftw_plan_dft_r2c fftw_plan_dft_r2c_1d fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_3d fftw_plan_many_dft_c2r fftw_plan_dft_c2r fftw_plan_dft_c2r_1d fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_3d fftw_plan_guru_dft_r2c fftw_plan_guru_dft_c2r fftw_plan_guru_split_dft_r2c fftw_plan_guru_split_dft_c2r fftw_plan_guru64_dft_r2c fftw_plan_guru64_dft_c2r fftw_plan_guru64_split_dft_r2c fftw_plan_guru64_split_dft_c2r fftw_plan_many_r2r fftw_plan_r2r fftw_plan_r2r_1d fftw_plan_r2r_2d fftw_plan_r2r_3d fftw_plan_guru_r2r fftw_plan_guru64_r2r fftw_init_threads fftw_export_wisdom_to_filename fftw_export_wisdom_to_string fftw_import_system_wisdom fftw_import_wisdom_from_filename fftw_import_wisdom_from_file fftw_import_wisdom_from_string fftw_import_wisdom fftw_sprint_plan fftw_malloc fftw_alloc_real fftw_alloc_complex fftw_estimate_cost fftw_cost fftw_alignment_of fftw_execute_dft fftw_execute_split_dft fftw_execute_dft_r2c fftw_execute_dft_c2r fftw_execute_split_dft_r2c fftw_execute_split_dft_c2r fftw_execute_r2r fftw_destroy_plan fftw_forget_wisdom fftw_cleanup fftw_set_timelimit fftw_plan_with_nthreads fftw_cleanup_threads fftw_make_planner_thread_safe fftw_export_wisdom_to_file fftw_export_wisdom fftw_fprint_plan fftw_print_plan fftw_free fftw_flops fftwf_plan_dft fftwf_plan_dft_1d fftwf_plan_dft_2d fftwf_plan_dft_3d fftwf_plan_many_dft fftwf_plan_guru_dft fftwf_plan_guru_split_dft fftwf_plan_guru64_dft fftwf_plan_guru64_split_dft fftwf_plan_many_dft_r2c fftwf_plan_dft_r2c fftwf_plan_dft_r2c_1d fftwf_plan_dft_r2c_2d fftwf_plan_dft_r2c_3d fftwf_plan_many_dft_c2r fftwf_plan_dft_c2r fftwf_plan_dft_c2r_1d fftwf_plan_dft_c2r_2d fftwf_plan_dft_c2r_3d fftwf_plan_guru_dft_r2c fftwf_plan_guru_dft_c2r fftwf_plan_guru_split_dft_r2c fftwf_plan_guru_split_dft_c2r fftwf_plan_guru64_dft_r2c fftwf_plan_guru64_dft_c2r fftwf_plan_guru64_split_dft_r2c fftwf_plan_guru64_split_dft_c2r fftwf_plan_many_r2r fftwf_plan_r2r fftwf_plan_r2r_1d fftwf_plan_r2r_2d fftwf_plan_r2r_3d fftwf_plan_guru_r2r fftwf_plan_guru64_r2r fftwf_init_threads fftwf_export_wisdom_to_filename fftwf_export_wisdom_to_string fftwf_import_system_wisdom fftwf_import_wisdom_from_filename fftwf_import_wisdom_from_file fftwf_import_wisdom_from_string fftwf_import_wisdom fftwf_sprint_plan fftwf_malloc fftwf_alloc_real fftwf_alloc_complex fftwf_estimate_cost fftwf_cost fftwf_alignment_of fftwf_execute_dft fftwf_execute_split_dft fftwf_execute_dft_r2c fftwf_execute_dft_c2r fftwf_execute_split_dft_r2c fftwf_execute_split_dft_c2r fftwf_execute_r2r fftwf_destroy_plan fftwf_forget_wisdom fftwf_cleanup fftwf_set_timelimit fftwf_plan_with_nthreads fftwf_cleanup_threads fftwf_make_planner_thread_safe fftwf_export_wisdom_to_file fftwf_export_wisdom fftwf_fprint_plan fftwf_print_plan fftwf_free fftwf_flops Derived Types fftw_iodim fftw_iodim64 fftwf_iodim fftwf_iodim64 Subroutines ftw_init ftw_end ftw1d_st ftw1d ft_kern ftw1d_sc Variables Type Visibility Attributes Name Initial integer, public, parameter :: C_FFTW_R2R_KIND = C_INT32_T integer(kind=C_INT), public, parameter :: FFTW_R2HC = 0 integer(kind=C_INT), public, parameter :: FFTW_HC2R = 1 integer(kind=C_INT), public, parameter :: FFTW_DHT = 2 integer(kind=C_INT), public, parameter :: FFTW_REDFT00 = 3 integer(kind=C_INT), public, parameter :: FFTW_REDFT01 = 4 integer(kind=C_INT), public, parameter :: FFTW_REDFT10 = 5 integer(kind=C_INT), public, parameter :: FFTW_REDFT11 = 6 integer(kind=C_INT), public, parameter :: FFTW_RODFT00 = 7 integer(kind=C_INT), public, parameter :: FFTW_RODFT01 = 8 integer(kind=C_INT), public, parameter :: FFTW_RODFT10 = 9 integer(kind=C_INT), public, parameter :: FFTW_RODFT11 = 10 integer(kind=C_INT), public, parameter :: FFTW_FORWARD = -1 integer(kind=C_INT), public, parameter :: FFTW_BACKWARD = +1 integer(kind=C_INT), public, parameter :: FFTW_MEASURE = 0 integer(kind=C_INT), public, parameter :: FFTW_DESTROY_INPUT = 1 integer(kind=C_INT), public, parameter :: FFTW_UNALIGNED = 2 integer(kind=C_INT), public, parameter :: FFTW_CONSERVE_MEMORY = 4 integer(kind=C_INT), public, parameter :: FFTW_EXHAUSTIVE = 8 integer(kind=C_INT), public, parameter :: FFTW_PRESERVE_INPUT = 16 integer(kind=C_INT), public, parameter :: FFTW_PATIENT = 32 integer(kind=C_INT), public, parameter :: FFTW_ESTIMATE = 64 integer(kind=C_INT), public, parameter :: FFTW_WISDOM_ONLY = 2097152 integer(kind=C_INT), public, parameter :: FFTW_ESTIMATE_PATIENT = 128 integer(kind=C_INT), public, parameter :: FFTW_BELIEVE_PCOST = 256 integer(kind=C_INT), public, parameter :: FFTW_NO_DFT_R2HC = 512 integer(kind=C_INT), public, parameter :: FFTW_NO_NONTHREADED = 1024 integer(kind=C_INT), public, parameter :: FFTW_NO_BUFFERING = 2048 integer(kind=C_INT), public, parameter :: FFTW_NO_INDIRECT_OP = 4096 integer(kind=C_INT), public, parameter :: FFTW_ALLOW_LARGE_GENERIC = 8192 integer(kind=C_INT), public, parameter :: FFTW_NO_RANK_SPLITS = 16384 integer(kind=C_INT), public, parameter :: FFTW_NO_VRANK_SPLITS = 32768 integer(kind=C_INT), public, parameter :: FFTW_NO_VRECURSE = 65536 integer(kind=C_INT), public, parameter :: FFTW_NO_SIMD = 131072 integer(kind=C_INT), public, parameter :: FFTW_NO_SLOW = 262144 integer(kind=C_INT), public, parameter :: FFTW_NO_FIXED_RADIX_LARGE_N = 524288 integer(kind=C_INT), public, parameter :: FFTW_ALLOW_PRUNING = 1048576 integer(kind=dp), public :: plan1 integer(kind=dp), public :: iplan1 integer(kind=dp), public :: plan2 integer(kind=dp), public :: iplan2 integer(kind=dp), public :: plan3 integer(kind=dp), public :: iplan3 real(kind=dp), public, allocatable :: cw (:,:) real(kind=dp), public, allocatable :: w1 (:) real(kind=dp), public, allocatable :: w1_st (:) real(kind=dp), public, allocatable :: w2 (:) real(kind=dp), public, allocatable :: w3 (:) real(kind=dp), public, allocatable :: cfhx (:) real(kind=dp), public, allocatable :: sfhx (:) real(kind=dp), public, allocatable :: cfhy (:) real(kind=dp), public, allocatable :: sfhy (:) real(kind=dp), public, allocatable :: cfhz (:) real(kind=dp), public, allocatable :: sfhz (:) Interfaces interface public function fftw_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftw_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftw_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftw_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftw_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftw_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftw_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftw_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftw_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftw_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftw_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_init_threads() bind(C, name='fftw_init_threads') Arguments None Return Value integer(kind=C_INT) interface public function fftw_export_wisdom_to_filename(filename) bind(C, name='fftw_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT) interface public function fftw_export_wisdom_to_string() bind(C, name='fftw_export_wisdom_to_string') Arguments None Return Value type(C_PTR) interface public function fftw_import_system_wisdom() bind(C, name='fftw_import_system_wisdom') Arguments None Return Value integer(kind=C_INT) interface public function fftw_import_wisdom_from_filename(filename) bind(C, name='fftw_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT) interface public function fftw_import_wisdom_from_file(input_file) bind(C, name='fftw_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=C_INT) interface public function fftw_import_wisdom_from_string(input_string) bind(C, name='fftw_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=C_INT) interface public function fftw_import_wisdom(read_char, data) bind(C, name='fftw_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=C_INT) interface public function fftw_sprint_plan(p) bind(C, name='fftw_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(C_PTR) interface public function fftw_malloc(n) bind(C, name='fftw_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftw_alloc_real(n) bind(C, name='fftw_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftw_alloc_complex(n) bind(C, name='fftw_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftw_estimate_cost(p) bind(C, name='fftw_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE) interface public function fftw_cost(p) bind(C, name='fftw_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE) interface public function fftw_alignment_of(p) bind(C, name='fftw_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), intent(out), dimension(*) :: p Return Value integer(kind=C_INT) interface public subroutine fftw_execute_dft(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out interface public subroutine fftw_execute_split_dft(p, ri, ii, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io interface public subroutine fftw_execute_dft_r2c(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out interface public subroutine fftw_execute_dft_c2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public subroutine fftw_execute_split_dft_r2c(p, in, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io interface public subroutine fftw_execute_split_dft_c2r(p, ri, ii, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public subroutine fftw_execute_r2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public subroutine fftw_destroy_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftw_forget_wisdom() bind(C, name=\"0\") Arguments None interface public subroutine fftw_cleanup() bind(C, name=\"0\") Arguments None interface public subroutine fftw_set_timelimit(t) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t interface public subroutine fftw_plan_with_nthreads(nthreads) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads interface public subroutine fftw_cleanup_threads() bind(C, name=\"0\") Arguments None interface public subroutine fftw_make_planner_thread_safe() bind(C, name=\"0\") Arguments None interface public subroutine fftw_export_wisdom_to_file(output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file interface public subroutine fftw_export_wisdom(write_char, data) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data interface public subroutine fftw_fprint_plan(p, output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file interface public subroutine fftw_print_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftw_free(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftw_flops(p, add, mul, fmas) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas interface public function fftwf_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftwf_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftwf_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftwf_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftwf_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftwf_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftwf_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftwf_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftwf_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_init_threads() bind(C, name='fftwf_init_threads') Arguments None Return Value integer(kind=C_INT) interface public function fftwf_export_wisdom_to_filename(filename) bind(C, name='fftwf_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT) interface public function fftwf_export_wisdom_to_string() bind(C, name='fftwf_export_wisdom_to_string') Arguments None Return Value type(C_PTR) interface public function fftwf_import_system_wisdom() bind(C, name='fftwf_import_system_wisdom') Arguments None Return Value integer(kind=C_INT) interface public function fftwf_import_wisdom_from_filename(filename) bind(C, name='fftwf_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT) interface public function fftwf_import_wisdom_from_file(input_file) bind(C, name='fftwf_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=C_INT) interface public function fftwf_import_wisdom_from_string(input_string) bind(C, name='fftwf_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=C_INT) interface public function fftwf_import_wisdom(read_char, data) bind(C, name='fftwf_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=C_INT) interface public function fftwf_sprint_plan(p) bind(C, name='fftwf_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(C_PTR) interface public function fftwf_malloc(n) bind(C, name='fftwf_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftwf_alloc_real(n) bind(C, name='fftwf_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftwf_alloc_complex(n) bind(C, name='fftwf_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftwf_estimate_cost(p) bind(C, name='fftwf_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE) interface public function fftwf_cost(p) bind(C, name='fftwf_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE) interface public function fftwf_alignment_of(p) bind(C, name='fftwf_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_FLOAT), intent(out), dimension(*) :: p Return Value integer(kind=C_INT) interface public subroutine fftwf_execute_dft(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out interface public subroutine fftwf_execute_split_dft(p, ri, ii, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io interface public subroutine fftwf_execute_dft_r2c(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out interface public subroutine fftwf_execute_dft_c2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public subroutine fftwf_execute_split_dft_r2c(p, in, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io interface public subroutine fftwf_execute_split_dft_c2r(p, ri, ii, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public subroutine fftwf_execute_r2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public subroutine fftwf_destroy_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftwf_forget_wisdom() bind(C, name=\"0\") Arguments None interface public subroutine fftwf_cleanup() bind(C, name=\"0\") Arguments None interface public subroutine fftwf_set_timelimit(t) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t interface public subroutine fftwf_plan_with_nthreads(nthreads) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads interface public subroutine fftwf_cleanup_threads() bind(C, name=\"0\") Arguments None interface public subroutine fftwf_make_planner_thread_safe() bind(C, name=\"0\") Arguments None interface public subroutine fftwf_export_wisdom_to_file(output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file interface public subroutine fftwf_export_wisdom(write_char, data) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data interface public subroutine fftwf_fprint_plan(p, output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file interface public subroutine fftwf_print_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftwf_free(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftwf_flops(p, add, mul, fmas) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas Derived Types type, public, bind(C) :: fftw_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os type, public, bind(C) :: fftw_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os type, public, bind(C) :: fftwf_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os type, public, bind(C) :: fftwf_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os Subroutines public subroutine ftw_init (n1, n2, n3, ind_ft) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ind_ft public subroutine ftw_end () Arguments None public subroutine ftw1d_st (w, n1, n2, n3, is, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir public subroutine ftw1d (w, n1, n2, n3, is, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir public subroutine ft_kern (w, n1, is) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:) integer, intent(in) :: n1 integer, intent(in) :: is public subroutine ftw1d_sc (w, n1, n2, n3, is, dir, sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir integer, intent(in) :: sym","tags":"","loc":"module/legacy_fft_lib.html"},{"title":"modern_fft_lib – ALaDyn","text":"Uses precision_def iso_c_binding module~~modern_fft_lib~~UsesGraph module~modern_fft_lib modern_fft_lib iso_c_binding iso_c_binding module~modern_fft_lib->iso_c_binding module~precision_def precision_def module~modern_fft_lib->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~modern_fft_lib~~UsedByGraph module~modern_fft_lib modern_fft_lib module~prl_fft prl_fft module~prl_fft->module~modern_fft_lib module~psolve psolve module~psolve->module~prl_fft module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~psolve module~pic_out_util pic_out_util module~pic_out_util->module~psolve program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables C_FFTW_R2R_KIND FFTW_R2HC FFTW_HC2R FFTW_DHT FFTW_REDFT00 FFTW_REDFT01 FFTW_REDFT10 FFTW_REDFT11 FFTW_RODFT00 FFTW_RODFT01 FFTW_RODFT10 FFTW_RODFT11 FFTW_FORWARD FFTW_BACKWARD FFTW_MEASURE FFTW_DESTROY_INPUT FFTW_UNALIGNED FFTW_CONSERVE_MEMORY FFTW_EXHAUSTIVE FFTW_PRESERVE_INPUT FFTW_PATIENT FFTW_ESTIMATE FFTW_WISDOM_ONLY FFTW_ESTIMATE_PATIENT FFTW_BELIEVE_PCOST FFTW_NO_DFT_R2HC FFTW_NO_NONTHREADED FFTW_NO_BUFFERING FFTW_NO_INDIRECT_OP FFTW_ALLOW_LARGE_GENERIC FFTW_NO_RANK_SPLITS FFTW_NO_VRANK_SPLITS FFTW_NO_VRECURSE FFTW_NO_SIMD FFTW_NO_SLOW FFTW_NO_FIXED_RADIX_LARGE_N FFTW_ALLOW_PRUNING in1_1d in2_1d in3_1d data1_sc data2_sc data3_sc plan1_s plan1_c plan2_s plan2_c plan3_s plan3_c plan1 iplan1 plan2 iplan2 plan3 iplan3 w1_re w2_re w3_re w1_cplx w2_cplx w3_cplx data1 data2 data3 cw w1_st cfhx sfhx cfhy sfhy cfhz sfhz Interfaces fftw_plan_dft fftw_plan_dft_1d fftw_plan_dft_2d fftw_plan_dft_3d fftw_plan_many_dft fftw_plan_guru_dft fftw_plan_guru_split_dft fftw_plan_guru64_dft fftw_plan_guru64_split_dft fftw_plan_many_dft_r2c fftw_plan_dft_r2c fftw_plan_dft_r2c_1d fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_3d fftw_plan_many_dft_c2r fftw_plan_dft_c2r fftw_plan_dft_c2r_1d fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_3d fftw_plan_guru_dft_r2c fftw_plan_guru_dft_c2r fftw_plan_guru_split_dft_r2c fftw_plan_guru_split_dft_c2r fftw_plan_guru64_dft_r2c fftw_plan_guru64_dft_c2r fftw_plan_guru64_split_dft_r2c fftw_plan_guru64_split_dft_c2r fftw_plan_many_r2r fftw_plan_r2r fftw_plan_r2r_1d fftw_plan_r2r_2d fftw_plan_r2r_3d fftw_plan_guru_r2r fftw_plan_guru64_r2r fftw_init_threads fftw_export_wisdom_to_filename fftw_export_wisdom_to_string fftw_import_system_wisdom fftw_import_wisdom_from_filename fftw_import_wisdom_from_file fftw_import_wisdom_from_string fftw_import_wisdom fftw_sprint_plan fftw_malloc fftw_alloc_real fftw_alloc_complex fftw_estimate_cost fftw_cost fftw_alignment_of fftw_execute_dft fftw_execute_split_dft fftw_execute_dft_r2c fftw_execute_dft_c2r fftw_execute_split_dft_r2c fftw_execute_split_dft_c2r fftw_execute_r2r fftw_destroy_plan fftw_forget_wisdom fftw_cleanup fftw_set_timelimit fftw_plan_with_nthreads fftw_cleanup_threads fftw_make_planner_thread_safe fftw_export_wisdom_to_file fftw_export_wisdom fftw_fprint_plan fftw_print_plan fftw_free fftw_flops fftwf_plan_dft fftwf_plan_dft_1d fftwf_plan_dft_2d fftwf_plan_dft_3d fftwf_plan_many_dft fftwf_plan_guru_dft fftwf_plan_guru_split_dft fftwf_plan_guru64_dft fftwf_plan_guru64_split_dft fftwf_plan_many_dft_r2c fftwf_plan_dft_r2c fftwf_plan_dft_r2c_1d fftwf_plan_dft_r2c_2d fftwf_plan_dft_r2c_3d fftwf_plan_many_dft_c2r fftwf_plan_dft_c2r fftwf_plan_dft_c2r_1d fftwf_plan_dft_c2r_2d fftwf_plan_dft_c2r_3d fftwf_plan_guru_dft_r2c fftwf_plan_guru_dft_c2r fftwf_plan_guru_split_dft_r2c fftwf_plan_guru_split_dft_c2r fftwf_plan_guru64_dft_r2c fftwf_plan_guru64_dft_c2r fftwf_plan_guru64_split_dft_r2c fftwf_plan_guru64_split_dft_c2r fftwf_plan_many_r2r fftwf_plan_r2r fftwf_plan_r2r_1d fftwf_plan_r2r_2d fftwf_plan_r2r_3d fftwf_plan_guru_r2r fftwf_plan_guru64_r2r fftwf_init_threads fftwf_export_wisdom_to_filename fftwf_export_wisdom_to_string fftwf_import_system_wisdom fftwf_import_wisdom_from_filename fftwf_import_wisdom_from_file fftwf_import_wisdom_from_string fftwf_import_wisdom fftwf_sprint_plan fftwf_malloc fftwf_alloc_real fftwf_alloc_complex fftwf_estimate_cost fftwf_cost fftwf_alignment_of fftwf_execute_dft fftwf_execute_split_dft fftwf_execute_dft_r2c fftwf_execute_dft_c2r fftwf_execute_split_dft_r2c fftwf_execute_split_dft_c2r fftwf_execute_r2r fftwf_destroy_plan fftwf_forget_wisdom fftwf_cleanup fftwf_set_timelimit fftwf_plan_with_nthreads fftwf_cleanup_threads fftwf_make_planner_thread_safe fftwf_export_wisdom_to_file fftwf_export_wisdom fftwf_fprint_plan fftwf_print_plan fftwf_free fftwf_flops Derived Types fftw_iodim fftw_iodim64 fftwf_iodim fftwf_iodim64 Functions logical_dimension determine_kind Subroutines ftw_init ftw_end ftw1d_st ftw1d ftw1d_sc Variables Type Visibility Attributes Name Initial integer, public, parameter :: C_FFTW_R2R_KIND = C_INT32_T integer(kind=C_INT), public, parameter :: FFTW_R2HC = 0 integer(kind=C_INT), public, parameter :: FFTW_HC2R = 1 integer(kind=C_INT), public, parameter :: FFTW_DHT = 2 integer(kind=C_INT), public, parameter :: FFTW_REDFT00 = 3 integer(kind=C_INT), public, parameter :: FFTW_REDFT01 = 4 integer(kind=C_INT), public, parameter :: FFTW_REDFT10 = 5 integer(kind=C_INT), public, parameter :: FFTW_REDFT11 = 6 integer(kind=C_INT), public, parameter :: FFTW_RODFT00 = 7 integer(kind=C_INT), public, parameter :: FFTW_RODFT01 = 8 integer(kind=C_INT), public, parameter :: FFTW_RODFT10 = 9 integer(kind=C_INT), public, parameter :: FFTW_RODFT11 = 10 integer(kind=C_INT), public, parameter :: FFTW_FORWARD = -1 integer(kind=C_INT), public, parameter :: FFTW_BACKWARD = +1 integer(kind=C_INT), public, parameter :: FFTW_MEASURE = 0 integer(kind=C_INT), public, parameter :: FFTW_DESTROY_INPUT = 1 integer(kind=C_INT), public, parameter :: FFTW_UNALIGNED = 2 integer(kind=C_INT), public, parameter :: FFTW_CONSERVE_MEMORY = 4 integer(kind=C_INT), public, parameter :: FFTW_EXHAUSTIVE = 8 integer(kind=C_INT), public, parameter :: FFTW_PRESERVE_INPUT = 16 integer(kind=C_INT), public, parameter :: FFTW_PATIENT = 32 integer(kind=C_INT), public, parameter :: FFTW_ESTIMATE = 64 integer(kind=C_INT), public, parameter :: FFTW_WISDOM_ONLY = 2097152 integer(kind=C_INT), public, parameter :: FFTW_ESTIMATE_PATIENT = 128 integer(kind=C_INT), public, parameter :: FFTW_BELIEVE_PCOST = 256 integer(kind=C_INT), public, parameter :: FFTW_NO_DFT_R2HC = 512 integer(kind=C_INT), public, parameter :: FFTW_NO_NONTHREADED = 1024 integer(kind=C_INT), public, parameter :: FFTW_NO_BUFFERING = 2048 integer(kind=C_INT), public, parameter :: FFTW_NO_INDIRECT_OP = 4096 integer(kind=C_INT), public, parameter :: FFTW_ALLOW_LARGE_GENERIC = 8192 integer(kind=C_INT), public, parameter :: FFTW_NO_RANK_SPLITS = 16384 integer(kind=C_INT), public, parameter :: FFTW_NO_VRANK_SPLITS = 32768 integer(kind=C_INT), public, parameter :: FFTW_NO_VRECURSE = 65536 integer(kind=C_INT), public, parameter :: FFTW_NO_SIMD = 131072 integer(kind=C_INT), public, parameter :: FFTW_NO_SLOW = 262144 integer(kind=C_INT), public, parameter :: FFTW_NO_FIXED_RADIX_LARGE_N = 524288 integer(kind=C_INT), public, parameter :: FFTW_ALLOW_PRUNING = 1048576 real(kind=C_DOUBLE), public, pointer :: in1_1d (:) Array for the FFT along x real(kind=C_DOUBLE), public, pointer :: in2_1d (:) Array for the FFT along y real(kind=C_DOUBLE), public, pointer :: in3_1d (:) Array for the FFT along z type(C_PTR), public :: data1_sc C Pointers assigned to the arrays type(C_PTR), public :: data2_sc C Pointers assigned to the arrays type(C_PTR), public :: data3_sc C Pointers assigned to the arrays type(C_PTR), public :: plan1_s Plans of the sine and cosine FFT along x type(C_PTR), public :: plan1_c Plans of the sine and cosine FFT along x type(C_PTR), public :: plan2_s Plans of the sine and cosine FFT along y type(C_PTR), public :: plan2_c Plans of the sine and cosine FFT along y type(C_PTR), public :: plan3_s Plans of the sine and cosine FFT along z type(C_PTR), public :: plan3_c Plans of the sine and cosine FFT along z type(C_PTR), public :: plan1 type(C_PTR), public :: iplan1 type(C_PTR), public :: plan2 type(C_PTR), public :: iplan2 type(C_PTR), public :: plan3 type(C_PTR), public :: iplan3 real(kind=C_DOUBLE), public, pointer :: w1_re (:) real(kind=C_DOUBLE), public, pointer :: w2_re (:) real(kind=C_DOUBLE), public, pointer :: w3_re (:) complex(kind=C_DOUBLE_COMPLEX), public, pointer :: w1_cplx (:) complex(kind=C_DOUBLE_COMPLEX), public, pointer :: w2_cplx (:) complex(kind=C_DOUBLE_COMPLEX), public, pointer :: w3_cplx (:) type(C_PTR), public :: data1 type(C_PTR), public :: data2 type(C_PTR), public :: data3 real(kind=dp), public, allocatable :: cw (:,:) real(kind=dp), public, allocatable :: w1_st (:) real(kind=dp), public, allocatable :: cfhx (:) real(kind=dp), public, allocatable :: sfhx (:) real(kind=dp), public, allocatable :: cfhy (:) real(kind=dp), public, allocatable :: sfhy (:) real(kind=dp), public, allocatable :: cfhz (:) real(kind=dp), public, allocatable :: sfhz (:) Interfaces interface public function fftw_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftw_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftw_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftw_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftw_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftw_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftw_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftw_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftw_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftw_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftw_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftw_init_threads() bind(C, name='fftw_init_threads') Arguments None Return Value integer(kind=C_INT) interface public function fftw_export_wisdom_to_filename(filename) bind(C, name='fftw_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT) interface public function fftw_export_wisdom_to_string() bind(C, name='fftw_export_wisdom_to_string') Arguments None Return Value type(C_PTR) interface public function fftw_import_system_wisdom() bind(C, name='fftw_import_system_wisdom') Arguments None Return Value integer(kind=C_INT) interface public function fftw_import_wisdom_from_filename(filename) bind(C, name='fftw_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT) interface public function fftw_import_wisdom_from_file(input_file) bind(C, name='fftw_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=C_INT) interface public function fftw_import_wisdom_from_string(input_string) bind(C, name='fftw_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=C_INT) interface public function fftw_import_wisdom(read_char, data) bind(C, name='fftw_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=C_INT) interface public function fftw_sprint_plan(p) bind(C, name='fftw_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(C_PTR) interface public function fftw_malloc(n) bind(C, name='fftw_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftw_alloc_real(n) bind(C, name='fftw_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftw_alloc_complex(n) bind(C, name='fftw_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftw_estimate_cost(p) bind(C, name='fftw_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE) interface public function fftw_cost(p) bind(C, name='fftw_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE) interface public function fftw_alignment_of(p) bind(C, name='fftw_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), intent(out), dimension(*) :: p Return Value integer(kind=C_INT) interface public subroutine fftw_execute_dft(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out interface public subroutine fftw_execute_split_dft(p, ri, ii, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io interface public subroutine fftw_execute_dft_r2c(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out interface public subroutine fftw_execute_dft_c2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public subroutine fftw_execute_split_dft_r2c(p, in, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io interface public subroutine fftw_execute_split_dft_c2r(p, ri, ii, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public subroutine fftw_execute_r2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface public subroutine fftw_destroy_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftw_forget_wisdom() bind(C, name=\"0\") Arguments None interface public subroutine fftw_cleanup() bind(C, name=\"0\") Arguments None interface public subroutine fftw_set_timelimit(t) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t interface public subroutine fftw_plan_with_nthreads(nthreads) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads interface public subroutine fftw_cleanup_threads() bind(C, name=\"0\") Arguments None interface public subroutine fftw_make_planner_thread_safe() bind(C, name=\"0\") Arguments None interface public subroutine fftw_export_wisdom_to_file(output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file interface public subroutine fftw_export_wisdom(write_char, data) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data interface public subroutine fftw_fprint_plan(p, output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file interface public subroutine fftw_print_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftw_free(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftw_flops(p, add, mul, fmas) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas interface public function fftwf_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftwf_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftwf_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftwf_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftwf_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftwf_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftwf_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftwf_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftwf_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(C_PTR) interface public function fftwf_init_threads() bind(C, name='fftwf_init_threads') Arguments None Return Value integer(kind=C_INT) interface public function fftwf_export_wisdom_to_filename(filename) bind(C, name='fftwf_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT) interface public function fftwf_export_wisdom_to_string() bind(C, name='fftwf_export_wisdom_to_string') Arguments None Return Value type(C_PTR) interface public function fftwf_import_system_wisdom() bind(C, name='fftwf_import_system_wisdom') Arguments None Return Value integer(kind=C_INT) interface public function fftwf_import_wisdom_from_filename(filename) bind(C, name='fftwf_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=C_INT) interface public function fftwf_import_wisdom_from_file(input_file) bind(C, name='fftwf_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=C_INT) interface public function fftwf_import_wisdom_from_string(input_string) bind(C, name='fftwf_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=C_INT) interface public function fftwf_import_wisdom(read_char, data) bind(C, name='fftwf_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=C_INT) interface public function fftwf_sprint_plan(p) bind(C, name='fftwf_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(C_PTR) interface public function fftwf_malloc(n) bind(C, name='fftwf_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftwf_alloc_real(n) bind(C, name='fftwf_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftwf_alloc_complex(n) bind(C, name='fftwf_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(C_PTR) interface public function fftwf_estimate_cost(p) bind(C, name='fftwf_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE) interface public function fftwf_cost(p) bind(C, name='fftwf_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=C_DOUBLE) interface public function fftwf_alignment_of(p) bind(C, name='fftwf_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_FLOAT), intent(out), dimension(*) :: p Return Value integer(kind=C_INT) interface public subroutine fftwf_execute_dft(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out interface public subroutine fftwf_execute_split_dft(p, ri, ii, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io interface public subroutine fftwf_execute_dft_r2c(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out interface public subroutine fftwf_execute_dft_c2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public subroutine fftwf_execute_split_dft_r2c(p, in, ro, io) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io interface public subroutine fftwf_execute_split_dft_c2r(p, ri, ii, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public subroutine fftwf_execute_r2r(p, in, out) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out interface public subroutine fftwf_destroy_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftwf_forget_wisdom() bind(C, name=\"0\") Arguments None interface public subroutine fftwf_cleanup() bind(C, name=\"0\") Arguments None interface public subroutine fftwf_set_timelimit(t) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t interface public subroutine fftwf_plan_with_nthreads(nthreads) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads interface public subroutine fftwf_cleanup_threads() bind(C, name=\"0\") Arguments None interface public subroutine fftwf_make_planner_thread_safe() bind(C, name=\"0\") Arguments None interface public subroutine fftwf_export_wisdom_to_file(output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file interface public subroutine fftwf_export_wisdom(write_char, data) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data interface public subroutine fftwf_fprint_plan(p, output_file) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file interface public subroutine fftwf_print_plan(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftwf_free(p) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface public subroutine fftwf_flops(p, add, mul, fmas) bind(C, name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas Derived Types type, public, bind(C) :: fftw_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os type, public, bind(C) :: fftw_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os type, public, bind(C) :: fftwf_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: n integer(kind=C_INT), public :: is integer(kind=C_INT), public :: os type, public, bind(C) :: fftwf_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: os Functions public pure function logical_dimension (kind_flag, N) result(log_dim) Returns the logical dimension given the FFT Kind.\n To be generalized for other applications than\n FFTW_RODFT00 and FFTW_REDFT00 Arguments Type Intent Optional Attributes Name integer(kind=C_INTPTR_T), intent(in) :: kind_flag integer, intent(in) :: N Return Value integer public pure function determine_kind (sym_index) result(kind) Converts the integer flag sym into the proper FFT kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: sym_index Return Value integer(kind=C_INTPTR_T) Subroutines public subroutine ftw_init (n1, n2, n3, ind_ft) Initialization of all the FFT variables and plans Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ind_ft public subroutine ftw_end () Routines that ends all the FFTs. It destroys the existing plans\n and deallocates the arrays. Arguments None public subroutine ftw1d_st (w, n1, n2, n3, is, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) WARNING: Not used in the code, need to be checked integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir public subroutine ftw1d (w, n1, n2, n3, is, dir) WARNING: Still to be checked Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir public subroutine ftw1d_sc (w, n1, n2, n3, is, dir, sym) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: w (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: is integer, intent(in) :: dir integer, intent(in) :: sym","tags":"","loc":"module/modern_fft_lib.html"},{"title":"grid_part_lib – ALaDyn","text":"Uses common_param grid_param stretched_grid module~~grid_part_lib~~UsesGraph module~grid_part_lib grid_part_lib module~common_param common_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~grid_param grid_param module~grid_part_lib->module~grid_param module~precision_def precision_def module~common_param->module~precision_def module~stretched_grid->module~common_param module~stretched_grid->module~grid_param module~mpi_var mpi_var module~stretched_grid->module~mpi_var module~struct_def struct_def module~grid_param->module~struct_def module~grid_param->module~precision_def module~struct_def->module~precision_def module~mpi_var->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid_part_lib~~UsedByGraph module~grid_part_lib grid_part_lib module~grid_part_connect grid_part_connect module~grid_part_connect->module~grid_part_lib module~grid_part_util grid_part_util module~grid_part_util->module~grid_part_lib module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~grid_part_util module~pic_out_util pic_out_util module~pic_out_util->module~grid_part_util module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~grid_part_connect program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_evolve->module~curr_and_fields_util module~env_evolve->module~curr_and_fields_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables half thr two_third one_sixth shx shy shz err_ind Subroutines set_int_pshape set_hint_pshape qlh_2d_spline qqh_1d_spline qqh_2d_spline qlh_3d_spline qqh_3d_spline qden_1d_wgh qden_2d_wgh cden_2d_wgh qden_3d_wgh cden_3d_wgh set_local_2d_positions set_local_3d_positions Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: half = 0.5 real(kind=dp), public, parameter :: thr = 0.75 real(kind=dp), public, parameter :: two_third = 2./3. real(kind=dp), public, parameter :: one_sixth = 1./6. real(kind=sp), public, parameter :: shx = 3. real(kind=sp), public, parameter :: shy = 3. real(kind=sp), public, parameter :: shz = 3. integer(kind=2), public :: err_ind Subroutines public subroutine set_int_pshape (spl, xx, ax, ind) Arguments Type Intent Optional Attributes Name integer, intent(in) :: spl real(kind=dp), intent(in) :: xx real(kind=dp), intent(out) :: ax (0:3) integer, intent(out) :: ind public subroutine set_hint_pshape (spl, xx, ax, ind) Arguments Type Intent Optional Attributes Name integer, intent(in) :: spl real(kind=dp), intent(in) :: xx real(kind=dp), intent(out) :: ax (0:3) integer, intent(out) :: ind public subroutine qlh_2d_spline (xp, ax, axh, ay, ayh, ix, ihx, iy, ihy) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:1) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: ayh (0:1) integer, intent(inout) :: ix integer, intent(inout) :: ihx integer, intent(inout) :: iy integer, intent(inout) :: ihy public subroutine qqh_1d_spline (xp, ax, axh, ix, ihx) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:2) integer, intent(inout) :: ix integer, intent(inout) :: ihx public subroutine qqh_2d_spline (xp, ax, axh, ay, ayh, ix, ihx, iy, ihy) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:2) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: ayh (0:2) integer, intent(inout) :: ix integer, intent(inout) :: ihx integer, intent(inout) :: iy integer, intent(inout) :: ihy public subroutine qlh_3d_spline (xp, ax, axh, ay, ayh, az, azh, ix, ihx, iy, ihy, iz, ihz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:1) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: ayh (0:1) real(kind=dp), intent(inout) :: az (0:2) real(kind=dp), intent(inout) :: azh (0:1) integer, intent(inout) :: ix integer, intent(inout) :: ihx integer, intent(inout) :: iy integer, intent(inout) :: ihy integer, intent(inout) :: iz integer, intent(inout) :: ihz public subroutine qqh_3d_spline (xp, ax, axh, ay, ayh, az, azh, ix, ihx, iy, ihy, iz, ihz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: axh (0:2) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: ayh (0:2) real(kind=dp), intent(inout) :: az (0:2) real(kind=dp), intent(inout) :: azh (0:2) integer, intent(inout) :: ix integer, intent(inout) :: ihx integer, intent(inout) :: iy integer, intent(inout) :: ihy integer, intent(inout) :: iz integer, intent(inout) :: ihz public subroutine qden_1d_wgh (xp, ax, ix) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) integer, intent(inout) :: ix public subroutine qden_2d_wgh (xp, ax, ay, ix, iy) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: ay (0:2) integer, intent(inout) :: ix integer, intent(inout) :: iy public subroutine cden_2d_wgh (xp, ax, ay, ix, iy) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:3) real(kind=dp), intent(inout) :: ay (0:3) integer, intent(inout) :: ix integer, intent(inout) :: iy public subroutine qden_3d_wgh (xp, ax, ay, az, ix, iy, iz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:2) real(kind=dp), intent(inout) :: ay (0:2) real(kind=dp), intent(inout) :: az (0:2) integer, intent(inout) :: ix integer, intent(inout) :: iy integer, intent(inout) :: iz public subroutine cden_3d_wgh (xp, ax, ay, az, ix, iy, iz) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: xp (:) real(kind=dp), intent(inout) :: ax (0:3) real(kind=dp), intent(inout) :: ay (0:3) real(kind=dp), intent(inout) :: az (0:3) integer, intent(inout) :: ix integer, intent(inout) :: iy integer, intent(inout) :: iz public subroutine set_local_2d_positions (pt_loc, n1, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt_loc (:,:) integer, intent(in) :: n1 integer, intent(in) :: np public subroutine set_local_3d_positions (pt_loc, n1, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt_loc (:,:) integer, intent(in) :: n1 integer, intent(in) :: np","tags":"","loc":"module/grid_part_lib.html"},{"title":"grid_part_util – ALaDyn","text":"Uses pstruct_data fstruct_data grid_part_lib module~~grid_part_util~~UsesGraph module~grid_part_util grid_part_util module~pstruct_data pstruct_data module~grid_part_util->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_util->module~grid_part_lib module~fstruct_data fstruct_data module~grid_part_util->module~fstruct_data module~precision_def precision_def module~pstruct_data->module~precision_def module~struct_def struct_def module~pstruct_data->module~struct_def module~grid_param grid_param module~grid_part_lib->module~grid_param module~common_param common_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~fstruct_data->module~precision_def module~grid_param->module~precision_def module~grid_param->module~struct_def module~common_param->module~precision_def module~struct_def->module~precision_def module~stretched_grid->module~grid_param module~stretched_grid->module~common_param module~mpi_var mpi_var module~stretched_grid->module~mpi_var module~mpi_var->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid_part_util~~UsedByGraph module~grid_part_util grid_part_util module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~grid_part_util module~pic_out_util pic_out_util module~pic_out_util->module~grid_part_util program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines set_part_gamma set_part_velocities set_ho_grid_charge set_charge_on_ftgrid set_grid_charge set_grid_env_den_energy set_grid_den_energy set_grid_charge_and_jx Subroutines public subroutine set_part_gamma (pt_loc, np, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt_loc (:,:) integer, intent(in) :: np integer, intent(in) :: nc public subroutine set_part_velocities (pt_loc, np, njc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: pt_loc (:,:) integer, intent(in) :: np integer, intent(in) :: njc public subroutine set_ho_grid_charge (sp_loc, pt, den, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: den (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: ic public subroutine set_charge_on_ftgrid (sp_loc, pt, den, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: den (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: ic public subroutine set_grid_charge (sp_loc, pt, den, np, ic) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: den (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: ic public subroutine set_grid_env_den_energy (sp_loc, pt, eden, np, icp) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: eden (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: icp public subroutine set_grid_den_energy (sp_loc, pt, eden, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: eden (:,:,:,:) integer, intent(in) :: np public subroutine set_grid_charge_and_jx (sp_loc, pt, eden, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: eden (:,:,:,:) integer, intent(in) :: np","tags":"","loc":"module/grid_part_util.html"},{"title":"grid_part_connect – ALaDyn","text":"Uses pstruct_data fstruct_data grid_part_lib module~~grid_part_connect~~UsesGraph module~grid_part_connect grid_part_connect module~pstruct_data pstruct_data module~grid_part_connect->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_connect->module~grid_part_lib module~fstruct_data fstruct_data module~grid_part_connect->module~fstruct_data module~precision_def precision_def module~pstruct_data->module~precision_def module~struct_def struct_def module~pstruct_data->module~struct_def module~grid_param grid_param module~grid_part_lib->module~grid_param module~common_param common_param module~grid_part_lib->module~common_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~fstruct_data->module~precision_def module~grid_param->module~precision_def module~grid_param->module~struct_def module~common_param->module~precision_def module~struct_def->module~precision_def module~stretched_grid->module~grid_param module~stretched_grid->module~common_param module~mpi_var mpi_var module~stretched_grid->module~mpi_var module~mpi_var->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid_part_connect~~UsedByGraph module~grid_part_connect grid_part_connect module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~grid_part_connect module~pic_evolve pic_evolve module~pic_evolve->module~curr_and_fields_util module~env_evolve env_evolve module~env_evolve->module~curr_and_fields_util program~aladyn aladyn program~aladyn->module~pic_evolve program~aladyn->module~env_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines set_part1d_acc set_part2d_hcell_acc set_part3d_hcell_acc set_ion_efield set_env_acc set_ion_env_field set_env_grad_interp set_env_density esirkepov_2d_curr esirkepov_3d_curr ncdef_2d_curr ncdef_3d_curr Subroutines public subroutine set_part1d_acc (ef, sp_loc, pt, np, ndf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ndf public subroutine set_part2d_hcell_acc (ef, sp_loc, pt, np, ndf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ndf public subroutine set_part3d_hcell_acc (ef, sp_loc, pt, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np public subroutine set_ion_efield (ef, sp_loc, pt, np) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np public subroutine set_env_acc (ef, av, sp_loc, pt, np, dt_step) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) real(kind=dp), intent(in) :: av (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np real(kind=dp), intent(in) :: dt_step public subroutine set_ion_env_field (ef, sp_loc, pt, np, om0) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np real(kind=dp), intent(in) :: om0 public subroutine set_env_grad_interp (av, sp_loc, pt, np, ndm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: av (:,:,:,:) type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) integer, intent(in) :: np integer, intent(in) :: ndm public subroutine set_env_density (efp, av, np, ic) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: efp (:,:) real(kind=dp), intent(inout) :: av (:,:,:,:) integer, intent(in) :: np integer, intent(in) :: ic public subroutine esirkepov_2d_curr (sp_loc, pt, jcurr, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: jcurr (:,:,:,:) integer, intent(in) :: np public subroutine esirkepov_3d_curr (sp_loc, pt, jcurr, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: jcurr (:,:,:,:) integer, intent(in) :: np public subroutine ncdef_2d_curr (sp_loc, pt, jcurr, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: jcurr (:,:,:,:) integer, intent(in) :: np public subroutine ncdef_3d_curr (sp_loc, pt, jcurr, np) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: pt (:,:) real(kind=dp), intent(inout) :: jcurr (:,:,:,:) integer, intent(in) :: np","tags":"","loc":"module/grid_part_connect.html"},{"title":"mpi_curr_interface – ALaDyn","text":"Uses pstruct_data fstruct_data parallel grid_param module~~mpi_curr_interface~~UsesGraph module~mpi_curr_interface mpi_curr_interface module~pstruct_data pstruct_data module~mpi_curr_interface->module~pstruct_data module~parallel parallel module~mpi_curr_interface->module~parallel module~fstruct_data fstruct_data module~mpi_curr_interface->module~fstruct_data module~grid_param grid_param module~mpi_curr_interface->module~grid_param module~precision_def precision_def module~pstruct_data->module~precision_def module~struct_def struct_def module~pstruct_data->module~struct_def module~common_param common_param module~parallel->module~common_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~fstruct_data->module~precision_def module~grid_param->module~precision_def module~grid_param->module~struct_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~util->module~precision_def module~code_util code_util module~util->module~code_util module~struct_def->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mpi_curr_interface~~UsedByGraph module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~mpi_curr_interface module~pic_out_util pic_out_util module~pic_out_util->module~mpi_curr_interface module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~mpi_curr_interface program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_evolve->module~curr_and_fields_util module~env_evolve->module~curr_and_fields_util Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables rt lt Subroutines fill_curr_yzxbdsdata fill_ftcurr_yzbdsdata jc_xyzbd den_zyxbd Variables Type Visibility Attributes Name Initial integer(kind=hp_int), private, parameter :: rt = 1 integer(kind=hp_int), private, parameter :: lt = -1 Subroutines public subroutine fill_curr_yzxbdsdata (curr, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: nc public subroutine fill_ftcurr_yzbdsdata (curr, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: nc public subroutine jc_xyzbd (curr, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: curr (:,:,:,:) integer, intent(in) :: nc public subroutine den_zyxbd (rho, ik) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: rho (:,:,:,:) integer, intent(in) :: ik","tags":"","loc":"module/mpi_curr_interface.html"},{"title":"parallel – ALaDyn","text":"Uses mpi_var common_param util mpi module~~parallel~~UsesGraph module~parallel parallel module~util util module~parallel->module~util module~common_param common_param module~parallel->module~common_param module~mpi_var mpi_var module~parallel->module~mpi_var mpi mpi module~parallel->mpi module~code_util code_util module~util->module~code_util module~precision_def precision_def module~util->module~precision_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~parallel~~UsedByGraph module~parallel parallel module~grid_fields grid_fields module~grid_fields->module~parallel module~run_data_info run_data_info module~run_data_info->module~parallel module~prl_fft prl_fft module~prl_fft->module~parallel module~mpi_field_interface mpi_field_interface module~mpi_field_interface->module~parallel module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~parallel module~pic_out pic_out module~pic_out->module~parallel module~mpi_curr_interface mpi_curr_interface module~mpi_curr_interface->module~parallel module~pic_dump pic_dump module~pic_dump->module~parallel module~mpi_part_interface mpi_part_interface module~mpi_part_interface->module~parallel module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~mpi_field_interface module~init_beam_part_distrib->module~mpi_curr_interface module~psolve psolve module~init_beam_part_distrib->module~psolve module~psolve->module~grid_fields module~psolve->module~prl_fft module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~grid_fields module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~mpi_curr_interface program~aladyn aladyn program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields program~aladyn->module~pic_out program~aladyn->module~init_beam_part_distrib module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~pic_evolve->module~mpi_part_interface module~pic_evolve->module~curr_and_fields_util module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~window window module~pic_evolve->module~window module~start_all->module~run_data_info module~start_all->module~pic_dump module~pic_in pic_in module~start_all->module~pic_in module~env_evolve->module~mpi_part_interface module~env_evolve->module~curr_and_fields_util module~env_evolve->module~fluid_density_momenta module~env_evolve->module~window module~fluid_density_momenta->module~grid_fields module~fluid_density_momenta->module~mpi_field_interface module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~pic_out_util->module~psolve module~window->module~run_data_info module~window->module~mpi_field_interface module~window->module~mpi_part_interface module~init_laser_field init_laser_field module~init_laser_field->module~grid_fields module~pic_in->module~init_laser_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables offset_kind whence mpi_err fp0x fp1x status error mpi_sd Subroutines check_decomposition start_parallel mpi_write_dp mpi_write_row_dp mpi_write_col_dp mpi_read_col_dp mpi_read_dp mpi_write_part mpi_write_part_col mpi_write_field mpi_write_field_col End_parallel exchange_idata exchange_2d_idata exchange_3d_sp_data exchange_1d_grdata exchange_2d_grdata exchange_3d_grdata exchange_grdata realvec_distribute intvec_distribute sr_idata sr_pdata sr_vidata exchange_pdata exchange_rdata exchange_rdata_int vint_2d_bcast vint_bcast int_bcast all_gather_dpreal allreduce_dpreal allreduce_big_int allreduce_sint allreduce_vint bcast_grdata bcast_realv_sum bcast_int_sum real_bcast local_to_global_grdata exchange_bd_3d_data exchange_bdx_data processor_grid_diag Variables Type Visibility Attributes Name Initial integer, public, parameter :: offset_kind = mpi_offset_kind integer, public, parameter :: whence = mpi_seek_set integer, public :: mpi_err real(kind=dp), public, allocatable :: fp0x (:,:,:,:) real(kind=dp), public, allocatable :: fp1x (:,:,:,:) integer, public :: status (mpi_status_size) integer, public :: error integer, public :: mpi_sd Subroutines public subroutine check_decomposition () Arguments None public subroutine start_parallel (ncmp, p_ind, b_ind) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncmp integer, intent(in) :: p_ind integer, intent(in) :: b_ind public subroutine mpi_write_dp (buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine mpi_write_row_dp (buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine mpi_write_col_dp (buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine mpi_read_col_dp (buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine mpi_read_dp (buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine mpi_write_part (buf, bufsize, loc_np, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer, intent(in) :: loc_np integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine mpi_write_part_col (buf, bufsize, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine mpi_write_field (buf, bufsize, header, header_size, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer, intent(in) :: header (:) integer, intent(in) :: header_size integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine mpi_write_field_col (buf, bufsize, header, header_size, disp, nchar, fout) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: buf (:) integer, intent(in) :: bufsize integer, intent(in) :: header (:) integer, intent(in) :: header_size integer(kind=offset_kind), intent(in) :: disp integer, intent(in) :: nchar character(len=nchar), intent(in) :: fout public subroutine End_parallel () Arguments None public subroutine exchange_idata (sr, idat, lenw, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr integer, intent(inout) :: idat (:) integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: tag public subroutine exchange_2d_idata (sr, idat, n1, n2, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr integer, intent(inout) :: idat (:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: ipe integer, intent(in) :: tag public subroutine exchange_3d_sp_data (sr, dat0, n1, n2, n3, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=sp), intent(inout) :: dat0 (:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: ipe integer, intent(in) :: tag public subroutine exchange_1d_grdata (sr, dat0, lenw, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=dp), intent(inout) :: dat0 (:) integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: tag public subroutine exchange_2d_grdata (sr, dat0, n1, n2, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=dp), intent(inout) :: dat0 (:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: ipe integer, intent(in) :: tag public subroutine exchange_3d_grdata (sr, dat0, lenw, dir, ipe) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=dp), intent(inout) :: dat0 (:,:,:) integer, intent(in) :: lenw integer, intent(in) :: dir integer, intent(in) :: ipe public subroutine exchange_grdata (sr, dat0, lenw, dir, ipe) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=dp), intent(inout) :: dat0 (:,:,:,:) integer, intent(in) :: lenw integer, intent(in) :: dir integer, intent(in) :: ipe public subroutine realvec_distribute (rs, rv, nproc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: rs real(kind=dp) :: rv (:) integer, intent(in) :: nproc public subroutine intvec_distribute (ns, nc, nproc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ns integer, intent(inout) :: nc (:) integer, intent(in) :: nproc public subroutine sr_idata (ns, nr, dir, side) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ns integer, intent(out) :: nr integer, intent(in) :: dir integer, intent(in) :: side public subroutine sr_pdata (sdata, rdata, ns, nr, dir, side) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sdata (:) real(kind=dp), intent(out) :: rdata (:) integer, intent(in) :: ns integer, intent(in) :: nr integer, intent(in) :: dir integer, intent(in) :: side public subroutine sr_vidata (sidat, ridat, n2, n3, dir, side) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sidat (n2,n3) integer, intent(out) :: ridat (n2,n3) integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: dir integer, intent(in) :: side public subroutine exchange_pdata (sr, pdata, lenw, ipe, tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: sr real(kind=sp), intent(inout) :: pdata (:) integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: tag public subroutine exchange_rdata (buff, sr, lenw, ipe, dir, tag) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: buff (:) logical, intent(in) :: sr integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: dir integer, intent(in) :: tag public subroutine exchange_rdata_int (buff, sr, lenw, ipe, dir, tag) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: buff (:) logical, intent(in) :: sr integer, intent(in) :: lenw integer, intent(in) :: ipe integer, intent(in) :: dir integer, intent(in) :: tag public subroutine vint_2d_bcast (mydat, n1, n2) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :) :: mydat integer, intent(in) :: n1 integer, intent(in) :: n2 public subroutine vint_bcast (mydat, nt) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: mydat (nt) integer, intent(in) :: nt public subroutine int_bcast (mydat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mydat public subroutine all_gather_dpreal (rv_send, rv_recv, dir, nt) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: rv_send (:) real(kind=dp), intent(inout) :: rv_recv (:) integer, intent(in) :: dir integer, intent(in) :: nt public subroutine allreduce_dpreal (ib, rv_loc, rv, nt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ib real(kind=dp), intent(in) :: rv_loc (:) real(kind=dp), intent(out) :: rv (:) integer, intent(in) :: nt public subroutine allreduce_big_int (n0, n1) Arguments Type Intent Optional Attributes Name integer(kind=dp), intent(in) :: n0 integer(kind=dp), intent(out) :: n1 public subroutine allreduce_sint (ib, dt0, dt_tot) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ib integer, intent(in) :: dt0 integer, intent(out) :: dt_tot public subroutine allreduce_vint (ib, dt0, dt_tot, nt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ib integer, intent(in) :: dt0 (nt) integer, intent(out) :: dt_tot (nt) integer, intent(in) :: nt public subroutine bcast_grdata (dat0, n1, n2, n3, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dat0 (:,:,:,:) integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: nc public subroutine bcast_realv_sum (ib, dt_prl, dt_tot, nt) Arguments Type Intent Optional Attributes Name logical, intent(in) :: ib real(kind=dp), intent(in) :: dt_prl (nt) real(kind=dp), intent(out) :: dt_tot (nt) integer, intent(in) :: nt public subroutine bcast_int_sum (dt_prl, dt_tot) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dt_prl integer, intent(out) :: dt_tot public subroutine real_bcast (dt_tot, ndt) Arguments Type Intent Optional Attributes Name real(kind=dp) :: dt_tot (ndt) integer, intent(in) :: ndt public subroutine local_to_global_grdata (buff1, buff2, lenws, ip, dir) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buff1 (:) real(kind=dp), intent(out) :: buff2 (:) integer, intent(in) :: lenws integer, intent(in) :: ip integer, intent(in) :: dir public subroutine exchange_bd_3d_data (buff1, lenws, buff2, lenwr, dir, side) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buff1 (:,:,:) integer, intent(in) :: lenws real(kind=dp), intent(out) :: buff2 (:,:,:) integer, intent(in) :: lenwr integer, intent(in) :: dir integer(kind=hp_int), intent(in) :: side public subroutine exchange_bdx_data (buff1, buff2, lenws, lenwr, dir, side) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: buff1 (:) real(kind=dp), intent(out) :: buff2 (:) integer, intent(in) :: lenws integer, intent(in) :: lenwr integer, intent(in) :: dir integer(kind=hp_int), intent(in) :: side public subroutine processor_grid_diag () Arguments None","tags":"","loc":"module/parallel.html"},{"title":"mpi_var – ALaDyn","text":"Uses precision_def module~~mpi_var~~UsesGraph module~mpi_var mpi_var module~precision_def precision_def module~mpi_var->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mpi_var~~UsedByGraph module~mpi_var mpi_var module~ionize ionize module~ionize->module~mpi_var module~parallel parallel module~parallel->module~mpi_var module~init_part_distrib init_part_distrib module~init_part_distrib->module~mpi_var module~set_grid_param set_grid_param module~set_grid_param->module~mpi_var module~read_input read_input module~read_input->module~mpi_var module~system_utilities system_utilities module~system_utilities->module~mpi_var module~grid_field_param grid_field_param module~grid_field_param->module~mpi_var module~stretched_grid stretched_grid module~stretched_grid->module~mpi_var module~grid_fields grid_fields module~grid_fields->module~parallel module~grid_fields->module~grid_field_param module~pic_evolve pic_evolve module~pic_evolve->module~ionize module~init_grid_field init_grid_field module~pic_evolve->module~init_grid_field module~mpi_part_interface mpi_part_interface module~pic_evolve->module~mpi_part_interface module~curr_and_fields_util curr_and_fields_util module~pic_evolve->module~curr_and_fields_util module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~window window module~pic_evolve->module~window module~start_all start_all module~start_all->module~ionize module~start_all->module~set_grid_param module~start_all->module~read_input module~start_all->module~system_utilities module~set_init_param set_init_param module~start_all->module~set_init_param module~pic_in pic_in module~start_all->module~pic_in module~run_data_info run_data_info module~start_all->module~run_data_info module~pic_dump pic_dump module~start_all->module~pic_dump module~env_evolve env_evolve module~env_evolve->module~ionize module~env_evolve->module~mpi_part_interface module~env_evolve->module~curr_and_fields_util module~env_evolve->module~fluid_density_momenta module~env_evolve->module~window module~set_init_param->module~set_grid_param module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~run_data_info->module~parallel module~prl_fft prl_fft module~prl_fft->module~parallel module~mpi_field_interface mpi_field_interface module~mpi_field_interface->module~parallel module~diag_part_and_fields diag_part_and_fields module~diag_part_and_fields->module~parallel module~pic_out pic_out module~pic_out->module~parallel module~mpi_curr_interface mpi_curr_interface module~mpi_curr_interface->module~parallel module~init_grid_field->module~grid_field_param module~grid_part_lib grid_part_lib module~grid_part_lib->module~stretched_grid module~pic_dump->module~parallel module~mpi_part_interface->module~parallel module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~mpi_field_interface module~init_beam_part_distrib->module~mpi_curr_interface module~init_beam_part_distrib->module~init_grid_field module~psolve psolve module~init_beam_part_distrib->module~psolve module~grid_part_util grid_part_util module~init_beam_part_distrib->module~grid_part_util module~psolve->module~grid_fields module~psolve->module~prl_fft module~curr_and_fields_util->module~grid_fields module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~mpi_curr_interface module~curr_and_fields_util->module~init_grid_field module~grid_part_connect grid_part_connect module~curr_and_fields_util->module~grid_part_connect program~aladyn aladyn program~aladyn->module~pic_evolve program~aladyn->module~start_all program~aladyn->module~env_evolve program~aladyn->module~run_data_info program~aladyn->module~diag_part_and_fields program~aladyn->module~pic_out program~aladyn->module~init_beam_part_distrib module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~fluid_density_momenta->module~grid_fields module~fluid_density_momenta->module~mpi_field_interface module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~pic_out_util->module~psolve module~pic_out_util->module~grid_part_util module~grid_part_connect->module~grid_part_lib module~grid_part_util->module~grid_part_lib module~window->module~run_data_info module~window->module~mpi_field_interface module~window->module~mpi_part_interface module~init_laser_field->module~grid_fields module~init_laser_field->module~init_grid_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables loc_npart loc_nbpart loc_ne_ionz loc_tpart yp_next yp_prev zp_next zp_prev xp_next xp_prev np_max pe_npmax np_min pe_npmin mype imodx imody imodz npe npe_yloc npe_zloc npe_xloc npe_yz mpi_size mpi_rank partype imodzx imodyz imodyx pe_min pe_max pe_min_y pe_max_y pe_min_z pe_max_z pe_min_x pe_max_x ndims dims pe0y pe0z pe1y pe1z pe0 pe1 prl prlx prly prlz xl_bd yl_bd zl_bd xr_bd yr_bd zr_bd pe0x pe1x pex0 pex1 comm coor comm_col col_or Variables Type Visibility Attributes Name Initial integer, public, allocatable :: loc_npart (:,:,:,:) integer, public, allocatable :: loc_nbpart (:,:,:,:) integer, public, allocatable :: loc_ne_ionz (:,:,:) integer, public, allocatable :: loc_tpart (:) integer, public, allocatable :: yp_next (:) integer, public, allocatable :: yp_prev (:) integer, public, allocatable :: zp_next (:) integer, public, allocatable :: zp_prev (:) integer, public, allocatable :: xp_next (:) integer, public, allocatable :: xp_prev (:) integer, public :: np_max integer, public :: pe_npmax integer, public :: np_min integer, public :: pe_npmin integer, public :: mype integer, public :: imodx integer, public :: imody integer, public :: imodz integer, public :: npe integer, public :: npe_yloc integer, public :: npe_zloc integer, public :: npe_xloc integer, public :: npe_yz integer, public :: mpi_size integer, public :: mpi_rank integer, public :: partype integer, public :: imodzx integer, public :: imodyz integer, public :: imodyx integer, public :: pe_min integer, public :: pe_max integer, public :: pe_min_y integer, public :: pe_max_y integer, public :: pe_min_z integer, public :: pe_max_z integer, public :: pe_min_x integer, public :: pe_max_x integer, public :: ndims integer, public :: dims (3) logical, public :: pe0y logical, public :: pe0z logical, public :: pe1y logical, public :: pe1z logical, public :: pe0 logical, public :: pe1 logical, public :: prl logical, public :: prlx logical, public :: prly logical, public :: prlz logical, public :: xl_bd logical, public :: yl_bd logical, public :: zl_bd logical, public :: xr_bd logical, public :: yr_bd logical, public :: zr_bd logical, public :: pe0x logical, public :: pe1x logical, public :: pex0 logical, public :: pex1 integer, public :: comm integer, public :: coor (3) integer, public :: comm_col (3) integer, public :: col_or (3)","tags":"","loc":"module/mpi_var.html"},{"title":"mpi_field_interface – ALaDyn","text":"Uses pstruct_data fstruct_data parallel grid_param module~~mpi_field_interface~~UsesGraph module~mpi_field_interface mpi_field_interface module~pstruct_data pstruct_data module~mpi_field_interface->module~pstruct_data module~parallel parallel module~mpi_field_interface->module~parallel module~fstruct_data fstruct_data module~mpi_field_interface->module~fstruct_data module~grid_param grid_param module~mpi_field_interface->module~grid_param module~precision_def precision_def module~pstruct_data->module~precision_def module~struct_def struct_def module~pstruct_data->module~struct_def module~common_param common_param module~parallel->module~common_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~fstruct_data->module~precision_def module~grid_param->module~precision_def module~grid_param->module~struct_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~util->module~precision_def module~code_util code_util module~util->module~code_util module~struct_def->module~precision_def module~code_util->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mpi_field_interface~~UsedByGraph module~mpi_field_interface mpi_field_interface module~init_beam_part_distrib init_beam_part_distrib module~init_beam_part_distrib->module~mpi_field_interface module~curr_and_fields_util curr_and_fields_util module~curr_and_fields_util->module~mpi_field_interface module~fluid_density_momenta fluid_density_momenta module~fluid_density_momenta->module~mpi_field_interface module~pic_out_util pic_out_util module~pic_out_util->module~mpi_field_interface module~window window module~window->module~mpi_field_interface program~aladyn aladyn program~aladyn->module~init_beam_part_distrib program~aladyn->module~pic_out_util module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_evolve->module~curr_and_fields_util module~pic_evolve->module~fluid_density_momenta module~pic_evolve->module~window module~env_evolve->module~curr_and_fields_util module~env_evolve->module~fluid_density_momenta module~env_evolve->module~window Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x_parity y_parity z_parity lft rgt Subroutines field_xyzbd fluid_left_xshift fields_left_xshift fill_ebfield_yzxbdsdata fill_ebfield_xbdsdata Variables Type Visibility Attributes Name Initial integer, private, parameter :: x_parity (6) = [-1, 1, 1, -1, 1, 1] integer, private, parameter :: y_parity (6) = [1, -1, 1, 1, -1, 1] integer, private, parameter :: z_parity (6) = [1, 1, -1, 1, 1, -1] integer(kind=hp_int), public, parameter :: lft = -1 integer(kind=hp_int), public, parameter :: rgt = 1 Subroutines public subroutine field_xyzbd (ef, nc) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: ef (:,:,:,:) integer, intent(in) :: nc public subroutine fluid_left_xshift (fld, den_x, den_yz, i1, i2, ic1, ic2, xsh) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: fld (:,:,:,:) real(kind=dp), intent(in) :: den_x (:) real(kind=dp), intent(in) :: den_yz (:,:) integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: xsh public subroutine fields_left_xshift (fld, i1, i2, ic1, ic2, xsh) Arguments Type Intent Optional Attributes Name real(kind=dp) :: fld (:,:,:,:) integer, intent(in) :: i1 integer, intent(in) :: i2 integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: xsh public subroutine fill_ebfield_yzxbdsdata (fld, ic1, ic2, str, stl) Arguments Type Intent Optional Attributes Name real(kind=dp) :: fld (:,:,:,:) integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: str integer, intent(in) :: stl public subroutine fill_ebfield_xbdsdata (fld, ic1, ic2, str, stl) Arguments Type Intent Optional Attributes Name real(kind=dp) :: fld (:,:,:,:) integer, intent(in) :: ic1 integer, intent(in) :: ic2 integer, intent(in) :: str integer, intent(in) :: stl","tags":"","loc":"module/mpi_field_interface.html"},{"title":"mpi_part_interface – ALaDyn","text":"Uses array_alloc grid_param code_util parallel module~~mpi_part_interface~~UsesGraph module~mpi_part_interface mpi_part_interface module~parallel parallel module~mpi_part_interface->module~parallel module~code_util code_util module~mpi_part_interface->module~code_util module~array_alloc array_alloc module~mpi_part_interface->module~array_alloc module~grid_param grid_param module~mpi_part_interface->module~grid_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~common_param common_param module~parallel->module~common_param module~precision_def precision_def module~code_util->module~precision_def module~fstruct_data fstruct_data module~array_alloc->module~fstruct_data module~pstruct_data pstruct_data module~array_alloc->module~pstruct_data module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~struct_def->module~precision_def module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_var->module~precision_def module~util->module~code_util module~util->module~precision_def module~common_param->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mpi_part_interface~~UsedByGraph module~mpi_part_interface mpi_part_interface module~pic_evolve pic_evolve module~pic_evolve->module~mpi_part_interface module~window window module~pic_evolve->module~window module~window->module~mpi_part_interface module~env_evolve env_evolve module~env_evolve->module~mpi_part_interface module~env_evolve->module~window program~aladyn aladyn program~aladyn->module~pic_evolve program~aladyn->module~env_evolve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables loc_pstore sp_aux sp1_aux Subroutines traffic_size_eval part_prl_wexchange part_prl_exchange reset_all_part_dist cell_part_dist Variables Type Visibility Attributes Name Initial real(kind=dp), public :: loc_pstore (7) real(kind=dp), public, allocatable :: sp_aux (:,:) real(kind=dp), public, allocatable :: sp1_aux (:,:) Subroutines public subroutine traffic_size_eval (sp_loc, xl, xr, pel, per, ibd, ind, npold, nsr, npnew) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr logical, intent(in) :: pel logical, intent(in) :: per integer, intent(in) :: ibd integer, intent(in) :: ind integer, intent(in) :: npold integer, intent(inout) :: nsr (4) integer, intent(inout) :: npnew public subroutine part_prl_wexchange (sp_loc, xl, xr, xlmin, xrmax, pel, per, ibd, dir, ndv, old_np, n_sr, npt) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr real(kind=dp), intent(in) :: xlmin real(kind=dp), intent(in) :: xrmax logical, intent(in) :: pel logical, intent(in) :: per integer, intent(in) :: ibd integer, intent(in) :: dir integer, intent(in) :: ndv integer, intent(in) :: old_np integer, intent(in) :: n_sr (4) integer, intent(out) :: npt public subroutine part_prl_exchange (sp_loc, vstore, xl, xr, xlmin, xrmax, pel, per, ibd, dir, ndv, old_np, n_sr, npt) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: sp_loc real(kind=dp), intent(in) :: vstore (:,:) real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr real(kind=dp), intent(in) :: xlmin real(kind=dp), intent(in) :: xrmax logical, intent(in) :: pel logical, intent(in) :: per integer, intent(in) :: ibd integer, intent(in) :: dir integer, intent(in) :: ndv integer, intent(in) :: old_np integer, intent(in) :: n_sr (4) integer, intent(out) :: npt public subroutine reset_all_part_dist (loc_sp, pstore, xl, xr, ib, np, ndv, cin, np_new, mwin) Arguments Type Intent Optional Attributes Name type(species), intent(inout) :: loc_sp real(kind=dp), intent(inout) :: pstore (:,:) real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr integer, intent(in) :: ib integer, intent(in) :: np integer, intent(in) :: ndv integer, intent(in) :: cin integer, intent(out) :: np_new logical, intent(in) :: mwin public subroutine cell_part_dist (moving_wind) Arguments Type Intent Optional Attributes Name logical, intent(in) :: moving_wind","tags":"","loc":"module/mpi_part_interface.html"},{"title":"run_data_info – ALaDyn","text":"Uses pstruct_data fstruct_data code_util common_param grid_param ionz_data parallel control_bunch_input phys_param module~~run_data_info~~UsesGraph module~run_data_info run_data_info module~control_bunch_input control_bunch_input module~run_data_info->module~control_bunch_input module~ionz_data ionz_data module~run_data_info->module~ionz_data module~fstruct_data fstruct_data module~run_data_info->module~fstruct_data module~parallel parallel module~run_data_info->module~parallel module~grid_param grid_param module~run_data_info->module~grid_param module~code_util code_util module~run_data_info->module~code_util module~pstruct_data pstruct_data module~run_data_info->module~pstruct_data module~common_param common_param module~run_data_info->module~common_param module~phys_param phys_param module~run_data_info->module~phys_param module~precision_def precision_def module~control_bunch_input->module~precision_def module~ionz_data->module~precision_def module~fstruct_data->module~precision_def module~parallel->module~common_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~code_util->module~precision_def module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~common_param->module~precision_def module~phys_param->module~precision_def module~mpi_var->module~precision_def module~util->module~code_util module~util->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~run_data_info~~UsedByGraph module~run_data_info run_data_info program~aladyn aladyn program~aladyn->module~run_data_info module~start_all start_all program~aladyn->module~start_all module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~env_evolve env_evolve program~aladyn->module~env_evolve module~window window module~window->module~run_data_info module~start_all->module~run_data_info module~pic_evolve->module~window module~env_evolve->module~window Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines timing error_message Part_numbers tot_num_part initial_run_info ioniz_data Final_run_info submem Max_pmemory_check Subroutines public subroutine timing () Arguments None public subroutine error_message () Arguments None public subroutine Part_numbers () Arguments None public subroutine tot_num_part () Arguments None public subroutine initial_run_info (nw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nw public subroutine ioniz_data (ef_max, z0, an, zlev, zmod) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: ef_max integer, intent(in) :: z0 (:) integer, intent(in) :: an (:) integer, intent(in) :: zlev integer, intent(in) :: zmod public subroutine Final_run_info () Arguments None public subroutine submem (rmem) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: rmem public subroutine Max_pmemory_check () Arguments None","tags":"","loc":"module/run_data_info.html"},{"title":"diag_part_and_fields – ALaDyn","text":"Uses pstruct_data fstruct_data code_util phys_param parallel grid_param control_bunch_input module~~diag_part_and_fields~~UsesGraph module~diag_part_and_fields diag_part_and_fields module~control_bunch_input control_bunch_input module~diag_part_and_fields->module~control_bunch_input module~grid_param grid_param module~diag_part_and_fields->module~grid_param module~fstruct_data fstruct_data module~diag_part_and_fields->module~fstruct_data module~parallel parallel module~diag_part_and_fields->module~parallel module~code_util code_util module~diag_part_and_fields->module~code_util module~pstruct_data pstruct_data module~diag_part_and_fields->module~pstruct_data module~phys_param phys_param module~diag_part_and_fields->module~phys_param module~precision_def precision_def module~control_bunch_input->module~precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~common_param common_param module~parallel->module~common_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~code_util->module~precision_def module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~phys_param->module~precision_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~util->module~code_util module~util->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~diag_part_and_fields~~UsedByGraph module~diag_part_and_fields diag_part_and_fields program~aladyn aladyn program~aladyn->module~diag_part_and_fields Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables tloc tsp eavg eavg1 pavg favg ne nde0 nde1 nde2 nde eksp_max nde_sm nde_sp ionz_number hgam_number bunch_number ionz_bavg bunch_bavg tbunch tionz hgam_charge ionz_charge bcharge hgam_bavg tgam Subroutines track_part_pdata_out energy_spect select_energy_spect energy_momenta laser_struct_data envelope_struct_data fields_on_target Envar bunch_corr enb_bunch enb_ionz enb_hgam en_data general_en_data en_bdata en_ionz_data en_high_gamma_data Variables Type Visibility Attributes Name Initial real(kind=dp), public :: tloc (10000) real(kind=dp), public :: tsp (1:1001) real(kind=dp), public :: eavg (10,1001) real(kind=dp), public :: eavg1 (10,1001) real(kind=dp), public :: pavg (15,1001,4) real(kind=dp), public :: favg (30,1001) integer, public, parameter :: ne = 100 real(kind=dp), public :: nde0 (ne) real(kind=dp), public :: nde1 (ne) real(kind=dp), public :: nde2 (ne) real(kind=dp), public :: nde (ne,500,4) real(kind=dp), public :: eksp_max (500,4) real(kind=dp), public :: nde_sm (ne,500,4) real(kind=dp), public :: nde_sp (ne,500,4) integer, public :: ionz_number (500) integer, public :: hgam_number (500) integer, public :: bunch_number (500,5) real(kind=dp), public :: ionz_bavg (500,18) real(kind=dp), public :: bunch_bavg (500,18,5) real(kind=dp), public :: tbunch (1000) real(kind=dp), public :: tionz (500) real(kind=dp), public :: hgam_charge (500) real(kind=dp), public :: ionz_charge (500) real(kind=dp), public :: bcharge (500,5) real(kind=dp), public :: hgam_bavg (500,18) real(kind=dp), public :: tgam (500) Subroutines public subroutine track_part_pdata_out (tk) Arguments Type Intent Optional Attributes Name integer, intent(in) :: tk public subroutine energy_spect (np, ekem, gfield) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=dp), intent(in) :: ekem real(kind=dp), intent(in) :: gfield (:,:) public subroutine select_energy_spect (np, ekem, xl, xr, gfield) Arguments Type Intent Optional Attributes Name integer, intent(in) :: np real(kind=dp), intent(in) :: ekem real(kind=dp), intent(in) :: xl real(kind=dp), intent(in) :: xr real(kind=dp), intent(in) :: gfield (:,:) public subroutine energy_momenta (sp_loc, gfield, np, ek, ekmax) Arguments Type Intent Optional Attributes Name type(species), intent(in) :: sp_loc real(kind=dp), intent(inout) :: gfield (:,:) integer, intent(in) :: np real(kind=dp), intent(out) :: ek (:) real(kind=dp), intent(out) :: ekmax public subroutine laser_struct_data (nst) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst public subroutine envelope_struct_data (nst) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst public subroutine fields_on_target (nst) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst public subroutine Envar (nst) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst public subroutine bunch_corr (bch, np_loc, np_norm, bcorr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bch (:,:) integer, intent(in) :: np_loc real(kind=dp), intent(in) :: np_norm real(kind=dp), intent(out) :: bcorr (16) public subroutine enb_bunch (nst, ib) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: ib public subroutine enb_ionz (nst, t_loc, gmm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: gmm public subroutine enb_hgam (nst, t_loc, gmm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst real(kind=dp), intent(in) :: t_loc real(kind=dp), intent(in) :: gmm public subroutine en_data (nst, itr, idata) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: itr integer, intent(in) :: idata public subroutine general_en_data (nst, itr, idata) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: itr integer, intent(in) :: idata public subroutine en_bdata (nst, it, idata) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: it integer, intent(in) :: idata public subroutine en_ionz_data (nst, itrz, data_id) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: itrz integer, intent(in) :: data_id public subroutine en_high_gamma_data (nst, itrz, data_id) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nst integer, intent(in) :: itrz integer, intent(in) :: data_id","tags":"","loc":"module/diag_part_and_fields.html"},{"title":"read_input – ALaDyn","text":"Uses common_param control_bunch_input code_util mpi_var module~~read_input~~UsesGraph module~read_input read_input module~common_param common_param module~read_input->module~common_param module~mpi_var mpi_var module~read_input->module~mpi_var module~code_util code_util module~read_input->module~code_util module~control_bunch_input control_bunch_input module~read_input->module~control_bunch_input module~precision_def precision_def module~common_param->module~precision_def module~mpi_var->module~precision_def module~code_util->module~precision_def module~control_bunch_input->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_input~~UsedByGraph module~read_input read_input module~start_all start_all module~start_all->module~read_input program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nml_iounit nml_ierr nml_error_message Functions isprime Subroutines read_main_input read_input_nml write_read_nml consistency_check_number_of_particles_comp consistency_check_grid consistency_check_number_of_particles from_ppc_to_npx_npy_npz primefactors print_at_screen_nml_error select_number_of_bunch_particles Variables Type Visibility Attributes Name Initial integer, private :: nml_iounit = 1 integer, private :: nml_ierr = 0 character(len=100), private :: nml_error_message = '' Functions private function isprime (num) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num Return Value logical Subroutines public subroutine read_main_input () Arguments None private subroutine read_input_nml () Arguments None public subroutine write_read_nml () Arguments None private subroutine consistency_check_number_of_particles_comp () Arguments None private subroutine consistency_check_grid () Arguments None private subroutine consistency_check_number_of_particles () Arguments None private subroutine from_ppc_to_npx_npy_npz () Arguments None private subroutine primefactors (num, factors, number_factors) Arguments Type Intent Optional Attributes Name integer, intent(in) :: num integer, intent(out), dimension((num/2)) :: factors integer, intent(inout) :: number_factors private subroutine print_at_screen_nml_error () Arguments None private subroutine select_number_of_bunch_particles () Arguments None","tags":"","loc":"module/read_input.html"},{"title":"pic_dump – ALaDyn","text":"Uses array_alloc code_util common_param grid_param parallel module~~pic_dump~~UsesGraph module~pic_dump pic_dump module~array_alloc array_alloc module~pic_dump->module~array_alloc module~grid_param grid_param module~pic_dump->module~grid_param module~parallel parallel module~pic_dump->module~parallel module~code_util code_util module~pic_dump->module~code_util module~common_param common_param module~pic_dump->module~common_param module~fstruct_data fstruct_data module~array_alloc->module~fstruct_data module~pstruct_data pstruct_data module~array_alloc->module~pstruct_data module~precision_def precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~parallel->module~common_param mpi mpi module~parallel->mpi module~mpi_var mpi_var module~parallel->module~mpi_var module~util util module~parallel->module~util module~code_util->module~precision_def module~common_param->module~precision_def module~fstruct_data->module~precision_def module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_var->module~precision_def module~util->module~code_util module~util->module~precision_def module~struct_def->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~pic_dump~~UsedByGraph module~pic_dump pic_dump module~start_all start_all module~start_all->module~pic_dump program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables send_buff recv_buff Subroutines dump_data restart Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: send_buff (:) real(kind=dp), private, allocatable :: recv_buff (:) Subroutines public subroutine dump_data (it_loc, tloc) Arguments Type Intent Optional Attributes Name integer, intent(in) :: it_loc real(kind=dp), intent(in) :: tloc public subroutine restart (it_loc, tloc) Arguments Type Intent Optional Attributes Name integer, intent(out) :: it_loc real(kind=dp), intent(out) :: tloc","tags":"","loc":"module/pic_dump.html"},{"title":"system_utilities – ALaDyn","text":"Uses mpi_var module~~system_utilities~~UsesGraph module~system_utilities system_utilities module~mpi_var mpi_var module~system_utilities->module~mpi_var module~precision_def precision_def module~mpi_var->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~system_utilities~~UsedByGraph module~system_utilities system_utilities module~start_all start_all module~start_all->module~system_utilities program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines create_timestep_folder create_initial_folders Subroutines public subroutine create_timestep_folder (iout) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iout public subroutine create_initial_folders () Arguments None","tags":"","loc":"module/system_utilities.html"},{"title":"set_init_param – ALaDyn","text":"Uses code_util phys_param common_param grid_param set_grid_param ionz_data control_bunch_input module~~set_init_param~~UsesGraph module~set_init_param set_init_param module~control_bunch_input control_bunch_input module~set_init_param->module~control_bunch_input module~ionz_data ionz_data module~set_init_param->module~ionz_data module~grid_param grid_param module~set_init_param->module~grid_param module~code_util code_util module~set_init_param->module~code_util module~set_grid_param set_grid_param module~set_init_param->module~set_grid_param module~common_param common_param module~set_init_param->module~common_param module~phys_param phys_param module~set_init_param->module~phys_param module~precision_def precision_def module~control_bunch_input->module~precision_def module~ionz_data->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~grid_param->module~precision_def module~code_util->module~precision_def module~set_grid_param->module~grid_param module~set_grid_param->module~common_param module~mpi_var mpi_var module~set_grid_param->module~mpi_var module~common_param->module~precision_def module~phys_param->module~precision_def module~struct_def->module~precision_def module~mpi_var->module~precision_def Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~set_init_param~~UsedByGraph module~set_init_param set_init_param module~start_all start_all module~start_all->module~set_init_param program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines set_initial_param Subroutines public subroutine set_initial_param () Arguments None","tags":"","loc":"module/set_init_param.html"},{"title":"start_all – ALaDyn","text":"Uses array_alloc set_init_param read_input set_grid_param ionize pic_in pic_dump run_data_info system_utilities module~~start_all~~UsesGraph module~start_all start_all module~set_init_param set_init_param module~start_all->module~set_init_param module~ionize ionize module~start_all->module~ionize module~array_alloc array_alloc module~start_all->module~array_alloc module~pic_in pic_in module~start_all->module~pic_in module~set_grid_param set_grid_param module~start_all->module~set_grid_param module~read_input read_input module~start_all->module~read_input module~run_data_info run_data_info module~start_all->module~run_data_info module~system_utilities system_utilities module~start_all->module~system_utilities module~pic_dump pic_dump module~start_all->module~pic_dump module~set_init_param->module~set_grid_param module~control_bunch_input control_bunch_input module~set_init_param->module~control_bunch_input module~ionz_data ionz_data module~set_init_param->module~ionz_data module~grid_param grid_param module~set_init_param->module~grid_param module~code_util code_util module~set_init_param->module~code_util module~common_param common_param module~set_init_param->module~common_param module~phys_param phys_param module~set_init_param->module~phys_param module~ionize->module~array_alloc module~ionize->module~ionz_data module~mpi_var mpi_var module~ionize->module~mpi_var module~util util module~ionize->module~util module~ionize->module~common_param module~fstruct_data fstruct_data module~array_alloc->module~fstruct_data module~pstruct_data pstruct_data module~array_alloc->module~pstruct_data module~init_part_distrib init_part_distrib module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~set_grid_param->module~grid_param module~set_grid_param->module~mpi_var module~set_grid_param->module~common_param module~read_input->module~control_bunch_input module~read_input->module~code_util module~read_input->module~mpi_var module~read_input->module~common_param module~run_data_info->module~control_bunch_input module~run_data_info->module~ionz_data module~run_data_info->module~grid_param module~run_data_info->module~fstruct_data module~run_data_info->module~code_util module~parallel parallel module~run_data_info->module~parallel module~run_data_info->module~pstruct_data module~run_data_info->module~common_param module~run_data_info->module~phys_param module~system_utilities->module~mpi_var module~pic_dump->module~array_alloc module~pic_dump->module~grid_param module~pic_dump->module~code_util module~pic_dump->module~parallel module~pic_dump->module~common_param module~precision_def precision_def module~control_bunch_input->module~precision_def module~ionz_data->module~precision_def module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~fstruct_data->module~precision_def module~init_part_distrib->module~array_alloc module~init_part_distrib->module~grid_param module~init_part_distrib->module~code_util module~init_part_distrib->module~mpi_var module~init_part_distrib->module~util module~init_part_distrib->module~common_param module~init_part_distrib->module~phys_param module~code_util->module~precision_def module~parallel->module~mpi_var module~parallel->module~util module~parallel->module~common_param mpi mpi module~parallel->mpi module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_var->module~precision_def module~util->module~code_util module~util->module~precision_def module~common_param->module~precision_def module~init_laser_field->module~fstruct_data module~init_laser_field->module~pstruct_data module~grid_fields grid_fields module~init_laser_field->module~grid_fields module~init_grid_field init_grid_field module~init_laser_field->module~init_grid_field module~phys_param->module~precision_def module~grid_fields->module~parallel module~grid_field_param grid_field_param module~grid_fields->module~grid_field_param module~init_grid_field->module~fstruct_data module~init_grid_field->module~pstruct_data module~init_grid_field->module~phys_param module~init_grid_field->module~grid_field_param module~struct_def->module~precision_def module~grid_field_param->module~grid_param module~grid_field_param->module~mpi_var module~grid_field_param->module~common_param Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~start_all~~UsedByGraph module~start_all start_all program~aladyn aladyn program~aladyn->module~start_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Start Subroutines public subroutine Start () Start subroutine. It reads the input file, initializes\n the variables and allocates the needed arrays before to start the\n simulation. Arguments None","tags":"","loc":"module/start_all.html"},{"title":"aladyn – ALaDyn","text":"Uses start_all diag_part_and_fields run_data_info pic_out_util pic_out init_beam_part_distrib pic_evolve env_evolve program~~aladyn~~UsesGraph program~aladyn aladyn module~init_beam_part_distrib init_beam_part_distrib program~aladyn->module~init_beam_part_distrib module~pic_evolve pic_evolve program~aladyn->module~pic_evolve module~start_all start_all program~aladyn->module~start_all module~env_evolve env_evolve program~aladyn->module~env_evolve module~pic_out_util pic_out_util program~aladyn->module~pic_out_util module~run_data_info run_data_info program~aladyn->module~run_data_info module~diag_part_and_fields diag_part_and_fields program~aladyn->module~diag_part_and_fields module~pic_out pic_out program~aladyn->module~pic_out module~array_alloc array_alloc module~init_beam_part_distrib->module~array_alloc module~psolve psolve module~init_beam_part_distrib->module~psolve module~control_bunch_input control_bunch_input module~init_beam_part_distrib->module~control_bunch_input module~grid_part_util grid_part_util module~init_beam_part_distrib->module~grid_part_util module~code_util code_util module~init_beam_part_distrib->module~code_util module~mpi_field_interface mpi_field_interface module~init_beam_part_distrib->module~mpi_field_interface module~init_grid_field init_grid_field module~init_beam_part_distrib->module~init_grid_field module~grid_param grid_param module~init_beam_part_distrib->module~grid_param module~mpi_curr_interface mpi_curr_interface module~init_beam_part_distrib->module~mpi_curr_interface module~util util module~init_beam_part_distrib->module~util module~phys_param phys_param module~init_beam_part_distrib->module~phys_param module~fluid_density_momenta fluid_density_momenta module~pic_evolve->module~fluid_density_momenta module~window window module~pic_evolve->module~window module~mpi_part_interface mpi_part_interface module~pic_evolve->module~mpi_part_interface module~ionize ionize module~pic_evolve->module~ionize module~pic_evolve->module~init_grid_field module~curr_and_fields_util curr_and_fields_util module~pic_evolve->module~curr_and_fields_util module~boris_push boris_push module~pic_evolve->module~boris_push module~start_all->module~run_data_info module~set_init_param set_init_param module~start_all->module~set_init_param module~start_all->module~array_alloc module~set_grid_param set_grid_param module~start_all->module~set_grid_param module~system_utilities system_utilities module~start_all->module~system_utilities module~pic_dump pic_dump module~start_all->module~pic_dump module~start_all->module~ionize module~pic_in pic_in module~start_all->module~pic_in module~read_input read_input module~start_all->module~read_input module~env_evolve->module~fluid_density_momenta module~env_evolve->module~window module~env_evolve->module~mpi_part_interface module~env_evolve->module~ionize module~env_evolve->module~curr_and_fields_util module~env_evolve->module~boris_push module~env_evolve->module~util module~pic_out_util->module~psolve module~pic_out_util->module~grid_part_util module~pic_out_util->module~mpi_field_interface module~pic_out_util->module~mpi_curr_interface module~pic_out_util->module~phys_param module~ionz_data ionz_data module~run_data_info->module~ionz_data module~common_param common_param module~run_data_info->module~common_param module~run_data_info->module~control_bunch_input module~fstruct_data fstruct_data module~run_data_info->module~fstruct_data module~run_data_info->module~code_util module~run_data_info->module~grid_param module~parallel parallel module~run_data_info->module~parallel module~pstruct_data pstruct_data module~run_data_info->module~pstruct_data module~run_data_info->module~phys_param module~diag_part_and_fields->module~control_bunch_input module~diag_part_and_fields->module~fstruct_data module~diag_part_and_fields->module~code_util module~diag_part_and_fields->module~grid_param module~diag_part_and_fields->module~parallel module~diag_part_and_fields->module~pstruct_data module~diag_part_and_fields->module~phys_param module~pic_out->module~common_param module~pic_out->module~fstruct_data module~pic_out->module~code_util module~pic_out->module~grid_param module~pic_out->module~parallel module~pic_out->module~pstruct_data module~set_init_param->module~ionz_data module~set_init_param->module~set_grid_param module~set_init_param->module~common_param module~set_init_param->module~control_bunch_input module~set_init_param->module~code_util module~set_init_param->module~grid_param module~set_init_param->module~phys_param module~array_alloc->module~fstruct_data module~array_alloc->module~pstruct_data module~fluid_density_momenta->module~mpi_field_interface module~grid_fields grid_fields module~fluid_density_momenta->module~grid_fields module~precision_def precision_def module~ionz_data->module~precision_def module~set_grid_param->module~common_param module~set_grid_param->module~grid_param module~mpi_var mpi_var module~set_grid_param->module~mpi_var module~system_utilities->module~mpi_var module~window->module~run_data_info module~window->module~common_param module~window->module~mpi_part_interface module~window->module~fstruct_data module~window->module~mpi_field_interface module~window->module~grid_param module~window->module~pstruct_data module~window->module~util module~common_param->module~precision_def module~pic_dump->module~array_alloc module~pic_dump->module~common_param module~pic_dump->module~code_util module~pic_dump->module~grid_param module~pic_dump->module~parallel module~psolve->module~common_param module~psolve->module~fstruct_data module~psolve->module~grid_param module~psolve->module~pstruct_data module~psolve->module~grid_fields module~prl_fft prl_fft module~psolve->module~prl_fft module~control_bunch_input->module~precision_def module~grid_part_util->module~fstruct_data module~grid_part_util->module~pstruct_data module~grid_part_lib grid_part_lib module~grid_part_util->module~grid_part_lib module~mpi_part_interface->module~array_alloc module~mpi_part_interface->module~code_util module~mpi_part_interface->module~grid_param module~mpi_part_interface->module~parallel module~ionize->module~array_alloc module~ionize->module~ionz_data module~ionize->module~common_param module~ionize->module~util module~ionize->module~mpi_var module~fstruct_data->module~precision_def module~init_part_distrib init_part_distrib module~pic_in->module~init_part_distrib module~init_laser_field init_laser_field module~pic_in->module~init_laser_field module~code_util->module~precision_def module~read_input->module~common_param module~read_input->module~control_bunch_input module~read_input->module~code_util module~read_input->module~mpi_var module~mpi_field_interface->module~fstruct_data module~mpi_field_interface->module~grid_param module~mpi_field_interface->module~parallel module~mpi_field_interface->module~pstruct_data module~init_grid_field->module~fstruct_data module~init_grid_field->module~pstruct_data module~init_grid_field->module~phys_param module~grid_field_param grid_field_param module~init_grid_field->module~grid_field_param module~curr_and_fields_util->module~fstruct_data module~curr_and_fields_util->module~mpi_field_interface module~curr_and_fields_util->module~init_grid_field module~curr_and_fields_util->module~grid_param module~curr_and_fields_util->module~pstruct_data module~curr_and_fields_util->module~mpi_curr_interface module~curr_and_fields_util->module~grid_fields module~grid_part_connect grid_part_connect module~curr_and_fields_util->module~grid_part_connect module~boris_push->module~common_param module~boris_push->module~fstruct_data module~boris_push->module~pstruct_data module~grid_param->module~precision_def module~struct_def struct_def module~grid_param->module~struct_def module~parallel->module~common_param module~parallel->module~util mpi mpi module~parallel->mpi module~parallel->module~mpi_var module~pstruct_data->module~precision_def module~pstruct_data->module~struct_def module~mpi_curr_interface->module~fstruct_data module~mpi_curr_interface->module~grid_param module~mpi_curr_interface->module~parallel module~mpi_curr_interface->module~pstruct_data module~util->module~code_util module~util->module~precision_def module~phys_param->module~precision_def module~grid_fields->module~parallel module~grid_fields->module~grid_field_param module~grid_part_connect->module~fstruct_data module~grid_part_connect->module~pstruct_data module~grid_part_connect->module~grid_part_lib module~init_part_distrib->module~array_alloc module~init_part_distrib->module~common_param module~init_part_distrib->module~code_util module~init_part_distrib->module~grid_param module~init_part_distrib->module~util module~init_part_distrib->module~phys_param module~init_part_distrib->module~mpi_var module~struct_def->module~precision_def module~prl_fft->module~parallel module~modern_fft_lib modern_fft_lib module~prl_fft->module~modern_fft_lib module~mpi_var->module~precision_def module~grid_field_param->module~common_param module~grid_field_param->module~grid_param module~grid_field_param->module~mpi_var module~grid_part_lib->module~common_param module~grid_part_lib->module~grid_param module~stretched_grid stretched_grid module~grid_part_lib->module~stretched_grid module~init_laser_field->module~fstruct_data module~init_laser_field->module~init_grid_field module~init_laser_field->module~pstruct_data module~init_laser_field->module~grid_fields module~modern_fft_lib->module~precision_def iso_c_binding iso_c_binding module~modern_fft_lib->iso_c_binding module~stretched_grid->module~common_param module~stretched_grid->module~grid_param module~stretched_grid->module~mpi_var Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~aladyn~~CallsGraph program~aladyn aladyn end_parallel end_parallel program~aladyn->end_parallel proc~part_numbers Part_numbers program~aladyn->proc~part_numbers proc~env_cycle Env_cycle program~aladyn->proc~env_cycle proc~initial_run_info initial_run_info program~aladyn->proc~initial_run_info proc~start Start program~aladyn->proc~start proc~lp_cycle Lp_cycle program~aladyn->proc~lp_cycle mpi_barrier mpi_barrier program~aladyn->mpi_barrier proc~max_pmemory_check Max_pmemory_check program~aladyn->proc~max_pmemory_check proc~final_run_info Final_run_info program~aladyn->proc~final_run_info loc_npart loc_npart proc~part_numbers->loc_npart proc~intvec_distribute intvec_distribute proc~part_numbers->proc~intvec_distribute proc~env_cycle->proc~part_numbers proc~error_message error_message proc~env_cycle->proc~error_message proc~env_run env_run proc~env_cycle->proc~env_run proc~beam_inject beam_inject proc~env_cycle->proc~beam_inject proc~timing timing proc~env_cycle->proc~timing proc~data_out data_out proc~env_cycle->proc~data_out proc~start->end_parallel proc~start->mpi_barrier ion_min ion_min proc~start->ion_min proc~set_ftgrid set_ftgrid proc~start->proc~set_ftgrid proc~set_fxgrid set_fxgrid proc~start->proc~set_fxgrid proc~set_loc_grid_param set_loc_grid_param proc~start->proc~set_loc_grid_param proc~create_initial_folders create_initial_folders proc~start->proc~create_initial_folders yft_ind yft_ind proc~start->yft_ind proc~read_main_input read_main_input proc~start->proc~read_main_input proc~init init proc~start->proc~init proc~v_alloc v_alloc proc~start->proc~v_alloc set_field_param set_field_param proc~start->set_field_param proc~restart restart proc~start->proc~restart loc_yg loc_yg proc~start->loc_yg proc~set_fyzxgrid set_fyzxgrid proc~start->proc~set_fyzxgrid atomic_number atomic_number proc~start->atomic_number loc_yft loc_yft proc~start->loc_yft proc~fluid_alloc fluid_alloc proc~start->proc~fluid_alloc proc~set_output_grid set_output_grid proc~start->proc~set_output_grid proc~mpi_loc_grid mpi_loc_grid proc~start->proc~mpi_loc_grid proc~set_initial_param set_initial_param proc~start->proc~set_initial_param float float proc~start->float proc~write_read_nml write_read_nml proc~start->proc~write_read_nml loc_yftgrid loc_yftgrid proc~start->loc_yftgrid loc_ygrid loc_ygrid proc~start->loc_ygrid proc~mpi_buffer_alloc mpi_buffer_alloc proc~start->proc~mpi_buffer_alloc start_parallel start_parallel proc~start->start_parallel proc~lp_cycle->proc~error_message proc~lp_run lp_run proc~lp_cycle->proc~lp_run proc~lp_cycle->proc~timing proc~lp_cycle->proc~data_out proc~allreduce_dpreal allreduce_dpreal proc~max_pmemory_check->proc~allreduce_dpreal proc~select_str_to_ft_grid select_str_to_ft_grid proc~set_ftgrid->proc~select_str_to_ft_grid proc~set_ftyzgrid set_ftyzgrid proc~set_ftgrid->proc~set_ftyzgrid mpi_send mpi_send proc~intvec_distribute->mpi_send mpi_recv mpi_recv proc~intvec_distribute->mpi_recv mpi_bcast mpi_bcast proc~intvec_distribute->mpi_bcast proc~read_input_nml read_input_nml proc~read_main_input->proc~read_input_nml proc~lpf2_evolve lpf2_evolve proc~lp_run->proc~lpf2_evolve proc~comoving_coordinate comoving_coordinate proc~lp_run->proc~comoving_coordinate proc~lp_window_xshift lp_window_xshift proc~lp_run->proc~lp_window_xshift proc~lp_pulse lp_pulse proc~init->proc~lp_pulse proc~set_envelope set_envelope proc~init->proc~set_envelope proc~cp_pulse cp_pulse proc~init->proc~cp_pulse proc~part_distribute part_distribute proc~init->proc~part_distribute proc~restart->loc_npart proc~restart->proc~intvec_distribute proc~vint_2d_bcast vint_2d_bcast proc~restart->proc~vint_2d_bcast wghpt wghpt proc~restart->wghpt proc~vint_bcast vint_bcast proc~restart->proc~vint_bcast proc~exchange_2d_grdata exchange_2d_grdata proc~restart->proc~exchange_2d_grdata up up proc~restart->up up0 up0 proc~restart->up0 ebf ebf proc~restart->ebf env env proc~restart->env env1 env1 proc~restart->env1 proc~p_alloc p_alloc proc~restart->proc~p_alloc loc_wghyz loc_wghyz proc~restart->loc_wghyz proc~exchange_1d_grdata exchange_1d_grdata proc~restart->proc~exchange_1d_grdata xpt xpt proc~restart->xpt loc_ypt loc_ypt proc~restart->loc_ypt loc_zpt loc_zpt proc~restart->loc_zpt fluid_x_profile fluid_x_profile proc~restart->fluid_x_profile proc~real_bcast real_bcast proc~restart->proc~real_bcast spec spec proc~restart->spec fluid_yz_profile fluid_yz_profile proc~restart->fluid_yz_profile proc~env_run->proc~comoving_coordinate proc~env_run->proc~lp_window_xshift proc~env_lpf2_evolve env_lpf2_evolve proc~env_run->proc~env_lpf2_evolve proc~beam_inject->loc_npart loc_nbpart loc_nbpart proc~beam_inject->loc_nbpart pot pot proc~beam_inject->pot proc~fill_ebfield_yzxbdsdata fill_ebfield_yzxbdsdata proc~beam_inject->proc~fill_ebfield_yzxbdsdata proc~beam_data beam_data proc~beam_inject->proc~beam_data proc~mpi_beam_ftgrid_distribute mpi_beam_ftgrid_distribute proc~beam_inject->proc~mpi_beam_ftgrid_distribute lp_end lp_end proc~beam_inject->lp_end proc~beam_inject->ebf proc~mpi_beam_distribute mpi_beam_distribute proc~beam_inject->proc~mpi_beam_distribute ebfp ebfp proc~beam_inject->ebfp ebf_bunch ebf_bunch proc~beam_inject->ebf_bunch proc~initial_beam_fields initial_beam_fields proc~beam_inject->proc~initial_beam_fields proc~beam_inject->proc~p_alloc proc~init_random_seed init_random_seed proc~beam_inject->proc~init_random_seed jc jc proc~beam_inject->jc ebfb ebfb proc~beam_inject->ebfb proc~beam_inject->spec bunch bunch proc~beam_inject->bunch proc~timing->proc~part_numbers proc~timing->proc~max_pmemory_check proc~tot_num_part tot_num_part proc~timing->proc~tot_num_part z z proc~set_initial_param->z proc~set_grid set_grid proc~set_initial_param->proc~set_grid y y proc~set_initial_param->y mpi_allreduce mpi_allreduce proc~allreduce_dpreal->mpi_allreduce proc~part_pdata_out part_pdata_out proc~data_out->proc~part_pdata_out proc~env_two_fields_out env_two_fields_out proc~data_out->proc~env_two_fields_out proc~envar Envar proc~data_out->proc~envar create_timestep_folder create_timestep_folder proc~data_out->create_timestep_folder proc~env_fields_out env_fields_out proc~data_out->proc~env_fields_out proc~fields_out fields_out proc~data_out->proc~fields_out proc~fields_out_new fields_out_new proc~data_out->proc~fields_out_new proc~fluid_den_mom_out fluid_den_mom_out proc~data_out->proc~fluid_den_mom_out proc~den_energy_out den_energy_out proc~data_out->proc~den_energy_out proc~prl_den_energy_interp prl_den_energy_interp proc~data_out->proc~prl_den_energy_interp proc~part_pdata_out->loc_npart proc~part_pdata_out->proc~intvec_distribute proc~mpi_write_part mpi_write_part proc~part_pdata_out->proc~mpi_write_part proc~endian endian proc~part_pdata_out->proc~endian proc~lpf2_evolve->ion_min proc~lpf2_evolve->loc_npart proc~lpf2_evolve->atomic_number proc~lpf2_evolve->ebfp proc~lpf2_evolve->jc proc~lpf2_evolve->spec proc~pfields_prepare pfields_prepare proc~lpf2_evolve->proc~pfields_prepare proc~update_adam_bash_fluid_variables update_adam_bash_fluid_variables proc~lpf2_evolve->proc~update_adam_bash_fluid_variables proc~advance_lpf_fields advance_lpf_fields proc~lpf2_evolve->proc~advance_lpf_fields proc~set_momentum_density_flux set_momentum_density_flux proc~lpf2_evolve->proc~set_momentum_density_flux init_random_seed init_random_seed proc~lpf2_evolve->init_random_seed proc~fluid_curr_accumulate fluid_curr_accumulate proc~lpf2_evolve->proc~fluid_curr_accumulate proc~lp_pulse->lp_end y0_cent y0_cent proc~lp_pulse->y0_cent loc_xgrid loc_xgrid proc~lp_pulse->loc_xgrid proc~init_lp_inc0_fields init_lp_inc0_fields proc~lp_pulse->proc~init_lp_inc0_fields z0_cent z0_cent proc~lp_pulse->z0_cent xc_loc xc_loc proc~lp_pulse->xc_loc lp_in lp_in proc~lp_pulse->lp_in xf_loc xf_loc proc~lp_pulse->xf_loc lp_delay lp_delay proc~lp_pulse->lp_delay lpx lpx proc~lp_pulse->lpx proc~exchange_bdx_data exchange_bdx_data proc~fill_ebfield_yzxbdsdata->proc~exchange_bdx_data proc~beam_data->ebfb exchange_2d_grdata exchange_2d_grdata proc~beam_data->exchange_2d_grdata unit_charge unit_charge proc~beam_data->unit_charge proc~exchange_pdata exchange_pdata proc~env_two_fields_out->proc~exchange_pdata proc~vint_bcast->mpi_bcast proc~mpi_beam_ftgrid_distribute->loc_nbpart proc~mpi_beam_ftgrid_distribute->ebfb proc~mpi_beam_ftgrid_distribute->bunch proc~cell_part_dist cell_part_dist proc~comoving_coordinate->proc~cell_part_dist proc~particles_inject particles_inject proc~comoving_coordinate->proc~particles_inject proc~lp_window_xshift->proc~part_numbers proc~fluid_left_xshift fluid_left_xshift proc~lp_window_xshift->proc~fluid_left_xshift proc~fields_left_xshift fields_left_xshift proc~lp_window_xshift->proc~fields_left_xshift proc~lp_window_xshift->proc~cell_part_dist proc~lp_window_xshift->proc~particles_inject proc~mpi_beam_distribute->loc_nbpart proc~mpi_beam_distribute->ebfb proc~mpi_beam_distribute->bunch proc~envar->loc_npart proc~envar->proc~allreduce_dpreal proc~enb_bunch enb_bunch proc~envar->proc~enb_bunch mass mass proc~envar->mass proc~envelope_struct_data envelope_struct_data proc~envar->proc~envelope_struct_data proc~env_fields_out->proc~exchange_pdata proc~initial_beam_fields->loc_yg loc_zg loc_zg proc~initial_beam_fields->loc_zg proc~set_envelope->lp_end proc~set_envelope->y0_cent proc~set_envelope->loc_xgrid proc~init_gprof_envelope_field init_gprof_envelope_field proc~set_envelope->proc~init_gprof_envelope_field proc~set_envelope->z0_cent proc~init_envelope_field init_envelope_field proc~set_envelope->proc~init_envelope_field proc~set_envelope->xc_loc proc~set_envelope->lp_in proc~set_envelope->xf_loc proc~set_envelope->lp_delay proc~set_envelope->lpx proc~fields_out->proc~exchange_pdata proc~fields_out->proc~endian proc~cp_pulse->lp_end proc~init_cp_fields init_cp_fields proc~cp_pulse->proc~init_cp_fields proc~cp_pulse->loc_xgrid proc~cp_pulse->lp_in proc~cp_pulse->lpx proc~consistency_check_grid consistency_check_grid proc~read_input_nml->proc~consistency_check_grid proc~consistency_check_number_of_particles_comp consistency_check_number_of_particles_comp proc~read_input_nml->proc~consistency_check_number_of_particles_comp proc~env_lpf2_evolve->ion_min proc~env_lpf2_evolve->loc_npart proc~env_lpf2_evolve->atomic_number proc~env_lpf2_evolve->ebfp proc~env_lpf2_evolve->proc~init_random_seed proc~env_lpf2_evolve->jc proc~env_lpf2_evolve->spec proc~advance_lpf_envelope advance_lpf_envelope proc~env_lpf2_evolve->proc~advance_lpf_envelope proc~env_fields_average env_fields_average proc~env_lpf2_evolve->proc~env_fields_average proc~env_lpf2_evolve->proc~update_adam_bash_fluid_variables proc~env_two_fields_average env_two_fields_average proc~env_lpf2_evolve->proc~env_two_fields_average enable_ionization enable_ionization proc~env_lpf2_evolve->enable_ionization flux flux proc~env_lpf2_evolve->flux proc~env_lpf2_evolve->proc~advance_lpf_fields proc~set_env_momentum_density_flux set_env_momentum_density_flux proc~env_lpf2_evolve->proc~set_env_momentum_density_flux proc~env_den_collect env_den_collect proc~env_lpf2_evolve->proc~env_den_collect proc~env_amp_two_fields_prepare env_amp_two_fields_prepare proc~env_lpf2_evolve->proc~env_amp_two_fields_prepare proc~curr_mpi_collect curr_mpi_collect proc~env_lpf2_evolve->proc~curr_mpi_collect proc~env_amp_prepare env_amp_prepare proc~env_lpf2_evolve->proc~env_amp_prepare set_env_density set_env_density proc~env_lpf2_evolve->set_env_density proc~env_lpf2_evolve->proc~fluid_curr_accumulate proc~mpi_write_field mpi_write_field proc~fields_out_new->proc~mpi_write_field proc~fields_out_new->proc~endian proc~tot_num_part->loc_npart proc~multi_layer_threesp_target multi_layer_threesp_target proc~part_distribute->proc~multi_layer_threesp_target proc~multi_layer_gas_target multi_layer_gas_target proc~part_distribute->proc~multi_layer_gas_target proc~preplasma_multisp preplasma_multisp proc~part_distribute->proc~preplasma_multisp proc~one_layer_nano_tubes one_layer_nano_tubes proc~part_distribute->proc~one_layer_nano_tubes proc~one_layer_nano_wires one_layer_nano_wires proc~part_distribute->proc~one_layer_nano_wires proc~multi_layer_twosp_target multi_layer_twosp_target proc~part_distribute->proc~multi_layer_twosp_target proc~fluid_den_mom_out->proc~exchange_pdata proc~fluid_den_mom_out->proc~endian proc~den_energy_out->proc~exchange_pdata proc~den_energy_out->proc~endian proc~prl_den_energy_interp->loc_npart proc~prl_den_energy_interp->loc_yg proc~prl_den_energy_interp->env proc~prl_den_energy_interp->jc proc~prl_den_energy_interp->spec proc~den_zyxbd den_zyxbd proc~prl_den_energy_interp->proc~den_zyxbd proc~prl_den_energy_interp->loc_zg proc~prl_den_energy_interp->mass proc~real_bcast->mpi_bcast proc~init_cp_fields->loc_yg proc~init_cp_fields->loc_ygrid proc~init_cp_fields->loc_zg proc~get_plane_wave_cp get_plane_wave_cp proc~init_cp_fields->proc~get_plane_wave_cp proc~get_laser_fields_cp get_laser_fields_cp proc~init_cp_fields->proc~get_laser_fields_cp loc_zgrid loc_zgrid proc~init_cp_fields->loc_zgrid loc_xg loc_xg proc~init_cp_fields->loc_xg proc~pfields_prepare->proc~fill_ebfield_yzxbdsdata proc~field_xyzbd field_xyzbd proc~pfields_prepare->proc~field_xyzbd proc~advance_lpf_envelope->proc~fill_ebfield_yzxbdsdata proc~env_maxw_solve env_maxw_solve proc~advance_lpf_envelope->proc~env_maxw_solve proc~env_bds env_bds proc~advance_lpf_envelope->proc~env_bds proc~env_lpf_solve env_lpf_solve proc~advance_lpf_envelope->proc~env_lpf_solve proc~init_gprof_envelope_field->loc_yg proc~init_gprof_envelope_field->loc_ygrid proc~init_gprof_envelope_field->loc_zg proc~init_gprof_envelope_field->loc_zgrid proc~init_gprof_envelope_field->loc_xg env_grad env_grad proc~env_fields_average->env_grad mpi_file_set_view mpi_file_set_view proc~mpi_write_part->mpi_file_set_view mpi_file_write mpi_file_write proc~mpi_write_part->mpi_file_write mpi_file_close mpi_file_close proc~mpi_write_part->mpi_file_close mpi_file_open mpi_file_open proc~mpi_write_part->mpi_file_open proc~fluid_left_xshift->proc~exchange_bdx_data proc~fields_left_xshift->proc~exchange_bdx_data proc~multi_layer_threesp_target->wghpt proc~multi_layer_threesp_target->proc~p_alloc proc~multi_layer_threesp_target->xpt proc~multi_layer_threesp_target->spec loc_xpt loc_xpt proc~multi_layer_threesp_target->loc_xpt loc_wghx loc_wghx proc~multi_layer_threesp_target->loc_wghx proc~set_uniform_yz_distrib set_uniform_yz_distrib proc~multi_layer_threesp_target->proc~set_uniform_yz_distrib proc~init_lp_inc0_fields->loc_yg proc~init_lp_inc0_fields->loc_ygrid proc~init_lp_inc0_fields->loc_zg proc~get_2dlaser_gprof_fields_lp get_2dlaser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_gprof_fields_lp proc~get_laser_gprof_fields_lp get_laser_gprof_fields_lp proc~init_lp_inc0_fields->proc~get_laser_gprof_fields_lp proc~init_lp_inc0_fields->loc_zgrid proc~get_laser_fields_lp get_laser_fields_lp proc~init_lp_inc0_fields->proc~get_laser_fields_lp proc~get_2dlaser_fields_lp get_2dlaser_fields_lp proc~init_lp_inc0_fields->proc~get_2dlaser_fields_lp proc~init_lp_inc0_fields->loc_xg proc~get_plane_wave_lp get_plane_wave_lp proc~init_lp_inc0_fields->proc~get_plane_wave_lp proc~update_adam_bash_fluid_variables->proc~fill_ebfield_yzxbdsdata proc~update_adam_bash_fluid_variables->unit_charge lorentz_fact lorentz_fact proc~update_adam_bash_fluid_variables->lorentz_fact proc~nc_fluid_density_momenta nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~nc_fluid_density_momenta proc~update_adam_bash_fluid_variables->proc~field_xyzbd proc~multi_layer_gas_target->wghpt proc~multi_layer_gas_target->proc~p_alloc proc~multi_layer_gas_target->xpt proc~multi_layer_gas_target->spec proc~multi_layer_gas_target->loc_xpt proc~multi_layer_gas_target->loc_wghx proc~multi_layer_gas_target->proc~set_uniform_yz_distrib proc~mpi_x_part_distrib mpi_x_part_distrib proc~multi_layer_gas_target->proc~mpi_x_part_distrib proc~preplasma_multisp->wghpt proc~preplasma_multisp->proc~p_alloc proc~preplasma_multisp->xpt proc~preplasma_multisp->spec proc~preplasma_multisp->loc_xpt proc~preplasma_multisp->loc_wghx proc~preplasma_multisp->proc~set_uniform_yz_distrib proc~advance_lpf_fields->proc~fill_ebfield_yzxbdsdata proc~field_xadvect field_xadvect proc~advance_lpf_fields->proc~field_xadvect proc~rotb rotb proc~advance_lpf_fields->proc~rotb proc~rote rote proc~advance_lpf_fields->proc~rote proc~ef_bds ef_bds proc~advance_lpf_fields->proc~ef_bds proc~bf_bds bf_bds proc~advance_lpf_fields->proc~bf_bds proc~env_den_collect->loc_yg proc~env_den_collect->loc_zg fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~env_den_collect->fill_curr_yzxbdsdata den_zyxbd den_zyxbd proc~env_den_collect->den_zyxbd proc~init_envelope_field->loc_yg proc~init_envelope_field->loc_ygrid proc~init_envelope_field->loc_zg proc~init_envelope_field->loc_zgrid proc~init_envelope_field->loc_xg proc~env_amp_two_fields_prepare->env_grad proc~fill_curr_yzxbdsdata fill_curr_yzxbdsdata proc~curr_mpi_collect->proc~fill_curr_yzxbdsdata proc~jc_xyzbd jc_xyzbd proc~curr_mpi_collect->proc~jc_xyzbd djc djc proc~curr_mpi_collect->djc proc~cell_part_dist->loc_npart proc~cell_part_dist->ebfp proc~cell_part_dist->spec proc~v_realloc v_realloc proc~cell_part_dist->proc~v_realloc proc~one_layer_nano_tubes->wghpt proc~one_layer_nano_tubes->proc~p_alloc proc~one_layer_nano_tubes->loc_wghyz proc~one_layer_nano_tubes->proc~init_random_seed proc~one_layer_nano_tubes->xpt proc~one_layer_nano_tubes->loc_ypt proc~one_layer_nano_tubes->loc_zpt proc~one_layer_nano_tubes->spec proc~one_layer_nano_tubes->loc_xpt zpt zpt proc~one_layer_nano_tubes->zpt proc~mpi_yz_part_distrib mpi_yz_part_distrib proc~one_layer_nano_tubes->proc~mpi_yz_part_distrib ypt ypt proc~one_layer_nano_tubes->ypt proc~gasdev gasdev proc~one_layer_nano_tubes->proc~gasdev proc~from_ppc_to_npx_npy_npz from_ppc_to_npx_npy_npz proc~consistency_check_number_of_particles_comp->proc~from_ppc_to_npx_npy_npz proc~one_layer_nano_wires->wghpt proc~one_layer_nano_wires->proc~p_alloc proc~one_layer_nano_wires->loc_wghyz proc~one_layer_nano_wires->xpt proc~one_layer_nano_wires->loc_ypt proc~one_layer_nano_wires->loc_zpt proc~one_layer_nano_wires->spec proc~one_layer_nano_wires->loc_xpt proc~one_layer_nano_wires->loc_wghx proc~set_pgrid_ind set_pgrid_ind proc~one_layer_nano_wires->proc~set_pgrid_ind proc~one_layer_nano_wires->zpt proc~one_layer_nano_wires->proc~mpi_yz_part_distrib proc~one_layer_nano_wires->ypt proc~multi_layer_twosp_target->wghpt proc~multi_layer_twosp_target->proc~p_alloc proc~multi_layer_twosp_target->xpt proc~multi_layer_twosp_target->spec proc~multi_layer_twosp_target->loc_xpt proc~multi_layer_twosp_target->loc_wghx proc~multi_layer_twosp_target->proc~set_uniform_yz_distrib proc~env_amp_prepare->env_grad proc~mpi_write_field->mpi_file_set_view proc~mpi_write_field->mpi_file_write proc~mpi_write_field->mpi_file_close proc~mpi_write_field->mpi_file_open proc~enb_bunch->loc_npart proc~enb_bunch->proc~allreduce_dpreal proc~bunch_corr bunch_corr proc~enb_bunch->proc~bunch_corr proc~envelope_struct_data->proc~allreduce_dpreal proc~fluid_curr_accumulate->proc~fill_ebfield_yzxbdsdata proc~fluid_curr_accumulate->unit_charge proc~fluid_curr_accumulate->proc~field_xyzbd proc~particles_inject->loc_npart v_realloc v_realloc proc~particles_inject->v_realloc proc~add_particles add_particles proc~particles_inject->proc~add_particles proc~bunch_corr->proc~allreduce_dpreal proc~fill_curr_yzxbdsdata->proc~exchange_bdx_data proc~trid_der1 trid_der1 proc~field_xadvect->proc~trid_der1 proc~rotb->loc_yg proc~rotb->loc_zg proc~potential_lapl potential_lapl proc~env_maxw_solve->proc~potential_lapl proc~isprime isprime proc~from_ppc_to_npx_npy_npz->proc~isprime proc~rote->loc_yg proc~rote->loc_zg proc~ef_bds->loc_yg proc~ef_bds->loc_zg proc~ef_bds->loc_zgrid proc~ef_bds->loc_xg proc~set_pgrid_ind->zpt proc~set_pgrid_ind->ypt proc~nc_fluid_density_momenta->loc_yg proc~nc_fluid_density_momenta->loc_zg proc~mpi_yz_part_distrib->loc_wghyz proc~mpi_yz_part_distrib->loc_ypt proc~mpi_yz_part_distrib->loc_zpt proc~mpi_yz_part_distrib->zpt proc~mpi_yz_part_distrib->ypt proc~env_bds->loc_yg proc~env_bds->loc_zg proc~set_uniform_yz_distrib->loc_wghyz proc~set_uniform_yz_distrib->loc_ypt proc~set_uniform_yz_distrib->loc_zpt proc~set_uniform_yz_distrib->proc~set_pgrid_ind proc~set_uniform_yz_distrib->zpt proc~set_uniform_yz_distrib->proc~mpi_yz_part_distrib proc~set_uniform_yz_distrib->ypt proc~mpi_x_part_distrib->wghpt proc~mpi_x_part_distrib->xpt proc~mpi_x_part_distrib->loc_xpt proc~mpi_x_part_distrib->loc_wghx proc~pp_lapl pp_lapl proc~env_lpf_solve->proc~pp_lapl proc~add_particles->proc~init_random_seed proc~add_particles->proc~gasdev proc~bf_bds->loc_yg proc~bf_bds->loc_zg proc~bf_bds->loc_xg proc~pp_lapl->loc_yg proc~pp_lapl->loc_zg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Lp_cycle Env_cycle data_out Subroutines subroutine Lp_cycle () LP_CYCLE: collects the Laser-plasma dynamics evolved as a standard PIC. Arguments None subroutine Env_cycle () Arguments None subroutine data_out () Arguments None","tags":"","loc":"program/aladyn.html"},{"title":"Guide – ALaDyn","text":"How to build ALaDyn is built using CMake. We support building ALaDyn on almost all sane systems. Here you can find a guide to build the code on many different OS configurations. appveyor and travis recipes can also help to understand how to build the code. How to contribute to the development Here you can find the instructions to propose your changes to ALaDyn Support channels We have a Telegram channel to promote latest news: join here We also have a group on Telegram ( join here ) (for quick questions and unofficial discussions), an official slack channel (for more technical discussions) and another slack channel for the italian plasma community Releases latest release: Other releases: v2.3.0 (v2019.1): v2.2.0 (v2018.3): v2.1.0 (v2018.2): v2.0.0 (v2018.1): v1.0.0 (v2017.1): v1.0.0-beta: v1.0.0-alpha2: v1.0.0-alpha:","tags":"","loc":"page//index.html"},{"title":"How to build – ALaDyn","text":"How to build the code 1) Follow your system prerequisites (below)\n2) Clone ALaDyn from this repository, or download a stable release git clone https://github.com/ALaDyn/ALaDyn.git cd ALaDyn 3) Use the best script depending to your configuration. There are many examples inside scripts/build . For example: ./scripts/build/cmake.generic Note that some scripts only work in a specific environment or shell. We support running ALaDyn only on x86-64 CPUs, with 64 bit operating systems. Prerequisites Ubuntu 1) Open a Bash terminal and type the following commands sudo apt-get update\nsudo apt-get dist-upgrade\nsudo apt-get install -y g++ gfortran cmake make git ninja-build libboost-all-dev libopenmpi-dev pkgconf libfftw3-dev pkg-config macOS 1) If not already installed, install the XCode Command Line Tools, typing this command in a terminal: xcode-select --install 2) If not already installed, install Homebrew following the official guide .\n3) Open the terminal and type these commands brew update\nbrew upgrade\nbrew install gcc cmake make git ninja boost open-mpi fftw pkg-config Windows (7+) - PGI Compiler 1) Install Visual Studio 2017 from the official website 2) Open your Powershell with Administrator privileges, type the following command and confirm it: PS \\> Set-ExecutionPolicy unrestricted 3) If not already installed, please install chocolatey using the official guide 4) If you are not sure about having them updated, or even installed, please install git , javaruntime , cmake and an updated Powershell . To do so, open your Powershell with Administrator privileges and type PS \\> cinst -y git cmake powershell javaruntime 5) Restart the PC if required by chocolatey after the latest step\n6) Install PGI 18.10 from the official website (the community edition is enough and is free; NOTE: install included MS-MPI, but avoid JRE and Cygwin). Note that for some time it was necessary to activate license for PGI 18.10 Community Edition (renaming the file %PROGRAMFILES%\\PGI\\license.dat-COMMUNITY-18.10 to %PROGRAMFILES%\\PGI\\license.dat )\n7) Define a work folder, which we will call WORKSPACE in this tutorial: this could be a \"Code\" folder in our home, a \"cpp\" folder on our desktop, whatever you want. Create it if you don't already have, using your favourite method (mkdir in Powershell, or from the graphical interface in explorer). We will now define an environment variable to tell the system where our folder is. Please note down its full path. Open a Powershell (as a standard user) and type PS \\> rundll32 sysdm . cpl , EditEnvironmentVariables 8) In the upper part of the window that pops-up, we have to create a new environment variable, with name WORKSPACE and value the full path noted down before.\nIf it not already in the PATH (this is possible only if you did it before), we also need to modify the \"Path\" variable adding the following string (on Windows 10 you need to add a new line to insert it, on Windows 7/8 it is necessary to append it using a ; as a separator between other records): %PROGRAMFILES%\\CMake\\bin 9) If vcpkg is not installed, please follow the next procedure, otherwise please jump to #11 PS \\> cd $env:WORKSPACE PS Code > git clone https : // github . com / Microsoft / vcpkg . git PS Code > cd vcpkg PS Code \\ vcpkg > .\\ bootstrap-vcpkg . bat 10) Open a Powershell with Administrator privileges and type PS \\> cd $env:WORKSPACE PS Code > cd vcpkg PS Code \\ vcpkg > .\\ vcpkg integrate install 11) Open a Powershell (as a standard user) and type (the last command requires a confirmation and is used to clean up unnecessary files). Note: do NOT install msmpi from vcpkg because it will be preferred from the one included in PGI and it is incompatible with PGI compiler PS \\> cd $env:WORKSPACE PS Code > cd vcpkg PS Code \\ vcpkg > .\\ vcpkg install fftw3 : x64-windows PS Code \\ vcpkg > rmdir .\\ buildtrees \\ PS Code \\ vcpkg > cd $env:WORKSPACE PS Code > git clone https : // github . com / ALaDyn / ALaDyn 12) Open a Powershell and build ALaDyn using the scripts\\build\\cmake.win.ps1 script PS \\> cd $env:WORKSPACE PS Code > cd ALaDyn PS Code \\ ALaDyn > .\\ scripts \\ build \\ cmake . win . ps1 13) You may have to manually copy the fftw3.dll from the vcpkg folder to the install folder PS \\> cd $env:WORKSPACE PS Code > cd ALaDyn PS Code \\ ALaDyn > cp $env:WORKSPACE \\ vcpkg \\ installed \\ x64-windows \\ bin \\ fftw3 . dll .\\ bin \\ Note: in case you need to re-download a compatible MS-MPI runtime, please use this link MS-MPI Redistributable 2012 R2 v4.2.4400.0 ; in case you need to re-download a compatible MS-MPI Client Utilities, please use this link MS-MPI CU 2012 R2 v4.2.4400.0 ; in case you need to re-download a compatible MS-MPI SDK, please use this link MS-MPI SDK 2012 R2 v4.2.4400.0 Upgrade software 1) To update software installed with Chocolatey, open a Powershell with Administrator privileges and type PS \\> cup all -y 2) To update libraries installed with vcpkg, open a Powershell (as a standard user), type these commands and follow on-screen instructions PS \\> cd $env:WORKSPACE PS Code > cd vcpkg PS Code > git pull PS Code > .\\ bootstrap-vcpkg . bat PS Code > .\\ vcpkg update PS Code > .\\ vcpkg upgrade - -no-dry-run Cygwin 1) If not already installed, please install chocolatey using the official guide 2) Open a Powershell with Administrator privileges and type PS \\> cinst -y cygwin 3) Open a Powershell (as a standard user) and type PS \\> Invoke-WebRequest https : // cygwin . com / setup-x86_64 . exe -OutFile $env:WORKSPACE \\ cygwin-setup . exe PS \\> cd $env:WORKSPACE PS Code > .\\ cygwin-setup - -quiet-mode - -no-shortcuts - -no-startmenu - -no-desktop - -upgrade-also - -packages gcc-g ++, libopenmpi-devel , gcc-fortran , cmake , fftw3 , libfftw3-devel , libboost-devel , zlib-devel , pkg-config","tags":"","loc":"page/./BUILD.html"},{"title":"Contributing guidelines – ALaDyn","text":"Contributing guidelines ALaDyn is an open source code, so you are very welcome to contribute! How to propose changes According to the general rules of Open Source code development, it is not possible to push any changes directly in the main repository. However, any Pull Request is evaluated by the community and then merged into the master branch. If you are new to GitHub, in the following there are the required steps in order to contribute. 1. Fork the repository The first required step is to fork ALaDyn repository. Click on \"Fork\", on the top right of the page, to fork the main repository into your GitHub account. From this moment on, your forked repository share the same history with ALaDyn , but may have a different future development. Since the intent to contribute, we suggest (so, this is an optional step) to set the main ALaDyn repository as a remote with git remote add upstream https://github.com/ALaDyn/ALaDyn This way, you can always keep your master branch up-to-date with all the development, by doing git fetch upstream\n  git merge upstream/master 2. Modify and commit the changes In your repository, create a new branch (which we suggest you to call dev/<yourname>/<nameofthebranch> ) and work on that. You should commit the changes and then push them on you online repository. The requested steps are therefore git checkout dev /< yourname >/< nameofthebranch > ... modify the code ... git add < changedfile > git commit - m 'Description of the changes' git push 3. Open a Pull Request After you pushed all the changes on your online repository, you can open a pull request by clicking on \"pull request\".\nYour changes will be therefore available to the community that can eventually discuss on them and decide when to merge them into the main repository. Recommendations Any pull request should Be as compact as possible, to facilitate the discussion and merging process. You can always open more than one pull request Contain correction and/or new fragments of code that can at least compile: you should try the compilation during your work. However, the Continuous Integration will check the pull request status as soon as you open it: any broken code cannot be merged. If possible, be already squashed . In particular, you should clean every confused or repeated commit, to reduce the number of them to the significant ones. For example (and this happens on daily basis, so don't worry!) an history such as <hash1> Fist try to fix bug\n<hash2> Second try to fix bug\n<hash3> Maybe this time works\n<hash4> Final fix should become <hash> Bug fixed","tags":"","loc":"page/./CONTRIBUTING.html"},{"title":"Code description – ALaDyn","text":"The ALaDyn PIC Code Overview ALaDyn is a Particle in Cell (PIC) code designed to investigate three main physical regimes: Laser-plasma interaction in under-dense gas targets for electron acceleration (LWFA). Beam-plasma interaction in under-dense gas targets for electron acceleration (PWFA). Laser-plasma interaction in over-dense solid targets for proton(ions) acceleration and related phenomenologies. Recent developments and applications are reported in the attached references. PIC numerical model A PIC method is based on a hybrid formal setting, whereby plasma particles are represented\non a Lagrangian framework whereas self-consistent fields are represented on the Eulerian framework\ngiven by Maxwell equations. As most other PIC codes, ALaDyn discretize particle and field dynamical equations\nby centred finite differences on a staggered  space and time grid (Yee's module) using one step\nsecond order leap-frog integrator. To connect Lagrangian particles to Eulerian fields collocated on the spatial grid, finite order\nB-splines are used. B-splines are local polynomials with compact support, allowing to\nrepresent delta-like point particles on a grid for charge deposition and, by converse,\nto assign field grid data to a point particle. Energy preserving PIC schemes do not satisfy local charge conservation and the related\nPoisson equation. By converse, using one of the many numerical recipes to enforce the\ncontinuity equations, energy conservation is heavily damaged. ALaDyn code implements both charge or energy preserving schemes, letting the user\nto choose, depending on the problem at hand. Besides the standard leap-frog integrator, ALaDyn also implements a fourth order in space and time Runge-Kutta integrator. This scheme\nrequires larger computational resources, of course, but can be of help to\nimprove on accuracy and reduce dispersive effects of wave propagation. The code implements also reduced models based on: Envelope (two-scale) approximation of the laser fields and of the particle dynamics; A cold fluid approximation of the wake fields. Reduced models are well tested only for (quasi) linear regimes. Serious problems\narise for non linear dynamics. In all the above configurations field induced ionization (tunnelling) are also implemented\nand can be activated if requested by the user.\nAll ionization models are based on ADK scheme plus barrier suppression (BSI) for higher Z ions. For solid targets, impact (collisional) ionization is under development. Implementation ALaDyn is almost completely written in Fortran 90 , but a couple of utility modules are written in C++ . C can also be easily used to extend code functionalities. Fortran 90 is the most popular computational language in PIC codes, probably because of\nthe higher efficiency in handling multidimensional arrays on a grid.\nFinite difference integration allows to exploit efficient parallelism by domain decomposition\nusing MPI technique to distribute the computational work among CPU units. ALaDyn has been successfully ported to many HPC architectures, both in Italy at CINECA and in Europe through\nPRACE Partnerships. From the CINECA IBM-SP6 system in 2011, to the test system at CINECA based on IBM/BGP in 2012,\nthen CINECA FERMI in 2014 and MARCONI in 2016, ALaDyn run on a multitude of HPC architectures, always extracting\ntop range performances. A new version has been recently released open source on the web, with a GPLv3 license.\nIn part it has been rewritten from scratch and it is the basis for future development.\nSources can be found, together with other codes, in our organization GitHub page at github.com/ALaDyn","tags":"","loc":"page/./DESCRIPTION.html"},{"title":"Write a Namelist – ALaDyn","text":"ALaDyn namelist guide Following here is a brief description of the new input.nml file required for the simulation parameters definition, through an example. GRID namelist block & GRID nx = 7168 , ny = 3584 , nz = 1 , ny_targ = 3500 , k0 = 10 0.0 , yx_rat = 2.0 , zx_rat = 2.0 , / nx is the number of grid points in the x direction for PWFA simulations, it is required that this number contains the number of cpus of the y and z domains defined by nprocx , nprocy and nprocz in order to be sure that FFTs are working as expected ny is the number of points in the y direction in order to be sure that the simulation is working as expected, it is better to always use a number that contains nprocx , nprocy and nprocz nz is the number of points in the z direction; for a 2D simulaton, use nz = 1 in order to be sure that the 3D simulation is working as expected, it is better to always use here a number that contains the number of cpu assigned to split the z domain ( mpi_ntot/pey ) ny_targ is the transverse size of the target, expressed in number of grid cell filled with particles (if the simulation is a 3D one, the target is a square in the xy plane) k0 defines the resolution, being the number of points per μm along x , so that Δx = 1/k0 [μm]; please remember to set a value small enough to solve the skin depth yx_rat is the ratio between the resolution along x and y : Δy = yx_rat/k0 [μm]. zx_rat is the ratio between the resolution along x and z : Δz = zx_rat/k0 [μm]; the resolution along z is the same as for y if this parameter is not defined. With those parameters, the full box size (in μm) is: Lx = nx / k0 , Ly = yx_rat * ny / k0 , Lz = zx_rat * nz / k0 SIMULATION namelist block & SIMULATION LPf_ord = 2 , der_ord = 2 , str_flag = 0 , iform = 0 , model_id = 1 , dmodel_id = 3 , ibx = 0 , iby = 0 , ibz = 0 , ibeam = 1 / Lpf_ord is  the integration scheme order. Lpf_ord=2 for standard leap-frog, Lpf_ord_ord=4 for RK4 (now disabled) der_ord is the order of the finite difference scheme. der_ord=2 or 3 for Lpf_ord=2, der_ord=4 for RK4 der_ord=2 → Standard Yee scheme der_ord=3 assures optimized wave (Laser) propagation in under dense plasmas using modified longitudinal derivative. str_flag has three possible different values: 0 for uniform grid 1 to enable stretching along transverse axes. The number of stretched cells is ny/6 and nz/6 , starting from both the boundaries. 2 to enable stretching along transverse axes. The number of stretched cells is ny/4 and nz/4 , starting from both the boundaries. This stretching is stronger. iform has two possible different values: 0 : Esirkepov's scheme for charge conservation (particle by particle, to be preferred) 1 : Esirkepov's scheme for charge conservation (inverted on grid along x, not allowed for MPI decomposition along the x coordinate) ( fallback on iform=0 ) 2 : no charge preserving (better energy conservation assured) model_id has five possible different values 1 laser is p-polarized 2 laser is s-polarized 3 laser is circularly polarized 4 laser is described by its envelope approximation model dmodel_id has five possible different values 1 uniform - the simulation is done using nsp species (electrons, Z_1,Z_2,Z_3) all distributed along the target x-profile 2 empty model 3 preplasma - the simulation is tested in this configuration: three nsp=3 species (electrons, Z_1, Z_2), with a preplasma made of Z_1 + e, a bulk made of Z_1 + e and a contaminant layer made of Z_2 + e 4 foam - the simulation is tested in this configuration: three nsp=3 species (electrons, Z_1, Z_2), with a foam made of Z_2 + e, a bulk made of Z_1 + e and a contaminant layer made of Z_2 + e 5 nanowires target with size parameters lpy(1),lpy(2) and species (e+Z_1) + a uniform bulk (e+Z_2) 6 nanotubes target with size parameters lpy(1),lpy(2) and species (e+Z_1) + a uniform bulk (e+Z_2) ibx , iby , ibz are the boundary conditions: 0 open 1 reflective 2 periodic ibeam : 0 1 2 For Envelope-fluid LWFA model (model_id = 4). Code solves Euler equations for plasma density with the laser described as an envelope. TARGET_DESCRIPTION namelist block & TARGET_DESCRIPTION nsp = 3 , nsb = 0 , ion_min ( 1 ) = 4 , ion_max ( 1 ) = 11 , atomic_number ( 1 ) = 13 , mass_number ( 1 ) = 2 6.98 , ion_min ( 2 ) = 1 , ion_max ( 2 ) = 1 , atomic_number ( 2 ) = 1 , mass_number ( 2 ) = 1.0 , ion_min ( 3 ) = 1 , ion_max ( 3 ) = 1 , atomic_number ( 3 ) = 1 , mass_number ( 3 ) = 1.0 , ionz_model = 0 , ionz_lev = 0 , t0_pl ( 1 ) = 0.0003 , t0_pl ( 2 ) = 0.0 , t0_pl ( 3 ) = 0.0 , t0_pl ( 4 ) = 0.0 , np_per_xc ( 1 ) = 12 , np_per_xc ( 2 ) = 4 , np_per_xc ( 3 ) = 4 , np_per_xc ( 4 ) = 4 , np_per_xc ( 5 ) = 4 , np_per_xc ( 6 ) = 4 , np_per_yc ( 1 ) = 9 , np_per_yc ( 2 ) = 3 , np_per_yc ( 3 ) = 4 , np_per_yc ( 4 ) = 4 , np_per_yc ( 5 ) = 4 , np_per_yc ( 6 ) = 4 , np_per_zc ( 1 ) = 1 , concentration ( 1 ) = 0.5 , concentration ( 2 ) = 0.5 , concentration ( 3 ) = 0 , concentration ( 4 ) = 0 , concentration ( 5 ) = 0 , concentration ( 6 ) = 0 , lpx ( 1 ) = 0.0 , lpx ( 2 ) = 0.0 , lpx ( 3 ) = 2.0 , lpx ( 4 ) = 0.0 , lpx ( 5 ) = 0.08 , lpx ( 6 ) = 0.0 , lpx ( 7 ) = 0.01 , lpy ( 1 ) = 0.0 , lpy ( 2 ) = 0.0 , n0_ref = 10 0.0 , np1 = 1.0 , np2 = 1 0.0 , r_c = 0.0 , / nsp is the number of species (be careful and coherent with dmodel_id ) nsb atomic_number(i) are the atomic number (Z) that define each element species ion_min(i) are the initial ionization status of the element species ion_max(i) are the maximum ionization status of the element species ionz_lev : if set to 0, we disable ionization; if 1, only one electron can be extracted per ion, if accessible, per timestep; if 2, it ionizes all the accessible levels in a single timestep ionz_model describes the various ionization models: 1 (pure ADK as in chen et al (2013), the best one for wake sims) 2 (ADK averaged over cycles, as in chen et al (2013), W_AC=<W_DC> , best for envelope simulations) 3 ( W_AC+BSI , added barrier suppression ionization) 4 (Minimum between ADK and BSI ionization values. Here the ADK value is computed averaging on m , the magnetic quantum number of the ionized electrons as in Lawrence-Douglas, 2013 ) mass_number(i) are the mass number (A) that define the exact isotope of a given atomic_number(i) . Here following you can find the only elements known by ALaDyn Hydrogen ( atomic_number = 1 ) - mass_number = 1.0 Helium ( atomic_number = 2 ) - mass_number = 4.0 Lithium ( atomic_number = 3 ) - mass_number = 6.0 Carbon ( atomic_number = 6 ) - mass_number = 1 2.0 Nitrogen ( atomic_number = 7 ) - mass_number = 1 4.0 Oxygen ( atomic_number = 8 ) - mass_number = 1 6.0 Neon ( atomic_number = 10 ) - mass_number = 2 0.0 Aluminium ( atomic_number = 13 ) - mass_number = 2 6.98 Silicon ( atomic_number = 14 ) - mass_number = 2 8.09 Argon ( atomic_number = 18 ) - mass_number = 3 9.948 Titanium ( atomic_number = 22 ) - mass_number = 4 7.8 Nickel ( atomic_number = 28 ) - mass_number = 5 8.7 Copper ( atomic_number = 29 ) - mass_number = 6 3.54 t0_pl(i) , with i from 1 to 4, are the initial temperatures in MeV for the different species np_per_xc(i) Please note that if np_per_xc(1) =0 , it just means to ignore the plasma and simply do a laser propagation simulation. . When in fluid model, particles can be activated anyway to obtain a Hybrid solver (particle + fluid). dmodel_id=1 : i=1 indicates the number of electrons, i=2 the number of macroparticles of Z_1 species, i=3 the number of macroparticles of Z_2 species and i=4 the number of macroparticles of Z_3 species. dmodel_id=3,4 : i=1,2 are the number of electrons and ions per cell along x/y in the bulk, i=3,4 refer to the front layer and i=5,6 to the contaminants. np_per_yc(i) : the same as np_per_xc , this describes the number of particles per cell along y directions (valid also for z for 3D simulations if np_per_zc(i) is not set) np_per_zc(i) : the same as np_per_xc , this describes the number of particles per cell along z directions concentration(i) : concentration of the i-th ion species. The sum of all the concentrations must be 1 to result in a consistent description. dmodel_id=1 lpx(1) is the length [μm] of the upstream layer (foam or preplasma), having density n1/nc lpx(2) is the length [μm] of the ramp (linear or exponential depending on the mdl ) connecting the upstream layer with the central one (made with bulk particles) lpx(3) is the length [μm] of the central layer (bulk), having density n2/nc lpx(4) is the length [μm] of the ramp (linear), connecting the bulk with the contaminants (made with bulk particles) lpx(5) is the length [μm] of the downstream layer (contaminants), having density n3/nc lpx(7) is the offset [μm] between the end of the laser and the beginning of the target (if zero, the target starts right at the end of the laser pulse). In the gaussian case, the end of the pulse is defined as the center position + the FWHM. The offset is calculated before laser rotation, so mind the transverse size if incid_angle ≠ 0 , in order to avoid laser initialization inside the target . n0_ref is the density in the central layer (bulk) LWFA case: density is in units of critical density If nsp=1 , n_over_nc is the plasma density If nsp>1 , n_over_nc is the density of the neutral gas, e.g. the gas jet density before the plasma formation.\nIf the background atoms are already ionized, the initial plasma density is computed accordingly. np1 is the density in the upstream layer (foam/preplasma) np2 is the density in the downstream layer (contaminants) dmodel_id=4 (Ramps are all cos&#94;2 ) lpx(1) is the length [μm] of the upramp to the plateau lpx(2) is the length [μm] of the first plateau (plasma bulk) with density n_over_nc lpx(3) is the length [μm] of the connecting ramp from the first plateau to the second one lpx(4) is the length [μm] of the second plateau (plasma bulk) with density np1*n_over_nc lpx(5) is the length [μm] of the connecting ramp from the second plateau to the third one lpx(6) is the length [μm] of the third plateau (plasma bulk) with density np2*n_over_nc lpx(7) is the offset [μm] between the end of the laser and the beginning of the target (if zero, the target starts right at the end of the laser pulse). In the gaussian case, the end of the pulse is defined as the center position + the FWHM. The offset is calculated before laser rotation, so mind the transverse size if incid_angle ≠ 0 , in order to avoid laser initialization inside the target . n0_ref is the density of the first plateau np1 is the density of the second plateau np2 is the density of the third plateau lpy(1) defines the wire size [μm]. lpy(2) defines the distance [μm] between wires (interwire size). n0_ref is the reference density in units of n_0=1e18 cm&#94;-3 . Code equations are normalized to that density. r_c is the plasma channel depth ==> n/n_over_nc = 1 + w0_y&#94;2*lambda_0&#94;2/(r_c&#94;2 *\\pi &#94;2 *n_over_nc)(y&#94;2+z&#94;2)/w0_y&#94;2 , where w0_y is the laser waist. If r_c = w0_y the channel is matched LASER namelist block & LASER G_prof = . true ., nb_laser = 1 , t0_lp = 1 6.5 , xc_lp = 1 6.5 , tau_fwhm = 3 3.0 , w0_y = 6.2 , a0 = 3.0 , incid_angle = 0.0 , lam0 = 0.8 , y0_cent = 0.0 , z0_cent = 0.0 , Enable_ionization ( 0 ) = . true . lp_delay = 2 0.59 , lp_offset = 0 , t1_lp = 20 0.0 , tau1_fwhm = 2 4.74 , w1_y = 3.5 , a1 = 0.45 , lam1 = 0.4 , y1_cent = 0.0 , z1_cent = 0.0 , Enable_ionization ( 1 ) = . true ., Symmetrization_pulse = . true ., a_symm_rat = 1.0 , / G_prof logical flag: if true the pulse is temporally gaussian, if false it has a cos&#94;2 shape nb_laser number of (identical) laser pulses injected xc_lp is the position (in μm) along x of the central point of the laser envelope t0_lp is the distance (in μm) after which the laser is focused; so the focus is at xf = xc_lp + t0_lp tau_fwhm is the FWHM pulse duration (in fs) w0_y is the transverse waist FWHM (in μm) a_0 is the laser adimensional parameter: a 0 =eA/(m e c 2 ) of all the pulses injected incid_angle Angle of incidence (degrees) of the laser pulse on the target. lam0 is the laser wavelength (in μm) of all the pulses injected y0_cent(1:nb_laser) is the array of the pulse center positions on the y axis z0_cent(1:nb_laser) is the array of the pulse center positions on the z axis lp_delay(1:nb_laser) is the array distance between the center of every injected laser pulse lp_offset is the distance between the center of the last injected pulse and the center of another different pulse injected (if different from 0) t1_lp same as t0_lp , but for the additional pulse injected with lp_offset/=0 tau1_fwhm same as tau_fwhm , but for the additional pulse injected with lp_offset/=0 w1_y same as w0_y , but for the additional pulse injected with lp_offset/=0 a1 same as a0 , but for the additional pulse injected with lp_offset/=0 lam1 same as lam0 , but for the additional pulse injected with lp_offset/=0 y1_cent(1:nb_laser) is the secondary pulse center positions on the y axis z1_cent(1:nb_laser) is the secondary pulse center positions on the z axis Enable_ionization(0) logical flag: indicates if the main pulse ( i.e. a_0 ) ionizes atoms Enable_ionization(1) logical flag: indicates if the secondary pulse ( i.e. a_1 ) ionizes atoms Symmetrization_pulse logical flag: when ionization is enabled, new electrons possess a nonzero temperature also in the transverse axis a_symm_rat is the pseudo-temperature that electrons acquire on the transverse axis, if Symmetrization_pulse=.true. . Formula is sin(2.*pi*u)*a_symm_rat*Delta_a BEAM INJECTION namelist block & BEAM_INJECT nb_1 = 5 , xc_1 = 30 , gam_1 = 300 , sxb_1 = 3 , syb_1 = 3 , epsy_1 = 0.2 , epsz_1 = 0.2 , dg_1 = 1 , charge_1 = 1 , t_inject = 0 , / nb_1 is the number of particles in the injected bunch in units of 10&#94;5 xc_1 is the longitudinal position of the bunch center gam_1 is the bunch mean gamma factor sxb_1 is the bunch longitudinal r.m.s length in microns syb_1 is the bunch transverse r.m.s length in microns (valid also for z direction in 3D) epsy_1 is the bunch normalized emittance along y epsz_1 is the bunch normalized emittance along z dg_1 is the bunch energy spread charge_1 is the bunch charge in pC t_inject time at which the bunch is injected in the simulation box MOVING_WINDOW namelist block & MOVING_WINDOW w_sh = 20 , wi_time = 10 0.0 , wf_time = 15 0.0 , w_speed = 1.0 / w_sh is the number of time steps after which the moving-window is called, repeatedly wi_time is the absolute time at which the window starts moving. nb: in order to block the MW from a certain simulation, the only tested path is to set a wi_time greater than the ending time of the simulation itself. w_speed=0 should also work, but is not tested for now wf_time is the absolute time at which the window stops moving w_speed is the speed over c of the moving window OUTPUT namelist block & OUTPUT nouts = 10 , iene = 200 , nvout = 3 , nden = 1 , npout = 0 , nbout = 0 , jump = 1 , pjump = 1 , xp0_out = 0.0 , xp1_out = 10 0.0 , yp_out = 2 0.0 , tmax = 10 0.0 , cfl = 0.8 , new_sim = 0 , id_new = 0 , dump = 0 , L_env_modulus = . true ., / nouts is the number of binary outputs during the relative time of the simulation iene is the number of text outputs during the relative time of the simulation nvout is the number of fields written. For a 2D P-polarized case, we have just 3 fields, E x , E y and B z ; in all the other cases there are 6 fields with these IDs: 1= E x , 2= E y , 3= E z , 4= B x , 5= B y , 6= B z . At each nouts step, every field with ID ≤ nvout will be dumped. nden can have three different values; every output is divided by species on different files: 1 : writes only the particle density n on the grid 2 : writes also the energy density n ･ gamma on the grid 3 : writes also the currents J on the grid npout 1 : writes only the electron phase space 2 : writes only the proton phase space in general it writes only the phase space of the n-th species, with n=npv ; if n=npv>nps , it writes the phase spaces of all the particle species nbout (only for PWFA) 1 : writes only the electron phase space 2 : writes only the proton phase space in general it writes only the phase space of the n-th species, with n=npv ; if n=npv>nps , it writes the phase spaces of all the particle species jump : jump on grid points; if jump=2 , it means that each processor is going to write only one point every two. Mind that it's extremely important that jump is a divisor of the number of grid points per processor , otherwise the grid output will be corrupted pjump : jump on particles; if pjump=2 , it means that each processor is going to write the phase space of just one particle every two. xp0_out , xp1_out and yp_out only particles contained inside the box defined by xp0 < x-w_speed t < xp1 , |y| < yp_out will be printed in the output tmax is the relative time (in μm, because it is multiplied by c ) that the simulation is going to be evolved. Being relative, it's going to be added to the time eventually already reached before the restart. To obtain the time in fs, you have to divide it by 0.299792458 [speed of light in μm/fs] cfl is the Courant–Friedrichs–Lewy parameter ( Wikipedia CFL-parameter page ) new_sim : identifies if a simulation is new new=0 (data is recreated from initial conditions) or if it is a restart new=1 (dump are going to be read) id_new identifies the starting number of the output files (if new=0 ) or the last one written in the previous step (if new=1 ) dump 1 : each processor will dump a binary file for every nout in order to enable restart 0 : dumps are suppressed L_env_modulus logical flag, only if model_id=4 : if true the code generates the absolute value of the laser envelope amplitude, otherwise gives the real and imaginary part in two separate files TRACKING namelist block (now disabled) & TRACKING P_tracking = . true ., nkjump = 1 , tkjump = 4 , txmin = 5 5. , txmax = 7 5. , tymin = - 8 0. , tymax = 8 0. , tzmin = - 2 0. , tzmax = 2 0. , t_in = 0. , t_out = 20 0. , / P_tracking logical flag: if true the particle tracking is enabled nkjump a tracked particle every nkjump is written in the output file tkjump a snapshot of the tracked particles phase space is taken every tkjump timestep txmin to select particles with initial longitudinal coordinate x > txmin to be tracked txmax to select particles with initial longitudinal coordinate x < txmax to be tracked tymin to select particles with initial transverse coordinate y > tymin to be tracked tymax to select particles with initial transverse coordinate y < tymax to be tracked tzmin to select particles with initial transverse coordinate z > tzmin to be tracked tzmax to select particles with initial transverse coordinate z < tzmax to be tracked t_in initial tracking time t_out final tracking time MPIPARAMS namelist block & MPIPARAMS nprocx = 1 , nprocy = 64 , nprocz = 1 / nprocx defines the number of processor the simulation will be splitted along the x coordinate nprocy defines the number of processor the simulation will be splitted along the y coordinate nprocz defines the number of processor the simulation will be splitted along the z coordinate mind that usually we do not split along x and we use the same number of processor along y and z (for 3D simulations) or we define nprocz=1 explicitly for 2D simulations. No guarantees are given if you want to explore other configurations (that should work anyway).","tags":"","loc":"page/./NAMELIST_GUIDE.html"},{"title":"Deprecated Guide – ALaDyn","text":"","tags":"","loc":"page/deprecated/index.html"},{"title":"Old input guide – ALaDyn","text":"ALaDyn input.data guide Following here is a brief description of the input.data file required for the simulation parameters definition, through an example. This method is currently deprecated, in favour of the new input namelist. Lines 1-2-3-4 / Grid parameters 7168 , 3584 , 1 , 3500 nx , ny , nz , ny_part 10 0.0 , 2.0 k0 , yx_rat nx is the number of grid points in the x direction for PWFA simulations, it is required that this number contains the number of cpus of the y and z domains defined by pey in order to be sure that FFTs are working as expected ny is the number of points in the y direction in order to be sure that the simulation is working as expected, it is better to always use a number that contains pey nz is the number of points in the z direction; for a 2D simulaton, use nz = 1 in order to be sure that the 3D simulation is working as expected, it is better to always use here a number that contains the number of cpu assigned to split the z domain ( mpi_ntot/pey ) nypart is the transverse size of the target, expressed in number of grid cell filled with particles (if the simulation is a 3D one, the target is a square in the xy plane) k0 defines the resolution, being the numbero of points per μm along x , so that Δx = 1/k0 [μm]; please remember to set a value small enough to solve the skin depth yxrat is the ratio between the resolution along x and y : Δy = yxrat/k0 [μm]; the resolution along z is the same as for y . With those parameters, the full box size (in μm) is: Lx = nx / k0 , Ly = yxrat * ny / k0 , Lz = yxrat * nz / k0 Lines 5-6 / Numerical schemes 2 , 2 , 0 , 0 LPf , Der , str , iform Lpf is the leapfrog order used in the integration scheme Der is the order of the finite difference scheme str has three possible different values: 0 for uniform grid 1 to enable stretching along transverse axes 2 to enable stretching along all axes, but for x it is only on the right side of the box (need testing) iform has two possible different values: 0 : (D x J x ,D y J y ,D z J z ) to be inverted on a grid (to be preferred) (energy conservation not guaranteed) 1 : only (D x J x ) to be inverted on a grid 2 : no charge preserving (use energy conservation algorithm) Lines 7-8 / Driver and target models 1 , 3 , 1 mdl , dmdl , ibeam mdl has five possible different values 1 laser is p-polarized 2 laser is s-polarized 3 laser is circularly polarized 4 laser is described by its envelope approximation model 5 the driver is an electron beam. Its description must be given in a separate namelist file 6 the driver is a proton bunch. Its description must be given in a separate namelist file dmdl has five possible different values 1 the simulation is done using just two species, electrons and protons 2 four species, e, p, C, Al, used in this way: [e+p]foam + [e+Al]bulk + [e+C+p]contaminants (Al is in reality a generic atom, defined by Z_i and A_i , while C is hard coded: we use Al in this readme since it is the common experimental choice, while for C it is an experimental mandatory choice - but it will be lifted in the future) 3 three species, e, p, C, in one layer: [e+C+p n]bulk (mind the n*, managed with nsb ) (C is in reality a generic atom, defined by Z_i and A_i : we use C in this readme since it is the common experimental choice) 4 three species, e, p, Al, used in this way: [e+p]foam + [e+Al]bulk + [e+p]contaminants 5 three species, e, p, Al, identic to case 4 , but with the contaminant layer mass limited ibeam :\n    for PWFA (model_id #5/#6): 0 1 2 Lines 9-10 / Number and type of particle species 0 , 0 , 0 , 3 , 1 ibx , iby , ibz , nsp , nsb nsp is the number of species (be careful and coherent with dmdl ) nsb , used with dmdl=3 , defines the ratio n between the number of C ions and protons, to form CH n Lines 11-12 / Ionization status and schemes 4 , 11 , 13 , 2 6.98 ion_min ( 1 ), ion_max ( 1 ), atomic_number ( 1 ), mass_number ( 1 ) 1 , 1 , 1 , 1.0 ion_min ( 2 ), ion_max ( 2 ), atomic_number ( 2 ), mass_number ( 2 ) 0 , 0 ionz_lev , ionz_model , ion_min ion_max atomic_number mass_number ionz_lev ionz_model Lines 13-14 / Initial temperatures of the species 0.0003 , 0.0 , 0.0 , 0.0 t0_pl ( 1 ), t0_pl ( 2 ), t0_pl ( 3 ), t0_pl ( 4 ) Lines 15-16-17-18 / Number of particles per cell 12 , 4 , 4 , 4 , 4 , 4 np_xc 9 , 3 , 4 , 4 , 4 , 4 np_yc First two are the number of electrons and ions per cell along x/y in the bulk, second two numbers refer to the front layer and third two to the contaminants. A special case is dmdl=3 , in which the first indicates the number of electrons, the second the number of protons (to be multiplies by nsb ) and the third is the number of ions; in this case the other numbers are not important. Describing the previous example, it means that, along x: n e x = 9, n i x = 4, in the central layer (bulk) n e x = 3, n i x = 3, in the frontal layer (foam) n e x = 6, n i x = 6, in the contaminant layer n e x = 0 in the first np_xc position just means to ignore the plasma and do just a laser propagation simulation. np_yc : the same as np_xc , this describes the number of particles per cell along transverse directions (valid also for z for 3D simulations) Lines 19-20 / Laser parameters 1 6.5 , 1 6.5 , 3 3.0 , 6.2 , 3.0 , 0.8 tf , xc , wx , wy , a0 , lam0 these lines are valid only for ibeam=1 xc is the position (in μm) along x of the central point of the laser envelope tf is the distance (in μm) after which the laser is focused; so the focus is at xf = xc + tf wx is twice the longitudinal waist, corresponding to the total laser length, which is twice the FWHM. For example, if we have a 40 fs FWHM Ti:Sa laser, we should write for wx=33 μm because: ( 40 fs / 3.333 ) * 2 * 1.37 = 33 μ m 40 / 3.3333 is done to convert fs to μ m * 2 is to convert from FWHM to full length * 1.37 is to convert from laser intensity to fields : usually we receive from experiments the FWHM of the laser intensity , but we set the length of fields and the FWHM of a cos4 has to be converted to the FWHM of a cos2 : FWHM ( cos4 ) = FWHM ( cos2 ) / 1.37 wy is the transverse waist FWHM (in μm) a is the laser adimensional parameter: a 0 =eA/(m e c 2 ) lam0 is the laser wavelength (in μm) Lines 21-22 / Target shape parameters 0.0 , 0.0 , 2.0 , 0.0 , 0.08 , 0.0 , 0.01 lx lx(1) is the length of the upstream layer (foam or preplasma), having density n1/nc lx(2) is the length of the ramp (linear or exponential depending on the mdl ) connecting the upstream layer with the central one (made with bulk particles) lx(3) is the length of the central layer (bulk), having density n2/nc lx(4) is the length of the ramp (linear), connecting the bulk with the contaminants (made with bulk particles) lx(5) is the length of the downstream layer (contaminants), having density n3/nc lx(6) is the angle α of incidence, between the laser axis and the target plane lx(7) is the offset between the end of the laser and the beginning of the target (if zero, the target starts right at the end of the laser pulse). The offset is calculated before laser rotation, so mind the transverse size if lx(6) ≠ 0 , in order to avoid laser initialization inside the target . Lines 23-24 / Target shape parameters 0.0 , 0.0 ly ly(1) defines the wire size ly(2) defines the interwire size Lines 25-26 / Target density parameters 10 0.0 , 1.0 , 1 0.0 n2 / nc , n1 / nc , n3 / nc n2/nc is the density in the central layer (bulk) n1/nc is the density in the upstream layer (foam/preplasma) n3/nc is the density in the downstream layer (contaminants) Lines 27-28 / Moving window 20 , 10 0.0 , 15 0.0 , 1.0 wnd_sh , w_in , w_end , w_speed wsh is the number of time steps after which the moving-window is called, repeatedly win is the absolute time at which the window starts moving wend is the absolute time at which the window stops moving wspeed is the β speed of the moving window Lines 29-30 / Output manager 10 , 200 , 3 , 1 , 0 , 0 nout , iene , nvout , nden , npout , nbout nout is the number of binary outputs during the relative time of the simulation iene is the number of text outputs during the relative time of the simulation nvout is the number of fields written. For a 2D P-polarized case, we have just 3 fields, E x , E y and B z ; in all the other cases there are 6 fields with these IDs: 1= E x , 2= E y , 3= E z , 4= B x , 5= B y , 6= B z . At each nout step, every field with ID ≤ nf will be dumped. nden can have three different values; every output is divided by species on different files: 1 : writes only the particle density n on the grid 2 : writes also the energy density n ･ gamma on the grid 3 : writes also the currents J on the grid npout 1 : writes only the electron phase space 2 : writes only the proton phase space in general it writes only the phase space of the n-th species, with n=npv ; if n=npv>nps , it writes the phase spaces of all the particle species nbout Lines 31-32 / Output subsampling 1 , 1 jmp , pjmp jmp : jump on grid points; if jmp=2 , it means that each processor is going to write only one point every two. Mind that it's extremely important that jmp is a divisor of the number of grid points per processor , otherwise the grid output will be corrupted pjmp : jump on particles; if pjmp=2 , it means that each processor is going to write the phase space of just one particle every two. Lines 33-34 / Particle box to be dumped 0.0 , 10 0.0 , 2 0.0 xp0 , xp1 , ypmax In the dump we will find only particles contained inside the box defined by xp0 < x < xp1 In the dump we will find only particles contained in the box |{y,z}| < ypmax Lines 35-36 / Simulation time settings 10 0.0 , 0.8 tmax , cfl tmax is the relative time (in μm, because it is multiplied by c ) that the simulation is going to be evolved. Being relative, it's going to be added to the time eventually already reached before the restart. To obtain the time in fs, you have to divide it by 0.299792458 [speed of light in μm/fs] cfl is the Courant–Friedrichs–Lewy parameter ( Wikipedia CFL-parameter page ) Lines 37-38 / Restart manager and processor settings 0 , 0 , 0 , 64 new , id_ew , dump , pey new : identifies if a simulation is new new=0 (data is recreated from initial conditions) or if it is a restart new=1 (dump are going to be read) id_ew identifies the starting number of the output files (if new=0 ) or the last one written in the previous step (if new=1 ) dump 1 : each processor will dump a binary file for every nout in order to enable restart 0 : dumps are suppressed pey identifies the number of processors used for 2D simulations, or how many processors are going to be used for the y domains ( mpi_ntot/pey is the number of processors used for the z domains) for 3D simulations.","tags":"","loc":"page/deprecated/input_data_guide.html"}]}